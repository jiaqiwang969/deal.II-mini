<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTriaAccessor.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TriaAccessor&lt; structdim, dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTriaAccessor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TriaAccessor&lt; structdim, dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grids and Triangulations</a> &raquo; <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> &raquo; <a class="el" href="group__Accessors.html">Accessor classes of the mesh iterators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tria__accessor_8h_source.html">deal.II/grid/tria_accessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TriaAccessor&lt; structdim, dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTriaAccessor__inherit__graph.svg" width="283" height="338"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a563ba5bc45b2c81bd7164bc107bc3f15"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a563ba5bc45b2c81bd7164bc107bc3f15">AccessorData</a> = typename <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a></td></tr>
<tr class="separator:a563ba5bc45b2c81bd7164bc107bc3f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bf7670cf3c4571fe55e051d2503190"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a90bf7670cf3c4571fe55e051d2503190">LocalData</a> = void *</td></tr>
<tr class="separator:a90bf7670cf3c4571fe55e051d2503190"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adcbbfa481886d095df724cef84d92286"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#adcbbfa481886d095df724cef84d92286">TriaAccessor</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *parent=nullptr, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level</a>=-1, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>=-1, const <a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a> *local_data=nullptr)</td></tr>
<tr class="separator:adcbbfa481886d095df724cef84d92286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff27529711a78693b3912ce592c25df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6ff27529711a78693b3912ce592c25df">TriaAccessor</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a> &amp;)=default</td></tr>
<tr class="separator:a6ff27529711a78693b3912ce592c25df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ff7adf27cb0ce877196474c858ddcf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a14ff7adf27cb0ce877196474c858ddcf">TriaAccessor</a> (<a class="el" href="classTriaAccessor.html">TriaAccessor</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a14ff7adf27cb0ce877196474c858ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf81fa90cc1506bbdf6a54fb0626985"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:aeaf81fa90cc1506bbdf6a54fb0626985"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aeaf81fa90cc1506bbdf6a54fb0626985">TriaAccessor</a> (const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:aeaf81fa90cc1506bbdf6a54fb0626985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397500f10867aa69f4a731cc9ab2de53"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:a397500f10867aa69f4a731cc9ab2de53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a397500f10867aa69f4a731cc9ab2de53">TriaAccessor</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:a397500f10867aa69f4a731cc9ab2de53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6274ae9855a9bd40654f82af32657427"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaAccessor.html">TriaAccessor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6274ae9855a9bd40654f82af32657427">operator=</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a> &amp;)=delete</td></tr>
<tr class="separator:a6274ae9855a9bd40654f82af32657427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce9055d943c6dfe89a07e5c0011a864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaAccessor.html">TriaAccessor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a5ce9055d943c6dfe89a07e5c0011a864">operator=</a> (<a class="el" href="classTriaAccessor.html">TriaAccessor</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a5ce9055d943c6dfe89a07e5c0011a864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb1d967889a26340ed512f68dbf5331"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8eb1d967889a26340ed512f68dbf5331">~TriaAccessor</a> ()=default</td></tr>
<tr class="separator:a8eb1d967889a26340ed512f68dbf5331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0b77c3f3c1de1f604d456d0718efc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aeb0b77c3f3c1de1f604d456d0718efc0">used</a> () const</td></tr>
<tr class="separator:aeb0b77c3f3c1de1f604d456d0718efc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab467082583c8bce60bd9dd669b939ae9"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab467082583c8bce60bd9dd669b939ae9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab467082583c8bce60bd9dd669b939ae9">extent_in_direction</a> (const unsigned <a class="el" href="classint.html">int</a> axis) const</td></tr>
<tr class="separator:ab467082583c8bce60bd9dd669b939ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0264eafc337e3596b9f895a091b18a44"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a0264eafc337e3596b9f895a091b18a44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a0264eafc337e3596b9f895a091b18a44">extent_in_direction</a> (const unsigned <a class="el" href="classint.html">int</a> axis) const</td></tr>
<tr class="separator:a0264eafc337e3596b9f895a091b18a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b363d9cf3b6911d41223c9ed5d82daa"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a1b363d9cf3b6911d41223c9ed5d82daa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a1b363d9cf3b6911d41223c9ed5d82daa">extent_in_direction</a> (const unsigned <a class="el" href="classint.html">int</a> axis) const</td></tr>
<tr class="separator:a1b363d9cf3b6911d41223c9ed5d82daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09623959e21c50be31d6e40b508c39b4"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a09623959e21c50be31d6e40b508c39b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a09623959e21c50be31d6e40b508c39b4">extent_in_direction</a> (const unsigned <a class="el" href="classint.html">int</a> axis) const</td></tr>
<tr class="separator:a09623959e21c50be31d6e40b508c39b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f33cb96e76ff07eaf0052427907aeb3"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7f33cb96e76ff07eaf0052427907aeb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a7f33cb96e76ff07eaf0052427907aeb3">extent_in_direction</a> (const unsigned <a class="el" href="classint.html">int</a> axis) const</td></tr>
<tr class="separator:a7f33cb96e76ff07eaf0052427907aeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b007b674b316f793f72b8ddc31e1cf9"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a8b007b674b316f793f72b8ddc31e1cf9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8b007b674b316f793f72b8ddc31e1cf9">set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> manifold_ind) const</td></tr>
<tr class="separator:a8b007b674b316f793f72b8ddc31e1cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">访问子对象</div></td></tr>
<tr class="memitem:a76b3fb7b9d5de13f797e3c04d4dd03a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a76b3fb7b9d5de13f797e3c04d4dd03a5">vertex_iterator</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a76b3fb7b9d5de13f797e3c04d4dd03a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81afd26d765a4cec094b25767b8dd42a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a81afd26d765a4cec094b25767b8dd42a">vertex_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a81afd26d765a4cec094b25767b8dd42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd6518eb0cf5fccc5926470128415d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3dd6518eb0cf5fccc5926470128415d9">vertex</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a3dd6518eb0cf5fccc5926470128415d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c8283c86c84e29f718cbfe4118b3b2"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt; dim, spacedim &gt;::line_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a54c8283c86c84e29f718cbfe4118b3b2">line</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a54c8283c86c84e29f718cbfe4118b3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450f0e6e00b9711650f59143e2085d95"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a450f0e6e00b9711650f59143e2085d95">line_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a450f0e6e00b9711650f59143e2085d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dc361f8b3fb30c60a9e248c2108979"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt; dim, spacedim &gt;::quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a04dc361f8b3fb30c60a9e248c2108979">quad</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a04dc361f8b3fb30c60a9e248c2108979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f77d56ddde728b892e3c736a28cd0c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab3f77d56ddde728b892e3c736a28cd0c">quad_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ab3f77d56ddde728b892e3c736a28cd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">子对象的方向</div></td></tr>
<tr class="memitem:a452389bb368ba37c9c5542ef956526ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a452389bb368ba37c9c5542ef956526ee">face_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> face) const</td></tr>
<tr class="separator:a452389bb368ba37c9c5542ef956526ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90f5ff1a44cb8a6e08196dac6cdb22e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad90f5ff1a44cb8a6e08196dac6cdb22e">face_flip</a> (const unsigned <a class="el" href="classint.html">int</a> face) const</td></tr>
<tr class="separator:ad90f5ff1a44cb8a6e08196dac6cdb22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f831f5ca8626677089f94af9be43a5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a2f831f5ca8626677089f94af9be43a5b">face_rotation</a> (const unsigned <a class="el" href="classint.html">int</a> face) const</td></tr>
<tr class="separator:a2f831f5ca8626677089f94af9be43a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aaa41d4d6e0942d888efc21ca5d6c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a08aaa41d4d6e0942d888efc21ca5d6c7">line_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html#a54c8283c86c84e29f718cbfe4118b3b2">line</a>) const</td></tr>
<tr class="separator:a08aaa41d4d6e0942d888efc21ca5d6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">访问儿童</div></td></tr>
<tr class="memitem:a4ce77fc45536beea670a0b5c1d91539c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a4ce77fc45536beea670a0b5c1d91539c">has_children</a> () const</td></tr>
<tr class="separator:a4ce77fc45536beea670a0b5c1d91539c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634bf3e1c46e9ba87dfafa8c869e8972"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a634bf3e1c46e9ba87dfafa8c869e8972">n_children</a> () const</td></tr>
<tr class="separator:a634bf3e1c46e9ba87dfafa8c869e8972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c1e25935669a4b310671a26e9dcbd2"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa0c1e25935669a4b310671a26e9dcbd2">number_of_children</a> () const</td></tr>
<tr class="separator:aa0c1e25935669a4b310671a26e9dcbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fb24948b4e177f8e4eb737ec057397"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a24fb24948b4e177f8e4eb737ec057397">n_active_descendants</a> () const</td></tr>
<tr class="separator:a24fb24948b4e177f8e4eb737ec057397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39e613fd2e2c22bdc8ba340068e5713"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa39e613fd2e2c22bdc8ba340068e5713">max_refinement_depth</a> () const</td></tr>
<tr class="separator:aa39e613fd2e2c22bdc8ba340068e5713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad791ab6cd4f749e0c9f601a2bc442bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad791ab6cd4f749e0c9f601a2bc442bd9">child</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ad791ab6cd4f749e0c9f601a2bc442bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237132d2e5161b34a05291e10f3d6feb"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a237132d2e5161b34a05291e10f3d6feb">child_iterator_to_index</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;<a class="el" href="classTriaAccessor.html#ad791ab6cd4f749e0c9f601a2bc442bd9">child</a>) const</td></tr>
<tr class="separator:a237132d2e5161b34a05291e10f3d6feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa035549b0c8b7eb7fcd33654bc73da29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa035549b0c8b7eb7fcd33654bc73da29">isotropic_child</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:aa035549b0c8b7eb7fcd33654bc73da29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a4a753f2ef5b2615a7e2fec21e0dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; structdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae6a4a753f2ef5b2615a7e2fec21e0dec">refinement_case</a> () const</td></tr>
<tr class="separator:ae6a4a753f2ef5b2615a7e2fec21e0dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7551fc85831a3fd4d5cd339b81d8c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#acd7551fc85831a3fd4d5cd339b81d8c6">child_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:acd7551fc85831a3fd4d5cd339b81d8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adec5f5b7786cf43e6011d03cc7903a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8adec5f5b7786cf43e6011d03cc7903a">isotropic_child_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a8adec5f5b7786cf43e6011d03cc7903a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">处理边界指标</div></td></tr>
<tr class="memitem:af2b4887416074f2ecdcd06512e864e48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af2b4887416074f2ecdcd06512e864e48">boundary_id</a> () const</td></tr>
<tr class="separator:af2b4887416074f2ecdcd06512e864e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654de9ccd776b524a27cd64bded48e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">set_boundary_id</a> (const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>) const</td></tr>
<tr class="separator:a654de9ccd776b524a27cd64bded48e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0304fb253839c45e64b60460ab040ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa0304fb253839c45e64b60460ab040ae">set_all_boundary_ids</a> (const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>) const</td></tr>
<tr class="separator:aa0304fb253839c45e64b60460ab040ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af211333148f7b1190db625ce91b23b65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af211333148f7b1190db625ce91b23b65">at_boundary</a> () const</td></tr>
<tr class="separator:af211333148f7b1190db625ce91b23b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d63b9ebf9b5c31aa702e49c664e59d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae4d63b9ebf9b5c31aa702e49c664e59d">get_manifold</a> () const</td></tr>
<tr class="separator:ae4d63b9ebf9b5c31aa702e49c664e59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">处理流形指标的问题</div></td></tr>
<tr class="memitem:a6c28dbcfefe0ffe1e51fe315c3565f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6c28dbcfefe0ffe1e51fe315c3565f94">manifold_id</a> () const</td></tr>
<tr class="separator:a6c28dbcfefe0ffe1e51fe315c3565f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbeb21da36433dc2ec117b9694ca2557"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">set_manifold_id</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>) const</td></tr>
<tr class="separator:gafbeb21da36433dc2ec117b9694ca2557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160a26ce22b36607556bcdcc20bc6d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga160a26ce22b36607556bcdcc20bc6d61">set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>) const</td></tr>
<tr class="separator:ga160a26ce22b36607556bcdcc20bc6d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">用户数据</div></td></tr>
<tr class="memitem:a6aa91f3e086777b02a2f6eef7ac19ebb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6aa91f3e086777b02a2f6eef7ac19ebb">user_flag_set</a> () const</td></tr>
<tr class="separator:a6aa91f3e086777b02a2f6eef7ac19ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dda85b6637fefd5db3d37ad7729fcb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6dda85b6637fefd5db3d37ad7729fcb1">set_user_flag</a> () const</td></tr>
<tr class="separator:a6dda85b6637fefd5db3d37ad7729fcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ff7c1bc2b4fc8abcd9b3ef44b5f485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a59ff7c1bc2b4fc8abcd9b3ef44b5f485">clear_user_flag</a> () const</td></tr>
<tr class="separator:a59ff7c1bc2b4fc8abcd9b3ef44b5f485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d791b3769c77bcfd1c56748a6c56fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a63d791b3769c77bcfd1c56748a6c56fa">recursively_set_user_flag</a> () const</td></tr>
<tr class="separator:a63d791b3769c77bcfd1c56748a6c56fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b22f28a2baf2dd90b5309c3f0136af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a50b22f28a2baf2dd90b5309c3f0136af">recursively_clear_user_flag</a> () const</td></tr>
<tr class="separator:a50b22f28a2baf2dd90b5309c3f0136af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3965091ec2c6ba6ed838a2479dd8110f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3965091ec2c6ba6ed838a2479dd8110f">clear_user_data</a> () const</td></tr>
<tr class="separator:a3965091ec2c6ba6ed838a2479dd8110f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaaa0940be75dd7436769b55538aaac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aceaaa0940be75dd7436769b55538aaac">set_user_pointer</a> (void *p) const</td></tr>
<tr class="separator:aceaaa0940be75dd7436769b55538aaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd20837028286220f0b2ba9b0d4b219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a1fd20837028286220f0b2ba9b0d4b219">clear_user_pointer</a> () const</td></tr>
<tr class="separator:a1fd20837028286220f0b2ba9b0d4b219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3700f2ce7587b2fbcaf85753c79bf40"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad3700f2ce7587b2fbcaf85753c79bf40">user_pointer</a> () const</td></tr>
<tr class="separator:ad3700f2ce7587b2fbcaf85753c79bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484e590959847d514d42814efa3e25c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a484e590959847d514d42814efa3e25c2">recursively_set_user_pointer</a> (void *p) const</td></tr>
<tr class="separator:a484e590959847d514d42814efa3e25c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04d1802d9b1e8923dcfef41ea624edc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad04d1802d9b1e8923dcfef41ea624edc">recursively_clear_user_pointer</a> () const</td></tr>
<tr class="separator:ad04d1802d9b1e8923dcfef41ea624edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cca979ccf43e19af78dcb91d19cfd87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a0cca979ccf43e19af78dcb91d19cfd87">set_user_index</a> (const unsigned <a class="el" href="classint.html">int</a> p) const</td></tr>
<tr class="separator:a0cca979ccf43e19af78dcb91d19cfd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a1e59ae7328b4c75c69720826736c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a97a1e59ae7328b4c75c69720826736c0">clear_user_index</a> () const</td></tr>
<tr class="separator:a97a1e59ae7328b4c75c69720826736c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a24da10289811179abbfb57253e9d3"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ac7a24da10289811179abbfb57253e9d3">user_index</a> () const</td></tr>
<tr class="separator:ac7a24da10289811179abbfb57253e9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309ae29be30ad5a259b1cd942e7d9e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a309ae29be30ad5a259b1cd942e7d9e9d">recursively_set_user_index</a> (const unsigned <a class="el" href="classint.html">int</a> p) const</td></tr>
<tr class="separator:a309ae29be30ad5a259b1cd942e7d9e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429e559fb261a631942d54c897243abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a429e559fb261a631942d54c897243abb">recursively_clear_user_index</a> () const</td></tr>
<tr class="separator:a429e559fb261a631942d54c897243abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">关于一个物体的几何信息</div></td></tr>
<tr class="memitem:af0e85725edb5d2bb43da61796f2fbbb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af0e85725edb5d2bb43da61796f2fbbb9">diameter</a> () const</td></tr>
<tr class="separator:af0e85725edb5d2bb43da61796f2fbbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af8bab7e9ad732b6f3fa6a120ed5208"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a7af8bab7e9ad732b6f3fa6a120ed5208">enclosing_ball</a> () const</td></tr>
<tr class="separator:a7af8bab7e9ad732b6f3fa6a120ed5208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57453302997d9df8d1e242bf663dc11b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a57453302997d9df8d1e242bf663dc11b">bounding_box</a> () const</td></tr>
<tr class="separator:a57453302997d9df8d1e242bf663dc11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a088728d7acb727fdc13bb6664d91a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a49a088728d7acb727fdc13bb6664d91a">extent_in_direction</a> (const unsigned <a class="el" href="classint.html">int</a> axis) const</td></tr>
<tr class="separator:a49a088728d7acb727fdc13bb6664d91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b268c743742c3c9ab159ff916d9236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a99b268c743742c3c9ab159ff916d9236">minimum_vertex_distance</a> () const</td></tr>
<tr class="separator:a99b268c743742c3c9ab159ff916d9236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49df04630565a833e168e9cab074305e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a49df04630565a833e168e9cab074305e">intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; structdim &gt; &amp;coordinates) const</td></tr>
<tr class="separator:a49df04630565a833e168e9cab074305e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb24d5074a9a7bf216bd82f5d0dc618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; structdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3eb24d5074a9a7bf216bd82f5d0dc618">real_to_unit_cell_affine_approximation</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point) const</td></tr>
<tr class="separator:a3eb24d5074a9a7bf216bd82f5d0dc618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b045bcae58de112897824f4f08d1713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8b045bcae58de112897824f4f08d1713">center</a> (const <a class="el" href="classbool.html">bool</a> respect_manifold=false, const <a class="el" href="classbool.html">bool</a> interpolate_from_surrounding=false) const</td></tr>
<tr class="separator:a8b045bcae58de112897824f4f08d1713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cc737f4b28f8d28a576d2e3d32ef9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a56cc737f4b28f8d28a576d2e3d32ef9f">barycenter</a> () const</td></tr>
<tr class="separator:a56cc737f4b28f8d28a576d2e3d32ef9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cecb2b7c9a1644fb5fd44bbba40ab0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a9cecb2b7c9a1644fb5fd44bbba40ab0c">measure</a> () const</td></tr>
<tr class="separator:a9cecb2b7c9a1644fb5fd44bbba40ab0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21eeac18f82c9689857c225ca6be7e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab21eeac18f82c9689857c225ca6be7e4">is_translation_of</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;o) const</td></tr>
<tr class="separator:ab21eeac18f82c9689857c225ca6be7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f79864c20e5ee8283e9ddb6f7c0415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classReferenceCell.html">ReferenceCell</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad2f79864c20e5ee8283e9ddb6f7c0415">reference_cell</a> () const</td></tr>
<tr class="separator:ad2f79864c20e5ee8283e9ddb6f7c0415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5ed83117e0ff9276abeb9a4fbaac61"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a4a5ed83117e0ff9276abeb9a4fbaac61">n_vertices</a> () const</td></tr>
<tr class="separator:a4a5ed83117e0ff9276abeb9a4fbaac61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e25f9720160ac96bc7f4eea0977784"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a48e25f9720160ac96bc7f4eea0977784">n_lines</a> () const</td></tr>
<tr class="separator:a48e25f9720160ac96bc7f4eea0977784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af330fe95fe8d30a99884797f61236913"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af330fe95fe8d30a99884797f61236913">n_faces</a> () const</td></tr>
<tr class="separator:af330fe95fe8d30a99884797f61236913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40947cf863ecef1ee08ec93f411baaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae40947cf863ecef1ee08ec93f411baaa">vertex_indices</a> () const</td></tr>
<tr class="separator:ae40947cf863ecef1ee08ec93f411baaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44268b67d46418c49a0a5e47f404adcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a44268b67d46418c49a0a5e47f404adcc">line_indices</a> () const</td></tr>
<tr class="separator:a44268b67d46418c49a0a5e47f404adcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4cabec41161961ab25d91b6cdc2425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a5b4cabec41161961ab25d91b6cdc2425">face_indices</a> () const</td></tr>
<tr class="separator:a5b4cabec41161961ab25d91b6cdc2425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">迭代器地址和状态</div></td></tr>
<tr class="memitem:ae826bd9e6c976638366d9993e6a6c7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level</a> () const</td></tr>
<tr class="separator:ae826bd9e6c976638366d9993e6a6c7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bebfc1e42324fbf595487e1bf668a22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a> () const</td></tr>
<tr class="separator:a6bebfc1e42324fbf595487e1bf668a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75f0d6c68a1a67ea03bd4727c29529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507">IteratorState::IteratorStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a5f75f0d6c68a1a67ea03bd4727c29529">state</a> () const</td></tr>
<tr class="separator:a5f75f0d6c68a1a67ea03bd4727c29529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af822c24c013e7b677f45ec2a8a41386a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af822c24c013e7b677f45ec2a8a41386a">get_triangulation</a> () const</td></tr>
<tr class="separator:af822c24c013e7b677f45ec2a8a41386a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac97bc3b07691e1a0ba9f32074642ae66"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ac97bc3b07691e1a0ba9f32074642ae66">space_dimension</a> = spacedim</td></tr>
<tr class="separator:ac97bc3b07691e1a0ba9f32074642ae66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125ed55a8362723639a14d083d9e745c"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a125ed55a8362723639a14d083d9e745c">dimension</a> = dim</td></tr>
<tr class="separator:a125ed55a8362723639a14d083d9e745c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e42860babc727fc028adfb9a3200b7"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a35e42860babc727fc028adfb9a3200b7">structure_dimension</a> = structdim</td></tr>
<tr class="separator:a35e42860babc727fc028adfb9a3200b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a436333e85278d0d4f3feb80abc2db97c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a436333e85278d0d4f3feb80abc2db97c">copy_from</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;)</td></tr>
<tr class="separator:a436333e85278d0d4f3feb80abc2db97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd4644115f0c10a4e07462029211274"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a7cd4644115f0c10a4e07462029211274">operator&lt;</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;other) const</td></tr>
<tr class="separator:a7cd4644115f0c10a4e07462029211274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88fce14be63f6000f7b5d70618dc14b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af88fce14be63f6000f7b5d70618dc14b">operator==</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;) const</td></tr>
<tr class="separator:af88fce14be63f6000f7b5d70618dc14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044710b90a02f1d4e6c2e39c00f51ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a044710b90a02f1d4e6c2e39c00f51ee7">operator!=</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;) const</td></tr>
<tr class="separator:a044710b90a02f1d4e6c2e39c00f51ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d5a6b58e60a06216665e31c26704bd"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaObjects.html">internal::TriangulationImplementation::TriaObjects</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ae6d5a6b58e60a06216665e31c26704bd">objects</a> () const</td></tr>
<tr class="separator:ae6d5a6b58e60a06216665e31c26704bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">迭代器的推进</div></td></tr>
<tr class="memitem:a5a24bd66635320e66d1dff07e3cb26e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a5a24bd66635320e66d1dff07e3cb26e1">operator++</a> ()</td></tr>
<tr class="separator:a5a24bd66635320e66d1dff07e3cb26e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d4f1dc476691cf77e88f2c3ed15afe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a85d4f1dc476691cf77e88f2c3ed15afe">operator--</a> ()</td></tr>
<tr class="separator:a85d4f1dc476691cf77e88f2c3ed15afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3ad5efb039ed878a124c9577acd92256"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1TriaAccessorImplementation_1_1PresentLevelType.html">internal::TriaAccessorImplementation::PresentLevelType</a>&lt; structdim, dim &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a3ad5efb039ed878a124c9577acd92256">present_level</a></td></tr>
<tr class="separator:a3ad5efb039ed878a124c9577acd92256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cf2d985abdb2c9a43ab97722305f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a11cf2d985abdb2c9a43ab97722305f34">present_index</a></td></tr>
<tr class="separator:a11cf2d985abdb2c9a43ab97722305f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02486bbb2ee4b94d1b51f03ba47257f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af02486bbb2ee4b94d1b51f03ba47257f">tria</a></td></tr>
<tr class="separator:af02486bbb2ee4b94d1b51f03ba47257f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a09d81693979927a7a966ddc18d243978"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a09d81693979927a7a966ddc18d243978">set_boundary_id_internal</a> (const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> id) const</td></tr>
<tr class="separator:a09d81693979927a7a966ddc18d243978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa045a20bce1bf6c012e50e9e12d37358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa045a20bce1bf6c012e50e9e12d37358">set_bounding_object_indices</a> (const std::initializer_list&lt; <a class="el" href="classint.html">int</a> &gt; &amp;new_indices) const</td></tr>
<tr class="separator:aa045a20bce1bf6c012e50e9e12d37358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5935fc1f892fdf9c90e4252c8aa2e095"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a5935fc1f892fdf9c90e4252c8aa2e095">set_bounding_object_indices</a> (const std::initializer_list&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;new_indices) const</td></tr>
<tr class="separator:a5935fc1f892fdf9c90e4252c8aa2e095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1947e00bce29b9e766546feb3bbd2f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab1947e00bce29b9e766546feb3bbd2f4">set_line_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html#a54c8283c86c84e29f718cbfe4118b3b2">line</a>, const <a class="el" href="classbool.html">bool</a> orientation) const</td></tr>
<tr class="separator:ab1947e00bce29b9e766546feb3bbd2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4e1cdc683814cbb505b66e088ded4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a2d4e1cdc683814cbb505b66e088ded4f">set_face_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> face, const <a class="el" href="classbool.html">bool</a> orientation) const</td></tr>
<tr class="separator:a2d4e1cdc683814cbb505b66e088ded4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120f75f4b65a498bd55ceffe89db968b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a120f75f4b65a498bd55ceffe89db968b">set_face_flip</a> (const unsigned <a class="el" href="classint.html">int</a> face, const <a class="el" href="classbool.html">bool</a> flip) const</td></tr>
<tr class="separator:a120f75f4b65a498bd55ceffe89db968b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eac7c4a6195f66c016eeaef1283ada8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a2eac7c4a6195f66c016eeaef1283ada8">set_face_rotation</a> (const unsigned <a class="el" href="classint.html">int</a> face, const <a class="el" href="classbool.html">bool</a> rotation) const</td></tr>
<tr class="separator:a2eac7c4a6195f66c016eeaef1283ada8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf46d7dd76ebe7b46e3e26d63859f0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6bf46d7dd76ebe7b46e3e26d63859f0c">set_used_flag</a> () const</td></tr>
<tr class="separator:a6bf46d7dd76ebe7b46e3e26d63859f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7983a80711bcde0ea9ec5f2cc95a935c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a7983a80711bcde0ea9ec5f2cc95a935c">clear_used_flag</a> () const</td></tr>
<tr class="separator:a7983a80711bcde0ea9ec5f2cc95a935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928a0f17388d3e7377fb216a0ca204a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a928a0f17388d3e7377fb216a0ca204a8">set_refinement_case</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; structdim &gt; &amp;ref_case) const</td></tr>
<tr class="separator:a928a0f17388d3e7377fb216a0ca204a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d0e9691107c5f5ed5b5fa54c71e92f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af0d0e9691107c5f5ed5b5fa54c71e92f">clear_refinement_case</a> () const</td></tr>
<tr class="separator:af0d0e9691107c5f5ed5b5fa54c71e92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee3827c653602a10ae243bfd26242eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aeee3827c653602a10ae243bfd26242eb">set_children</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>) const</td></tr>
<tr class="separator:aeee3827c653602a10ae243bfd26242eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048a39a28d4f2a4490a71e2edc8cfc3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a048a39a28d4f2a4490a71e2edc8cfc3f">clear_children</a> () const</td></tr>
<tr class="separator:a048a39a28d4f2a4490a71e2edc8cfc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abe9e690d5d7904f804316e15362a2191"><td class="memTemplParams" colspan="2">template&lt;int , int &gt; </td></tr>
<tr class="memitem:abe9e690d5d7904f804316e15362a2191"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#abe9e690d5d7904f804316e15362a2191">Triangulation</a></td></tr>
<tr class="separator:abe9e690d5d7904f804316e15362a2191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1173edf91a9d914373821b6117f32a8f"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a1173edf91a9d914373821b6117f32a8f">::internal::TriangulationImplementation::Implementation</a></td></tr>
<tr class="separator:a1173edf91a9d914373821b6117f32a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5f94c07c2ca904c27c04ca38eac0e1"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8b5f94c07c2ca904c27c04ca38eac0e1">::internal::TriangulationImplementation::ImplementationMixedMesh</a></td></tr>
<tr class="separator:a8b5f94c07c2ca904c27c04ca38eac0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bd8833f949eb9ac7a4dc4669177f26"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a66bd8833f949eb9ac7a4dc4669177f26">::internal::TriaAccessorImplementation::Implementation</a></td></tr>
<tr class="separator:a66bd8833f949eb9ac7a4dc4669177f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int structdim, int dim, int spacedim&gt;<br />
class TriaAccessor&lt; structdim, dim, spacedim &gt;</h3>

<p>一个提供对三角形中的对象的访问的类，如它的顶点、子对象、子女、几何信息等。这个类表示维度为 <code>structdim</code> （即1代表线，2代表四边形，3代表六边形）的对象在维度为 <code>dim</code> （即1代表线的三角结构，2代表四边形的三角结构，3代表六边形的三角结构）的三角结构中，该空间嵌入维度为 <code>spacedim</code> ]（对于 <code>spacedim==dim</code> ，三角形代表 \(R^{dim}\) 中的一个域，对于 <code>spacedim&gt;dim</code> ，三角形是嵌入高维空间中的流形）。 对于 <code>structdim</code> 等于零的情况，即对于三角化的顶点，该类有一个特殊化。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00144">144</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a563ba5bc45b2c81bd7164bc107bc3f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563ba5bc45b2c81bd7164bc107bc3f15">&#9670;&nbsp;</a></span>AccessorData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a> =  typename <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt;structdim, dim, spacedim&gt;::<a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从基类传播别名到这个类。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00689">689</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a90bf7670cf3c4571fe55e051d2503190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bf7670cf3c4571fe55e051d2503190">&#9670;&nbsp;</a></span>LocalData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a90bf7670cf3c4571fe55e051d2503190">LocalData</a> =  void *</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用来从迭代器向访问器类传递参数的数据类型，无论这些参数的数量类型是什么，都是统一的。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00435">435</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adcbbfa481886d095df724cef84d92286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbbfa481886d095df724cef84d92286">&#9670;&nbsp;</a></span>TriaAccessor() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a> *&#160;</td>
          <td class="paramname"><em>local_data</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。 </p>

</div>
</div>
<a id="a6ff27529711a78693b3912ce592c25df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff27529711a78693b3912ce592c25df">&#9670;&nbsp;</a></span>TriaAccessor() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制构造函数不被删除，但复制的构造元素不应该被修改，也是对复制赋值运算符的注释。 </p>

</div>
</div>
<a id="a14ff7adf27cb0ce877196474c858ddcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ff7adf27cb0ce877196474c858ddcf">&#9670;&nbsp;</a></span>TriaAccessor() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动构造函数。 </p>

</div>
</div>
<a id="aeaf81fa90cc1506bbdf6a54fb0626985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf81fa90cc1506bbdf6a54fb0626985">&#9670;&nbsp;</a></span>TriaAccessor() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>转换构造器。这个构造器的存在是为了使某些构造在独立于维度的代码中写得更简单。例如，它允许将一个面的迭代器分配给一个线的迭代器，这个操作在2D中很有用，但在3D中没有任何意义。这里的构造函数是为了使代码符合C++的要求而存在的，但它会无条件地中止；换句话说，将一个面迭代器分配给一个线迭代器，最好放在一个if语句中，检查维度是否为2，并在3D中分配给一个四边形迭代器（如果没有这个构造函数，如果我们碰巧为2d编译，这个操作是非法的）。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03488">3488</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a397500f10867aa69f4a731cc9ab2de53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397500f10867aa69f4a731cc9ab2de53">&#9670;&nbsp;</a></span>TriaAccessor() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>另一个对象之间的转换操作符，就像之前的那个一样，没有意义。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03518">3518</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a8eb1d967889a26340ed512f68dbf5331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb1d967889a26340ed512f68dbf5331">&#9670;&nbsp;</a></span>~TriaAccessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::~<a class="el" href="classTriaAccessor.html">TriaAccessor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>默认的解构器。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6274ae9855a9bd40654f82af32657427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6274ae9855a9bd40654f82af32657427">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&amp; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制运算符。这些运算符通常在类似<code>iterator a,b;a=*b;</code>的情况下使用。据推测，这里的意图是将 <code>b</code> 所指向的对象复制到 <code>a</code>. 所指向的对象。然而，取消引用迭代器的结果不是一个对象，而是一个存取器；因此，这个操作对三角形的迭代器没有用。 因此，这个操作被声明为删除，不能使用。 </p>

</div>
</div>
<a id="a5ce9055d943c6dfe89a07e5c0011a864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce9055d943c6dfe89a07e5c0011a864">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&amp; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动赋值运算符。允许移动。 </p>

</div>
</div>
<a id="aeb0b77c3f3c1de1f604d456d0718efc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0b77c3f3c1de1f604d456d0718efc0">&#9670;&nbsp;</a></span>used()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::used </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>测试元素是否被使用。 返回值是 <code>true</code> 对于所有的迭代器都是正常的迭代器或活动的迭代器，只有原始迭代器可以返回 <code>false</code>. 因为原始迭代器只在库的内部使用，你通常不需要这个函数。 </p>

</div>
</div>
<a id="a76b3fb7b9d5de13f797e3c04d4dd03a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b3fb7b9d5de13f797e3c04d4dd03a5">&#9670;&nbsp;</a></span>vertex_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;0, dim, spacedim&gt; &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex_iterator </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>指向与此对象相连接的 <code>ith</code> 顶点的指针。如果 <code>dim=1</code> ，则抛出一个异常。 </p>

</div>
</div>
<a id="a81afd26d765a4cec094b25767b8dd42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81afd26d765a4cec094b25767b8dd42a">&#9670;&nbsp;</a></span>vertex_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回当前对象的第i个顶点的全局索引。关于顶点编号的惯例在GeometryInfo类的文档中有所规定。 请注意，返回值只是几何顶点的索引。 它与可能与之相关的自由度无关。 关于这一点，请参阅 <code><a class="el" href="classDoFAccessor.html#a5aa1f2d13ea10d3e36d7fc6d982467ed">DoFAccessor::vertex_dof_index</a></code> 函数。 </p><dl class="section note"><dt>Note</dt><dd>尽管有这个名字，这里返回的索引只是全局的，即它是特定于一个特定的三角形对象，或者，在三角形实际上是 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, 类型的情况下，特定于存储在当前处理器上的分布式三角形的那一部分。 </dd></dl>

</div>
</div>
<a id="a3dd6518eb0cf5fccc5926470128415d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd6518eb0cf5fccc5926470128415d9">&#9670;&nbsp;</a></span>vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;&amp; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个对 <code>ith</code> 顶点的引用。该引用不是常量，也就是说，可以在赋值的左侧调用该函数，从而在三角剖分中移动单元的顶点。 当然，这样做需要你确保顶点的新位置保持有用。</p>
<ul>
<li>例如，避免倒置或其他扭曲的情况（另见 <a class="el" href="DEALGlossary.html#GlossDistorted">本词汇表条目</a>）。 <dl class="section note"><dt>Note</dt><dd>当一个单元被细化时，它的子单元继承了它们与母单元共享的那些顶点的位置（加上为新的子单元创建的边、面和单元内部的新顶点的位置）。如果一个单元的顶点被移动，这意味着其子单元也将使用这些新的位置。 另一方面，想象一下2D的情况，你有一个被精化的单元（有四个子单元），然后你移动连接所有四个子单元的中心顶点。如果你再次将这四个子单元粗化到母单元，那么移动的顶点的位置就会丢失，如果在以后的步骤中，你再次细化母单元，那么新的顶点将再次被放置在与第一次相同的位置上。</dd></dl>
</li>
<li>即，不在你之前移动的位置。 <dl class="section note"><dt>Note</dt><dd>如果你有一个 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 对象，上述的行为是相关的。在那里，细化一个网格总是涉及到重新划分。换句话说，你可能在一个处理器上移动到不同位置的本地拥有的单元的顶点（见 <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">这个词汇表条目</a> ），在网格细化时可能被移动到不同的处理器上（即使这些特定的单元没有被细化），这将根据他们之前拥有的粗略单元的位置重新创建他们的位置，而不是根据这些顶点在之前拥有它们的处理器的位置。换句话说，在并行计算中，你可能必须在每次网格细化后明确地移动节点，因为顶点的位置可能会也可能不会在伴随着网格细化的重新划分中被保留下来。 </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a54c8283c86c84e29f718cbfe4118b3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c8283c86c84e29f718cbfe4118b3b2">&#9670;&nbsp;</a></span>line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::TriangulationImplementation:: Iterators&lt;dim, spacedim&gt;::line_iterator <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>指向与此物体相邻的 <code>ith</code> 线的指针。 </p>

</div>
</div>
<a id="a450f0e6e00b9711650f59143e2085d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450f0e6e00b9711650f59143e2085d95">&#9670;&nbsp;</a></span>line_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>围绕此对象的 <code>ith</code> 线的索引。 只对<code>structdim&gt;1</code>实现，否则会产生异常。 </p>

</div>
</div>
<a id="a04dc361f8b3fb30c60a9e248c2108979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dc361f8b3fb30c60a9e248c2108979">&#9670;&nbsp;</a></span>quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::TriangulationImplementation:: Iterators&lt;dim, spacedim&gt;::quad_iterator <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>指向包围此对象的 <code>ith</code> 四边形的指针。 </p>

</div>
</div>
<a id="ab3f77d56ddde728b892e3c736a28cd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f77d56ddde728b892e3c736a28cd0c">&#9670;&nbsp;</a></span>quad_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::quad_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>绑定此对象的 <code>ith</code> 四边形的索引。 只对<code>structdim&gt;2</code>实现，否则产生异常。 </p>

</div>
</div>
<a id="a452389bb368ba37c9c5542ef956526ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452389bb368ba37c9c5542ef956526ee">&#9670;&nbsp;</a></span>face_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回索引为 <code>face</code> 的面的法线是否指向标准方向（ <code>true</code>) ），或者是否相反（ <code>false</code>). 哪个是标准方向，用GeometryInfo类来记录。在1d和2d中，它总是 <code>true</code>, ，但在3d中它可能是不同的，见GeometryInfo类文档中的相应讨论。 这个函数实际上只在库的内部使用，除非你绝对知道这是怎么回事。 </p>

</div>
</div>
<a id="ad90f5ff1a44cb8a6e08196dac6cdb22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90f5ff1a44cb8a6e08196dac6cdb22e">&#9670;&nbsp;</a></span>face_flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_flip </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回索引为 <code>face</code> 的面是否旋转了180度（ <code>为真）或不旋转（</code> <code>false</code>). 在1d和2d中，这总是 <code>false</code>, ，但在3d中可能不同，见GeometryInfo类文档中的相关讨论。 这个函数实际上只在库的内部使用，除非你绝对知道这是怎么回事。 </p>

</div>
</div>
<a id="a2f831f5ca8626677089f94af9be43a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f831f5ca8626677089f94af9be43a5b">&#9670;&nbsp;</a></span>face_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_rotation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回索引为 <code>face</code> 的面是否旋转了90度（ <code>为真）或不旋转（</code> <code>false</code>). 在1d和2d中，这总是 <code>false</code>, ，但在3d中可能不同，见GeometryInfo类文档中的相关讨论。 这个函数实际上只在库的内部使用，除非你绝对知道这是怎么回事。 </p>

</div>
</div>
<a id="a08aaa41d4d6e0942d888efc21ca5d6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08aaa41d4d6e0942d888efc21ca5d6c7">&#9670;&nbsp;</a></span>line_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回索引为 <code>line</code> 的线条是否朝向标准方向。 <code>true</code> 表示线的方向是从顶点0到顶点1，否则就是相反的方向。在1d和2d中，它总是 <code>true</code>, ，但在3d中它可能是不同的，见GeometryInfo类文档中的相应讨论。 这个函数实际上只在库的内部使用，除非你绝对知道这是怎么回事。 这个函数查询 <a class="el" href="classReferenceCell.html#a24db72fed8c0bf34ab1a1751ad2b1f38">ReferenceCell::standard_vs_true_line_orientation()</a>. 。 </p>

</div>
</div>
<a id="a4ce77fc45536beea670a0b5c1d91539c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce77fc45536beea670a0b5c1d91539c">&#9670;&nbsp;</a></span>has_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::has_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>测试对象是否有子代。 </p>

</div>
</div>
<a id="a634bf3e1c46e9ba87dfafa8c869e8972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634bf3e1c46e9ba87dfafa8c869e8972">&#9670;&nbsp;</a></span>n_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回此对象的直系子女数。未精炼的单元格的子代数为零。 </p>

</div>
</div>
<a id="aa0c1e25935669a4b310671a26e9dcbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c1e25935669a4b310671a26e9dcbd2">&#9670;&nbsp;</a></span>number_of_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::number_of_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>使用n_active_descendants()代替。</dd></dl>

</div>
</div>
<a id="a24fb24948b4e177f8e4eb737ec057397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fb24948b4e177f8e4eb737ec057397">&#9670;&nbsp;</a></span>n_active_descendants()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_active_descendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算并返回该对象的活动后裔的数量。例如，如果一个六边形的所有八个子单元都被进一步各向同性地精炼了一次，返回的数字将是64，而不是80。 如果目前的单元没有被细化，则返回一个。 如果把三角结构看成是一个森林，每棵树的根都是粗大的网格单元，节点都有后代（单元的子女），那么这个函数就会返回源自当前对象的子树中终端节点的数量；因此，如果当前对象没有被进一步细化，答案是1。 </p>

</div>
</div>
<a id="aa39e613fd2e2c22bdc8ba340068e5713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39e613fd2e2c22bdc8ba340068e5713">&#9670;&nbsp;</a></span>max_refinement_depth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::max_refinement_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个对象被精炼的次数。请注意，并不是所有的子对象都被精炼了那么多次（这就是为什么我们要在前面加上 <code>max_</code>), 的原因，返回的数字是这个对象的任何分支中的最大精炼次数。 例如，如果这个对象被精炼了，并且它的一个子对象正好再被精炼一次，那么<code>max_refinement_depth</code>应该返回2。 如果这个对象没有被精炼（即它是活动的），那么返回值是0。 </p>

</div>
</div>
<a id="ad791ab6cd4f749e0c9f601a2bc442bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad791ab6cd4f749e0c9f601a2bc442bd9">&#9670;&nbsp;</a></span>child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;structdim, dim, spacedim&gt; &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::child </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个指向 <code>ith</code> 子对象的迭代器。 </p>

</div>
</div>
<a id="a237132d2e5161b34a05291e10f3d6feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237132d2e5161b34a05291e10f3d6feb">&#9670;&nbsp;</a></span>child_iterator_to_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::child_iterator_to_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回当前单元格上 <code>child</code> 的子数。这是 <a class="el" href="classTriaAccessor.html#ad791ab6cd4f749e0c9f601a2bc442bd9">TriaAccessor::child()</a>. 的反函数。 </p>

</div>
</div>
<a id="aa035549b0c8b7eb7fcd33654bc73da29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa035549b0c8b7eb7fcd33654bc73da29">&#9670;&nbsp;</a></span>isotropic_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;structdim, dim, spacedim&gt; &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::isotropic_child </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该对象的迭代器，该对象与各向同性细化的第i个孩子相同。如果当前对象是各向同性细化的，那么返回的对象就是第i个子对象。如果当前对象是各向异性精炼的，那么返回的子对象实际上可能是该对象的孙子，或者根本就不存在（在这种情况下会产生一个异常）。 </p>

</div>
</div>
<a id="ae6a4a753f2ef5b2615a7e2fec21e0dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a4a753f2ef5b2615a7e2fec21e0dec">&#9670;&nbsp;</a></span>refinement_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;structdim&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::refinement_case </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个单元格的RefinementCase。 </p>

</div>
</div>
<a id="acd7551fc85831a3fd4d5cd339b81d8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7551fc85831a3fd4d5cd339b81d8c6">&#9670;&nbsp;</a></span>child_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::child_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>ith</code> 子单元的索引。如果单元格的子代被访问，则子代的级别比本单元格的级别高一个。面的孩子没有级别。如果子单元不存在。</p>
<ul>
<li>被返回。 </li>
</ul>

</div>
</div>
<a id="a8adec5f5b7786cf43e6011d03cc7903a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adec5f5b7786cf43e6011d03cc7903a">&#9670;&nbsp;</a></span>isotropic_child_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::isotropic_child_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>ith</code> 各向同性的子女的索引。参见isotropic_child()函数对这个概念的定义。 如果该子集不存在。</p>
<ul>
<li>被返回。 </li>
</ul>

</div>
</div>
<a id="af2b4887416074f2ecdcd06512e864e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b4887416074f2ecdcd06512e864e48">&#9670;&nbsp;</a></span>boundary_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::boundary_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回此对象的边界指示器。 如果返回值是特殊值 <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>, ，那么这个对象就在域的内部。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">关于边界指标的词汇条目</a> </dd></dl>

</div>
</div>
<a id="a654de9ccd776b524a27cd64bded48e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654de9ccd776b524a27cd64bded48e14">&#9670;&nbsp;</a></span>set_boundary_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_boundary_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置当前对象的边界指标。这与boundary_id()函数的情况相同。 这个函数只设置当前对象本身的边界对象，而不是绑定它的指标。例如，在3D中，如果这个函数被调用到一个面，那么绑定这个面的4条边的边界指标保持不变。如果你想同时设置面和边的边界指标，请使用set_all_boundary_ids()函数。你可以在 <a class="el" href="step_49.html">step-49</a> 的结果部分看到没有使用正确函数的结果。 </p><dl class="section warning"><dt>Warning</dt><dd>你不应该设置内部面（不在域的边界上的面）的边界指示器，也不应该将外部面的边界指示器设置为 <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> （这个值是为其他目的保留的）。如果边界单元的边界指示器为 <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> ，或者内部单元的边界指示器不是 <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>. ，算法可能无法工作或产生非常混乱的结果。 不幸的是，当前对象没有办法找出它是否真的处于域的边界，因此无法确定你试图设置的值在当前情况下是否有意义。 @ @ "" </dd></dl>

</div>
</div>
<a id="aa0304fb253839c45e64b60460ab040ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0304fb253839c45e64b60460ab040ae">&#9670;&nbsp;</a></span>set_all_boundary_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_all_boundary_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像set_boundary_id()那样做，但也要设置约束当前对象的边界指标。例如，在3D中，如果对一个面调用set_boundary_id()，那么绑定该面的4条边的边界指标保持不变。相反，如果你调用当前函数，面和边的边界指示器都被设置为给定值。 如果你在3D中设置面的边界指示器（在2D中，该函数的作用与set_boundary_id()相同），并且你这样做是因为你想用一个弯曲的边界对象来表示与当前面相对应的那部分边界，那么这个函数就很有用。在这种情况下，Triangulation类需要弄清楚在网格细化时将新的顶点放在哪里，高阶Mapping对象也需要弄清楚曲线边界近似的新插值点应该在哪里。在这两种情况下，这两个类首先要确定边界面边缘的插值点，询问边界对象，然后再向边界对象询问对应于边界面内部的插值点。为了使其正常工作，仅仅设置了面的边界指示器是不够的，还需要设置约束面的边缘的边界指示器。这个函数一次就完成了所有这些工作。你可以在 <a class="el" href="step_49.html">step-49</a> 的结果部分看到没有使用正确函数的结果。 @ @ "" </p>

</div>
</div>
<a id="af211333148f7b1190db625ce91b23b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af211333148f7b1190db625ce91b23b65">&#9670;&nbsp;</a></span>at_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::at_boundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个对象是否在边界上。显然，这个函数的使用只适用于<code>dim &gt;structdim</code>; 然而，对于<code>dim==structdim</code>，一个对象是一个单元，CellAccessor类提供了另一种可能性来确定一个单元是否在边界。 </p>

</div>
</div>
<a id="ae4d63b9ebf9b5c31aa702e49c664e59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d63b9ebf9b5c31aa702e49c664e59d">&#9670;&nbsp;</a></span>get_manifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classManifold.html">Manifold</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::get_manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该对象所使用的流形对象的常数引用。 正如 <a class="el" href="group__manifold.html">Manifold description for triangulations</a> 模块中所解释的，寻找合适的流形描述的过程涉及到查询流形或边界指标。更多信息见那里。 </p>

</div>
</div>
<a id="a6c28dbcfefe0ffe1e51fe315c3565f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c28dbcfefe0ffe1e51fe315c3565f94">&#9670;&nbsp;</a></span>manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::manifold_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回此对象的歧管指标。 如果返回值是特殊值 <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>, ，那么这个对象就与一个标准的笛卡尔流形描述相关。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">关于流形指标的词汇条目</a> </dd></dl>

</div>
</div>
<a id="a6aa91f3e086777b02a2f6eef7ac19ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa91f3e086777b02a2f6eef7ac19ebb">&#9670;&nbsp;</a></span>user_flag_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::user_flag_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>读取用户标志。更多信息见 <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> 。 </p>

</div>
</div>
<a id="a6dda85b6637fefd5db3d37ad7729fcb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dda85b6637fefd5db3d37ad7729fcb1">&#9670;&nbsp;</a></span>set_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置用户标志。参见 <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> 了解更多信息。 </p>

</div>
</div>
<a id="a59ff7c1bc2b4fc8abcd9b3ef44b5f485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ff7c1bc2b4fc8abcd9b3ef44b5f485">&#9670;&nbsp;</a></span>clear_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>清除用户标志。参见 <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> 了解更多信息。 </p>

</div>
</div>
<a id="a63d791b3769c77bcfd1c56748a6c56fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d791b3769c77bcfd1c56748a6c56fa">&#9670;&nbsp;</a></span>recursively_set_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_set_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为这个和所有的子代设置用户标志。参见 <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> 以了解更多信息。 </p>

</div>
</div>
<a id="a50b22f28a2baf2dd90b5309c3f0136af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b22f28a2baf2dd90b5309c3f0136af">&#9670;&nbsp;</a></span>recursively_clear_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_clear_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>清除此项目和所有子项目的用户标志。参见 <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> 以了解更多信息。 </p>

</div>
</div>
<a id="a3965091ec2c6ba6ed838a2479dd8110f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3965091ec2c6ba6ed838a2479dd8110f">&#9670;&nbsp;</a></span>clear_user_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将用户数据重置为零，与指针或索引无关。更多信息见 GlossUserData 。 </p>

</div>
</div>
<a id="aceaaa0940be75dd7436769b55538aaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceaaa0940be75dd7436769b55538aaac">&#9670;&nbsp;</a></span>set_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_user_pointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将用户指针设置为 <code>p</code>. 。 </p><dl class="section note"><dt>Note</dt><dd>用户指针和用户索引是相互排斥的。因此，你只能使用其中之一，除非你在中间调用 <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> 。 参见 GlossUserData 以了解更多信息。 </dd></dl>

</div>
</div>
<a id="a1fd20837028286220f0b2ba9b0d4b219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd20837028286220f0b2ba9b0d4b219">&#9670;&nbsp;</a></span>clear_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将用户指针重置为 <code>nullptr</code> 指针。参见 GlossUserData 以了解更多信息。 </p>

</div>
</div>
<a id="ad3700f2ce7587b2fbcaf85753c79bf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3700f2ce7587b2fbcaf85753c79bf40">&#9670;&nbsp;</a></span>user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::user_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>访问用户指针的值。用户有责任确保该指针指向有用的东西。你应该使用新式的cast操作符来保持最低限度的类型安全，例如。 </p><dl class="section note"><dt>Note</dt><dd>用户指针和用户索引是互斥的。因此，你只能使用其中之一，除非你在中间调用 <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> 。<code>A a=static_cast&lt;A*&gt;(cell-&gt;<a class="el" href="classTriaAccessor.html#ad3700f2ce7587b2fbcaf85753c79bf40">user_pointer()</a>)；</code>。 更多信息见 GlossUserData 。 </dd></dl>

</div>
</div>
<a id="a484e590959847d514d42814efa3e25c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484e590959847d514d42814efa3e25c2">&#9670;&nbsp;</a></span>recursively_set_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_set_user_pointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将此对象及其所有子对象的用户指针设置为给定值。例如，如果某个子域的所有单元格，或者边界的某个部分的所有面都应该有用户指针指向描述这部分域或边界的对象，这就很有用。 请注意，用户指针在网格细化过程中是不被继承的，所以在网格细化之后，可能会有单元格或面没有用户指针指向描述对象。在这种情况下，只需简单地循环所有具有此信息的最粗层次的元素，并使用此函数递归地设置三角形的所有更细层次的用户指针。 </p><dl class="section note"><dt>Note</dt><dd>用户指针和用户索引是互斥的。因此，你只能使用其中之一，除非你在中间调用 <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> 。 更多信息见 GlossUserData 。 </dd></dl>

</div>
</div>
<a id="ad04d1802d9b1e8923dcfef41ea624edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04d1802d9b1e8923dcfef41ea624edc">&#9670;&nbsp;</a></span>recursively_clear_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_clear_user_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>清除这个对象的用户指针和它所有的子对象。这与recursively_set_user_pointer()函数的说法相同。更多信息见 GlossUserData 。 </p>

</div>
</div>
<a id="a0cca979ccf43e19af78dcb91d19cfd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cca979ccf43e19af78dcb91d19cfd87">&#9670;&nbsp;</a></span>set_user_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_user_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将用户索引设置为 <code>p</code>. 。 </p><dl class="section note"><dt>Note</dt><dd>用户指针和用户索引是相互排斥的。因此，你只能使用其中之一，除非你在中间调用 <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> 。更多信息见 GlossUserData 。 </dd></dl>

</div>
</div>
<a id="a97a1e59ae7328b4c75c69720826736c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a1e59ae7328b4c75c69720826736c0">&#9670;&nbsp;</a></span>clear_user_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将用户索引重置为0。更多信息见 GlossUserData 。 </p>

</div>
</div>
<a id="ac7a24da10289811179abbfb57253e9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a24da10289811179abbfb57253e9d3">&#9670;&nbsp;</a></span>user_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::user_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>访问用户索引的值。 </p><dl class="section note"><dt>Note</dt><dd>用户指针和用户索引是相互排斥的。因此，你只能使用其中之一，除非你在中间调用 <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> 。 更多信息见 GlossUserData 。 </dd></dl>

</div>
</div>
<a id="a309ae29be30ad5a259b1cd942e7d9e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309ae29be30ad5a259b1cd942e7d9e9d">&#9670;&nbsp;</a></span>recursively_set_user_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_set_user_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置此对象及其所有子对象的用户索引。 请注意，用户索引在网格细化中是不被继承的，所以在网格细化后，可能会有单元格或面的用户索引不符合预期。在这种情况下，只需循环查看所有拥有该信息的最粗层次的元素，并使用该函数递归设置三角结构中所有更细层次的用户索引。 </p><dl class="section note"><dt>Note</dt><dd>用户指针和用户索引是相互排斥的。因此，你只能使用其中之一，除非你在中间调用 <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> 。 更多信息见 GlossUserData 。 </dd></dl>

</div>
</div>
<a id="a429e559fb261a631942d54c897243abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429e559fb261a631942d54c897243abb">&#9670;&nbsp;</a></span>recursively_clear_user_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_clear_user_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>清除这个对象的用户索引和它的所有后代。这与recursively_set_user_index()函数的说法相同。 更多信息见 GlossUserData 。 </p>

</div>
</div>
<a id="af0e85725edb5d2bb43da61796f2fbbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e85725edb5d2bb43da61796f2fbbb9">&#9670;&nbsp;</a></span>diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::diameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>物体的直径。 一个物体的直径被计算为当前物体的最大对角线。如果这个物体是四边形，那么有两条这样的对角线，如果是六面体，那么有四条对角线连接 "对面
"的点。对于三角形和四面体，该函数只是返回最长边的长度。 楔形和金字塔的情况就比较困难了。对于楔形，我们返回三个四边形面的最长对角线的长度或两个三角形面的最长边的长度。对于金字塔，同样的原则也适用。 在所有这些情况下，这个 "直径
"的定义不一定是物体内部各点之间最大距离意义上的真正直径。事实上，我们经常可以构造出不是这样的物体，尽管这些物体与参考形状相比一般都有很大的变形。此外，对于可能使用高阶映射的物体，我们可能会有凸起的面，这也会给计算物体直径的精确表示带来麻烦。也就是说，上面使用的定义对于大多数计算来说是完全足够的。 </p>

</div>
</div>
<a id="a7af8bab7e9ad732b6f3fa6a120ed5208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af8bab7e9ad732b6f3fa6a120ed5208">&#9670;&nbsp;</a></span>enclosing_ball()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;, <a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::enclosing_ball </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一对Point和double，对应于物体的中心和合理的小包围球的半径。 该函数实现了Ritter的O(n)算法，以获得一个围绕对象顶点的合理的小包围球。 包围球的初始猜测是包含对象的最大对角线作为其直径的球。 从这样的初始猜测开始，算法测试对象的所有顶点（除了最大对角线的顶点）在几何上是否在球内。 如果发现任何顶点（v）在几何上不在球内，则通过移动球的中心和增加半径来构建一个新的球的迭代，以便在几何上包围先前的球和顶点（v）。当所有的顶点都在球的几何范围内时，该算法就结束了。 如果一个顶点（v）在几何上位于球的某个迭代中，那么它将在球的后续迭代中继续如此（这是真实的，通过/a结构）。 </p><dl class="section note"><dt>Note</dt><dd>这个函数假定从参考单元开始的d-线性映射。 <a href="http://geomalgorithms.com/a08-_containers.html">see this</a>和[Ritter 1990]。 </dd></dl>

</div>
</div>
<a id="a57453302997d9df8d1e242bf663dc11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57453302997d9df8d1e242bf663dc11b">&#9670;&nbsp;</a></span>bounding_box()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::bounding_box </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回包围该对象的最小边界框。 注意，这个方法不知道你可能用来做计算的任何映射。如果你使用的是修改顶点位置的映射对象，比如MappingQEulerian，或者MappingFEField，那么你应该调用函数 <a class="el" href="classMapping.html#a50d2861c7e444384240609ec53093a54">Mapping::get_bounding_box()</a> 代替。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01587">1587</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a49a088728d7acb727fdc13bb6664d91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a088728d7acb727fdc13bb6664d91a">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对象在给定轴线方向的长度，在本地坐标系中指定。关于本地轴的含义和列举，请参见GeometryInfo的文档。 请注意，一个物体的 "长度
"可以有多种解释。在这里，我们选择它作为对象的任何一条边的最大长度，这些边与参考单元上选择的轴平行。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01609">1609</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a99b268c743742c3c9ab159ff916d9236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b268c743742c3c9ab159ff916d9236">&#9670;&nbsp;</a></span>minimum_vertex_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::minimum_vertex_distance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回任何两个顶点之间的最小距离。 </p>

</div>
</div>
<a id="a49df04630565a833e168e9cab074305e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49df04630565a833e168e9cab074305e">&#9670;&nbsp;</a></span>intermediate_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::intermediate_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; structdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>coordinates</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个属于此对象所在的流形&lt;dim,spacedim&gt;的点，给定其在参考单元格 <code>structdim</code> 上的参数化坐标。该函数可查询底层流形对象，并可用于获得该对象上任意点的精确几何位置。 注意，参数 <code>coordinates</code> 是 <em> 参考单元 </em> 上的坐标，以参考坐标给出。换句话说，该参数提供了不同顶点之间的权重。例如，对于线，调用这个函数的参数是Point&lt;1&gt;(.5)，相当于要求线的中心。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01714">1714</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a3eb24d5074a9a7bf216bd82f5d0dc618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb24d5074a9a7bf216bd82f5d0dc618">&#9670;&nbsp;</a></span>real_to_unit_cell_affine_approximation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; structdim &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::real_to_unit_cell_affine_approximation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数通过从参考 \(d\) 维单元反转 \(d\) 线性函数的仿射近似，计算从实数到单元格的快速近似转换。 单位单元到实数单元映射的仿生近似是通过仿生函数与本对象的 \(2^d\) 顶点的最小二乘法拟合找到的。对于任何有效的网格单元，其几何形状不是退化的，这个操作的结果是一个唯一的仿生映射。因此，对于所有给定的输入点，这个函数将返回一个有限的结果，即使在实际的双/三线或高阶映射的实际转换可能是单数的情况下。除了仅从顶点近似映射外，该函数还忽略了附加的流形描述。只有在从单元格到实际单元格的转换确实是仿生的情况下，结果才是准确的，比如在一维或二维/三维的笛卡尔和仿生（平行四边形）网格。 对于单元格的精确变换，使用 <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>. 。 </p><dl class="section note"><dt>Note</dt><dd>如果dim&lt;spacedim，我们首先将p投影到平面上。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01736">1736</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a8b045bcae58de112897824f4f08d1713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b045bcae58de112897824f4f08d1713">&#9670;&nbsp;</a></span>center()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::center </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>respect_manifold</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>interpolate_from_surrounding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>物体的中心。对象的中心被定义为顶点位置的平均值，这也是 \(Q_1\) 映射将映射参考单元的中心的地方。然而，你也可以要求这个函数返回与当前对象相关的底层流形对象所计算的顶点的平均值，方法是将可选参数 <code>respect_manifold</code>. 设置为 true 流形通常会将顶点的坐标拉回到参考域（不一定是参考单元），在那里计算平均值，然后再将平均值点的坐标推到物理空间；结果点保证位于流形内，即使流形是弯曲的。 当对象使用不同的流形描述作为其周围环境时，比如该TriaAccessor的部分边界对象使用非平面流形描述，但对象本身是平面的， <a class="el" href="classTriaAccessor.html#a8b045bcae58de112897824f4f08d1713">TriaAccessor::center()</a> 函数给出的结果可能不够准确，即使参数 <code>respect_manifold</code> 被设置为真。如果你发现这种情况，你可以通过将第二个附加参数 <code>interpolate_from_surrounding设置为真来进一步完善中心的计算。这将通过从所有边界对象的中心进行所谓的无限插值来计算中心的位置。对于一个二维物体，它在四条周围线中的每一条上加了</code> <code>1/2</code> 的权重，在四个顶点上加了 <code>-1/4</code> 的权重。这相当于四个面的描述之间的线性插值，减去顶点的贡献，当通过与顶点相邻的两条线时，顶点的贡献被加了两次。在三维中，面的权重是 <code>1/2</code> ，线的权重是 <code>-1/4</code> ，而顶点的权重是 <code>1/8</code> 。为了进一步了解情况，还可以赋予TransfiniteInterpolationManifold类，该类不仅能够将这种有益的描述应用于单个单元，而且能够应用于粗略单元的所有子女。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01755">1755</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a56cc737f4b28f8d28a576d2e3d32ef9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cc737f4b28f8d28a576d2e3d32ef9f">&#9670;&nbsp;</a></span>barycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::barycenter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回对象的arycenter（也叫中心点）。在 \(D\) 空间维度中，维度为 \(K\) 的对象的arycenter由 </p><p class="formulaDsp">
\[ \mathbf x_K = \frac{1}{|K|} \int_K \mathbf x \; \textrm{d}x \]
</p>
<p>定义的 \(\mathbf x_K\) -维向量给出，其中对象的度量由 </p><p class="formulaDsp">
\[ |K| = \int_K \mathbf 1 \; \textrm{d}x. \]
</p>
<p>给出。 这个函数假定 \(K\) 由 \(d\) -线性函数从参考 \(d\) -维单元映射出来。然后，上面的积分可以被拉回到参考单元，并准确地进行评估（如果通过冗长的，并且与Center()函数相比，昂贵的计算）。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01565">1565</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a9cecb2b7c9a1644fb5fd44bbba40ab0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cecb2b7c9a1644fb5fd44bbba40ab0c">&#9670;&nbsp;</a></span>measure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::measure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算对象的dim-dimensional度量。对于二维空间中的二维单元，这等于其体积。另一方面，对于三维空间中的二维单元，或者如果当前指向的对象是三维空间中的三维单元的二维面，那么该函数就会计算该对象所占的面积。对于一个一维的物体，返回其长度。 该函数只计算假定由（双/三）线性映射表示的单元、面或边的量度。换句话说，它只考虑绑定当前对象的顶点的位置，而不考虑对象的内部实际上如何被映射。在大多数简单的情况下，这正是你想要的。然而，对于不 "直
"的对象，例如，嵌入三维空间的二维单元作为弯曲域的三角化的一部分，三维单元的二维面不仅仅是平行四边形，或者位于域的边界的面不仅仅是由直线段或平面限定的，这个函数只计算由描述有关对象的真实几何的流形或边界对象定义的 "真实
"对象的（双/三）线性内插的二维度量。如果你想考虑 "真实
"几何，你将需要通过在物体上积分一个等于1的函数来计算这个度量，在应用正交之后，等于将你想用于积分的FEValues或FEFaceValues对象返回的JxW值相加。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01576">1576</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ab21eeac18f82c9689857c225ca6be7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21eeac18f82c9689857c225ca6be7e4">&#9670;&nbsp;</a></span>is_translation_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::is_translation_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果当前对象是给定参数的翻译，则返回真。 </p><dl class="section note"><dt>Note</dt><dd>为了三角测量的目的，单元格、面等只由其顶点来描述。因此，当前函数只对顶点的位置进行比较。然而，对于许多实际应用来说，决定一个单元是否是另一个单元的翻译的不仅仅是顶点，还有单元如何从参考单元映射到它在现实空间中的位置。例如，如果我们使用高阶映射，那么不仅顶点必须是彼此的平移，而且还必须是沿边缘的点。因此，在这些问题中，应该问映射，而不是当前的函数，两个对象是否是彼此的平移。 </dd></dl>

</div>
</div>
<a id="ad2f79864c20e5ee8283e9ddb6f7c0415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f79864c20e5ee8283e9ddb6f7c0415">&#9670;&nbsp;</a></span>reference_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classReferenceCell.html">ReferenceCell</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::reference_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>当前对象的参考单元格类型。 </p>

</div>
</div>
<a id="a4a5ed83117e0ff9276abeb9a4fbaac61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5ed83117e0ff9276abeb9a4fbaac61">&#9670;&nbsp;</a></span>n_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>顶点的数量。 </p>

</div>
</div>
<a id="a48e25f9720160ac96bc7f4eea0977784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e25f9720160ac96bc7f4eea0977784">&#9670;&nbsp;</a></span>n_lines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>行的数量。 </p>

</div>
</div>
<a id="af330fe95fe8d30a99884797f61236913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af330fe95fe8d30a99884797f61236913">&#9670;&nbsp;</a></span>n_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>面的数量。 </p><dl class="section note"><dt>Note</dt><dd>只对单元格实现（dim==spacedim）。 </dd></dl>

</div>
</div>
<a id="ae40947cf863ecef1ee08ec93f411baaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40947cf863ecef1ee08ec93f411baaa">&#9670;&nbsp;</a></span>vertex_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个对象，它可以被认为是一个包含从零到n_vertices()所有索引的数组。 </p>

</div>
</div>
<a id="a44268b67d46418c49a0a5e47f404adcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44268b67d46418c49a0a5e47f404adcc">&#9670;&nbsp;</a></span>line_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个对象，它可以被认为是一个包含从零到n_lines()所有索引的数组。 </p>

</div>
</div>
<a id="a5b4cabec41161961ab25d91b6cdc2425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4cabec41161961ab25d91b6cdc2425">&#9670;&nbsp;</a></span>face_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个对象，它可以被认为是一个包含从零到n_faces()的所有索引的数组。 </p><dl class="section note"><dt>Note</dt><dd>只对单元格实现（dim==spacedim）。 </dd></dl>

</div>
</div>
<a id="a09d81693979927a7a966ddc18d243978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d81693979927a7a966ddc18d243978">&#9670;&nbsp;</a></span>set_boundary_id_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_boundary_id_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与set_boundary_id类似，但没有检查内部面或无效的id。 </p>

</div>
</div>
<a id="aa045a20bce1bf6c012e50e9e12d37358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa045a20bce1bf6c012e50e9e12d37358">&#9670;&nbsp;</a></span>set_bounding_object_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_bounding_object_indices </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置那些约束当前对象的对象的索引。例如，如果当前对象代表一个单元格，那么该参数表示绑定该单元格的面的索引。如果当前对象代表一条线，那么该参数表示绑定该线的顶点的指数。以此类推。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01525">1525</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a5935fc1f892fdf9c90e4252c8aa2e095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5935fc1f892fdf9c90e4252c8aa2e095">&#9670;&nbsp;</a></span>set_bounding_object_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_bounding_object_indices </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与上述相同，但对<code>无符号int</code>而言。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01545">1545</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ab1947e00bce29b9e766546feb3bbd2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1947e00bce29b9e766546feb3bbd2f4">&#9670;&nbsp;</a></span>set_line_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_line_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置标志，表明 <code><a class="el" href="classTriaAccessor.html#a08aaa41d4d6e0942d888efc21ca5d6c7">line_orientation()</a></code> 将返回什么。 只有在3D中才能设置面的线方向（即 <code>structdim==2 &amp;&amp; dim==3</code> ）。 </p>

</div>
</div>
<a id="a2d4e1cdc683814cbb505b66e088ded4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4e1cdc683814cbb505b66e088ded4f">&#9670;&nbsp;</a></span>set_face_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_face_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置索引为 <code>face</code> 的四边形的法线是否指向标准方向（ <code>true</code>) ），或者是否相反（ <code>false</code>). 哪个是标准方向，用GeometryInfo类记录。 这个函数只用于库的内部使用。将这个标志设置为任何其他的值，而不是三角测量已经设置的值，必然会给你带来灾难。 </p>

</div>
</div>
<a id="a120f75f4b65a498bd55ceffe89db968b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120f75f4b65a498bd55ceffe89db968b">&#9670;&nbsp;</a></span>set_face_flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_face_flip </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>flip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置标志表明， <code><a class="el" href="classTriaAccessor.html#ad90f5ff1a44cb8a6e08196dac6cdb22e">face_flip()</a></code> 将返回什么。 只有在三维中才能设置单元格的面朝向（即 <code>structdim==3 &amp;&amp; dim==3</code> ）。 </p>

</div>
</div>
<a id="a2eac7c4a6195f66c016eeaef1283ada8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eac7c4a6195f66c016eeaef1283ada8">&#9670;&nbsp;</a></span>set_face_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_face_rotation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置标志，表明 <code><a class="el" href="classTriaAccessor.html#a2f831f5ca8626677089f94af9be43a5b">face_rotation()</a></code> 将返回什么。 只有在3D中才能设置单元格的面朝向（即 <code>structdim==3 &amp;&amp; dim==3</code> ）。 </p>

</div>
</div>
<a id="a6bf46d7dd76ebe7b46e3e26d63859f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf46d7dd76ebe7b46e3e26d63859f0c">&#9670;&nbsp;</a></span>set_used_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_used_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置 <code>used</code> 标志。仅用于库的内部使用。 </p>

</div>
</div>
<a id="a7983a80711bcde0ea9ec5f2cc95a935c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7983a80711bcde0ea9ec5f2cc95a935c">&#9670;&nbsp;</a></span>clear_used_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_used_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>清除 <code>used</code> 标志。仅供图书馆内部使用。 </p>

</div>
</div>
<a id="a928a0f17388d3e7377fb216a0ca204a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928a0f17388d3e7377fb216a0ca204a8">&#9670;&nbsp;</a></span>set_refinement_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_refinement_case </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; structdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_case</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置 <code>RefinementCase&lt;dim&gt;</code> 这个TriaObject的精炼。对于<code>structdim=1</code>不定义，因为线条总是被细化成2条子线（各向同性细化）。 如果你接触这个函数，你应该很清楚你在做什么。它是专门用于库的内部使用的。 </p>

</div>
</div>
<a id="af0d0e9691107c5f5ed5b5fa54c71e92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d0e9691107c5f5ed5b5fa54c71e92f">&#9670;&nbsp;</a></span>clear_refinement_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_refinement_case </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>清除这个TriaObject的RefinementCase&lt;dim&gt;，即重置为 <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase&lt;dim&gt;::no_refinement</a>. 你应该很清楚你在做什么，如果你碰触这个函数。它是专门用于库的内部使用的。 </p>

</div>
</div>
<a id="aeee3827c653602a10ae243bfd26242eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee3827c653602a10ae243bfd26242eb">&#9670;&nbsp;</a></span>set_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_children </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置第1个孩子的索引。由于孩子们至少是成对出现的，我们只需要存储第二个孩子的索引，也就是偶数孩子的索引。请确保首先设置第i=0个孩子的索引。不允许对奇数的孩子调用这个函数。 </p>

</div>
</div>
<a id="a048a39a28d4f2a4490a71e2edc8cfc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048a39a28d4f2a4490a71e2edc8cfc3f">&#9670;&nbsp;</a></span>clear_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>清除子字段，即把它设置为一个值，表示这个单元格没有子字。 </p>

</div>
</div>
<a id="ab467082583c8bce60bd9dd669b939ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab467082583c8bce60bd9dd669b939ae9">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 1, 1, 1 &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01620">1620</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a0264eafc337e3596b9f895a091b18a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0264eafc337e3596b9f895a091b18a44">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 1, 1, 2 &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01631">1631</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a1b363d9cf3b6911d41223c9ed5d82daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b363d9cf3b6911d41223c9ed5d82daa">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 2, 2, 2 &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lines along x-axis, see <a class="el" href="structGeometryInfo.html">GeometryInfo</a></p>
<p>Lines along y-axis </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01642">1642</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a09623959e21c50be31d6e40b508c39b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09623959e21c50be31d6e40b508c39b4">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 2, 2, 3 &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lines along x-axis, see <a class="el" href="structGeometryInfo.html">GeometryInfo</a></p>
<p>Lines along y-axis </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01656">1656</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a7f33cb96e76ff07eaf0052427907aeb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f33cb96e76ff07eaf0052427907aeb3">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 3, 3, 3 &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lines along x-axis, see <a class="el" href="structGeometryInfo.html">GeometryInfo</a></p>
<p>Lines along y-axis</p>
<p>Lines along z-axis </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01671">1671</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a8b007b674b316f793f72b8ddc31e1cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b007b674b316f793f72b8ddc31e1cf9">&#9670;&nbsp;</a></span>set_all_manifold_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 3, 3, 3 &gt;::set_all_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>manifold_ind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01693">1693</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a436333e85278d0d4f3feb80abc2db97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436333e85278d0d4f3feb80abc2db97c">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制操作符。因为这只是从迭代器中调用，所以不要返回任何东西，因为迭代器会返回自己。 这个方法是受保护的，因为它只能从迭代器类中调用。 </p>

</div>
</div>
<a id="a7cd4644115f0c10a4e07462029211274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd4644115f0c10a4e07462029211274">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>访问器的比较运算符。这个操作符在比较迭代器进入三角形的对象时使用，例如，当把它们放入一个 <code>std::map</code>. 如果::structure_dimension小于::dimension，我们只是比较这样一个对象的索引，因为面和边没有层次。如果::structure_dimension等于::dimension，我们首先比较层次，只有在层次相等时才比较索引。 </p>

</div>
</div>
<a id="af88fce14be63f6000f7b5d70618dc14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88fce14be63f6000f7b5d70618dc14b">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>比较是否相等。 </p>

</div>
</div>
<a id="a044710b90a02f1d4e6c2e39c00f51ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044710b90a02f1d4e6c2e39c00f51ee7">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>比较不平等。 </p>

</div>
</div>
<a id="a5a24bd66635320e66d1dff07e3cb26e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a24bd66635320e66d1dff07e3cb26e1">&#9670;&nbsp;</a></span>operator++()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>该操作符将迭代器推进到下一个元素。 仅适用于 <code>dim=1</code> 。如果有更多的元素，下一个元素就是这一层的下一个。如果现在的元素是这一层的最后一个，则访问下一层的第一个。 </p>

</div>
</div>
<a id="a85d4f1dc476691cf77e88f2c3ed15afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d4f1dc476691cf77e88f2c3ed15afe">&#9670;&nbsp;</a></span>operator--()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个操作符将迭代器移动到前一个元素。 仅适用于 <code>dim=1</code> 。如果<code>index&gt;0</code>，前一个元素是本层的前一个。如果现在的元素是这一层的第一个，则访问前一层的最后一个。 </p>

</div>
</div>
<a id="ae6d5a6b58e60a06216665e31c26704bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d5a6b58e60a06216665e31c26704bd">&#9670;&nbsp;</a></span>objects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaObjects.html">internal::TriangulationImplementation::TriaObjects</a>&amp; <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>访问具有相同维度的Triangulation的其他对象。 </p>

</div>
</div>
<a id="ae826bd9e6c976638366d9993e6a6c7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae826bd9e6c976638366d9993e6a6c7c0">&#9670;&nbsp;</a></span>level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于单元格，该函数返回该单元格所处的网格层次。对于所有其他对象，该函数返回零。 </p><dl class="section note"><dt>Note</dt><dd>在一个三角形对象中，单元格由一对 <code>(level, index)</code> 唯一标识，前者是单元格的细化层次，后者是该细化层次中单元格的索引（前者是本函数的返回值）。 因此，可能有多个处于不同细化级别的单元格，但在其级别中具有相同的索引。与此相反，如果当前对象对应的是一个面或边，那么该对象就只能通过其索引来识别，因为面和边没有细化级别。对于这些对象，当前函数总是返回0作为级别。 </dd></dl>

</div>
</div>
<a id="a6bebfc1e42324fbf595487e1bf668a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bebfc1e42324fbf595487e1bf668a22">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回当前级别上指向的元素的索引。 在Triangulation对象中，单元格由一对 <code>(level, index)</code> 唯一标识，前者是单元格的细化级别，后者是该细化级别中单元格的索引（后者是本函数的返回值）。因此，可能有多个处于不同细化级别的单元格，但在其级别中具有相同的索引。与此相反，如果当前对象对应于一个面或边，那么该对象只能通过其索引来识别，因为面和边没有细化级别。 </p><dl class="section note"><dt>Note</dt><dd>这个函数返回的索引对象并不是每个层次上的连续数字集：从一个单元到另一个单元，一个层次中的一些索引可能没有使用。 </dd>
<dd>
如果三角图实际上是 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 类型的，那么指数就只相对于存储在当前处理器上的分布式三角图的那部分。换句话说，生活在不同处理器上的三角形分区中的单元可能具有相同的索引，即使它们指的是同一个单元，也可能具有不同的索引，即使它们指的是同一个单元（例如，如果一个单元被一个处理器拥有，但在另一个处理器上是一个幽灵单元）。 </dd></dl>

</div>
</div>
<a id="a5f75f0d6c68a1a67ea03bd4727c29529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f75f0d6c68a1a67ea03bd4727c29529">&#9670;&nbsp;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507">IteratorState::IteratorStates</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回迭代器的状态。 关于一个访问器可能处于的不同状态，请参考TriaRawIterator文档。 </p>

</div>
</div>
<a id="af822c24c013e7b677f45ec2a8a41386a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af822c24c013e7b677f45ec2a8a41386a">&#9670;&nbsp;</a></span>get_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回该类所指向的对象所属于的三角形的引用。 </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="abe9e690d5d7904f804316e15362a2191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9e690d5d7904f804316e15362a2191">&#9670;&nbsp;</a></span>Triangulation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTriangulation.html">Triangulation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l01588">1588</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a1173edf91a9d914373821b6117f32a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1173edf91a9d914373821b6117f32a8f">&#9670;&nbsp;</a></span>::internal::TriangulationImplementation::Implementation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Implementation.html">internal::TriangulationImplementation::Implementation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l01590">1590</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a8b5f94c07c2ca904c27c04ca38eac0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5f94c07c2ca904c27c04ca38eac0e1">&#9670;&nbsp;</a></span>::internal::TriangulationImplementation::ImplementationMixedMesh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::internal::TriangulationImplementation:: ImplementationMixedMesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l01592">1592</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a66bd8833f949eb9ac7a4dc4669177f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bd8833f949eb9ac7a4dc4669177f26">&#9670;&nbsp;</a></span>::internal::TriaAccessorImplementation::Implementation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::internal::TriaAccessorImplementation::Implementation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l01593">1593</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac97bc3b07691e1a0ba9f32074642ae66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97bc3b07691e1a0ba9f32074642ae66">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个访问器所代表的对象所处空间的尺寸。 例如，如果这个访问器代表一个四边形，它是四维空间中一个二维表面的一部分，那么这个值就是四。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00306">306</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a125ed55a8362723639a14d083d9e745c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125ed55a8362723639a14d083d9e745c">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个访问器所代表的事物的尺寸，是这个访问器的一部分。例如，如果这个访问器代表一条线，是六面体的一部分，那么这个值就是三。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00312">312</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a35e42860babc727fc028adfb9a3200b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e42860babc727fc028adfb9a3200b7">&#9670;&nbsp;</a></span>structure_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::structure_dimension = structdim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>该访问器所代表的当前对象的尺寸。例如，如果它是线（不管它是四面体还是六面体的一部分，也不管我们处于什么维度），那么这个值就等于1。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00318">318</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a3ad5efb039ed878a124c9577acd92256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad5efb039ed878a124c9577acd92256">&#9670;&nbsp;</a></span>present_level</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::TriaAccessorImplementation:: PresentLevelType&lt;structdim, dim&gt;::type <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::present_level</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果这是一个单元格（<code>structdim==dim</code>），则是水平。否则，包含零。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00496">496</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a11cf2d985abdb2c9a43ab97722305f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cf2d985abdb2c9a43ab97722305f34">&#9670;&nbsp;</a></span>present_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::present_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用于存储目前所使用的级别上目前所指向的元素的索引。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00502">502</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="af02486bbb2ee4b94d1b51f03ba47257f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02486bbb2ee4b94d1b51f03ba47257f">&#9670;&nbsp;</a></span>tria</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;* <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::tria</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向我们行动的三角图的指针。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00508">508</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/grid/<a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a></li>
<li>source/grid/<a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
