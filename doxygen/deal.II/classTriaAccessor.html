<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTriaAccessor.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TriaAccessor&lt; structdim, dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTriaAccessor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TriaAccessor&lt; structdim, dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a> &raquo; <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> &raquo; <a class="el" href="group__Accessors.html">Accessor classes of the mesh iterators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tria__accessor_8h_source.html">deal.II/grid/tria_accessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TriaAccessor&lt; structdim, dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTriaAccessor__inherit__graph.svg" width="254" height="338"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a563ba5bc45b2c81bd7164bc107bc3f15"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a563ba5bc45b2c81bd7164bc107bc3f15">AccessorData</a> = typename <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a></td></tr>
<tr class="separator:a563ba5bc45b2c81bd7164bc107bc3f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bf7670cf3c4571fe55e051d2503190"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a90bf7670cf3c4571fe55e051d2503190">LocalData</a> = void *</td></tr>
<tr class="separator:a90bf7670cf3c4571fe55e051d2503190"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adcbbfa481886d095df724cef84d92286"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#adcbbfa481886d095df724cef84d92286">TriaAccessor</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *parent=nullptr, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level</a>=-1, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>=-1, const <a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a> *local_data=nullptr)</td></tr>
<tr class="separator:adcbbfa481886d095df724cef84d92286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff27529711a78693b3912ce592c25df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6ff27529711a78693b3912ce592c25df">TriaAccessor</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a> &amp;)=default</td></tr>
<tr class="separator:a6ff27529711a78693b3912ce592c25df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ff7adf27cb0ce877196474c858ddcf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a14ff7adf27cb0ce877196474c858ddcf">TriaAccessor</a> (<a class="el" href="classTriaAccessor.html">TriaAccessor</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a14ff7adf27cb0ce877196474c858ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf81fa90cc1506bbdf6a54fb0626985"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:aeaf81fa90cc1506bbdf6a54fb0626985"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aeaf81fa90cc1506bbdf6a54fb0626985">TriaAccessor</a> (const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:aeaf81fa90cc1506bbdf6a54fb0626985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397500f10867aa69f4a731cc9ab2de53"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:a397500f10867aa69f4a731cc9ab2de53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a397500f10867aa69f4a731cc9ab2de53">TriaAccessor</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:a397500f10867aa69f4a731cc9ab2de53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6274ae9855a9bd40654f82af32657427"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaAccessor.html">TriaAccessor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6274ae9855a9bd40654f82af32657427">operator=</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a> &amp;)=delete</td></tr>
<tr class="separator:a6274ae9855a9bd40654f82af32657427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce9055d943c6dfe89a07e5c0011a864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaAccessor.html">TriaAccessor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a5ce9055d943c6dfe89a07e5c0011a864">operator=</a> (<a class="el" href="classTriaAccessor.html">TriaAccessor</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a5ce9055d943c6dfe89a07e5c0011a864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb1d967889a26340ed512f68dbf5331"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8eb1d967889a26340ed512f68dbf5331">~TriaAccessor</a> ()=default</td></tr>
<tr class="separator:a8eb1d967889a26340ed512f68dbf5331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0b77c3f3c1de1f604d456d0718efc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aeb0b77c3f3c1de1f604d456d0718efc0">used</a> () const</td></tr>
<tr class="separator:aeb0b77c3f3c1de1f604d456d0718efc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing sub-objects</div></td></tr>
<tr class="memitem:a76b3fb7b9d5de13f797e3c04d4dd03a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a76b3fb7b9d5de13f797e3c04d4dd03a5">vertex_iterator</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a76b3fb7b9d5de13f797e3c04d4dd03a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81afd26d765a4cec094b25767b8dd42a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a81afd26d765a4cec094b25767b8dd42a">vertex_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a81afd26d765a4cec094b25767b8dd42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd6518eb0cf5fccc5926470128415d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3dd6518eb0cf5fccc5926470128415d9">vertex</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a3dd6518eb0cf5fccc5926470128415d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c8283c86c84e29f718cbfe4118b3b2"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt; dim, spacedim &gt;::line_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a54c8283c86c84e29f718cbfe4118b3b2">line</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a54c8283c86c84e29f718cbfe4118b3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450f0e6e00b9711650f59143e2085d95"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a450f0e6e00b9711650f59143e2085d95">line_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a450f0e6e00b9711650f59143e2085d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dc361f8b3fb30c60a9e248c2108979"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt; dim, spacedim &gt;::quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a04dc361f8b3fb30c60a9e248c2108979">quad</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a04dc361f8b3fb30c60a9e248c2108979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f77d56ddde728b892e3c736a28cd0c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab3f77d56ddde728b892e3c736a28cd0c">quad_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ab3f77d56ddde728b892e3c736a28cd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Orientation of sub-objects</div></td></tr>
<tr class="memitem:a452389bb368ba37c9c5542ef956526ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a452389bb368ba37c9c5542ef956526ee">face_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> face) const</td></tr>
<tr class="separator:a452389bb368ba37c9c5542ef956526ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90f5ff1a44cb8a6e08196dac6cdb22e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad90f5ff1a44cb8a6e08196dac6cdb22e">face_flip</a> (const unsigned <a class="el" href="classint.html">int</a> face) const</td></tr>
<tr class="separator:ad90f5ff1a44cb8a6e08196dac6cdb22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f831f5ca8626677089f94af9be43a5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a2f831f5ca8626677089f94af9be43a5b">face_rotation</a> (const unsigned <a class="el" href="classint.html">int</a> face) const</td></tr>
<tr class="separator:a2f831f5ca8626677089f94af9be43a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aaa41d4d6e0942d888efc21ca5d6c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a08aaa41d4d6e0942d888efc21ca5d6c7">line_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html#a54c8283c86c84e29f718cbfe4118b3b2">line</a>) const</td></tr>
<tr class="separator:a08aaa41d4d6e0942d888efc21ca5d6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing children</div></td></tr>
<tr class="memitem:a4ce77fc45536beea670a0b5c1d91539c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a4ce77fc45536beea670a0b5c1d91539c">has_children</a> () const</td></tr>
<tr class="separator:a4ce77fc45536beea670a0b5c1d91539c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634bf3e1c46e9ba87dfafa8c869e8972"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a634bf3e1c46e9ba87dfafa8c869e8972">n_children</a> () const</td></tr>
<tr class="separator:a634bf3e1c46e9ba87dfafa8c869e8972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c1e25935669a4b310671a26e9dcbd2"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa0c1e25935669a4b310671a26e9dcbd2">number_of_children</a> () const</td></tr>
<tr class="separator:aa0c1e25935669a4b310671a26e9dcbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fb24948b4e177f8e4eb737ec057397"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a24fb24948b4e177f8e4eb737ec057397">n_active_descendants</a> () const</td></tr>
<tr class="separator:a24fb24948b4e177f8e4eb737ec057397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39e613fd2e2c22bdc8ba340068e5713"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa39e613fd2e2c22bdc8ba340068e5713">max_refinement_depth</a> () const</td></tr>
<tr class="separator:aa39e613fd2e2c22bdc8ba340068e5713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad791ab6cd4f749e0c9f601a2bc442bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad791ab6cd4f749e0c9f601a2bc442bd9">child</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ad791ab6cd4f749e0c9f601a2bc442bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237132d2e5161b34a05291e10f3d6feb"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a237132d2e5161b34a05291e10f3d6feb">child_iterator_to_index</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;<a class="el" href="classTriaAccessor.html#ad791ab6cd4f749e0c9f601a2bc442bd9">child</a>) const</td></tr>
<tr class="separator:a237132d2e5161b34a05291e10f3d6feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa035549b0c8b7eb7fcd33654bc73da29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa035549b0c8b7eb7fcd33654bc73da29">isotropic_child</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:aa035549b0c8b7eb7fcd33654bc73da29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a4a753f2ef5b2615a7e2fec21e0dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; structdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae6a4a753f2ef5b2615a7e2fec21e0dec">refinement_case</a> () const</td></tr>
<tr class="separator:ae6a4a753f2ef5b2615a7e2fec21e0dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7551fc85831a3fd4d5cd339b81d8c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#acd7551fc85831a3fd4d5cd339b81d8c6">child_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:acd7551fc85831a3fd4d5cd339b81d8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adec5f5b7786cf43e6011d03cc7903a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8adec5f5b7786cf43e6011d03cc7903a">isotropic_child_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a8adec5f5b7786cf43e6011d03cc7903a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with boundary indicators</div></td></tr>
<tr class="memitem:af2b4887416074f2ecdcd06512e864e48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af2b4887416074f2ecdcd06512e864e48">boundary_id</a> () const</td></tr>
<tr class="separator:af2b4887416074f2ecdcd06512e864e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654de9ccd776b524a27cd64bded48e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">set_boundary_id</a> (const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>) const</td></tr>
<tr class="separator:a654de9ccd776b524a27cd64bded48e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0304fb253839c45e64b60460ab040ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa0304fb253839c45e64b60460ab040ae">set_all_boundary_ids</a> (const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>) const</td></tr>
<tr class="separator:aa0304fb253839c45e64b60460ab040ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af211333148f7b1190db625ce91b23b65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af211333148f7b1190db625ce91b23b65">at_boundary</a> () const</td></tr>
<tr class="separator:af211333148f7b1190db625ce91b23b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d63b9ebf9b5c31aa702e49c664e59d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae4d63b9ebf9b5c31aa702e49c664e59d">get_manifold</a> () const</td></tr>
<tr class="separator:ae4d63b9ebf9b5c31aa702e49c664e59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with manifold indicators</div></td></tr>
<tr class="memitem:a6c28dbcfefe0ffe1e51fe315c3565f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6c28dbcfefe0ffe1e51fe315c3565f94">manifold_id</a> () const</td></tr>
<tr class="separator:a6c28dbcfefe0ffe1e51fe315c3565f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbeb21da36433dc2ec117b9694ca2557"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">set_manifold_id</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>) const</td></tr>
<tr class="separator:gafbeb21da36433dc2ec117b9694ca2557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160a26ce22b36607556bcdcc20bc6d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga160a26ce22b36607556bcdcc20bc6d61">set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>) const</td></tr>
<tr class="separator:ga160a26ce22b36607556bcdcc20bc6d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">User data</div></td></tr>
<tr class="memitem:a6aa91f3e086777b02a2f6eef7ac19ebb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6aa91f3e086777b02a2f6eef7ac19ebb">user_flag_set</a> () const</td></tr>
<tr class="separator:a6aa91f3e086777b02a2f6eef7ac19ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dda85b6637fefd5db3d37ad7729fcb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6dda85b6637fefd5db3d37ad7729fcb1">set_user_flag</a> () const</td></tr>
<tr class="separator:a6dda85b6637fefd5db3d37ad7729fcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ff7c1bc2b4fc8abcd9b3ef44b5f485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a59ff7c1bc2b4fc8abcd9b3ef44b5f485">clear_user_flag</a> () const</td></tr>
<tr class="separator:a59ff7c1bc2b4fc8abcd9b3ef44b5f485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d791b3769c77bcfd1c56748a6c56fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a63d791b3769c77bcfd1c56748a6c56fa">recursively_set_user_flag</a> () const</td></tr>
<tr class="separator:a63d791b3769c77bcfd1c56748a6c56fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b22f28a2baf2dd90b5309c3f0136af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a50b22f28a2baf2dd90b5309c3f0136af">recursively_clear_user_flag</a> () const</td></tr>
<tr class="separator:a50b22f28a2baf2dd90b5309c3f0136af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3965091ec2c6ba6ed838a2479dd8110f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3965091ec2c6ba6ed838a2479dd8110f">clear_user_data</a> () const</td></tr>
<tr class="separator:a3965091ec2c6ba6ed838a2479dd8110f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaaa0940be75dd7436769b55538aaac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aceaaa0940be75dd7436769b55538aaac">set_user_pointer</a> (void *p) const</td></tr>
<tr class="separator:aceaaa0940be75dd7436769b55538aaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd20837028286220f0b2ba9b0d4b219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a1fd20837028286220f0b2ba9b0d4b219">clear_user_pointer</a> () const</td></tr>
<tr class="separator:a1fd20837028286220f0b2ba9b0d4b219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3700f2ce7587b2fbcaf85753c79bf40"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad3700f2ce7587b2fbcaf85753c79bf40">user_pointer</a> () const</td></tr>
<tr class="separator:ad3700f2ce7587b2fbcaf85753c79bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484e590959847d514d42814efa3e25c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a484e590959847d514d42814efa3e25c2">recursively_set_user_pointer</a> (void *p) const</td></tr>
<tr class="separator:a484e590959847d514d42814efa3e25c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04d1802d9b1e8923dcfef41ea624edc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad04d1802d9b1e8923dcfef41ea624edc">recursively_clear_user_pointer</a> () const</td></tr>
<tr class="separator:ad04d1802d9b1e8923dcfef41ea624edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cca979ccf43e19af78dcb91d19cfd87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a0cca979ccf43e19af78dcb91d19cfd87">set_user_index</a> (const unsigned <a class="el" href="classint.html">int</a> p) const</td></tr>
<tr class="separator:a0cca979ccf43e19af78dcb91d19cfd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a1e59ae7328b4c75c69720826736c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a97a1e59ae7328b4c75c69720826736c0">clear_user_index</a> () const</td></tr>
<tr class="separator:a97a1e59ae7328b4c75c69720826736c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a24da10289811179abbfb57253e9d3"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ac7a24da10289811179abbfb57253e9d3">user_index</a> () const</td></tr>
<tr class="separator:ac7a24da10289811179abbfb57253e9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309ae29be30ad5a259b1cd942e7d9e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a309ae29be30ad5a259b1cd942e7d9e9d">recursively_set_user_index</a> (const unsigned <a class="el" href="classint.html">int</a> p) const</td></tr>
<tr class="separator:a309ae29be30ad5a259b1cd942e7d9e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429e559fb261a631942d54c897243abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a429e559fb261a631942d54c897243abb">recursively_clear_user_index</a> () const</td></tr>
<tr class="separator:a429e559fb261a631942d54c897243abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Geometric information about an object</div></td></tr>
<tr class="memitem:af0e85725edb5d2bb43da61796f2fbbb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af0e85725edb5d2bb43da61796f2fbbb9">diameter</a> () const</td></tr>
<tr class="separator:af0e85725edb5d2bb43da61796f2fbbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af8bab7e9ad732b6f3fa6a120ed5208"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a7af8bab7e9ad732b6f3fa6a120ed5208">enclosing_ball</a> () const</td></tr>
<tr class="separator:a7af8bab7e9ad732b6f3fa6a120ed5208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf87ae60fcf03c3eb4332ee6e634647f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#acf87ae60fcf03c3eb4332ee6e634647f">bounding_box</a> () const</td></tr>
<tr class="separator:acf87ae60fcf03c3eb4332ee6e634647f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a088728d7acb727fdc13bb6664d91a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a49a088728d7acb727fdc13bb6664d91a">extent_in_direction</a> (const unsigned <a class="el" href="classint.html">int</a> axis) const</td></tr>
<tr class="separator:a49a088728d7acb727fdc13bb6664d91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b268c743742c3c9ab159ff916d9236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a99b268c743742c3c9ab159ff916d9236">minimum_vertex_distance</a> () const</td></tr>
<tr class="separator:a99b268c743742c3c9ab159ff916d9236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68f07dabea75fdc6af95db7ed5ed394"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad68f07dabea75fdc6af95db7ed5ed394">intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; structdim &gt; &amp;coordinates) const</td></tr>
<tr class="separator:ad68f07dabea75fdc6af95db7ed5ed394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3814b2ee53cd391e23dd4448a3d78abd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; structdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3814b2ee53cd391e23dd4448a3d78abd">real_to_unit_cell_affine_approximation</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point) const</td></tr>
<tr class="separator:a3814b2ee53cd391e23dd4448a3d78abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309aff7fc274a52af0d567b1533d5596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a309aff7fc274a52af0d567b1533d5596">center</a> (const <a class="el" href="classbool.html">bool</a> respect_manifold=false, const <a class="el" href="classbool.html">bool</a> interpolate_from_surrounding=false) const</td></tr>
<tr class="separator:a309aff7fc274a52af0d567b1533d5596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ddbc9b39806cb2131b5518caef50db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a80ddbc9b39806cb2131b5518caef50db">barycenter</a> () const</td></tr>
<tr class="separator:a80ddbc9b39806cb2131b5518caef50db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cecb2b7c9a1644fb5fd44bbba40ab0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a9cecb2b7c9a1644fb5fd44bbba40ab0c">measure</a> () const</td></tr>
<tr class="separator:a9cecb2b7c9a1644fb5fd44bbba40ab0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21eeac18f82c9689857c225ca6be7e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab21eeac18f82c9689857c225ca6be7e4">is_translation_of</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;o) const</td></tr>
<tr class="separator:ab21eeac18f82c9689857c225ca6be7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f79864c20e5ee8283e9ddb6f7c0415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classReferenceCell.html">ReferenceCell</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad2f79864c20e5ee8283e9ddb6f7c0415">reference_cell</a> () const</td></tr>
<tr class="separator:ad2f79864c20e5ee8283e9ddb6f7c0415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5ed83117e0ff9276abeb9a4fbaac61"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a4a5ed83117e0ff9276abeb9a4fbaac61">n_vertices</a> () const</td></tr>
<tr class="separator:a4a5ed83117e0ff9276abeb9a4fbaac61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e25f9720160ac96bc7f4eea0977784"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a48e25f9720160ac96bc7f4eea0977784">n_lines</a> () const</td></tr>
<tr class="separator:a48e25f9720160ac96bc7f4eea0977784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af330fe95fe8d30a99884797f61236913"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af330fe95fe8d30a99884797f61236913">n_faces</a> () const</td></tr>
<tr class="separator:af330fe95fe8d30a99884797f61236913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40947cf863ecef1ee08ec93f411baaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae40947cf863ecef1ee08ec93f411baaa">vertex_indices</a> () const</td></tr>
<tr class="separator:ae40947cf863ecef1ee08ec93f411baaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44268b67d46418c49a0a5e47f404adcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a44268b67d46418c49a0a5e47f404adcc">line_indices</a> () const</td></tr>
<tr class="separator:a44268b67d46418c49a0a5e47f404adcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4cabec41161961ab25d91b6cdc2425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a5b4cabec41161961ab25d91b6cdc2425">face_indices</a> () const</td></tr>
<tr class="separator:a5b4cabec41161961ab25d91b6cdc2425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterator address and state</div></td></tr>
<tr class="memitem:ae826bd9e6c976638366d9993e6a6c7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level</a> () const</td></tr>
<tr class="separator:ae826bd9e6c976638366d9993e6a6c7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bebfc1e42324fbf595487e1bf668a22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a> () const</td></tr>
<tr class="separator:a6bebfc1e42324fbf595487e1bf668a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75f0d6c68a1a67ea03bd4727c29529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507">IteratorState::IteratorStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a5f75f0d6c68a1a67ea03bd4727c29529">state</a> () const</td></tr>
<tr class="separator:a5f75f0d6c68a1a67ea03bd4727c29529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af822c24c013e7b677f45ec2a8a41386a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af822c24c013e7b677f45ec2a8a41386a">get_triangulation</a> () const</td></tr>
<tr class="separator:af822c24c013e7b677f45ec2a8a41386a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac97bc3b07691e1a0ba9f32074642ae66"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ac97bc3b07691e1a0ba9f32074642ae66">space_dimension</a> = spacedim</td></tr>
<tr class="separator:ac97bc3b07691e1a0ba9f32074642ae66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125ed55a8362723639a14d083d9e745c"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a125ed55a8362723639a14d083d9e745c">dimension</a> = dim</td></tr>
<tr class="separator:a125ed55a8362723639a14d083d9e745c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e42860babc727fc028adfb9a3200b7"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a35e42860babc727fc028adfb9a3200b7">structure_dimension</a> = structdim</td></tr>
<tr class="separator:a35e42860babc727fc028adfb9a3200b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a436333e85278d0d4f3feb80abc2db97c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a436333e85278d0d4f3feb80abc2db97c">copy_from</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;)</td></tr>
<tr class="separator:a436333e85278d0d4f3feb80abc2db97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd4644115f0c10a4e07462029211274"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a7cd4644115f0c10a4e07462029211274">operator&lt;</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;other) const</td></tr>
<tr class="separator:a7cd4644115f0c10a4e07462029211274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88fce14be63f6000f7b5d70618dc14b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af88fce14be63f6000f7b5d70618dc14b">operator==</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;) const</td></tr>
<tr class="separator:af88fce14be63f6000f7b5d70618dc14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044710b90a02f1d4e6c2e39c00f51ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a044710b90a02f1d4e6c2e39c00f51ee7">operator!=</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;) const</td></tr>
<tr class="separator:a044710b90a02f1d4e6c2e39c00f51ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d5a6b58e60a06216665e31c26704bd"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaObjects.html">internal::TriangulationImplementation::TriaObjects</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ae6d5a6b58e60a06216665e31c26704bd">objects</a> () const</td></tr>
<tr class="separator:ae6d5a6b58e60a06216665e31c26704bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Advancement of iterators</div></td></tr>
<tr class="memitem:a5a24bd66635320e66d1dff07e3cb26e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a5a24bd66635320e66d1dff07e3cb26e1">operator++</a> ()</td></tr>
<tr class="separator:a5a24bd66635320e66d1dff07e3cb26e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d4f1dc476691cf77e88f2c3ed15afe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a85d4f1dc476691cf77e88f2c3ed15afe">operator--</a> ()</td></tr>
<tr class="separator:a85d4f1dc476691cf77e88f2c3ed15afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3ad5efb039ed878a124c9577acd92256"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1TriaAccessorImplementation_1_1PresentLevelType.html">internal::TriaAccessorImplementation::PresentLevelType</a>&lt; structdim, dim &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a3ad5efb039ed878a124c9577acd92256">present_level</a></td></tr>
<tr class="separator:a3ad5efb039ed878a124c9577acd92256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cf2d985abdb2c9a43ab97722305f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a11cf2d985abdb2c9a43ab97722305f34">present_index</a></td></tr>
<tr class="separator:a11cf2d985abdb2c9a43ab97722305f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02486bbb2ee4b94d1b51f03ba47257f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af02486bbb2ee4b94d1b51f03ba47257f">tria</a></td></tr>
<tr class="separator:af02486bbb2ee4b94d1b51f03ba47257f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a09d81693979927a7a966ddc18d243978"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a09d81693979927a7a966ddc18d243978">set_boundary_id_internal</a> (const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> id) const</td></tr>
<tr class="separator:a09d81693979927a7a966ddc18d243978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa045a20bce1bf6c012e50e9e12d37358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa045a20bce1bf6c012e50e9e12d37358">set_bounding_object_indices</a> (const std::initializer_list&lt; <a class="el" href="classint.html">int</a> &gt; &amp;new_indices) const</td></tr>
<tr class="separator:aa045a20bce1bf6c012e50e9e12d37358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5935fc1f892fdf9c90e4252c8aa2e095"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a5935fc1f892fdf9c90e4252c8aa2e095">set_bounding_object_indices</a> (const std::initializer_list&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;new_indices) const</td></tr>
<tr class="separator:a5935fc1f892fdf9c90e4252c8aa2e095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1947e00bce29b9e766546feb3bbd2f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab1947e00bce29b9e766546feb3bbd2f4">set_line_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html#a54c8283c86c84e29f718cbfe4118b3b2">line</a>, const <a class="el" href="classbool.html">bool</a> orientation) const</td></tr>
<tr class="separator:ab1947e00bce29b9e766546feb3bbd2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4e1cdc683814cbb505b66e088ded4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a2d4e1cdc683814cbb505b66e088ded4f">set_face_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> face, const <a class="el" href="classbool.html">bool</a> orientation) const</td></tr>
<tr class="separator:a2d4e1cdc683814cbb505b66e088ded4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120f75f4b65a498bd55ceffe89db968b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a120f75f4b65a498bd55ceffe89db968b">set_face_flip</a> (const unsigned <a class="el" href="classint.html">int</a> face, const <a class="el" href="classbool.html">bool</a> flip) const</td></tr>
<tr class="separator:a120f75f4b65a498bd55ceffe89db968b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eac7c4a6195f66c016eeaef1283ada8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a2eac7c4a6195f66c016eeaef1283ada8">set_face_rotation</a> (const unsigned <a class="el" href="classint.html">int</a> face, const <a class="el" href="classbool.html">bool</a> rotation) const</td></tr>
<tr class="separator:a2eac7c4a6195f66c016eeaef1283ada8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf46d7dd76ebe7b46e3e26d63859f0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6bf46d7dd76ebe7b46e3e26d63859f0c">set_used_flag</a> () const</td></tr>
<tr class="separator:a6bf46d7dd76ebe7b46e3e26d63859f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7983a80711bcde0ea9ec5f2cc95a935c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a7983a80711bcde0ea9ec5f2cc95a935c">clear_used_flag</a> () const</td></tr>
<tr class="separator:a7983a80711bcde0ea9ec5f2cc95a935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928a0f17388d3e7377fb216a0ca204a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a928a0f17388d3e7377fb216a0ca204a8">set_refinement_case</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; structdim &gt; &amp;ref_case) const</td></tr>
<tr class="separator:a928a0f17388d3e7377fb216a0ca204a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d0e9691107c5f5ed5b5fa54c71e92f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af0d0e9691107c5f5ed5b5fa54c71e92f">clear_refinement_case</a> () const</td></tr>
<tr class="separator:af0d0e9691107c5f5ed5b5fa54c71e92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee3827c653602a10ae243bfd26242eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aeee3827c653602a10ae243bfd26242eb">set_children</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>) const</td></tr>
<tr class="separator:aeee3827c653602a10ae243bfd26242eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048a39a28d4f2a4490a71e2edc8cfc3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a048a39a28d4f2a4490a71e2edc8cfc3f">clear_children</a> () const</td></tr>
<tr class="separator:a048a39a28d4f2a4490a71e2edc8cfc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abe9e690d5d7904f804316e15362a2191"><td class="memTemplParams" colspan="2">template&lt;int , int &gt; </td></tr>
<tr class="memitem:abe9e690d5d7904f804316e15362a2191"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#abe9e690d5d7904f804316e15362a2191">Triangulation</a></td></tr>
<tr class="separator:abe9e690d5d7904f804316e15362a2191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1173edf91a9d914373821b6117f32a8f"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a1173edf91a9d914373821b6117f32a8f">::internal::TriangulationImplementation::Implementation</a></td></tr>
<tr class="separator:a1173edf91a9d914373821b6117f32a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5f94c07c2ca904c27c04ca38eac0e1"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8b5f94c07c2ca904c27c04ca38eac0e1">::internal::TriangulationImplementation::ImplementationMixedMesh</a></td></tr>
<tr class="separator:a8b5f94c07c2ca904c27c04ca38eac0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bd8833f949eb9ac7a4dc4669177f26"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a66bd8833f949eb9ac7a4dc4669177f26">::internal::TriaAccessorImplementation::Implementation</a></td></tr>
<tr class="separator:a66bd8833f949eb9ac7a4dc4669177f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int structdim, int dim, int spacedim&gt;<br />
class TriaAccessor&lt; structdim, dim, spacedim &gt;</h3>

<p>A class that provides access to objects in a triangulation such as its vertices, sub-objects, children, geometric information, etc. This class represents objects of dimension <code>structdim</code> (i.e. 1 for lines, 2 for quads, 3 for hexes) in a triangulation of dimensionality <code>dim</code> (i.e. 1 for a triangulation of lines, 2 for a triangulation of quads, and 3 for a triangulation of hexes) that is embedded in a space of dimensionality <code>spacedim</code> (for <code>spacedim==dim</code> the triangulation represents a domain in \(R^{dim}\), for <code>spacedim&gt;dim</code> the triangulation is of a manifold embedded in a higher dimensional space).</p>
<p>There is a specialization of this class for the case where <code>structdim</code> equals zero, i.e., for vertices of a triangulation. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00138">138</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a563ba5bc45b2c81bd7164bc107bc3f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563ba5bc45b2c81bd7164bc107bc3f15">&#9670;&nbsp;</a></span>AccessorData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a> =  typename <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt;structdim, dim, spacedim&gt;::<a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate alias from base class to this class. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00713">713</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a90bf7670cf3c4571fe55e051d2503190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bf7670cf3c4571fe55e051d2503190">&#9670;&nbsp;</a></span>LocalData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a90bf7670cf3c4571fe55e051d2503190">LocalData</a> =  void *</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Data type to be used for passing parameters from iterators to the accessor classes in a unified way, no matter what the type of number of these parameters is. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00441">441</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adcbbfa481886d095df724cef84d92286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbbfa481886d095df724cef84d92286">&#9670;&nbsp;</a></span>TriaAccessor() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a> *&#160;</td>
          <td class="paramname"><em>local_data</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a id="a6ff27529711a78693b3912ce592c25df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff27529711a78693b3912ce592c25df">&#9670;&nbsp;</a></span>TriaAccessor() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy constructor is not deleted but copied constructed elements should not be modified, also the comments to the copy assignment operator. </p>

</div>
</div>
<a id="a14ff7adf27cb0ce877196474c858ddcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ff7adf27cb0ce877196474c858ddcf">&#9670;&nbsp;</a></span>TriaAccessor() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. </p>

</div>
</div>
<a id="aeaf81fa90cc1506bbdf6a54fb0626985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf81fa90cc1506bbdf6a54fb0626985">&#9670;&nbsp;</a></span>TriaAccessor() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Conversion constructor. This constructor exists to make certain constructs simpler to write in dimension independent code. For example, it allows assigning a face iterator to a line iterator, an operation that is useful in 2d but doesn't make any sense in 3d. The constructor here exists for the purpose of making the code conform to C++ but it will unconditionally abort; in other words, assigning a face iterator to a line iterator is better put into an if-statement that checks that the dimension is two, and assign to a quad iterator in 3d (an operator that, without this constructor would be illegal if we happen to compile for 2d). </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03921">3921</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a397500f10867aa69f4a731cc9ab2de53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397500f10867aa69f4a731cc9ab2de53">&#9670;&nbsp;</a></span>TriaAccessor() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another conversion operator between objects that don't make sense, just like the previous one. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03951">3951</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a8eb1d967889a26340ed512f68dbf5331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb1d967889a26340ed512f68dbf5331">&#9670;&nbsp;</a></span>~TriaAccessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::~<a class="el" href="classTriaAccessor.html">TriaAccessor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defaulted destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6274ae9855a9bd40654f82af32657427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6274ae9855a9bd40654f82af32657427">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&amp; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator. These operators are usually used in a context like <code>iterator a,b; *a=*b;</code>. Presumably, the intent here is to copy the object pointed to by <code>b</code> to the object pointed to by <code>a</code>. However, the result of dereferencing an iterator is not an object but an accessor; consequently, this operation is not useful for iterators on triangulations. Consequently, this operator is declared as deleted and can not be used. </p>

</div>
</div>
<a id="a5ce9055d943c6dfe89a07e5c0011a864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce9055d943c6dfe89a07e5c0011a864">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&amp; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator. Moving is allowed. </p>

</div>
</div>
<a id="aeb0b77c3f3c1de1f604d456d0718efc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0b77c3f3c1de1f604d456d0718efc0">&#9670;&nbsp;</a></span>used()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::used </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for the element being used or not. The return value is <code>true</code> for all iterators that are either normal iterators or active iterators, only raw iterators can return <code>false</code>. Since raw iterators are only used in the interiors of the library, you will not usually need this function. </p>

</div>
</div>
<a id="a76b3fb7b9d5de13f797e3c04d4dd03a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b3fb7b9d5de13f797e3c04d4dd03a5">&#9670;&nbsp;</a></span>vertex_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;0, dim, spacedim&gt; &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex_iterator </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the <code>ith</code> vertex bounding this object. Throw an exception if <code>dim=1</code>. </p>

</div>
</div>
<a id="a81afd26d765a4cec094b25767b8dd42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81afd26d765a4cec094b25767b8dd42a">&#9670;&nbsp;</a></span>vertex_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the global index of i-th vertex of the current object. The convention regarding the numbering of vertices is laid down in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>Note that the returned value is only the index of the geometrical vertex. It has nothing to do with possible degrees of freedom associated with it. For this, see the <code><a class="el" href="classDoFAccessor.html#a5aa1f2d13ea10d3e36d7fc6d982467ed">DoFAccessor::vertex_dof_index</a></code> functions.</p>
<dl class="section note"><dt>Note</dt><dd>Despite the name, the index returned here is only global in the sense that it is specific to a particular <a class="el" href="classTriangulation.html">Triangulation</a> object or, in the case the triangulation is actually of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, specific to that part of the distributed triangulation stored on the current processor. </dd></dl>

</div>
</div>
<a id="a3dd6518eb0cf5fccc5926470128415d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd6518eb0cf5fccc5926470128415d9">&#9670;&nbsp;</a></span>vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;&amp; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the <code>ith</code> vertex. The reference is not const, i.e., it is possible to call this function on the left hand side of an assignment, thereby moving the vertex of a cell within the triangulation. Of course, doing so requires that you ensure that the new location of the vertex remains useful &ndash; for example, avoiding inverted or otherwise distorted (see also <a class="el" href="DEALGlossary.html#GlossDistorted">this glossary entry</a>).</p>
<dl class="section note"><dt>Note</dt><dd>When a cell is refined, its children inherit the position of the vertex positions of those vertices they share with the mother cell (plus the locations of the new vertices on edges, faces, and cell interiors that are created for the new child cells). If the vertex of a cell is moved, this implies that its children will also use these new locations. On the other hand, imagine a 2d situation where you have one cell that is refined (with four children) and then you move the central vertex connecting all four children. If you coarsen these four children again to the mother cell, then the location of the moved vertex is lost and if, in a later step, you refine the mother cell again, the then again new vertex will be placed again at the same position as the first time around &ndash; i.e., not at the location you had previously moved it to.</dd>
<dd>
The behavior described above is relevant if you have a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object. There, refining a mesh always involves a re-partitioning. In other words, vertices of locally owned cells (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">this glossary entry</a>) that you may have moved to a different location on one processor may be moved to a different processor upon mesh refinement (even if these particular cells were not refined) which will re-create their position based on the position of the coarse cells they previously had, not based on the position these vertices had on the processor that previously owned them. In other words, in parallel computations, you will probably have to move nodes explicitly after every mesh refinement because vertex positions may or may not be preserved across the re-partitioning that accompanies mesh refinement. </dd></dl>

</div>
</div>
<a id="a54c8283c86c84e29f718cbfe4118b3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c8283c86c84e29f718cbfe4118b3b2">&#9670;&nbsp;</a></span>line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::TriangulationImplementation:: Iterators&lt;dim, spacedim&gt;::line_iterator <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the <code>ith</code> line bounding this object. </p>

</div>
</div>
<a id="a450f0e6e00b9711650f59143e2085d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450f0e6e00b9711650f59143e2085d95">&#9670;&nbsp;</a></span>line_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Line index of the <code>ith</code> line bounding this object.</p>
<p>Implemented only for <code>structdim&gt;1</code>, otherwise an exception generated. </p>

</div>
</div>
<a id="a04dc361f8b3fb30c60a9e248c2108979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dc361f8b3fb30c60a9e248c2108979">&#9670;&nbsp;</a></span>quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::TriangulationImplementation:: Iterators&lt;dim, spacedim&gt;::quad_iterator <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the <code>ith</code> quad bounding this object. </p>

</div>
</div>
<a id="ab3f77d56ddde728b892e3c736a28cd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f77d56ddde728b892e3c736a28cd0c">&#9670;&nbsp;</a></span>quad_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::quad_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Quad index of the <code>ith</code> quad bounding this object.</p>
<p>Implemented only for <code>structdim&gt;2</code>, otherwise an exception generated. </p>

</div>
</div>
<a id="a452389bb368ba37c9c5542ef956526ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452389bb368ba37c9c5542ef956526ee">&#9670;&nbsp;</a></span>face_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the face with index <code>face</code> has its normal pointing in the standard direction (<code>true</code>) or whether it is the opposite (<code>false</code>). Which is the standard direction is documented with the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class. In 1d and 2d, this is always <code>true</code>, but in 3d it may be different, see the respective discussion in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>This function is really only for internal use in the library unless you absolutely know what this is all about. </p>

</div>
</div>
<a id="ad90f5ff1a44cb8a6e08196dac6cdb22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90f5ff1a44cb8a6e08196dac6cdb22e">&#9670;&nbsp;</a></span>face_flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_flip </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the face with index <code>face</code> is rotated by 180 degrees (<code>true</code>) or not (<code>false</code>). In 1d and 2d, this is always <code>false</code>, but in 3d it may be different, see the respective discussion in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>This function is really only for internal use in the library unless you absolutely know what this is all about. </p>

</div>
</div>
<a id="a2f831f5ca8626677089f94af9be43a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f831f5ca8626677089f94af9be43a5b">&#9670;&nbsp;</a></span>face_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_rotation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the face with index <code>face</code> is rotated by 90 degrees (<code>true</code>) or not (<code>false</code>). In 1d and 2d, this is always <code>false</code>, but in 3d it may be different, see the respective discussion in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>This function is really only for internal use in the library unless you absolutely know what this is all about. </p>

</div>
</div>
<a id="a08aaa41d4d6e0942d888efc21ca5d6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08aaa41d4d6e0942d888efc21ca5d6c7">&#9670;&nbsp;</a></span>line_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the line with index <code>line</code> is oriented in standard direction. <code>true</code> indicates, that the line is oriented from vertex 0 to vertex 1, whereas it is the other way around otherwise. In 1d and 2d, this is always <code>true</code>, but in 3d it may be different, see the respective discussion in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>This function is really only for internal use in the library unless you absolutely know what this is all about.</p>
<p>This function queries <a class="el" href="classReferenceCell.html#a24db72fed8c0bf34ab1a1751ad2b1f38">ReferenceCell::standard_vs_true_line_orientation()</a>. </p>

</div>
</div>
<a id="a4ce77fc45536beea670a0b5c1d91539c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce77fc45536beea670a0b5c1d91539c">&#9670;&nbsp;</a></span>has_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::has_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether the object has children. </p>

</div>
</div>
<a id="a634bf3e1c46e9ba87dfafa8c869e8972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634bf3e1c46e9ba87dfafa8c869e8972">&#9670;&nbsp;</a></span>n_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of immediate children of this object. The number of children of an unrefined cell is zero. </p>

</div>
</div>
<a id="aa0c1e25935669a4b310671a26e9dcbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c1e25935669a4b310671a26e9dcbd2">&#9670;&nbsp;</a></span>number_of_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::number_of_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>Use <a class="el" href="classTriaAccessor.html#a24fb24948b4e177f8e4eb737ec057397">n_active_descendants()</a> instead. </dd></dl>

</div>
</div>
<a id="a24fb24948b4e177f8e4eb737ec057397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fb24948b4e177f8e4eb737ec057397">&#9670;&nbsp;</a></span>n_active_descendants()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_active_descendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute and return the number of active descendants of this objects. For example, if all of the eight children of a hex are further refined isotropically exactly once, the returned number will be 64, not 80.</p>
<p>If the present cell is not refined, one is returned.</p>
<p>If one considers a triangulation as a forest where the root of each tree are the coarse mesh cells and nodes have descendants (the children of a cell), then this function returns the number of terminal nodes in the sub-tree originating from the current object; consequently, if the current object is not further refined, the answer is one. </p>

</div>
</div>
<a id="aa39e613fd2e2c22bdc8ba340068e5713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39e613fd2e2c22bdc8ba340068e5713">&#9670;&nbsp;</a></span>max_refinement_depth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::max_refinement_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of times that this object is refined. Note that not all its children are refined that often (which is why we prepend <code>max_</code>), the returned number is rather the maximum number of refinement in any branch of children of this object.</p>
<p>For example, if this object is refined, and one of its children is refined exactly one more time, then <code>max_refinement_depth</code> should return 2.</p>
<p>If this object is not refined (i.e. it is active), then the return value is zero. </p>

</div>
</div>
<a id="ad791ab6cd4f749e0c9f601a2bc442bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad791ab6cd4f749e0c9f601a2bc442bd9">&#9670;&nbsp;</a></span>child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;structdim, dim, spacedim&gt; &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::child </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to the <code>ith</code> child. </p>

</div>
</div>
<a id="a237132d2e5161b34a05291e10f3d6feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237132d2e5161b34a05291e10f3d6feb">&#9670;&nbsp;</a></span>child_iterator_to_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::child_iterator_to_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the child number of <code>child</code> on the current cell. This is the inverse function of <a class="el" href="classTriaAccessor.html#ad791ab6cd4f749e0c9f601a2bc442bd9">TriaAccessor::child()</a>. </p>

</div>
</div>
<a id="aa035549b0c8b7eb7fcd33654bc73da29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa035549b0c8b7eb7fcd33654bc73da29">&#9670;&nbsp;</a></span>isotropic_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;structdim, dim, spacedim&gt; &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::isotropic_child </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to that object that is identical to the ith child for isotropic refinement. If the current object is refined isotropically, then the returned object is the ith child. If the current object is refined anisotropically, the returned child may in fact be a grandchild of the object, or may not exist at all (in which case an exception is generated). </p>

</div>
</div>
<a id="ae6a4a753f2ef5b2615a7e2fec21e0dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a4a753f2ef5b2615a7e2fec21e0dec">&#9670;&nbsp;</a></span>refinement_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;structdim&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::refinement_case </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classRefinementCase.html">RefinementCase</a> of this cell. </p>

</div>
</div>
<a id="acd7551fc85831a3fd4d5cd339b81d8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7551fc85831a3fd4d5cd339b81d8c6">&#9670;&nbsp;</a></span>child_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::child_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index of the <code>ith</code> child. The level of the child is one higher than that of the present cell, if the children of a cell are accessed. The children of faces have no level. If the child does not exist, -1 is returned. </p>

</div>
</div>
<a id="a8adec5f5b7786cf43e6011d03cc7903a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adec5f5b7786cf43e6011d03cc7903a">&#9670;&nbsp;</a></span>isotropic_child_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::isotropic_child_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index of the <code>ith</code> isotropic child. See the <a class="el" href="classTriaAccessor.html#aa035549b0c8b7eb7fcd33654bc73da29">isotropic_child()</a> function for a definition of this concept. If the child does not exist, -1 is returned. </p>

</div>
</div>
<a id="af2b4887416074f2ecdcd06512e864e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b4887416074f2ecdcd06512e864e48">&#9670;&nbsp;</a></span>boundary_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::boundary_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the boundary indicator of this object.</p>
<p>If the return value is the special value <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>, then this object is in the interior of the domain.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="a654de9ccd776b524a27cd64bded48e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654de9ccd776b524a27cd64bded48e14">&#9670;&nbsp;</a></span>set_boundary_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_boundary_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the boundary indicator of the current object. The same applies as for the <a class="el" href="classTriaAccessor.html#af2b4887416074f2ecdcd06512e864e48">boundary_id()</a> function.</p>
<p>This function only sets the boundary object of the current object itself, not the indicators of the ones that bound it. For example, in 3d, if this function is called on a face, then the boundary indicator of the 4 edges that bound the face remain unchanged. If you want to set the boundary indicators of face and edges at the same time, use the <a class="el" href="classTriaAccessor.html#aa0304fb253839c45e64b60460ab040ae">set_all_boundary_ids()</a> function. You can see the result of not using the correct function in the results section of step-49.</p>
<dl class="section warning"><dt>Warning</dt><dd>You should never set the boundary indicator of an interior face (a face not at the boundary of the domain), or set the boundary indicator of an exterior face to <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> (this value is reserved for another purpose). <a class="el" href="namespaceAlgorithms.html">Algorithms</a> may not work or produce very confusing results if boundary cells have a boundary indicator of <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> or if interior cells have boundary indicators other than <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>. Unfortunately, the current object has no means of finding out whether it really is at the boundary of the domain and so cannot determine whether the value you are trying to set makes sense under the current circumstances.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="aa0304fb253839c45e64b60460ab040ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0304fb253839c45e64b60460ab040ae">&#9670;&nbsp;</a></span>set_all_boundary_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_all_boundary_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do as <a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">set_boundary_id()</a> but also set the boundary indicators of the objects that bound the current object. For example, in 3d, if <a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">set_boundary_id()</a> is called on a face, then the boundary indicator of the 4 edges that bound the face remain unchanged. In contrast, if you call the current function, the boundary indicators of face and edges are all set to the given value.</p>
<p>This function is useful if you set boundary indicators of faces in 3d (in 2d, the function does the same as <a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">set_boundary_id()</a>) and you do so because you want a curved boundary object to represent the part of the boundary that corresponds to the current face. In that case, the <a class="el" href="classTriangulation.html">Triangulation</a> class needs to figure out where to put new vertices upon mesh refinement, and higher order <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> objects also need to figure out where new interpolation points for a curved boundary approximation should be. In either case, the two classes first determine where interpolation points on the edges of a boundary face should be, asking the boundary object, before asking the boundary object for the interpolation points corresponding to the interior of the boundary face. For this to work properly, it is not sufficient to have set the boundary indicator for the face alone, but you also need to set the boundary indicators of the edges that bound the face. This function does all of this at once. You can see the result of not using the correct function in the results section of step-49.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="af211333148f7b1190db625ce91b23b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af211333148f7b1190db625ce91b23b65">&#9670;&nbsp;</a></span>at_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::at_boundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this object is at the boundary. Obviously, the use of this function is only possible for <code>dim&gt;structdim</code>; however, for <code>dim==structdim</code>, an object is a cell and the <a class="el" href="classCellAccessor.html">CellAccessor</a> class offers another possibility to determine whether a cell is at the boundary or not. </p>

</div>
</div>
<a id="ae4d63b9ebf9b5c31aa702e49c664e59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d63b9ebf9b5c31aa702e49c664e59d">&#9670;&nbsp;</a></span>get_manifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classManifold.html">Manifold</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::get_manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant reference to the manifold object used for this object.</p>
<p>As explained in the <a class="el" href="group__manifold.html">Manifold description for triangulations</a> module, the process involved in finding the appropriate manifold description involves querying both the manifold or boundary indicators. See there for more information. </p>

</div>
</div>
<a id="a6c28dbcfefe0ffe1e51fe315c3565f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c28dbcfefe0ffe1e51fe315c3565f94">&#9670;&nbsp;</a></span>manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::manifold_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the manifold indicator of this object.</p>
<p>If the return value is the special value <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>, then this object is associated with a standard Cartesian <a class="el" href="classManifold.html">Manifold</a> Description.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="a6aa91f3e086777b02a2f6eef7ac19ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa91f3e086777b02a2f6eef7ac19ebb">&#9670;&nbsp;</a></span>user_flag_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::user_flag_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the user flag. See <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> for more information. </p>

</div>
</div>
<a id="a6dda85b6637fefd5db3d37ad7729fcb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dda85b6637fefd5db3d37ad7729fcb1">&#9670;&nbsp;</a></span>set_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the user flag. See <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> for more information. </p>

</div>
</div>
<a id="a59ff7c1bc2b4fc8abcd9b3ef44b5f485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ff7c1bc2b4fc8abcd9b3ef44b5f485">&#9670;&nbsp;</a></span>clear_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the user flag. See <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> for more information. </p>

</div>
</div>
<a id="a63d791b3769c77bcfd1c56748a6c56fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d791b3769c77bcfd1c56748a6c56fa">&#9670;&nbsp;</a></span>recursively_set_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_set_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the user flag for this and all descendants. See <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> for more information. </p>

</div>
</div>
<a id="a50b22f28a2baf2dd90b5309c3f0136af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b22f28a2baf2dd90b5309c3f0136af">&#9670;&nbsp;</a></span>recursively_clear_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_clear_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the user flag for this and all descendants. See <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> for more information. </p>

</div>
</div>
<a id="a3965091ec2c6ba6ed838a2479dd8110f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3965091ec2c6ba6ed838a2479dd8110f">&#9670;&nbsp;</a></span>clear_user_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the user data to zero, independent if pointer or index. See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="aceaaa0940be75dd7436769b55538aaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceaaa0940be75dd7436769b55538aaac">&#9670;&nbsp;</a></span>set_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_user_pointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the user pointer to <code>p</code>.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between.</dd></dl>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="a1fd20837028286220f0b2ba9b0d4b219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd20837028286220f0b2ba9b0d4b219">&#9670;&nbsp;</a></span>clear_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the user pointer to a <code>nullptr</code> pointer. See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="ad3700f2ce7587b2fbcaf85753c79bf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3700f2ce7587b2fbcaf85753c79bf40">&#9670;&nbsp;</a></span>user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::user_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the value of the user pointer. It is in the responsibility of the user to make sure that the pointer points to something useful. You should use the new style cast operator to maintain a minimum of type safety, e.g.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between. <code>A <em>a=static_cast&lt;A</em>&gt;(cell-&gt;<a class="el" href="classTriaAccessor.html#ad3700f2ce7587b2fbcaf85753c79bf40">user_pointer()</a>);</code>.</dd></dl>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="a484e590959847d514d42814efa3e25c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484e590959847d514d42814efa3e25c2">&#9670;&nbsp;</a></span>recursively_set_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_set_user_pointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the user pointer of this object and all its children to the given value. This is useful for example if all cells of a certain subdomain, or all faces of a certain part of the boundary should have user pointers pointing to objects describing this part of the domain or boundary.</p>
<p>Note that the user pointer is not inherited under mesh refinement, so after mesh refinement there might be cells or faces that don't have user pointers pointing to the describing object. In this case, simply loop over all the elements of the coarsest level that has this information, and use this function to recursively set the user pointer of all finer levels of the triangulation.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between.</dd></dl>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="ad04d1802d9b1e8923dcfef41ea624edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04d1802d9b1e8923dcfef41ea624edc">&#9670;&nbsp;</a></span>recursively_clear_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_clear_user_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the user pointer of this object and all of its descendants. The same holds as said for the <a class="el" href="classTriaAccessor.html#a484e590959847d514d42814efa3e25c2">recursively_set_user_pointer()</a> function. See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="a0cca979ccf43e19af78dcb91d19cfd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cca979ccf43e19af78dcb91d19cfd87">&#9670;&nbsp;</a></span>set_user_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_user_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the user index to <code>p</code>.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between. See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </dd></dl>

</div>
</div>
<a id="a97a1e59ae7328b4c75c69720826736c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a1e59ae7328b4c75c69720826736c0">&#9670;&nbsp;</a></span>clear_user_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the user index to 0. See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="ac7a24da10289811179abbfb57253e9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a24da10289811179abbfb57253e9d3">&#9670;&nbsp;</a></span>user_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::user_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the value of the user index.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between.</dd></dl>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="a309ae29be30ad5a259b1cd942e7d9e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309ae29be30ad5a259b1cd942e7d9e9d">&#9670;&nbsp;</a></span>recursively_set_user_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_set_user_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the user index of this object and all its children.</p>
<p>Note that the user index is not inherited under mesh refinement, so after mesh refinement there might be cells or faces that don't have the expected user indices. In this case, simply loop over all the elements of the coarsest level that has this information, and use this function to recursively set the user index of all finer levels of the triangulation.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between.</dd></dl>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="a429e559fb261a631942d54c897243abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429e559fb261a631942d54c897243abb">&#9670;&nbsp;</a></span>recursively_clear_user_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_clear_user_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the user index of this object and all of its descendants. The same holds as said for the <a class="el" href="classTriaAccessor.html#a309ae29be30ad5a259b1cd942e7d9e9d">recursively_set_user_index()</a> function.</p>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="af0e85725edb5d2bb43da61796f2fbbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e85725edb5d2bb43da61796f2fbbb9">&#9670;&nbsp;</a></span>diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::diameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Diameter of the object.</p>
<p>The diameter of an object is computed to be the largest diagonal of the current object. If this object is a quadrilateral, then there are two such diagonal, and if it is a hexahedron, then there are four diagonals that connect "opposite" points. For triangles and tetrahedra, the function simply returns the length of the longest edge.</p>
<p>The situation is more difficult for wedges and pyramids: For wedges, we return the length of the longest diagonal of the three quadrilateral faces or the longest edge length of the two triangular faces. For pyramids, the same principle is applied.</p>
<p>In all of these cases, this definition of "diameter" is not necessarily the true diameter in the sense of the largest distance between points inside the object. Indeed, one can often construct objects for which it is not, though these are generally quite deformed compared to the reference shape. Furthermore, for objects that may use higher order mappings, one may have bulging faces that also create trouble for computing an exact representation of the diameter of the object. That said, the definition used above is completely sufficient for most computations. </p>

</div>
</div>
<a id="a7af8bab7e9ad732b6f3fa6a120ed5208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af8bab7e9ad732b6f3fa6a120ed5208">&#9670;&nbsp;</a></span>enclosing_ball()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;, <a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::enclosing_ball </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pair of <a class="el" href="classPoint.html">Point</a> and double corresponding to the center and the radius of a reasonably small enclosing ball of the object.</p>
<p>The function implements Ritter's O(n) algorithm to get a reasonably small enclosing ball around the vertices of the object. The initial guess for the enclosing ball is taken to be the ball which contains the largest diagonal of the object as its diameter. Starting from such an initial guess, the algorithm tests whether all the vertices of the object (except the vertices of the largest diagonal) are geometrically within the ball. If any vertex (v) is found to be geometrically outside the ball, a new iterate of the ball is constructed by shifting its center and increasing the radius so as to geometrically enclose both the previous ball and the vertex (v). The algorithm terminates when all the vertices are geometrically inside the ball.</p>
<p>If a vertex (v) is geometrically inside a particular iterate of the ball, then it will continue to be so in the subsequent iterates of the ball (this is true <em>by</em> <em>construction</em>).</p>
<dl class="section note"><dt>Note</dt><dd>This function assumes d-linear mapping from the reference cell.</dd></dl>
<p><a href="http://geomalgorithms.com/a08-_containers.html">see this</a> and [Ritter 1990] </p>

</div>
</div>
<a id="acf87ae60fcf03c3eb4332ee6e634647f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf87ae60fcf03c3eb4332ee6e634647f">&#9670;&nbsp;</a></span>bounding_box()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt;spacedim&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::bounding_box </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the smallest bounding box that encloses the object.</p>
<p>Notice that this method is not aware of any mapping you may be using to do your computations. If you are using a mapping object that modifies the position of the vertices, like <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a>, or <a class="el" href="classMappingFEField.html">MappingFEField</a>, then you should call the function <a class="el" href="classMapping.html#adf83c098abdb6607178efdb62af91ac0">Mapping::get_bounding_box()</a> instead. </p>

</div>
</div>
<a id="a49a088728d7acb727fdc13bb6664d91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a088728d7acb727fdc13bb6664d91a">&#9670;&nbsp;</a></span>extent_in_direction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of an object in the direction of the given axis, specified in the local coordinate system. See the documentation of <a class="el" href="structGeometryInfo.html">GeometryInfo</a> for the meaning and enumeration of the local axes.</p>
<p>Note that the "length" of an object can be interpreted in a variety of ways. Here, we choose it as the maximal length of any of the edges of the object that are parallel to the chosen axis on the reference cell. </p>

</div>
</div>
<a id="a99b268c743742c3c9ab159ff916d9236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b268c743742c3c9ab159ff916d9236">&#9670;&nbsp;</a></span>minimum_vertex_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::minimum_vertex_distance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the minimal distance between any two vertices. </p>

</div>
</div>
<a id="ad68f07dabea75fdc6af95db7ed5ed394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68f07dabea75fdc6af95db7ed5ed394">&#9670;&nbsp;</a></span>intermediate_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::intermediate_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; structdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>coordinates</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a point belonging to the Manifold&lt;dim,spacedim&gt; where this object lives, given its parametric coordinates on the reference <code>structdim</code> cell. This function queries the underlying manifold object, and can be used to obtain the exact geometrical location of arbitrary points on this object.</p>
<p>Notice that the argument <code>coordinates</code> are the coordinates on the <em>reference cell</em>, given in reference coordinates. In other words, the argument provides a weighting between the different vertices. For example, for lines, calling this function with argument <a class="el" href="classPoint.html">Point&lt;1&gt;</a>(.5), is equivalent to asking the line for its center. </p>

</div>
</div>
<a id="a3814b2ee53cd391e23dd4448a3d78abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3814b2ee53cd391e23dd4448a3d78abd">&#9670;&nbsp;</a></span>real_to_unit_cell_affine_approximation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;structdim&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::real_to_unit_cell_affine_approximation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function computes a fast approximate transformation from the real to the unit cell by inversion of an affine approximation of the \(d\)-linear function from the reference \(d\)-dimensional cell.</p>
<p>The affine approximation of the unit to real cell mapping is found by a least squares fit of an affine function to the \(2^d\) vertices of the present object. For any valid mesh cell whose geometry is not degenerate, this operation results in a unique affine mapping. Thus, this function will return a finite result for all given input points, even in cases where the actual transformation by an actual bi-/trilinear or higher order mapping might be singular. Besides only approximating the mapping from the vertex points, this function also ignores the attached manifold descriptions. The result is only exact in case the transformation from the unit to the real cell is indeed affine, such as in one dimension or for Cartesian and affine (parallelogram) meshes in 2D/3D.</p>
<p>For exact transformations to the unit cell, use <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If dim&lt;spacedim we first project p onto the plane. </dd></dl>

</div>
</div>
<a id="a309aff7fc274a52af0d567b1533d5596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309aff7fc274a52af0d567b1533d5596">&#9670;&nbsp;</a></span>center()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::center </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>respect_manifold</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>interpolate_from_surrounding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Center of the object. The center of an object is defined to be the average of the locations of the vertices, which is also where a \(Q_1\) mapping would map the center of the reference cell. However, you can also ask this function to instead return the average of the vertices as computed by the underlying <a class="el" href="classManifold.html">Manifold</a> object associated with the current object, by setting to true the optional parameter <code>respect_manifold</code>. <a class="el" href="namespaceManifolds.html">Manifolds</a> would then typically pull back the coordinates of the vertices to a reference domain (not necessarily the reference cell), compute the average there, and then push forward the coordinates of the averaged point to the physical space again; the resulting point is guaranteed to lie within the manifold, even if the manifold is curved.</p>
<p>When the object uses a different manifold description as its surrounding, like when part of the bounding objects of this <a class="el" href="classTriaAccessor.html">TriaAccessor</a> use a non-flat manifold description but the object itself is flat, the result given by the <a class="el" href="classTriaAccessor.html#a309aff7fc274a52af0d567b1533d5596">TriaAccessor::center()</a> function may not be accurate enough, even when parameter <code>respect_manifold</code> is set to true. If you find this to be case, than you can further refine the computation of the center by setting to true the second additional parameter <code>interpolate_from_surrounding</code>. This computes the location of the center by a so-called transfinite interpolation from the center of all the bounding objects. For a 2D object, it puts a weight of <code>1/2</code> on each of the four surrounding lines and a weight <code>-1/4</code> on the four vertices. This corresponds to a linear interpolation between the descriptions of the four faces, subtracting the contribution of the vertices that is added twice when coming through both lines adjacent to the vertex. In 3D, the weights for faces are <code>1/2</code>, the weights for lines are <code>-1/4</code>, and the weights for vertices are <code>1/8</code>. For further information, also confer to the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> class that is able to not only apply this beneficial description to a single cell but all children of a coarse cell. </p>

</div>
</div>
<a id="a80ddbc9b39806cb2131b5518caef50db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ddbc9b39806cb2131b5518caef50db">&#9670;&nbsp;</a></span>barycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::barycenter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the barycenter (also called centroid) of the object. The barycenter for an object \(K\) of dimension \(d\) in \(D\) space dimensions is given by the \(D\)-dimensional vector \(\mathbf x_K\) defined by </p><p class="formulaDsp">
\[ \mathbf x_K = \frac{1}{|K|} \int_K \mathbf x \; \textrm{d}x \]
</p>
<p> where the measure of the object is given by </p><p class="formulaDsp">
\[ |K| = \int_K \mathbf 1 \; \textrm{d}x. \]
</p>
<p> This function assumes that \(K\) is mapped by a \(d\)-linear function from the reference \(d\)-dimensional cell. Then the integrals above can be pulled back to the reference cell and evaluated exactly (if through lengthy and, compared to the <a class="el" href="classTriaAccessor.html#a309aff7fc274a52af0d567b1533d5596">center()</a> function, expensive computations). </p>

</div>
</div>
<a id="a9cecb2b7c9a1644fb5fd44bbba40ab0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cecb2b7c9a1644fb5fd44bbba40ab0c">&#9670;&nbsp;</a></span>measure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::measure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the dim-dimensional measure of the object. For a dim-dimensional cell in dim-dimensional space, this equals its volume. On the other hand, for a 2d cell in 3d space, or if the current object pointed to is a 2d face of a 3d cell in 3d space, then the function computes the area the object occupies. For a one-dimensional object, return its length.</p>
<p>The function only computes the measure of cells, faces or edges assumed to be represented by (bi-/tri-)linear mappings. In other words, it only takes into account the locations of the vertices that bound the current object but not how the interior of the object may actually be mapped. In most simple cases, this is exactly what you want. However, for objects that are not "straight", e.g. 2d cells embedded in 3d space as part of a triangulation of a curved domain, two-dimensional faces of 3d cells that are not just parallelograms, or for faces that are at the boundary of a domain that is not just bounded by straight line segments or planes, this function only computes the dim-dimensional measure of a (bi-/tri-)linear interpolation of the "real" object as defined by the manifold or boundary object describing the real geometry of the object in question. If you want to consider the "real" geometry, you will need to compute the measure by integrating a function equal to one over the object, which after applying quadrature equals the summing the JxW values returned by the <a class="el" href="classFEValues.html">FEValues</a> or <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object you will want to use for the integral. </p>

</div>
</div>
<a id="ab21eeac18f82c9689857c225ca6be7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21eeac18f82c9689857c225ca6be7e4">&#9670;&nbsp;</a></span>is_translation_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::is_translation_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the current object is a translation of the given argument.</p>
<dl class="section note"><dt>Note</dt><dd>For the purpose of a triangulation, cells, faces, etc are only characterized by their vertices. The current function therefore only compares the locations of vertices. For many practical applications, however, it is not only the vertices that determine whether one cell is a translation of another, but also how the cell is mapped from the reference cell to its location in real space. For example, if we are using higher order mappings, then not only do the vertices have to be translations of each other, but also the points along edges. In these questions, therefore, it would be appropriate to ask the mapping, not the current function, whether two objects are translations of each other. </dd></dl>

</div>
</div>
<a id="ad2f79864c20e5ee8283e9ddb6f7c0415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f79864c20e5ee8283e9ddb6f7c0415">&#9670;&nbsp;</a></span>reference_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classReferenceCell.html">ReferenceCell</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::reference_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reference cell type of the current object. </p>

</div>
</div>
<a id="a4a5ed83117e0ff9276abeb9a4fbaac61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5ed83117e0ff9276abeb9a4fbaac61">&#9670;&nbsp;</a></span>n_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of vertices. </p>

</div>
</div>
<a id="a48e25f9720160ac96bc7f4eea0977784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e25f9720160ac96bc7f4eea0977784">&#9670;&nbsp;</a></span>n_lines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of lines. </p>

</div>
</div>
<a id="af330fe95fe8d30a99884797f61236913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af330fe95fe8d30a99884797f61236913">&#9670;&nbsp;</a></span>n_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of faces.</p>
<dl class="section note"><dt>Note</dt><dd>Only implemented for cells (dim==spacedim). </dd></dl>

</div>
</div>
<a id="ae40947cf863ecef1ee08ec93f411baaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40947cf863ecef1ee08ec93f411baaa">&#9670;&nbsp;</a></span>vertex_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero to <a class="el" href="classTriaAccessor.html#a4a5ed83117e0ff9276abeb9a4fbaac61">n_vertices()</a>. </p>

</div>
</div>
<a id="a44268b67d46418c49a0a5e47f404adcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44268b67d46418c49a0a5e47f404adcc">&#9670;&nbsp;</a></span>line_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero to <a class="el" href="classTriaAccessor.html#a48e25f9720160ac96bc7f4eea0977784">n_lines()</a>. </p>

</div>
</div>
<a id="a5b4cabec41161961ab25d91b6cdc2425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4cabec41161961ab25d91b6cdc2425">&#9670;&nbsp;</a></span>face_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero to <a class="el" href="classTriaAccessor.html#af330fe95fe8d30a99884797f61236913">n_faces()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Only implemented for cells (dim==spacedim). </dd></dl>

</div>
</div>
<a id="a09d81693979927a7a966ddc18d243978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d81693979927a7a966ddc18d243978">&#9670;&nbsp;</a></span>set_boundary_id_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_boundary_id_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like set_boundary_id but without checking for internal faces or invalid ids. </p>

</div>
</div>
<a id="aa045a20bce1bf6c012e50e9e12d37358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa045a20bce1bf6c012e50e9e12d37358">&#9670;&nbsp;</a></span>set_bounding_object_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_bounding_object_indices </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the indices of those objects that bound the current object. For example, if the current object represents a cell, then the argument denotes the indices of the faces that bound the cell. If the current object represents a line, the argument denotes the indices of the vertices that bound it. And so on. </p>

</div>
</div>
<a id="a5935fc1f892fdf9c90e4252c8aa2e095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5935fc1f892fdf9c90e4252c8aa2e095">&#9670;&nbsp;</a></span>set_bounding_object_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_bounding_object_indices </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as above but for <code>unsigned int</code>. </p>

</div>
</div>
<a id="ab1947e00bce29b9e766546feb3bbd2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1947e00bce29b9e766546feb3bbd2f4">&#9670;&nbsp;</a></span>set_line_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_line_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the flag indicating, what <code><a class="el" href="classTriaAccessor.html#a08aaa41d4d6e0942d888efc21ca5d6c7">line_orientation()</a></code> will return.</p>
<p>It is only possible to set the line_orientation of faces in 3d (i.e. <code>structdim==2 &amp;&amp; dim==3</code>). </p>

</div>
</div>
<a id="a2d4e1cdc683814cbb505b66e088ded4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4e1cdc683814cbb505b66e088ded4f">&#9670;&nbsp;</a></span>set_face_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_face_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set whether the quad with index <code>face</code> has its normal pointing in the standard direction (<code>true</code>) or whether it is the opposite (<code>false</code>). Which is the standard direction is documented with the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>This function is only for internal use in the library. Setting this flag to any other value than the one that the triangulation has already set is bound to bring you disaster. </p>

</div>
</div>
<a id="a120f75f4b65a498bd55ceffe89db968b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120f75f4b65a498bd55ceffe89db968b">&#9670;&nbsp;</a></span>set_face_flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_face_flip </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>flip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the flag indicating, what <code><a class="el" href="classTriaAccessor.html#ad90f5ff1a44cb8a6e08196dac6cdb22e">face_flip()</a></code> will return.</p>
<p>It is only possible to set the face_orientation of cells in 3d (i.e. <code>structdim==3 &amp;&amp; dim==3</code>). </p>

</div>
</div>
<a id="a2eac7c4a6195f66c016eeaef1283ada8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eac7c4a6195f66c016eeaef1283ada8">&#9670;&nbsp;</a></span>set_face_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_face_rotation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the flag indicating, what <code><a class="el" href="classTriaAccessor.html#a2f831f5ca8626677089f94af9be43a5b">face_rotation()</a></code> will return.</p>
<p>It is only possible to set the face_orientation of cells in 3d (i.e. <code>structdim==3 &amp;&amp; dim==3</code>). </p>

</div>
</div>
<a id="a6bf46d7dd76ebe7b46e3e26d63859f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf46d7dd76ebe7b46e3e26d63859f0c">&#9670;&nbsp;</a></span>set_used_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_used_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the <code>used</code> flag. Only for internal use in the library. </p>

</div>
</div>
<a id="a7983a80711bcde0ea9ec5f2cc95a935c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7983a80711bcde0ea9ec5f2cc95a935c">&#9670;&nbsp;</a></span>clear_used_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_used_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the <code>used</code> flag. Only for internal use in the library. </p>

</div>
</div>
<a id="a928a0f17388d3e7377fb216a0ca204a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928a0f17388d3e7377fb216a0ca204a8">&#9670;&nbsp;</a></span>set_refinement_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_refinement_case </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; structdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_case</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the <code>RefinementCase&lt;dim&gt;</code> this TriaObject is refined with. Not defined for <code>structdim=1</code> as lines are always refined resulting in 2 children lines (isotropic refinement).</p>
<p>You should know quite exactly what you are doing if you touch this function. It is exclusively for internal use in the library. </p>

</div>
</div>
<a id="af0d0e9691107c5f5ed5b5fa54c71e92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d0e9691107c5f5ed5b5fa54c71e92f">&#9670;&nbsp;</a></span>clear_refinement_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_refinement_case </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the RefinementCase&lt;dim&gt; of this TriaObject, i.e. reset it to <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase&lt;dim&gt;::no_refinement</a>.</p>
<p>You should know quite exactly what you are doing if you touch this function. It is exclusively for internal use in the library. </p>

</div>
</div>
<a id="aeee3827c653602a10ae243bfd26242eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee3827c653602a10ae243bfd26242eb">&#9670;&nbsp;</a></span>set_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_children </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the index of the ith child. Since the children come at least in pairs, we need to store the index of only every second child, i.e. of the even numbered children. Make sure, that the index of child i=0 is set first. Calling this function for odd numbered children is not allowed. </p>

</div>
</div>
<a id="a048a39a28d4f2a4490a71e2edc8cfc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048a39a28d4f2a4490a71e2edc8cfc3f">&#9670;&nbsp;</a></span>clear_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the child field, i.e. set it to a value which indicates that this cell has no children. </p>

</div>
</div>
<a id="a436333e85278d0d4f3feb80abc2db97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436333e85278d0d4f3feb80abc2db97c">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator. Since this is only called from iterators, do not return anything, since the iterator will return itself.</p>
<p>This method is protected, since it is only to be called from the iterator class. </p>

</div>
</div>
<a id="a7cd4644115f0c10a4e07462029211274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd4644115f0c10a4e07462029211274">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator for accessors. This operator is used when comparing iterators into objects of a triangulation, for example when putting them into a <code>std::map</code>.</p>
<p>If <a class="el" href="classTriaAccessorBase.html#a35e42860babc727fc028adfb9a3200b7">structure_dimension</a> is less than <a class="el" href="classTriaAccessorBase.html#a125ed55a8362723639a14d083d9e745c">dimension</a>, we simply compare the index of such an object because faces and edges do not have levels. If <a class="el" href="classTriaAccessorBase.html#a35e42860babc727fc028adfb9a3200b7">structure_dimension</a> equals <a class="el" href="classTriaAccessorBase.html#a125ed55a8362723639a14d083d9e745c">dimension</a>, we compare the level first, and the index only if levels are equal. </p>

</div>
</div>
<a id="af88fce14be63f6000f7b5d70618dc14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88fce14be63f6000f7b5d70618dc14b">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for equality. </p>

</div>
</div>
<a id="a044710b90a02f1d4e6c2e39c00f51ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044710b90a02f1d4e6c2e39c00f51ee7">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for inequality. </p>

</div>
</div>
<a id="a5a24bd66635320e66d1dff07e3cb26e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a24bd66635320e66d1dff07e3cb26e1">&#9670;&nbsp;</a></span>operator++()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operator advances the iterator to the next element.</p>
<p>For <code>dim=1</code> only: The next element is next on this level if there are more. If the present element is the last on this level, the first on the next level is accessed. </p>

</div>
</div>
<a id="a85d4f1dc476691cf77e88f2c3ed15afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d4f1dc476691cf77e88f2c3ed15afe">&#9670;&nbsp;</a></span>operator--()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operator moves the iterator to the previous element.</p>
<p>For <code>dim=1</code> only: The previous element is previous on this level if <code>index&gt;0</code>. If the present element is the first on this level, the last on the previous level is accessed. </p>

</div>
</div>
<a id="ae6d5a6b58e60a06216665e31c26704bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d5a6b58e60a06216665e31c26704bd">&#9670;&nbsp;</a></span>objects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaObjects.html">internal::TriangulationImplementation::TriaObjects</a>&amp; <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to the other objects of a <a class="el" href="classTriangulation.html">Triangulation</a> with same dimension. </p>

</div>
</div>
<a id="ae826bd9e6c976638366d9993e6a6c7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae826bd9e6c976638366d9993e6a6c7c0">&#9670;&nbsp;</a></span>level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For cells, this function returns the level within the mesh hierarchy at which this cell is located. For all other objects, the function returns zero.</p>
<dl class="section note"><dt>Note</dt><dd>Within a <a class="el" href="classTriangulation.html">Triangulation</a> object, cells are uniquely identified by a pair <code>(level, index)</code> where the former is the cell's refinement level and the latter is the index of the cell within this refinement level (the former being what this function returns). Consequently, there may be multiple cells on different refinement levels but with the same index within their level. Contrary to this, if the current object corresponds to a face or edge, then the object is uniquely identified solely by its index as faces and edges do not have a refinement level. For these objects, the current function always returns zero as the level. </dd></dl>

</div>
</div>
<a id="a6bebfc1e42324fbf595487e1bf668a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bebfc1e42324fbf595487e1bf668a22">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the index of the element presently pointed to on the present level.</p>
<p>Within a <a class="el" href="classTriangulation.html">Triangulation</a> object, cells are uniquely identified by a pair <code>(level, index)</code> where the former is the cell's refinement level and the latter is the index of the cell within this refinement level (the latter being what this function returns). Consequently, there may be multiple cells on different refinement levels but with the same index within their level. Contrary to this, if the current object corresponds to a face or edge, then the object is uniquely identified solely by its index as faces and edges do not have a refinement level.</p>
<dl class="section note"><dt>Note</dt><dd>The indices objects returned by this function are not a contiguous set of numbers on each level: going from cell to cell, some of the indices in a level may be unused.</dd>
<dd>
If the triangulation is actually of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> then the indices are relatively only to that part of the distributed triangulation that is stored on the current processor. In other words, cells living in the partitions of the triangulation stored on different processors may have the same index even if they refer to the same cell, and the may have different indices even if they do refer to the same cell (e.g., if a cell is owned by one processor but is a ghost cell on another). </dd></dl>

</div>
</div>
<a id="a5f75f0d6c68a1a67ea03bd4727c29529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f75f0d6c68a1a67ea03bd4727c29529">&#9670;&nbsp;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507">IteratorState::IteratorStates</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the state of the iterator. For the different states an accessor can be in, refer to the <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> documentation. </p>

</div>
</div>
<a id="af822c24c013e7b677f45ec2a8a41386a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af822c24c013e7b677f45ec2a8a41386a">&#9670;&nbsp;</a></span>get_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the triangulation which the object pointed to by this class belongs to. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="abe9e690d5d7904f804316e15362a2191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9e690d5d7904f804316e15362a2191">&#9670;&nbsp;</a></span>Triangulation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTriangulation.html">Triangulation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l01840">1840</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a1173edf91a9d914373821b6117f32a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1173edf91a9d914373821b6117f32a8f">&#9670;&nbsp;</a></span>::internal::TriangulationImplementation::Implementation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::internal::TriangulationImplementation::Implementation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l01842">1842</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a8b5f94c07c2ca904c27c04ca38eac0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5f94c07c2ca904c27c04ca38eac0e1">&#9670;&nbsp;</a></span>::internal::TriangulationImplementation::ImplementationMixedMesh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::internal::TriangulationImplementation:: ImplementationMixedMesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l01844">1844</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a66bd8833f949eb9ac7a4dc4669177f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bd8833f949eb9ac7a4dc4669177f26">&#9670;&nbsp;</a></span>::internal::TriaAccessorImplementation::Implementation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::internal::TriaAccessorImplementation::Implementation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l01845">1845</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac97bc3b07691e1a0ba9f32074642ae66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97bc3b07691e1a0ba9f32074642ae66">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimension of the space the object represented by this accessor lives in. For example, if this accessor represents a quad that is part of a two- dimensional surface in four-dimensional space, then this value is four. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00309">309</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a125ed55a8362723639a14d083d9e745c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125ed55a8362723639a14d083d9e745c">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimensionality of the object that the thing represented by this accessor is part of. For example, if this accessor represents a line that is part of a hexahedron, then this value will be three. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00316">316</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a35e42860babc727fc028adfb9a3200b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e42860babc727fc028adfb9a3200b7">&#9670;&nbsp;</a></span>structure_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::structure_dimension = structdim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimensionality of the current object represented by this accessor. For example, if it is line (irrespective of whether it is part of a quad or hex, and what dimension we are in), then this value equals 1. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00323">323</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a3ad5efb039ed878a124c9577acd92256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad5efb039ed878a124c9577acd92256">&#9670;&nbsp;</a></span>present_level</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::TriaAccessorImplementation:: PresentLevelType&lt;structdim, dim&gt;::type <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::present_level</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The level if this is a cell (<code>structdim==dim</code>). Else, contains zero. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00521">521</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a11cf2d985abdb2c9a43ab97722305f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cf2d985abdb2c9a43ab97722305f34">&#9670;&nbsp;</a></span>present_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::present_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used to store the index of the element presently pointed to on the level presently used. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00527">527</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="af02486bbb2ee4b94d1b51f03ba47257f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02486bbb2ee4b94d1b51f03ba47257f">&#9670;&nbsp;</a></span>tria</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;* <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::tria</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the triangulation which we act on. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00532">532</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/grid/<a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
