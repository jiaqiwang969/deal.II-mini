<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classParameterHandler.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: ParameterHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classParameterHandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ParameterHandler Class Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__input.html">Input</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="parameter__handler_8h_source.html">deal.II/base/parameter_handler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ParameterHandler:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classParameterHandler__inherit__graph.svg" width="166" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8364dda711b93753c6809eefe2a8e827"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> { <br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a> = 0x0000, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f">Short</a> = 0x0001, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a50ae66aa378db81bb360ce7cdf96e3e1">KeepDeclarationOrder</a> = 0x0002, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a9b48379ffc293bc0a49b7aa342dbc9bf">PRM</a> = 0x0010, 
<br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">Text</a> = PRM, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3b5d289d79f36e819a7bd0d81a52ee37">LaTeX</a> = 0x0020, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a5ed7026d01b66b89ee3c1aef3efbfd4a">Description</a> = 0x0040, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510">XML</a> = 0x0080, 
<br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a456d0f94d7d72f33234d02a8b2e9030c">JSON</a> = 0x0100, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aadc1ef9748b3bb19e21e097bfe4f70b1">ShortPRM</a> = PRM | Short, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a6d91eaf8deb52a5d3cba991a9bb23ac7">ShortText</a> = ShortPRM, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aadab70cda4e49776ec93690fd9e1bbd1">ShortXML</a> = XML | Short, 
<br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a26b405ba447d5fcbeb3c178076c4580f">ShortJSON</a> = JSON | Short, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a0fbe0a13822fbc6b4e28fd6b416eb9ca">ShortLaTeX</a> = LaTeX | Short
<br />
 }</td></tr>
<tr class="separator:a8364dda711b93753c6809eefe2a8e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7aebc6956ea423d376c5fe881b8d5c4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a7aebc6956ea423d376c5fe881b8d5c4d">ParameterHandler</a> ()</td></tr>
<tr class="separator:a7aebc6956ea423d376c5fe881b8d5c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88837d277a9403e34572f0813ccffd9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae88837d277a9403e34572f0813ccffd9">~ParameterHandler</a> () override=default</td></tr>
<tr class="separator:ae88837d277a9403e34572f0813ccffd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4eeb455a8c693e9824ff2355e44b76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a3b4eeb455a8c693e9824ff2355e44b76">ParameterHandler</a> (const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;)=delete</td></tr>
<tr class="separator:a3b4eeb455a8c693e9824ff2355e44b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9f6389423d58763d539e13e2b09234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#afb9f6389423d58763d539e13e2b09234">operator=</a> (const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;)=delete</td></tr>
<tr class="separator:afb9f6389423d58763d539e13e2b09234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddaa05c5463c6c0b7701e18005717a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a> (std::istream &amp;input, const std::string &amp;filename=&quot;input file&quot;, const std::string &amp;last_line=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> skip_undefined=false)</td></tr>
<tr class="separator:a0ddaa05c5463c6c0b7701e18005717a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647461d59c5de46d345d56e0f856d581"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a647461d59c5de46d345d56e0f856d581">parse_input</a> (const std::string &amp;filename, const std::string &amp;last_line=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> skip_undefined=false, const <a class="el" href="classbool.html">bool</a> assert_mandatory_entries_are_found=false)</td></tr>
<tr class="separator:a647461d59c5de46d345d56e0f856d581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bb8b2735fb7e9980ec73ff7b489f7f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a79bb8b2735fb7e9980ec73ff7b489f7f">parse_input_from_string</a> (const std::string &amp;s, const std::string &amp;last_line=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> skip_undefined=false)</td></tr>
<tr class="separator:a79bb8b2735fb7e9980ec73ff7b489f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e7edb2a86419b76f4a1b69dfdd873a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a12e7edb2a86419b76f4a1b69dfdd873a">parse_input_from_xml</a> (std::istream &amp;input, const <a class="el" href="classbool.html">bool</a> skip_undefined=false)</td></tr>
<tr class="separator:a12e7edb2a86419b76f4a1b69dfdd873a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4afb8f5cc2451fb16be1fff32b4380"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#afb4afb8f5cc2451fb16be1fff32b4380">parse_input_from_json</a> (std::istream &amp;input, const <a class="el" href="classbool.html">bool</a> skip_undefined=false)</td></tr>
<tr class="separator:afb4afb8f5cc2451fb16be1fff32b4380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6184baed4eba575e422161dc86ed12e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6184baed4eba575e422161dc86ed12e3">clear</a> ()</td></tr>
<tr class="separator:a6184baed4eba575e422161dc86ed12e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d65f458be69e23a348221cb67fc411d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (const std::string &amp;entry, const std::string &amp;default_value, const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;pattern=<a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(), const std::string &amp;documentation=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> has_to_be_set=false)</td></tr>
<tr class="separator:a6d65f458be69e23a348221cb67fc411d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f3996003757093fb0e050a6729e81b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action</a> (const std::string &amp;entry, const std::function&lt; void(const std::string &amp;value)&gt; &amp;action)</td></tr>
<tr class="separator:a59f3996003757093fb0e050a6729e81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b75c02037d19fd7fd781785fcefc79"><td class="memTemplParams" colspan="2">template&lt;class ParameterType &gt; </td></tr>
<tr class="memitem:a04b75c02037d19fd7fd781785fcefc79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">add_parameter</a> (const std::string &amp;entry, ParameterType &amp;parameter, const std::string &amp;documentation=&quot;&quot;, const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;pattern= *<a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a>&lt; ParameterType &gt;::to_pattern(), const <a class="el" href="classbool.html">bool</a> has_to_be_set=false)</td></tr>
<tr class="separator:a04b75c02037d19fd7fd781785fcefc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb847561585089c4c7fcf51eddece16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aecb847561585089c4c7fcf51eddece16">declare_alias</a> (const std::string &amp;existing_entry_name, const std::string &amp;alias_name, const <a class="el" href="classbool.html">bool</a> alias_is_deprecated=false)</td></tr>
<tr class="separator:aecb847561585089c4c7fcf51eddece16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29c20cde6d44186806d559beb468696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (const std::string &amp;subsection)</td></tr>
<tr class="separator:af29c20cde6d44186806d559beb468696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599462cacd492e2f712bf7369507dcff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ()</td></tr>
<tr class="separator:a599462cacd492e2f712bf7369507dcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6142462087d1cd62d294eccb1f58867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae6142462087d1cd62d294eccb1f58867">subsection_path_exists</a> (const std::vector&lt; std::string &gt; &amp;sub_path) const</td></tr>
<tr class="separator:ae6142462087d1cd62d294eccb1f58867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cfbaca954f444047302446a4e87125"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a91cfbaca954f444047302446a4e87125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08ccf6fbd95de45a35b53ba0c09f49f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa08ccf6fbd95de45a35b53ba0c09f49f">get</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:aa08ccf6fbd95de45a35b53ba0c09f49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fa98fdc0c52980a5b1de0ee1fc5bb2"><td class="memItemLeft" align="right" valign="top">long <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a61fa98fdc0c52980a5b1de0ee1fc5bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421a09eb0548f1fb3783d97d3e85fd5c"><td class="memItemLeft" align="right" valign="top">long <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a421a09eb0548f1fb3783d97d3e85fd5c">get_integer</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a421a09eb0548f1fb3783d97d3e85fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf3c7846747695b1f327677e3716ec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a> (const std::string &amp;entry_name) const</td></tr>
<tr class="separator:aeaf3c7846747695b1f327677e3716ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913289695be07bd949bf94aa5cd5ad54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a913289695be07bd949bf94aa5cd5ad54">get_double</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a913289695be07bd949bf94aa5cd5ad54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb45dc67787e3fab7882461929b5fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a> (const std::string &amp;entry_name) const</td></tr>
<tr class="separator:a6bb45dc67787e3fab7882461929b5fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209f365b60c5b0a76080b86693baa36b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a209f365b60c5b0a76080b86693baa36b">get_bool</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a209f365b60c5b0a76080b86693baa36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6418ea655b1b550b9dcf63513030196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> (const std::string &amp;entry_name, const std::string &amp;new_value)</td></tr>
<tr class="separator:aa6418ea655b1b550b9dcf63513030196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af288e1fe38ac1a1baf1cef3058b63ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af288e1fe38ac1a1baf1cef3058b63ce1">set</a> (const std::string &amp;entry_name, const char *new_value)</td></tr>
<tr class="separator:af288e1fe38ac1a1baf1cef3058b63ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89180ba36c54e207286a3545f8371b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa89180ba36c54e207286a3545f8371b4">set</a> (const std::string &amp;entry_name, const long <a class="el" href="classint.html">int</a> new_value)</td></tr>
<tr class="separator:aa89180ba36c54e207286a3545f8371b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46b9dd6387d7e48ddca4add8baad2aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ad46b9dd6387d7e48ddca4add8baad2aa">set</a> (const std::string &amp;entry_name, const <a class="el" href="classdouble.html">double</a> new_value)</td></tr>
<tr class="separator:ad46b9dd6387d7e48ddca4add8baad2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae417f9634872a427765365cd5ee9b160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae417f9634872a427765365cd5ee9b160">set</a> (const std::string &amp;entry_name, const <a class="el" href="classbool.html">bool</a> new_value)</td></tr>
<tr class="separator:ae417f9634872a427765365cd5ee9b160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac3a8b19ade16e96e8ea25906daf23a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a> (std::ostream &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style) const</td></tr>
<tr class="separator:a4ac3a8b19ade16e96e8ea25906daf23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fde9ad56e01eed0648e56106e6bf1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a17fde9ad56e01eed0648e56106e6bf1e">print_parameters</a> (const std::string &amp;filename, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style=<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a>) const</td></tr>
<tr class="separator:a17fde9ad56e01eed0648e56106e6bf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa900e3460a10639fc4d8703ef09a7c0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa900e3460a10639fc4d8703ef09a7c0a">log_parameters</a> (<a class="el" href="classLogStream.html">LogStream</a> &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style=<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a>)</td></tr>
<tr class="separator:aa900e3460a10639fc4d8703ef09a7c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15f2618f3b24c04eead226c5271be1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae15f2618f3b24c04eead226c5271be1a">log_parameters_section</a> (<a class="el" href="classLogStream.html">LogStream</a> &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style=<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a>)</td></tr>
<tr class="separator:ae15f2618f3b24c04eead226c5271be1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0342139603da3b30b132446d94a17b25"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a0342139603da3b30b132446d94a17b25">memory_consumption</a> () const</td></tr>
<tr class="separator:a0342139603da3b30b132446d94a17b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df38ff67c1c8352e04de490e0c0a39e"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a5df38ff67c1c8352e04de490e0c0a39e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a5df38ff67c1c8352e04de490e0c0a39e">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:a5df38ff67c1c8352e04de490e0c0a39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a09fd2ee6d01b78079f894893aacd6c4c">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac896adce1ec1db3f525f57811764879"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:aac896adce1ec1db3f525f57811764879"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aac896adce1ec1db3f525f57811764879">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:aac896adce1ec1db3f525f57811764879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede1a749bba8ee11876fd114a16c4f3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aede1a749bba8ee11876fd114a16c4f3e">operator==</a> (const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm2) const</td></tr>
<tr class="separator:aede1a749bba8ee11876fd114a16c4f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a299c29da8a837a1b8441039d0fa79"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa5a299c29da8a837a1b8441039d0fa79">get_entries_wrongly_not_set</a> () const</td></tr>
<tr class="separator:aa5a299c29da8a837a1b8441039d0fa79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af441ab90c4d310c1c7d12c5f0050024f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af441ab90c4d310c1c7d12c5f0050024f">assert_that_entries_have_been_set</a> () const</td></tr>
<tr class="separator:af441ab90c4d310c1c7d12c5f0050024f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga55b48a9b5ced390a0c292e8103afdf91"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga55b48a9b5ced390a0c292e8103afdf91">ExcEntryAlreadyExists</a> (std::string arg1)</td></tr>
<tr class="separator:ga55b48a9b5ced390a0c292e8103afdf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b16bc7be372c9270121d278858a672f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8b16bc7be372c9270121d278858a672f">ExcValueDoesNotMatchPattern</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga8b16bc7be372c9270121d278858a672f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9213c9ff33bbb3d167b67fa890a6d9ce"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9213c9ff33bbb3d167b67fa890a6d9ce">ExcAlreadyAtTopLevel</a> ()</td></tr>
<tr class="separator:ga9213c9ff33bbb3d167b67fa890a6d9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab8cc9a7fa6a9c6114a207b795007d5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga2ab8cc9a7fa6a9c6114a207b795007d5">ExcEntryUndeclared</a> (std::string arg1)</td></tr>
<tr class="separator:ga2ab8cc9a7fa6a9c6114a207b795007d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a05434eefbd2de0314b0a483247d96d"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0a05434eefbd2de0314b0a483247d96d">ExcUnbalancedSubsections</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga0a05434eefbd2de0314b0a483247d96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8136031b245c5a29ddac3940090f0ac"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad8136031b245c5a29ddac3940090f0ac">ExcNoSubsection</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gad8136031b245c5a29ddac3940090f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa620e44b3aa3cf356feaa424a516086e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa620e44b3aa3cf356feaa424a516086e">ExcCannotParseLine</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gaa620e44b3aa3cf356feaa424a516086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3cb505bbdd65d21ef66e3ef7e383bab"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad3cb505bbdd65d21ef66e3ef7e383bab">ExcInvalidEntryForPattern</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3, std::string arg4, std::string arg5)</td></tr>
<tr class="separator:gad3cb505bbdd65d21ef66e3ef7e383bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43bb6588e469c2e12a430fb7ea316da1"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga43bb6588e469c2e12a430fb7ea316da1">ExcInvalidXMLParameterFile</a> ()</td></tr>
<tr class="separator:ga43bb6588e469c2e12a430fb7ea316da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2febc2a5dd0328f971093085bf9b4fa"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2febc2a5dd0328f971093085bf9b4fa">ExcCannotOpenIncludeStatementFile</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac2febc2a5dd0328f971093085bf9b4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a309a5cd29993c8070462ec3ac70564cc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a309a5cd29993c8070462ec3ac70564cc">get_current_path</a> () const</td></tr>
<tr class="separator:a309a5cd29993c8070462ec3ac70564cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae05819ce1de5de30ad92322fc8fc8da"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aae05819ce1de5de30ad92322fc8fc8da">get_current_full_path</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:aae05819ce1de5de30ad92322fc8fc8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d7994d250bf62a83a4c3e119e8e1dd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a74d7994d250bf62a83a4c3e119e8e1dd">get_current_full_path</a> (const std::vector&lt; std::string &gt; &amp;sub_path, const std::string &amp;name) const</td></tr>
<tr class="separator:a74d7994d250bf62a83a4c3e119e8e1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bdedef2bd8e6a1fe405a92c4d19590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae9bdedef2bd8e6a1fe405a92c4d19590">scan_line</a> (std::string line, const std::string &amp;input_filename, const unsigned <a class="el" href="classint.html">int</a> current_line_n, const <a class="el" href="classbool.html">bool</a> skip_undefined)</td></tr>
<tr class="separator:ae9bdedef2bd8e6a1fe405a92c4d19590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acc4642bfc38ec36b4927eb520661db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a4acc4642bfc38ec36b4927eb520661db">recursively_print_parameters</a> (const boost::property_tree::ptree &amp;tree, const std::vector&lt; std::string &gt; &amp;target_subsection_path, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a> style, const unsigned <a class="el" href="classint.html">int</a> indent_level, std::ostream &amp;out) const</td></tr>
<tr class="separator:a4acc4642bfc38ec36b4927eb520661db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aefa5b69fc4d1d56dd6bc90e2dcf24d56"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aefa5b69fc4d1d56dd6bc90e2dcf24d56">subsection_path</a></td></tr>
<tr class="separator:aefa5b69fc4d1d56dd6bc90e2dcf24d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c753f43844f2c1196d4ef939048bb0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; boost::property_tree::ptree &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae3c753f43844f2c1196d4ef939048bb0">entries</a></td></tr>
<tr class="separator:ae3c753f43844f2c1196d4ef939048bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad871495dd6e1c35e2d36ecb3f66a53a"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::pair&lt; <a class="el" href="classbool.html">bool</a>, <a class="el" href="classbool.html">bool</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aad871495dd6e1c35e2d36ecb3f66a53a">entries_set_status</a></td></tr>
<tr class="separator:aad871495dd6e1c35e2d36ecb3f66a53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caa993b840f2e2d76fcfd7b94cbc799"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a3caa993b840f2e2d76fcfd7b94cbc799">patterns</a></td></tr>
<tr class="separator:a3caa993b840f2e2d76fcfd7b94cbc799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45eff738f43667037e3e59be30f04b0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::function&lt; void(const std::string &amp;)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ad45eff738f43667037e3e59be30f04b0">actions</a></td></tr>
<tr class="separator:ad45eff738f43667037e3e59be30f04b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a009fb8cb45463ac3a57f8cb371fbc82b"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a009fb8cb45463ac3a57f8cb371fbc82b">path_separator</a> = '.'</td></tr>
<tr class="separator:a009fb8cb45463ac3a57f8cb371fbc82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6cb3efd46790a1d4b58f5ffe7bb66c06"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6cb3efd46790a1d4b58f5ffe7bb66c06">MultipleParameterLoop</a></td></tr>
<tr class="separator:a6cb3efd46790a1d4b58f5ffe7bb66c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classParameterHandler.html">ParameterHandler</a> class provides a standard interface to an input file which provides at run-time for program parameters such as time step sizes, geometries, right hand sides etc. The input for the program is given in files, streams or strings in memory using text like </p><div class="fragment"><div class="line"><span class="keyword">set</span> Time step size = 0.3</div><div class="line">set Geometry       = [0,1]x[0,3]</div></div><!-- fragment --><p> Input may be sorted into subsection trees in order to give the input a logical structure, and input files may include other files.</p>
<p>The <a class="el" href="classParameterHandler.html">ParameterHandler</a> class is discussed in step-29, step-33, and step-34.</p>
<h3>Declaring entries</h3>
<p>In order to use the facilities of a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object, one first has to make known the different entries the input file may or may not contain. This is done in the following way:</p>
<div class="fragment"><div class="line">...</div><div class="line">ParameterHandler prm;</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Time step size&quot;</span>,</div><div class="line">                   <span class="stringliteral">&quot;0.2&quot;</span>,</div><div class="line">                   <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                   <span class="stringliteral">&quot;Some documentation&quot;</span>);</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Geometry&quot;</span>,</div><div class="line">                   <span class="stringliteral">&quot;[0,1]x[0,1]&quot;</span>,</div><div class="line">                   <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>());</div><div class="line">...</div></div><!-- fragment --><p> Each entry is declared using the function <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a>. The first parameter is the name of the entry (in short: the entry). The second is the default answer to be taken in case the entry is not specified in the input file. The third parameter is a regular expression which the input (and the default answer) has to match. Several such regular expressions are defined in <a class="el" href="namespacePatterns.html">Patterns</a>. This parameter can be omitted, in which case it will default to <a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>, i.e. a pattern that matches every input string. The fourth parameter can be used to document the intent or expected format of an entry; its value is printed as a comment when writing all entries of a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object using the <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters()</a> function to allow for easier understanding of a parameter file. It can be omitted as well, in which case no such documentation will be printed.</p>
<p>Entries may be located in subsections which form a kind of input tree. For example input parameters for linear solver routines should be classified in a subsection named <code>Linear solver</code> or any other suitable name. This is accomplished in the following way: </p><div class="fragment"><div class="line">...</div><div class="line">LinEq eq;</div><div class="line">eq.declare_parameters (prm);</div><div class="line">...</div><div class="line"></div><div class="line">void LinEq::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Solver&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;CG&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;CG|GMRES|GaussElim&quot;</span>),</div><div class="line">                       <span class="stringliteral">&quot;Name of a linear solver for the inner iteration&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Maximum number of iterations&quot;</span>, <span class="stringliteral">&quot;20&quot;</span>,</div><div class="line">                       ParameterHandler::RegularExpressions::Integer());</div><div class="line">    ...</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><p>Subsections may be nested. For example a nonlinear solver may have a linear solver as member object. Then the function call tree would be something like (if the class <code>NonLinEq</code> has a member variables <code>eq</code> of type <code>LinEq</code>): </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> NonLinEq::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Nonlinear method&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;Newton-Raphson&quot;</span>,</div><div class="line">                       ParameterHandler::RegularExpressions::Anything());</div><div class="line">    eq.declare_parameters (prm);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><p>For class member functions which declare the different entries we propose to use the common name <code>declare_parameters</code>. In normal cases this method can be <code>static</code> since the entries will not depend on any previous knowledge. Classes for which entries should logically be grouped into subsections should declare these subsections themselves. If a class has two or more member variables of the same type both of which should have their own parameters, this parent class' method <code>declare_parameters</code> is responsible to group them into different subsections: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> NonLinEq::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver 1&quot;</span>);</div><div class="line">    {</div><div class="line">      eq1.declare_parameters (prm);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver 2&quot;</span>);</div><div class="line">    {</div><div class="line">      eq2.declare_parameters (prm);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><h3>Input files and special characters</h3>
<p>For the first example above the input file would look like the following: </p><div class="fragment"><div class="line">...</div><div class="line">subsection Nonlinear solver</div><div class="line">  <span class="keyword">set</span> Nonlinear method = Gradient</div><div class="line"><span class="preprocessor">  # this is a comment</span></div><div class="line">  subsection Linear solver</div><div class="line">    <span class="keyword">set</span> Solver                       = CG</div><div class="line">    <span class="keyword">set</span> Maximum number of iterations = 30</div><div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line">...                       # other stuff</div></div><!-- fragment --><p> The words <code>subsection</code>, <code>set</code> and <code>end</code> may be either written in lowercase or uppercase letters. Leading and trailing whitespace is removed, multiple whitespace is condensed into only one. Since the latter applies also to the name of an entry, an entry name will not be recognized if in the declaration multiple whitespace is used.</p>
<p>In entry names and values the following characters are not allowed: <code>#</code>, <code>{</code>, <code>}</code>, <code>|</code>. Their use is reserved for the <a class="el" href="classMultipleParameterLoop.html">MultipleParameterLoop</a> class.</p>
<p>Comments starting with # are skipped.</p>
<p>Continuation lines are allowed by means of the character <code>\</code>, which must be the last character (aside from whitespace, which is ignored) of the line. When a line is a continuation (i.e., the previous line ended in a <code>\</code>), then, unlike the default behavior of the <code>C</code> preprocessor, all whitespace at the beginning of the line is ignored.</p>
<p>We propose to use the following scheme to name entries: start the first word with a capital letter and use lowercase letters further on. The same applies to the possible entry values to the right of the <code>=</code> sign.</p>
<h3>Including other input files</h3>
<p>An input file can include other include files using the syntax </p><div class="fragment"><div class="line">...</div><div class="line">include some_other_file.prm</div><div class="line">...</div></div><!-- fragment --><p> The file so referenced is searched for relative to the current directory (not relative to the directory in which the including parameter file is located, since this is not known to all three versions of the <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input()</a> function).</p>
<h3>Reading data from input sources</h3>
<p>In order to read input there are three possibilities: reading from an <code>std::istream</code> object, reading from a file of which the name is given and reading from a string in memory in which the lines are separated by <code>\n</code> characters. These possibilities are used as follows: </p><div class="fragment"><div class="line"><a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">...</div><div class="line"><span class="comment">// declaration of entries</span></div><div class="line">...</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a> (std::cin); <span class="comment">// read input from standard in,</span></div><div class="line"><span class="comment">// or</span></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a> (<span class="stringliteral">&quot;simulation.prm&quot;</span>);</div><div class="line"><span class="comment">// or</span></div><div class="line"><span class="keywordtype">char</span> *in = <span class="stringliteral">&quot;set Time step size = 0.3 \n ...&quot;</span>;</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a79bb8b2735fb7e9980ec73ff7b489f7f">parse_input_from_string</a> (in);</div><div class="line">...</div></div><!-- fragment --><p> You can use several sources of input successively. Entries which are changed more than once will be overwritten every time they are used.</p>
<p>You should not try to declare entries using <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> and <a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection()</a> with as yet unknown subsection names after using <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input()</a>. The results in this case are unspecified.</p>
<p>If an error occurs upon reading the input, error messages are written to <code>std::cerr</code> and the reader function returns with a return value of <code>false</code>. This is opposed to almost all other functions in deal.II, which would normally throw an exception if an error occurs; this difference in behavior is a relic of the fact that this class predates deal.II and had previously been written for a different project.</p>
<h3>Using the ParameterHandler Graphical User Interface</h3>
<p>An alternative to using the hand-written input files shown above is to use the graphical user interface (GUI) that accompanies this class.</p>
<p>See <a href="https://github.com/dealii/parameter_gui">the parameter_gui github repository</a> for further details.</p>
<h3>Getting entry values out of a ParameterHandler object</h3>
<p>Each class gets its data out of a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object by calling the <a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get()</a> member functions like this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> NonLinEq::get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> method = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Nonlinear method&quot;</span>);</div><div class="line">  eq.get_parameters (prm);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><p> <a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get()</a> returns the value of the given entry. If the entry was not specified in the input source(s), the default value is returned. You have to enter and leave subsections exactly as you did when declaring subsections. You may choose the order in which to traverse the subsection tree.</p>
<p>It is possible to avoid calls to <a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection()</a> and <a class="el" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection()</a> by supplying <a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get()</a> with a vector of strings representing the path from which to get a value. For example, the following two versions of get_parameters() will produce the same result: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> NonLinEq::get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 1 Settings&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">  solver_ = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Solver&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> NonLinEq::get_parameters (<span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  std::vector&lt;std::string&gt; path =</div><div class="line">    {<span class="stringliteral">&quot;Equation 1 Settings&quot;</span>, <span class="stringliteral">&quot;Linear solver&quot;</span>};</div><div class="line">  solver_ = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (path, <span class="stringliteral">&quot;Solver&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>The latter method allows the <a class="el" href="classParameterHandler.html">ParameterHandler</a> reference to be <code>const</code>.</p>
<p>It is guaranteed that only entries matching the given regular expression are returned, i.e. an input entry value which does not match the regular expression is not stored.</p>
<p>You can use <a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get()</a> to retrieve the parameter in text form, <a class="el" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer()</a> to get an integer or <a class="el" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double()</a> to get a double. You can also use <a class="el" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool()</a>. It will cause an internal error if the string could not be converted to an integer, double or a bool. This should, though, not happen if you correctly specified the regular expression for this entry; you should not try to get out an integer or a double from an entry for which no according regular expression was set. The internal error is raised through the <a class="el" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert()</a> macro family which only works in debug mode.</p>
<p>If you want to print out all user selectable features, use the <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters()</a> function. It is generally a good idea to print all parameters at the beginning of a log file, since this way input and output are together in one file which makes matching at a later time easier. Additionally, the function also print those entries which have not been modified in the input file and are thus set to default values; since default values may change in the process of program development, you cannot know the values of parameters not specified in the input file.</p>
<h3>Adding Actions to Parameters</h3>
<p>It is often convenient to have something happen as soon as a parameter value is read. This could be a check that it is valid &ndash; say, that a file that is listed in the parameter file exists &ndash; or to initiate something else in response, such as setting a variable outside the <a class="el" href="classParameterHandler.html">ParameterHandler</a> (as in the example shown below). In almost all cases, this "action" could also be initiated once all parameters are read via <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input()</a>, but it is sometimes <em>convenient</em> to do it right away.</p>
<p>This is facilitated by the <a class="el" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action()</a> function that can be called after declaring a parameter via <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a>. "Actions" are in essence pointers to functions that will be called for parameters that have associated actions. These functions take the value of a parameter as argument, and can then do whatever they want with it &ndash; e.g., save it somewhere outside the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object. (Exactly when the action is called is described in the documentation of the <a class="el" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action()</a> function.) Of course, in C++ one doesn't usually pass around the address of a function, but an action can be a function-like object (taking a string as argument) that results from calling such as a <a href="http://en.cppreference.com/w/cpp/language/lambda">lambda function</a> that has the form </p><div class="fragment"><div class="line">[] (<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;<a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>) { ... <span class="keywordflow">do</span> something with the <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a> ... }</div></div><!-- fragment --><p> and that is attached to a specific parameter.</p>
<p>A typical example of such an action would be as follows: let's assume that you have a program that declares a parameter for the number of iterations it is going to run, say </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyAlgorithm</div><div class="line">{</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a> ();</div><div class="line">   <span class="keyword">private</span>:</div><div class="line">     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations;</div><div class="line">};</div></div><!-- fragment --><p> then one could obtain this parameter from a parameter file using a code snippet in <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MyAlgorithm::run</a> ()</div><div class="line">{</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Number of iterations&quot;</span>,  <span class="comment">// name of parameter</span></div><div class="line">                     <span class="stringliteral">&quot;10&quot;</span>,                    <span class="comment">// default value</span></div><div class="line">                     <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1,100),<span class="comment">// allowed values: 1...100</span></div><div class="line">                     <span class="stringliteral">&quot;The number of ...&quot;</span>);    <span class="comment">// some documentation</span></div><div class="line"></div><div class="line">  <span class="comment">// next read the parameter from an input file...</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a> (<span class="stringliteral">&quot;my_algorithm.prm&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// ...and finally get the value for use in the program:</span></div><div class="line">  n_iterations = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Number of iterations&quot;</span>);</div><div class="line"></div><div class="line">  ... actual code doing something useful follows here...</div></div><!-- fragment --><p>This two-step process &ndash; first declaring the parameter, and later reading it &ndash; is a bit cumbersome because one has to first declare <em>all</em> parameters and at a later time retrieve them from the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object. In large programs, these two things also often happen in different functions.</p>
<p>To avoid this, it would be nice if we could put both the declaration and the retrieval into the same place. This can be done via actions, and the function would then look like this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MyAlgorithm::run</a> ()</div><div class="line">{</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Number of iterations&quot;</span>,  <span class="comment">// name of parameter</span></div><div class="line">                     <span class="stringliteral">&quot;10&quot;</span>,                    <span class="comment">// default value</span></div><div class="line">                     <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1,100),<span class="comment">// allowed values: 1...100</span></div><div class="line">                     <span class="stringliteral">&quot;The number of ...&quot;</span>);    <span class="comment">// some documentation</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action</a> (<span class="stringliteral">&quot;Number of iterations&quot;</span>,</div><div class="line">                  [&amp;](<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;value)</div><div class="line">                  {</div><div class="line">                    this-&gt;n_iterations = <a class="code" href="namespaceUtilities.html#af7e8ff146c677d8a2408b88e4936f57d">Utilities::string_to_int</a>(value);</div><div class="line">                  });</div><div class="line"></div><div class="line">  <span class="comment">// next read the parameter from an input file...</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a> (<span class="stringliteral">&quot;my_algorithm.prm&quot;</span>);</div><div class="line"></div><div class="line">  ... actual code doing something useful follows here...</div></div><!-- fragment --><p> Here, the action consists of a lambda function that takes the value for this parameter as a string, and then converts it to an integer to store in the variable where it belongs. This action is executed inside the call to <code>prm.parse_input()</code>, and so there is now no longer a need to extract the parameter's value at a later time. Furthermore, the code that sets the member variable is located right next to the place where the parameter is actually declared, so we no longer need to have two separate parts of the code base that deal with input parameters.</p>
<p>Of course, it is possible to execute far more involved actions than just setting a member variable as shown above, even though that is a typical case.</p>
<h3>Style guide for data retrieval</h3>
<p>We propose that every class which gets data out of a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object provides a function named <code>get_parameters</code>. This should be declared <code>virtual</code>. <code>get_parameters</code> functions in derived classes should call the <code>BaseClass::get_parameters</code> function.</p>
<h3>Experience with large parameter lists</h3>
<p>Experience has shown that in programs defining larger numbers of parameters (more than, say, fifty) it is advantageous to define an additional class holding these parameters. This class is more like a C-style structure, having a large number of variables, usually public. It then has at least two functions, which declare and parse the parameters. In the main program, the main class has an object of this parameter class and delegates declaration and parsing of parameters to this object.</p>
<p>The advantage of this approach is that you can keep out the technical details (declaration and parsing) out of the main class and additionally don't clutter up your main class with dozens or more variables denoting the parameters.</p>
<h3>Worked Example</h3>
<p>This is the code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"><span class="keyword">class </span>LinearEquation</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">  <span class="keywordtype">void</span> get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> method;</div><div class="line">  <span class="keywordtype">int</span>         max_iterations;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>Problem</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  LinearEquation eq1, eq2;</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> matrix1, matrix2;</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> outfile;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">  <span class="keywordtype">void</span> get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> do_something ();</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LinearEquation::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  <span class="comment">// declare parameters for the linear solver in a subsection</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Solver&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;CG&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;CG|BiCGStab|GMRES&quot;</span>),</div><div class="line">                       <span class="stringliteral">&quot;Name of a linear solver for the inner iteration&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Maximum number of iterations&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;20&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>());</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LinearEquation::get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    method         = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Solver&quot;</span>);</div><div class="line">    max_iterations = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Maximum number of iterations&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  LinearEquation: method=&quot;</span> &lt;&lt; method</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;, max_iterations=&quot;</span> &lt;&lt; max_iterations</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Problem::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  <span class="comment">// first some global parameter entries</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (</div><div class="line">    <span class="stringliteral">&quot;Output file&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;out&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">    <span class="stringliteral">&quot;Name of the output file, either relative or absolute&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Equation 1&quot;</span>, <span class="stringliteral">&quot;Laplace&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                     <span class="stringliteral">&quot;String identifying the equation we want to solve&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Equation 2&quot;</span>,</div><div class="line">                     <span class="stringliteral">&quot;Elasticity&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>());</div><div class="line"></div><div class="line">  <span class="comment">// declare parameters for the first equation</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 1 Settings&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;Sparse&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;Full|Sparse|Diagonal&quot;</span>),</div><div class="line">                       <span class="stringliteral">&quot;Type of the matrix to be used, either full, &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;sparse, or diagonal&quot;</span>);</div><div class="line">    LinearEquation::declare_parameters (prm);  <span class="comment">// for eq1</span></div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">  <span class="comment">// declare parameters for the second equation</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 2 Settings&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;Sparse&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;Full|Sparse|Diagonal&quot;</span>));</div><div class="line">    LinearEquation::declare_parameters (prm);  <span class="comment">// for eq2</span></div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Problem::get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  <span class="comment">// entries of the problem class</span></div><div class="line">  outfile = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Output file&quot;</span>);</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> equation1 = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Equation 1&quot;</span>),</div><div class="line">              equation2 = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Equation 2&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// get parameters for the first equation</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 1 Settings&quot;</span>);</div><div class="line">  {</div><div class="line">    matrix1 = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>);</div><div class="line">    eq1.get_parameters (prm); <span class="comment">// for eq1</span></div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">  <span class="comment">// get parameters for the second equation</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 2 Settings&quot;</span>);</div><div class="line">  {</div><div class="line">    matrix2 = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>);</div><div class="line">    eq2.get_parameters (prm); <span class="comment">// for eq2</span></div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">  std::cout</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;  Problem: outfile=&quot;</span> &lt;&lt; outfile &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;           eq1=&quot;</span>     &lt;&lt; equation1 &lt;&lt; <span class="stringliteral">&quot;, eq2=&quot;</span> &lt;&lt; equation2 &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;           matrix1=&quot;</span> &lt;&lt; matrix1 &lt;&lt; <span class="stringliteral">&quot;, matrix2=&quot;</span> &lt;&lt; matrix2</div><div class="line">    &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Problem::do_something ()</div><div class="line">{</div><div class="line">  <span class="comment">// While this example does nothing here, at this point in the program</span></div><div class="line">  <span class="comment">// all of the parameters are known so we can start doing computations.</span></div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">  Problem p;</div><div class="line">  p.declare_parameters (prm);</div><div class="line">  <span class="comment">// read input from &quot;prmtest.prm&quot;; giving argv[1] would also be a</span></div><div class="line">  <span class="comment">// good idea</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a> (<span class="stringliteral">&quot;prmtest.prm&quot;</span>);</div><div class="line">  <span class="comment">// print parameters to std::cout as ASCII text</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a> (std::cout, <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div><div class="line">  <span class="comment">// get parameters into the program</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span> &lt;&lt; <span class="stringliteral">&quot;Getting parameters:&quot;</span> &lt;&lt; std::endl;</div><div class="line">  p.get_parameters (prm);</div><div class="line">  <span class="comment">// now run the program with these input parameters</span></div><div class="line">  p.do_something ();</div><div class="line">}</div></div><!-- fragment --><p>This is the input file (named "prmtest.prm"): </p><div class="fragment"><div class="line"><span class="preprocessor"># first declare the types of equations</span></div><div class="line"><span class="keyword">set</span> Equation 1 = Poisson</div><div class="line"><span class="keyword">set</span> Equation 2 = Stokes</div><div class="line"></div><div class="line">subsection Equation 1 <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a></div><div class="line">  <span class="keyword">set</span> Matrix type = Sparse</div><div class="line">  subsection Linear solver # parameters <span class="keywordflow">for</span> linear solver 1</div><div class="line">    <span class="keyword">set</span> Solver                       = Gauss-Seidel</div><div class="line">    <span class="keyword">set</span> Maximum number of iterations = 40</div><div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"></div><div class="line">subsection Equation 2 <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a></div><div class="line">  <span class="keyword">set</span> Matrix type = Full</div><div class="line">  subsection Linear solver</div><div class="line">    <span class="keyword">set</span> Solver                       = CG</div><div class="line">    <span class="keyword">set</span> Maximum number of iterations = 100</div><div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div></div><!-- fragment --><p>And here is the output of the program: </p><div class="fragment"><div class="line">Line &lt;8&gt; of file &lt;prmtest.prm&gt;:</div><div class="line">    The entry value</div><div class="line">        Gauss-Seidel</div><div class="line">    <span class="keywordflow">for</span> the entry named</div><div class="line">        Solver</div><div class="line">    does not match the given pattern</div><div class="line">        [Selection CG|BiCGStab|GMRES ]</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor"># Listing of Parameters</span></div><div class="line"><span class="preprocessor"># ---------------------</span></div><div class="line"><span class="preprocessor"># String identifying the equation we want to solve</span></div><div class="line"><span class="keyword">set</span> Equation 1  = Poisson # <span class="keywordflow">default</span>: Laplace</div><div class="line"><span class="keyword">set</span> Equation 2  = Stokes  # <span class="keywordflow">default</span>: Elasticity</div><div class="line"></div><div class="line"><span class="preprocessor"># Name of the output file, either relative to the present path or absolute</span></div><div class="line"><span class="keyword">set</span> Output file = out</div><div class="line"></div><div class="line"></div><div class="line">subsection Equation 1 <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a></div><div class="line"><span class="preprocessor">  # Type of the matrix to be used, either full, sparse, or diagonal</span></div><div class="line">  <span class="keyword">set</span> Matrix type = Sparse</div><div class="line"></div><div class="line"></div><div class="line">  subsection Linear solver</div><div class="line">    <span class="keyword">set</span> Maximum number of iterations = 40 # <span class="keywordflow">default</span>: 20</div><div class="line"><span class="preprocessor">    # Name of a linear solver for the inner iteration</span></div><div class="line">    <span class="keyword">set</span> Solver                       = CG</div><div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"></div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"></div><div class="line"></div><div class="line">subsection Equation 2 <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a></div><div class="line">  <span class="keyword">set</span> Matrix type = Full # <span class="keywordflow">default</span>: Sparse</div><div class="line"></div><div class="line"></div><div class="line">  subsection Linear solver</div><div class="line">    <span class="keyword">set</span> Maximum number of iterations = 100 # <span class="keywordflow">default</span>: 20</div><div class="line"><span class="preprocessor">    # Name of a linear solver for the inner iteration</span></div><div class="line">    <span class="keyword">set</span> Solver                       = CG</div><div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"></div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">Getting parameters:</div><div class="line">  LinearEquation: method=CG, max_iterations=40</div><div class="line">  LinearEquation: method=CG, max_iterations=100</div><div class="line">  Problem: outfile=out</div><div class="line">           eq1=Poisson, eq2=Stokes</div><div class="line">           matrix1=Sparse, matrix2=Full</div></div><!-- fragment --><h3>Representation of Parameters</h3>
<p>Here is some more internal information about the representation of parameters:</p>
<p>Logically, parameters and the nested sections they are arranged in can be thought of as a hierarchical directory structure, or a tree. Take, for example, the following code declaring a set of parameters and sections they live in: </p><div class="fragment"><div class="line"><a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Maximal number of iterations&quot;</span>,</div><div class="line">                   <span class="stringliteral">&quot;10&quot;</span>,</div><div class="line">                   <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (1, 1000),</div><div class="line">                   <span class="stringliteral">&quot;A parameter that describes the maximal number of &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;iterations the CG method is to take before giving &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;up on a matrix.&quot;</span>);</div><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Preconditioner&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;Kind&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;SSOR&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a> (<span class="stringliteral">&quot;SSOR|Jacobi&quot;</span>),</div><div class="line">    <span class="stringliteral">&quot;A string that describes the kind of preconditioner to use.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;Relaxation factor&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;1.0&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a> (0, 1),</div><div class="line">    <span class="stringliteral">&quot;The numerical value (between zero and one) for the &quot;</span></div><div class="line">    <span class="stringliteral">&quot;relaxation factor to use in the preconditioner.&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div></div><!-- fragment --><p>We can think of the parameters so arranged as a file system in which every parameter is a directory. The name of this directory is the name of the parameter, and in this directory lie files that describe the parameter. These files are at the time of writing this documentation (other fields, such as those indicating "actions" may also exist in each directory):</p>
<ul>
<li><code>value</code>: The content of this file is the current value of this parameter; initially, the content of the file equals the default value of the parameter.</li>
<li><code>default_value</code>: The content of this file is the default value of the parameter.</li>
<li><code>pattern</code>: A textual representation of the pattern that describes the parameter's possible values.</li>
<li><code>pattern_index</code>: A number that indexes the <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> object that is used to describe the parameter.</li>
<li><code>documentation</code>: The content of this file is the documentation given for a parameter as the last argument of the <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">ParameterHandler::declare_entry</a> call. With the exception of the <code>value</code> file, the contents of files are never changed after declaration of a parameter.</li>
</ul>
<p>Alternatively, a directory in this file system may not have a file called <code>value</code> in it. In that case, the directory represents a subsection as declared above, and the directory's name will correspond to the name of the subsection. It will then have no files in it at all, but it may have further directories in it: some of these directories will be parameters (indicates by the presence of files) or further nested subsections.</p>
<p>Given this explanation, the code above will lead to a hierarchical representation of data that looks like this (the content of files is indicated at the right in a different font):</p>
<div class="image">
<img src="parameter_handler.png" alt="parameter_handler.png"/>
</div>
<p>Once parameters have been read in, the contents of the <code>value</code> "files" may be different while the other files remain untouched.</p>
<p>Using the <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">ParameterHandler::print_parameters()</a> function with <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510">ParameterHandler::XML</a> as second argument, we can get a complete representation of this data structure in XML. It will look like this: </p><div class="fragment"><div class="line">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> encoding=<span class="stringliteral">&quot;utf-8&quot;</span>?&gt;</div><div class="line">&lt;<a class="code" href="classParameterHandler.html">ParameterHandler</a>&gt;</div><div class="line">  &lt;Maximal_20number_20of_20iterations&gt;</div><div class="line">    &lt;value&gt;10&lt;/value&gt;</div><div class="line">    &lt;default_value&gt;10&lt;/default_value&gt;</div><div class="line">    &lt;documentation&gt;</div><div class="line">      A parameter that describes the maximal number of iterations the CG</div><div class="line">      method is to take before giving up on a <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>.</div><div class="line">    &lt;/documentation&gt;</div><div class="line">    &lt;pattern&gt;0&lt;/pattern&gt;</div><div class="line">    &lt;pattern_description&gt;</div><div class="line">      [Integer range 1...1000 (inclusive)]</div><div class="line">    &lt;/pattern_description&gt;</div><div class="line">  &lt;/Maximal_20number_20of_20iterations&gt;</div><div class="line">  &lt;Preconditioner&gt;</div><div class="line">    &lt;Kind&gt;&lt;value&gt;SSOR&lt;/value&gt;</div><div class="line">      &lt;default_value&gt;SSOR&lt;/default_value&gt;</div><div class="line">      &lt;documentation&gt;</div><div class="line">        A <span class="keywordtype">string</span> that describes the kind of preconditioner to use.</div><div class="line">      &lt;/documentation&gt;</div><div class="line">      &lt;pattern&gt;1&lt;/pattern&gt;</div><div class="line">      &lt;pattern_description&gt;SSOR|Jacobi&lt;/pattern_description&gt;</div><div class="line">    &lt;/Kind&gt;</div><div class="line">    &lt;Relaxation_20factor&gt;</div><div class="line">      &lt;value&gt;1.0&lt;/value&gt;</div><div class="line">      &lt;default_value&gt;1.0&lt;/default_value&gt;</div><div class="line">      &lt;documentation&gt;</div><div class="line">        The numerical value (between <a class="code" href="namespaceLAPACKSupport.html#a0d8802698d585eec62a2a54e6387b05b">zero</a> and <a class="code" href="namespaceLAPACKSupport.html#aceda56512460bbad2f9fdb8a3d0e1e51">one</a>) <span class="keywordflow">for</span> the relaxation</div><div class="line">        factor to use in the preconditioner.</div><div class="line">      &lt;/documentation&gt;</div><div class="line">      &lt;pattern&gt;2&lt;/pattern&gt;</div><div class="line">      &lt;pattern_description&gt;</div><div class="line">        [Floating <a class="code" href="namespaceOpenCASCADE.html#a041fdfae3d9ed8c073c54277acdd0b96">point</a> range 0...1 (inclusive)]</div><div class="line">      &lt;/pattern_description&gt;</div><div class="line">    &lt;/Relaxation_20factor&gt;</div><div class="line">  &lt;/Preconditioner&gt;</div><div class="line">&lt;<a class="code" href="classParameterHandler.html">ParameterHandler</a>&gt;</div></div><!-- fragment --><p> This representation closely resembles the directory/file structure discussed above. The only difference is that directory and file names are mangled: since they should only contain letters and numbers, every character in their names that is not a letter or number is replaced by an underscore followed by its two-digit hexadecimal representation. In addition, the special name "value" is mangled when used as the name of a parameter, given that this name is also used to name special files in the hierarchy structure. Finally, the entire tree is wrapped into a tag <code>ParameterHandler</code> to satisfy the XML requirement that there be only a single top-level construct in each file.</p>
<p>The tree structure (and its XML representation) is what the graphical user interface (see above) uses to represent parameters like a directory/file collection. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l00840">840</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a8364dda711b93753c6809eefe2a8e827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8364dda711b93753c6809eefe2a8e827">&#9670;&nbsp;</a></span>OutputStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of possible output formats used for functions like <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">ParameterHandler::print_parameters()</a>. The options can be categorized into two groups:</p><ul>
<li>format options: PRM, LaTeX, Description, XML, JSON</li>
<li>stylistic options: Short, KeepDeclarationOrder</li>
</ul>
<p>Only one format option may be specified at the time. Any function that accepts an OutputStyle as an option will throw if you specify more than one.</p>
<p>A number of shortcuts of commonly used option combinations are provided. E.g., ShortPRM prints the parameters in the PRM format, while skipping the documentation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48"></a>DefaultStyle&#160;</td><td class="fielddoc"><p>Default stylistic style: print documentation and sort all parameters alphabetically. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f"></a>Short&#160;</td><td class="fielddoc"><p>Write input for <a class="el" href="classParameterHandler.html">ParameterHandler</a> without comments or changed default values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a50ae66aa378db81bb360ce7cdf96e3e1"></a>KeepDeclarationOrder&#160;</td><td class="fielddoc"><p>Keep the order of the parameters as they have been declared. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a9b48379ffc293bc0a49b7aa342dbc9bf"></a>PRM&#160;</td><td class="fielddoc"><p>Write human readable output suitable to be read by <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> again. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365"></a>Text&#160;</td><td class="fielddoc"><p>Write human readable output suitable to be read by <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> again.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Use <code>PRM</code> instead of <code>Text</code>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a3b5d289d79f36e819a7bd0d81a52ee37"></a>LaTeX&#160;</td><td class="fielddoc"><p>Write parameters as a LaTeX table. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a5ed7026d01b66b89ee3c1aef3efbfd4a"></a>Description&#160;</td><td class="fielddoc"><p>Write out declared parameters with description and possible values.</p>
<dl class="section note"><dt>Note</dt><dd>This format is not suitable to be read back again. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510"></a>XML&#160;</td><td class="fielddoc"><p>Write out everything as an <a href="http://en.wikipedia.org/wiki/XML">XML</a> file suitable to be read by <a class="el" href="classParameterHandler.html#a12e7edb2a86419b76f4a1b69dfdd873a">ParameterHandler::parse_input_from_xml()</a> again.</p>
<p>See the general documentation of this class for an example of output. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a456d0f94d7d72f33234d02a8b2e9030c"></a>JSON&#160;</td><td class="fielddoc"><p>Write out everything as a <a href="http://en.wikipedia.org/wiki/JSON">JSON</a> file suitable to be read by <a class="el" href="classParameterHandler.html#afb4afb8f5cc2451fb16be1fff32b4380">ParameterHandler::parse_input_from_json()</a> again. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827aadc1ef9748b3bb19e21e097bfe4f70b1"></a>ShortPRM&#160;</td><td class="fielddoc"><p>Write the content of <a class="el" href="classParameterHandler.html">ParameterHandler</a> without comments or changed default values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a6d91eaf8deb52a5d3cba991a9bb23ac7"></a>ShortText&#160;</td><td class="fielddoc"><p>Write the content of <a class="el" href="classParameterHandler.html">ParameterHandler</a> without comments or changed default values.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Use <code>ShortPRM</code> instead of <code>ShortText</code>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827aadab70cda4e49776ec93690fd9e1bbd1"></a>ShortXML&#160;</td><td class="fielddoc"><p>Write the content of <a class="el" href="classParameterHandler.html">ParameterHandler</a> without comments or changed default values as a XML file. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a26b405ba447d5fcbeb3c178076c4580f"></a>ShortJSON&#160;</td><td class="fielddoc"><p>Write the content of <a class="el" href="classParameterHandler.html">ParameterHandler</a> without comments or changed default values as a JSON file. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a0fbe0a13822fbc6b4e28fd6b416eb9ca"></a>ShortLaTeX&#160;</td><td class="fielddoc"><p>Write the content of <a class="el" href="classParameterHandler.html">ParameterHandler</a> without comments or changed default values as a LaTeX file. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l00858">858</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7aebc6956ea423d376c5fe881b8d5c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aebc6956ea423d376c5fe881b8d5c4d">&#9670;&nbsp;</a></span>ParameterHandler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParameterHandler::ParameterHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00047">47</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae88837d277a9403e34572f0813ccffd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88837d277a9403e34572f0813ccffd9">&#9670;&nbsp;</a></span>~ParameterHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ParameterHandler::~ParameterHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Declare this only to have a virtual destructor, which is safer as we have virtual functions. It actually does nothing spectacular. </p>

</div>
</div>
<a id="a3b4eeb455a8c693e9824ff2355e44b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4eeb455a8c693e9824ff2355e44b76">&#9670;&nbsp;</a></span>ParameterHandler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParameterHandler::ParameterHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inhibit automatic CopyConstructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afb9f6389423d58763d539e13e2b09234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9f6389423d58763d539e13e2b09234">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParameterHandler.html">ParameterHandler</a>&amp; ParameterHandler::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inhibit automatic assignment operator. </p>

</div>
</div>
<a id="a0ddaa05c5463c6c0b7701e18005717a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddaa05c5463c6c0b7701e18005717a9">&#9670;&nbsp;</a></span>parse_input() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;input&#160;file&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse each line from a stream until the stream returns the <code>eof</code> condition or error to provide values for known parameter fields. The second argument can be used to denote the name of the file (if that's what the input stream represents) we are reading from; this is only used when creating output for exceptions.</p>
<p>If non-empty <code>last_line</code> is provided, the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object will stop parsing lines after encountering <code>last_line</code> . This is handy when adding extra data that shall be parsed manually.</p>
<p>If <code>skip_undefined</code> is <code>true</code>, the parameter handler will skip undefined sections and entries. This is useful for partially parsing a parameter file, for example to obtain only the spatial dimension of the problem. By default all entries and subsections are expected to be declared.</p>
<p>The function sets the value of all parameters it encounters in the input file to the provided value. Parameters not explicitly listed in the input file are left at the value they previously held, which will be the default value provided to <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> unless one has previously read a different input file.</p>
<p>Each parameter value is matched against the pattern for this parameter that was provided to <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a>, and for each parameter all associated actions that may previously have been set by <a class="el" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action()</a> are executed. If a parameter does not satisfy its pattern, or if an associated action throws an exception, then the value provided for the parameter is not set and the current object reverts to the subsection it was in before the current function was called. No further processing of the input stream occurs, that is everything that comes after the parameter whose value does not satisfy its pattern is ignored. </p>

<p>Reimplemented in <a class="el" href="classMultipleParameterLoop.html#a978e161aae61a62c27a7dec2d7fd527b">MultipleParameterLoop</a>.</p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00399">399</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a647461d59c5de46d345d56e0f856d581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647461d59c5de46d345d56e0f856d581">&#9670;&nbsp;</a></span>parse_input() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>assert_mandatory_entries_are_found</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse input from a specified parameter file <code>filename</code> independently of the type of input file (prm, xml, json) being used. The code path selected by this function is extracted from the ending of the filename, so the user has to make sure that the content of the input file is consistent with its name.</p>
<p>The parameter <code>last_line</code> will only be used for parameter files of .prm type. See the other parse_input function for documentation.</p>
<p>The user can specify whether parameters in the input file not added to the parameter handler will be skipped by <code>skip_undefined</code> (enables partial parsing), and whether the code will assert that all parameters of the parameter handler declared with flag <code>has_to_be_set=true</code> are indeed found in the input file.</p>
<p>If the function is called with <code>skip_undefined=true</code>, it is recommended to also set <code>assert_mandatory_entries_are_found=true</code>. For example, this ensures that parameters with typos in the input file will not be skipped, while such mistakes would otherwise remain unrecognized. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00532">532</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a79bb8b2735fb7e9980ec73ff7b489f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bb8b2735fb7e9980ec73ff7b489f7f">&#9670;&nbsp;</a></span>parse_input_from_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input_from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse input from a string to populate known parameter fields. The lines in the string must be separated by <code>\n</code> characters.</p>
<p>The function in essence reads the entire file into a stream and then calls the other <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input()</a> function with that stream. See there for more information. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00560">560</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a12e7edb2a86419b76f4a1b69dfdd873a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e7edb2a86419b76f4a1b69dfdd873a">&#9670;&nbsp;</a></span>parse_input_from_xml()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input_from_xml </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse input from an XML stream to populate known parameter fields. This could be from a file originally written by the <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters()</a> function using the XML output style and then modified by hand as necessary, or from a file written using this method and then modified by the graphical parameter GUI (see the general documentation of this class). </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00700">700</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="afb4afb8f5cc2451fb16be1fff32b4380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4afb8f5cc2451fb16be1fff32b4380">&#9670;&nbsp;</a></span>parse_input_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input_from_json </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse input from a JSON stream to populate known parameter fields. This could be from a file originally written by the <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters()</a> function using the JSON output style and then modified by hand as necessary, or from a separate program that knows how to write JSON format for <a class="el" href="classParameterHandler.html">ParameterHandler</a> input. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00756">756</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a6184baed4eba575e422161dc86ed12e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6184baed4eba575e422161dc86ed12e3">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all contents. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00787">787</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a6d65f458be69e23a348221cb67fc411d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d65f458be69e23a348221cb67fc411d">&#9670;&nbsp;</a></span>declare_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::declare_entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em> = <code><a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>documentation</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>has_to_be_set</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a new entry with name <code>entry</code>, default and for which any input has to match the <code>pattern</code> (default: any pattern).</p>
<p>The function generates an exception of type ExcValueDoesNotMatchPattern if the default value doesn't match the given pattern, using the C++ throw mechanism. However, this exception is only generated <em>after</em> the entry has been created; if you have code where no sensible default value for a parameter is possible, you can then catch and ignore this exception.</p>
<p>The parameter <code>documentation</code> defaulting to an empty string is used to add a documenting text to each entry which will be printed as a comment when this class is asked to write out all declarations to a stream using the <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters()</a> function.</p>
<p>The parameter <code>has_to_be_set</code> can be used in order to declare this parameter as a parameter whose default value has to be overwritten by one of the methods provided by this class. Whether a parameter has been set successfully can be queried by the functions <a class="el" href="classParameterHandler.html#aa5a299c29da8a837a1b8441039d0fa79">get_entries_wrongly_not_set()</a> and <a class="el" href="classParameterHandler.html#af441ab90c4d310c1c7d12c5f0050024f">assert_that_entries_have_been_set()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>An entry can be declared more than once without generating an error, for example to override an earlier default value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00796">796</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a59f3996003757093fb0e050a6729e81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f3996003757093fb0e050a6729e81b">&#9670;&nbsp;</a></span>add_action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::add_action </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const std::string &amp;value)&gt; &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach an action to the parameter with name <code>entry</code> in the current section. The action needs to be a function-like object that takes the value of the parameter as a (string) argument. See the general documentation of this class for a longer description of actions, as well as examples.</p>
<p>The action is executed in three different circumstances:</p><ul>
<li>With the default value of the parameter with name <code>name</code>, at the end of the current function. This is useful because it allows for the action to execute whatever it needs to do at least once for each parameter, even those that are not actually specified in the input file (and thus remain at their default values).</li>
<li>Within the <a class="el" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">ParameterHandler::set()</a> functions that explicitly set a value for a parameter.</li>
<li>Within the <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input()</a> function and similar functions such as <a class="el" href="classParameterHandler.html#a79bb8b2735fb7e9980ec73ff7b489f7f">parse_input_from_string()</a>. Here, the action is executed whenever the parameter with which it is associated is read from the input, after it has been established that the value so read matches the pattern that corresponds to this parameter, and before the value is actually saved.</li>
</ul>
<p>It is valid to add multiple actions to the same parameter. They will in that case be executed in the same order in which they were added.</p>
<dl class="section note"><dt>Note</dt><dd>Actions may modify all sorts of variables in their scope. The only thing an action should not modify is the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object it is attached to. In other words, it is not allowed to enter or leave sections of the current <a class="el" href="classParameterHandler.html">ParameterHandler</a> object. It is, in principle, acceptable to call <a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">ParameterHandler::get()</a> and related functions on other parameters in the current section, but since there is no guarantee about the order in which they will be read from an input file, you will not want to rely on the values these functions would return.</dd>
<dd>
Throwing an exception in an action is generally not a good idea, but yields fundamentally the same result as if one tries to read a parameter from a file for which the value does not satisfy the pattern associated with the parameter. In other words, the value just read is discarded, and <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> stops to read any further content from the file. See <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00842">842</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a04b75c02037d19fd7fd781785fcefc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b75c02037d19fd7fd781785fcefc79">&#9670;&nbsp;</a></span>add_parameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ParameterType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::add_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParameterType &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>documentation</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em> = <code>*<a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a>&lt;ParameterType&gt;::to_pattern()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>has_to_be_set</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a new entry name <code>entry</code>, set its default value to the content of the variable <code>parameter</code>, and create an action that will fill <code>parameter</code> with updated values when a file is parsed, or the entry is set to a new value.</p>
<p>By default, the pattern to use is obtained by calling the function <a class="el" href="structPatterns_1_1Tools_1_1Convert.html#a3fb901bae7fe2de5dc27da09e989ad2c">Patterns::Tools::Convert&lt;T&gt;::to_pattern()</a>, but a custom one can be used.</p>
<p>The parameter <code>has_to_be_set</code> can be used in order to declare this parameter as a parameter whose default value has to be overwritten by one of the methods provided by this class. Whether a parameter has been set successfully can be queried by the functions <a class="el" href="classParameterHandler.html#aa5a299c29da8a837a1b8441039d0fa79">get_entries_wrongly_not_set()</a> and <a class="el" href="classParameterHandler.html#af441ab90c4d310c1c7d12c5f0050024f">assert_that_entries_have_been_set()</a>. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02315">2315</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aecb847561585089c4c7fcf51eddece16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb847561585089c4c7fcf51eddece16">&#9670;&nbsp;</a></span>declare_alias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::declare_alias </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>existing_entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alias_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>alias_is_deprecated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an alias for an existing entry. This provides a way to refer to a parameter in the input file using an alternate name. The alias will be in the current section, and the referenced entry needs to be an existing entry in the current section.</p>
<p>The primary purpose of this function is to allow for a backward compatible way of changing names in input files of applications for which backward compatibility is important. This can be achieved by changing the name of the parameter in the call to <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a>, and then creating an alias that maps the old name to the new name. This way, old input files can continue to refer to parameters under the old name, and they will automatically be mapped to the new parameter name.</p>
<p>It is valid to set the same parameter multiple times in an input file. The value that will ultimately be chosen in such cases is simply the last value set. This rule also applies to aliases, where the final value of a parameter is the last value set either through the current name of the parameter or through any of its possible multiple aliases. For example, if you have an input file that looks like </p><div class="fragment"><div class="line"><span class="keyword">set</span> parm1       = 1</div><div class="line"><span class="keyword">set</span> parm1_alias = 2</div></div><!-- fragment --><p> where <code>parm1_alias</code> is an alias declared via </p><div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#aecb847561585089c4c7fcf51eddece16">declare_alias</a> (<span class="stringliteral">&quot;parm1&quot;</span>, <span class="stringliteral">&quot;parm1_alias&quot;</span>);</div></div><!-- fragment --><p> then the final value for the parameter called <code>parm1</code> will be 2, not 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">existing_entry_name</td><td>The name of an existing parameter in the current section that the alias should refer to. </td></tr>
    <tr><td class="paramname">alias_name</td><td>An alternate name for the parameter referenced by the first argument. </td></tr>
    <tr><td class="paramname">alias_is_deprecated</td><td>If true, mark the alias as deprecated. This will then be listed in the description of the alias if you call <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters()</a>, and you will get a warning on the screen when reading an input file that contains this deprecated alias. The purpose of this argument is to be able to allow the use of an old name for a parameter (see above) but make it clear that this old name will eventually be removed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00878">878</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af29c20cde6d44186806d559beb468696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29c20cde6d44186806d559beb468696">&#9670;&nbsp;</a></span>enter_subsection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::enter_subsection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subsection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enter a subsection. If it does not yet exist, create it. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00939">939</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a599462cacd492e2f712bf7369507dcff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599462cacd492e2f712bf7369507dcff">&#9670;&nbsp;</a></span>leave_subsection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::leave_subsection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Leave present subsection. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00953">953</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae6142462087d1cd62d294eccb1f58867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6142462087d1cd62d294eccb1f58867">&#9670;&nbsp;</a></span>subsection_path_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::subsection_path_exists </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a subsection or a subsection path exists in current tree. The input parameter <code>sub_path</code> is assumed to be relative to the currently selected path. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00966">966</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a91cfbaca954f444047302446a4e87125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cfbaca954f444047302446a4e87125">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_string</code>. If the entry was changed, then the changed value is returned, otherwise the default value. If the value of an undeclared entry is required, an <code>Assert</code> will fail. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00987">987</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa08ccf6fbd95de45a35b53ba0c09f49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08ccf6fbd95de45a35b53ba0c09f49f">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_string</code>. If the entry was changed, then the changed value is returned, otherwise the default value. If the value of an undeclared entry is required, an <code>Assert</code> will fail. If <code>entry_subsection_path</code> is non-empty, the value will be gotten from the subsection represented by that path instead of the current subsection. The first string in <code>entry_subsection_path</code> must be the name of a subsection of the current section, and each next string must be the name of a subsection of the one before it. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01004">1004</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a61fa98fdc0c52980a5b1de0ee1fc5bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fa98fdc0c52980a5b1de0ee1fc5bb2">&#9670;&nbsp;</a></span>get_integer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classint.html">int</a> ParameterHandler::get_integer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_string</code> as <code>long int</code>. (A long int is chosen so that even very large unsigned values can be returned by this function). </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01025">1025</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a421a09eb0548f1fb3783d97d3e85fd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421a09eb0548f1fb3783d97d3e85fd5c">&#9670;&nbsp;</a></span>get_integer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classint.html">int</a> ParameterHandler::get_integer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_string</code> as <code>long int</code>. (A long int is chosen so that even very large unsigned values can be returned by this function). If <code>entry_subsection_path</code> is non-empty, the value will be gotten from the subsection represented by that path instead of the current subsection. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01044">1044</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aeaf3c7846747695b1f327677e3716ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf3c7846747695b1f327677e3716ec5">&#9670;&nbsp;</a></span>get_double() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> ParameterHandler::get_double </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_name</code> as <code>double</code>. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01068">1068</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a913289695be07bd949bf94aa5cd5ad54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913289695be07bd949bf94aa5cd5ad54">&#9670;&nbsp;</a></span>get_double() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> ParameterHandler::get_double </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_name</code> as <code>double</code>. If <code>entry_subsection_path</code> is non-empty, the value will be gotten from the subsection represented by that path instead of the current subsection. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01088">1088</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a6bb45dc67787e3fab7882461929b5fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb45dc67787e3fab7882461929b5fbe">&#9670;&nbsp;</a></span>get_bool() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::get_bool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_name</code> as <code>bool</code>. The entry may be "true" or "yes" for <code>true</code>, "false" or "no" for <code>false</code> respectively. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01113">1113</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a209f365b60c5b0a76080b86693baa36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209f365b60c5b0a76080b86693baa36b">&#9670;&nbsp;</a></span>get_bool() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::get_bool </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_name</code> as <code>bool</code>. The entry may be "true" or "yes" for <code>true</code>, "false" or "no" for <code>false</code> respectively. If <code>entry_subsection_path</code> is non-empty, the value will be gotten from the subsection represented by that path instead of the current subsection. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01130">1130</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa6418ea655b1b550b9dcf63513030196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6418ea655b1b550b9dcf63513030196">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01152">1152</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af288e1fe38ac1a1baf1cef3058b63ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af288e1fe38ac1a1baf1cef3058b63ce1">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but an overload where the second argument is a character pointer. This is necessary, since otherwise the call to <code>set("abc","def")</code> will be mapped to the function taking one string and a bool as arguments, which is certainly not what is most often intended.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01205">1205</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa89180ba36c54e207286a3545f8371b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89180ba36c54e207286a3545f8371b4">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01227">1227</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ad46b9dd6387d7e48ddca4add8baad2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46b9dd6387d7e48ddca4add8baad2aa">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>For internal purposes, the new value needs to be converted to a string. This is done using 16 digits of accuracy, so the set value and the one you can get back out using <a class="el" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double()</a> may differ in the 16th digit.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01213">1213</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae417f9634872a427765365cd5ee9b160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae417f9634872a427765365cd5ee9b160">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01240">1240</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a4ac3a8b19ade16e96e8ea25906daf23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac3a8b19ade16e96e8ea25906daf23a">&#9670;&nbsp;</a></span>print_parameters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; ParameterHandler::print_parameters </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print all parameters with the given <code>style</code> to <code>out</code>.</p>
<p>Before printing, all current parameters and subsections are sorted alphabetically by default. This behavior can be disabled setting the optional parameter <code>style</code> to <code>KeepDeclarationOrder</code>: in this case entries are printed in the same order as they have been declared.</p>
<p>In <code>PRM</code>, <code>XML</code>, and <code>JSON</code> format, the output is formatted in such a way that it is possible to use it for later input again. This is most useful to record the parameters for a specific run, since if you output the parameters using this function into a log file, you can always recover the results by simply copying the output to your input file.</p>
<p>Besides the name and value of each entry, the output also contains the default value of entries if it is different from the actual value, as well as the documenting string given to the <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> function if available.</p>
<p>By using the flag <code>Short</code> in combination with <code>PRM</code>, <code>XML</code>, <code>JSON</code>, or <code>LaTeX</code> (or by using the shortcuts <code>ShortPRM</code>, <code>ShortXML</code>, <code>ShortJSON</code>, or <code>ShortLaTeX</code>), a reduced output can be generated, only containing the values and skipping the documentation.</p>
<p>In <code>XML</code> format, the output starts with one root element <code><a class="el" href="classParameterHandler.html">ParameterHandler</a></code> in order to get a valid XML document and all subsections under it.</p>
<p>In <code>LaTeX</code> format, the output contains the same information but in a format so that the resulting file can be input into a latex document such as a manual for the code for which this object handles run-time parameters. The various sections of parameters are then represented by latex section and subsection commands as well as by nested enumerations.</p>
<p>You can reference specific parameter sections and individual parameters by the labels that are generated automatically for each entry. The labels have the format <code>parameters:section1/subsection1</code> and <code>parameters:section1/subsection1/someentry</code>. Because special characters can appear in the section and entry names, these will be "mangled". Here, all characters except <code>[a-zA-Z0-9]</code> are replaced by <code>_XX</code>, where <code>XX</code> is the two-digit ascii code of the character in hexadecimal encoding (so a space becomes <code>_20</code> for example).</p>
<p>While this function escapes special LaTeX-specific characters (backslash, underscore, etc.) in most of the output (names, default values, etc.), the documentation string is passed as-is. This means you can use math environments and other formatting in the description, but you need to escape quotes, backslashes, underscores, etc. yourself.</p>
<p>In addition, all parameter names are listed with <code>\index</code> statements in two indices called <code>prmindex</code> (where the name of each parameter is listed in the index) and <code>prmindexfull</code> where parameter names are listed sorted by the section in which they exist. By default, the LaTeX program ignores these <code>\index</code> commands, but they can be used to generate an index by using the following commands in the preamble of the latex file : </p><div class="fragment"><div class="line">\usepackage{imakeidx}</div><div class="line">\makeindex[name=prmindex, title=Index of <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>-time parameter <a class="code" href="classParameterHandler.html#ae3c753f43844f2c1196d4ef939048bb0">entries</a>]</div><div class="line">\makeindex[name=prmindexfull,</div><div class="line">           title=Index of <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>-time parameters with section names]</div></div><!-- fragment --><p> and at the end of the file this: </p><div class="fragment"><div class="line">\printindex[prmindex]</div><div class="line">\printindex[prmindexfull]</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01250">1250</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a17fde9ad56e01eed0648e56106e6bf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17fde9ad56e01eed0648e56106e6bf1e">&#9670;&nbsp;</a></span>print_parameters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::print_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em> = <code><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print all parameters to the file given by <code>filename</code> with the given output style <code>style</code>.</p>
<p>This function deduces the output format from the extension of the specified filename. Supported extensions are <code>prm</code>, <code>xml</code>, <code>tex</code>, and <code>json</code>. Hence, it is not necessary to specify an output format via the <code>style</code> argument as long as one of these extensions is added to the filename. If an output format is specified in the <code>style</code> parameter nevertheless, the output format has to be consistent with the filename extension.</p>
<p>If no extension is specified or the extension is not supported, the output format is deduced from the <code>style</code> argument.</p>
<p>If neither the extension is supported, nor does the <code>style</code> parameter contain a format specification, an assertion is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The output file name. </td></tr>
    <tr><td class="paramname">style</td><td>The style with which output is produced. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01354">1354</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa900e3460a10639fc4d8703ef09a7c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa900e3460a10639fc4d8703ef09a7c0a">&#9670;&nbsp;</a></span>log_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::log_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLogStream.html">LogStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em> = <code><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print parameters to a logstream. This function allows to print all parameters into a log-file. Sections will be indented in the usual log- file style.</p>
<p>All current parameters and subsections are sorted alphabetically by default. This behavior can be disabled setting the optional parameter <code>style</code> to <code>KeepDeclarationOrder</code>: in this case entries are printed in the same order as they have been declared.</p>
<dl class="section note"><dt>Note</dt><dd>All style settings in <code>style</code> not related to the ordering are ignored. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01757">1757</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae15f2618f3b24c04eead226c5271be1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15f2618f3b24c04eead226c5271be1a">&#9670;&nbsp;</a></span>log_parameters_section()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::log_parameters_section </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLogStream.html">LogStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em> = <code><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log parameters in the present subsection. The subsection is determined by the <code>subsection_path</code> member variable. This variable is controlled by entering and leaving subsections through the <a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection()</a> and <a class="el" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection()</a> functions.</p>
<p>All current parameters and subsections are sorted alphabetically by default. This behavior can be disabled setting the optional parameter <code>style</code> to <code>KeepDeclarationOrder</code>: in this case entries are printed in the same order as they have been declared.</p>
<dl class="section note"><dt>Note</dt><dd>All style settings in <code>style</code> not related to the ordering are ignored.</dd></dl>
<p>In most cases, you will not want to use this function directly, but have it called recursively by the previous function. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01768">1768</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a0342139603da3b30b132446d94a17b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0342139603da3b30b132446d94a17b25">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ParameterHandler::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02009">2009</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a5df38ff67c1c8352e04de490e0c0a39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df38ff67c1c8352e04de490e0c0a39e">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02277">2277</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="a09fd2ee6d01b78079f894893aacd6c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fd2ee6d01b78079f894893aacd6c4c">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02296">2296</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aac896adce1ec1db3f525f57811764879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac896adce1ec1db3f525f57811764879">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="aede1a749bba8ee11876fd114a16c4f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede1a749bba8ee11876fd114a16c4f3e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for equality. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02018">2018</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa5a299c29da8a837a1b8441039d0fa79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a299c29da8a837a1b8441039d0fa79">&#9670;&nbsp;</a></span>get_entries_wrongly_not_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; ParameterHandler::get_entries_wrongly_not_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a set of parameter names (including subsection names) corresponding to those entries of the parameter handler that have not been set by one of the functions parsing parameters from an input file or by an explicit call to one of the <a class="el" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set()</a> functions, but that have been declared as mandatory parameters that must be set (through the last argument of the <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> function or <a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">add_parameter()</a> function). </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02043">2043</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af441ab90c4d310c1c7d12c5f0050024f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af441ab90c4d310c1c7d12c5f0050024f">&#9670;&nbsp;</a></span>assert_that_entries_have_been_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::assert_that_entries_have_been_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Asserts that those entries of the parameter handler with flag <code>has_to_be_set = true</code> have been set. An exception is invoked if at least one of these parameters has not been set. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02057">2057</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a309a5cd29993c8070462ec3ac70564cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309a5cd29993c8070462ec3ac70564cc">&#9670;&nbsp;</a></span>get_current_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get_current_path </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the string that identifies the current path into the property tree. This is only a path, i.e. it is not terminated by the path_separator character.</p>
<p>This function simply calls collate_path_string() with <code>subsection_path</code> as argument </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00358">358</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aae05819ce1de5de30ad92322fc8fc8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae05819ce1de5de30ad92322fc8fc8da">&#9670;&nbsp;</a></span>get_current_full_path() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get_current_full_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the name of an entry as argument, the function computes a full path into the parameter tree using the current subsection. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00366">366</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a74d7994d250bf62a83a4c3e119e8e1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d7994d250bf62a83a4c3e119e8e1dd">&#9670;&nbsp;</a></span>get_current_full_path() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get_current_full_path </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function computes a full path into the parameter tree given a path from the current subsection and the name of an entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00380">380</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae9bdedef2bd8e6a1fe405a92c4d19590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bdedef2bd8e6a1fe405a92c4d19590">&#9670;&nbsp;</a></span>scan_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::scan_line </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>current_line_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scan one line of input. <code>input_filename</code> and <code>current_line_n</code> are the name of the input file and the number of the line presently scanned (these are used in exception messages to show where parse errors occurred). This function will raise an exception if the line contains an undeclared subsection or entry, if the line's entry does not match its given pattern, or if the line could not be understood as a valid parameter file expression.</p>
<p>The function modifies its argument, but also takes it by value, so the caller's variable is not changed.</p>
<p>If <code>skip_undefined</code> is <code>true</code>, the parser will skip undefined sections and entries. This is useful for partially parsing a parameter file, for example to obtain only the spatial dimension of the problem. By default all entries and subsections are expected to be declared. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01814">1814</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a4acc4642bfc38ec36b4927eb520661db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acc4642bfc38ec36b4927eb520661db">&#9670;&nbsp;</a></span>recursively_print_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::recursively_print_parameters </td>
          <td>(</td>
          <td class="paramtype">const boost::property_tree::ptree &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>indent_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print out the parameters of the subsection given by the <code>target_subsection_path</code> argument, as well as all subsections within it recursively. This function is called from the <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters()</a> function, and is implemented for all <code>style</code> arguments other than XML and JSON (where we can output the entire set of parameters via BOOST functions). The <code>indent_level</code> argument indicates how many spaces the output should be indented, so that subsections properly nest inside the output of higher sections. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01379">1379</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a6cb3efd46790a1d4b58f5ffe7bb66c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb3efd46790a1d4b58f5ffe7bb66c06">&#9670;&nbsp;</a></span>MultipleParameterLoop</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classMultipleParameterLoop.html">MultipleParameterLoop</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01837">1837</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a009fb8cb45463ac3a57f8cb371fbc82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009fb8cb45463ac3a57f8cb371fbc82b">&#9670;&nbsp;</a></span>path_separator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char ParameterHandler::path_separator = '.'</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The separator used when accessing elements of a path into the parameter tree. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01726">1726</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aefa5b69fc4d1d56dd6bc90e2dcf24d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa5b69fc4d1d56dd6bc90e2dcf24d56">&#9670;&nbsp;</a></span>subsection_path</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; ParameterHandler::subsection_path</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Path of presently selected subsections; empty list means top level </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01731">1731</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="ae3c753f43844f2c1196d4ef939048bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c753f43844f2c1196d4ef939048bb0">&#9670;&nbsp;</a></span>entries</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;boost::property_tree::ptree&gt; ParameterHandler::entries</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The complete tree of sections and entries. See the general documentation of this class for a description how data is stored in this variable.</p>
<p>The variable is a pointer so that we can use an incomplete type, rather than having to include all of the property_tree stuff from boost. This works around a problem with gcc 4.5. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01741">1741</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aad871495dd6e1c35e2d36ecb3f66a53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad871495dd6e1c35e2d36ecb3f66a53a">&#9670;&nbsp;</a></span>entries_set_status</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::pair&lt;<a class="el" href="classbool.html">bool</a>, <a class="el" href="classbool.html">bool</a>&gt; &gt; ParameterHandler::entries_set_status</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A map that stores a pair of boolean variables for each entry added to the parameter handler. The first bool describes whether the parameter has to be set according to the last argument of the functions <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> or <a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">add_parameter()</a>, and the second bool contains the information whether the parameter has been set by any of the functions parsing input parameters or by a set function of this class. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01751">1751</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="a3caa993b840f2e2d76fcfd7b94cbc799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3caa993b840f2e2d76fcfd7b94cbc799">&#9670;&nbsp;</a></span>patterns</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unique_ptr&lt;const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a>&gt; &gt; ParameterHandler::patterns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of patterns that are used to describe the parameters of this object. Every nodes in the property tree corresponding to a parameter stores an index into this array. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01758">1758</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="ad45eff738f43667037e3e59be30f04b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45eff738f43667037e3e59be30f04b0">&#9670;&nbsp;</a></span>actions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::function&lt;void(const std::string &amp;)&gt; &gt; ParameterHandler::actions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of actions that are associated with parameters. These are added by the <a class="el" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action()</a> function. Nodes in the property tree corresponding to individual parameters store indices into this array in order to reference specific actions. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01766">1766</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a></li>
<li>source/base/<a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
