<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classParameterHandler.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: ParameterHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classParameterHandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ParameterHandler Class Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__input.html">Input</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="parameter__handler_8h_source.html">deal.II/base/parameter_handler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ParameterHandler:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classParameterHandler__inherit__graph.svg" width="183" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8364dda711b93753c6809eefe2a8e827"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> { <br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a> = 0x0000, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f">Short</a> = 0x0001, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a50ae66aa378db81bb360ce7cdf96e3e1">KeepDeclarationOrder</a> = 0x0002, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a9b48379ffc293bc0a49b7aa342dbc9bf">PRM</a> = 0x0010, 
<br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">Text</a> = PRM, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3b5d289d79f36e819a7bd0d81a52ee37">LaTeX</a> = 0x0020, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a5ed7026d01b66b89ee3c1aef3efbfd4a">Description</a> = 0x0040, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510">XML</a> = 0x0080, 
<br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a456d0f94d7d72f33234d02a8b2e9030c">JSON</a> = 0x0100, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aadc1ef9748b3bb19e21e097bfe4f70b1">ShortPRM</a> = PRM | Short, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a6d91eaf8deb52a5d3cba991a9bb23ac7">ShortText</a> = ShortPRM, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aadab70cda4e49776ec93690fd9e1bbd1">ShortXML</a> = XML | Short, 
<br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a26b405ba447d5fcbeb3c178076c4580f">ShortJSON</a> = JSON | Short, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a0fbe0a13822fbc6b4e28fd6b416eb9ca">ShortLaTeX</a> = LaTeX | Short
<br />
 }</td></tr>
<tr class="separator:a8364dda711b93753c6809eefe2a8e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8f9975e29e77c65dfde69a389a03377"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa8f9975e29e77c65dfde69a389a03377">ExcInvalidEntryForPatternXML</a> = <a class="el" href="group__Exceptions.html#ga8b16bc7be372c9270121d278858a672f">ExcValueDoesNotMatchPattern</a></td></tr>
<tr class="separator:gaa8f9975e29e77c65dfde69a389a03377"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7aebc6956ea423d376c5fe881b8d5c4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a7aebc6956ea423d376c5fe881b8d5c4d">ParameterHandler</a> ()</td></tr>
<tr class="separator:a7aebc6956ea423d376c5fe881b8d5c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88837d277a9403e34572f0813ccffd9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae88837d277a9403e34572f0813ccffd9">~ParameterHandler</a> () override=default</td></tr>
<tr class="separator:ae88837d277a9403e34572f0813ccffd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4eeb455a8c693e9824ff2355e44b76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a3b4eeb455a8c693e9824ff2355e44b76">ParameterHandler</a> (const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;)=delete</td></tr>
<tr class="separator:a3b4eeb455a8c693e9824ff2355e44b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9f6389423d58763d539e13e2b09234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#afb9f6389423d58763d539e13e2b09234">operator=</a> (const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;)=delete</td></tr>
<tr class="separator:afb9f6389423d58763d539e13e2b09234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddaa05c5463c6c0b7701e18005717a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a> (std::istream &amp;input, const std::string &amp;filename=&quot;input file&quot;, const std::string &amp;last_line=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> skip_undefined=false)</td></tr>
<tr class="separator:a0ddaa05c5463c6c0b7701e18005717a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647461d59c5de46d345d56e0f856d581"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a647461d59c5de46d345d56e0f856d581">parse_input</a> (const std::string &amp;filename, const std::string &amp;last_line=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> skip_undefined=false, const <a class="el" href="classbool.html">bool</a> assert_mandatory_entries_are_found=false)</td></tr>
<tr class="separator:a647461d59c5de46d345d56e0f856d581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bb8b2735fb7e9980ec73ff7b489f7f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a79bb8b2735fb7e9980ec73ff7b489f7f">parse_input_from_string</a> (const std::string &amp;s, const std::string &amp;last_line=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> skip_undefined=false)</td></tr>
<tr class="separator:a79bb8b2735fb7e9980ec73ff7b489f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e7edb2a86419b76f4a1b69dfdd873a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a12e7edb2a86419b76f4a1b69dfdd873a">parse_input_from_xml</a> (std::istream &amp;input, const <a class="el" href="classbool.html">bool</a> skip_undefined=false)</td></tr>
<tr class="separator:a12e7edb2a86419b76f4a1b69dfdd873a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4afb8f5cc2451fb16be1fff32b4380"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#afb4afb8f5cc2451fb16be1fff32b4380">parse_input_from_json</a> (std::istream &amp;input, const <a class="el" href="classbool.html">bool</a> skip_undefined=false)</td></tr>
<tr class="separator:afb4afb8f5cc2451fb16be1fff32b4380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6184baed4eba575e422161dc86ed12e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6184baed4eba575e422161dc86ed12e3">clear</a> ()</td></tr>
<tr class="separator:a6184baed4eba575e422161dc86ed12e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d65f458be69e23a348221cb67fc411d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (const std::string &amp;entry, const std::string &amp;default_value, const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;pattern=<a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(), const std::string &amp;documentation=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> has_to_be_set=false)</td></tr>
<tr class="separator:a6d65f458be69e23a348221cb67fc411d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f3996003757093fb0e050a6729e81b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action</a> (const std::string &amp;entry, const std::function&lt; void(const std::string &amp;value)&gt; &amp;action)</td></tr>
<tr class="separator:a59f3996003757093fb0e050a6729e81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b75c02037d19fd7fd781785fcefc79"><td class="memTemplParams" colspan="2">template&lt;class ParameterType &gt; </td></tr>
<tr class="memitem:a04b75c02037d19fd7fd781785fcefc79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">add_parameter</a> (const std::string &amp;entry, ParameterType &amp;parameter, const std::string &amp;documentation=&quot;&quot;, const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;pattern= *<a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a>&lt; ParameterType &gt;::to_pattern(), const <a class="el" href="classbool.html">bool</a> has_to_be_set=false)</td></tr>
<tr class="separator:a04b75c02037d19fd7fd781785fcefc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb847561585089c4c7fcf51eddece16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aecb847561585089c4c7fcf51eddece16">declare_alias</a> (const std::string &amp;existing_entry_name, const std::string &amp;alias_name, const <a class="el" href="classbool.html">bool</a> alias_is_deprecated=false)</td></tr>
<tr class="separator:aecb847561585089c4c7fcf51eddece16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29c20cde6d44186806d559beb468696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (const std::string &amp;subsection)</td></tr>
<tr class="separator:af29c20cde6d44186806d559beb468696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599462cacd492e2f712bf7369507dcff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ()</td></tr>
<tr class="separator:a599462cacd492e2f712bf7369507dcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6142462087d1cd62d294eccb1f58867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae6142462087d1cd62d294eccb1f58867">subsection_path_exists</a> (const std::vector&lt; std::string &gt; &amp;sub_path) const</td></tr>
<tr class="separator:ae6142462087d1cd62d294eccb1f58867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cfbaca954f444047302446a4e87125"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a91cfbaca954f444047302446a4e87125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08ccf6fbd95de45a35b53ba0c09f49f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa08ccf6fbd95de45a35b53ba0c09f49f">get</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:aa08ccf6fbd95de45a35b53ba0c09f49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fa98fdc0c52980a5b1de0ee1fc5bb2"><td class="memItemLeft" align="right" valign="top">long <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a61fa98fdc0c52980a5b1de0ee1fc5bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421a09eb0548f1fb3783d97d3e85fd5c"><td class="memItemLeft" align="right" valign="top">long <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a421a09eb0548f1fb3783d97d3e85fd5c">get_integer</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a421a09eb0548f1fb3783d97d3e85fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf3c7846747695b1f327677e3716ec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a> (const std::string &amp;entry_name) const</td></tr>
<tr class="separator:aeaf3c7846747695b1f327677e3716ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913289695be07bd949bf94aa5cd5ad54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a913289695be07bd949bf94aa5cd5ad54">get_double</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a913289695be07bd949bf94aa5cd5ad54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb45dc67787e3fab7882461929b5fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a> (const std::string &amp;entry_name) const</td></tr>
<tr class="separator:a6bb45dc67787e3fab7882461929b5fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209f365b60c5b0a76080b86693baa36b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a209f365b60c5b0a76080b86693baa36b">get_bool</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a209f365b60c5b0a76080b86693baa36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6418ea655b1b550b9dcf63513030196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> (const std::string &amp;entry_name, const std::string &amp;new_value)</td></tr>
<tr class="separator:aa6418ea655b1b550b9dcf63513030196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af288e1fe38ac1a1baf1cef3058b63ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af288e1fe38ac1a1baf1cef3058b63ce1">set</a> (const std::string &amp;entry_name, const char *new_value)</td></tr>
<tr class="separator:af288e1fe38ac1a1baf1cef3058b63ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89180ba36c54e207286a3545f8371b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa89180ba36c54e207286a3545f8371b4">set</a> (const std::string &amp;entry_name, const long <a class="el" href="classint.html">int</a> new_value)</td></tr>
<tr class="separator:aa89180ba36c54e207286a3545f8371b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46b9dd6387d7e48ddca4add8baad2aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ad46b9dd6387d7e48ddca4add8baad2aa">set</a> (const std::string &amp;entry_name, const <a class="el" href="classdouble.html">double</a> new_value)</td></tr>
<tr class="separator:ad46b9dd6387d7e48ddca4add8baad2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae417f9634872a427765365cd5ee9b160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae417f9634872a427765365cd5ee9b160">set</a> (const std::string &amp;entry_name, const <a class="el" href="classbool.html">bool</a> new_value)</td></tr>
<tr class="separator:ae417f9634872a427765365cd5ee9b160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac3a8b19ade16e96e8ea25906daf23a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a> (std::ostream &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style) const</td></tr>
<tr class="separator:a4ac3a8b19ade16e96e8ea25906daf23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fde9ad56e01eed0648e56106e6bf1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a17fde9ad56e01eed0648e56106e6bf1e">print_parameters</a> (const std::string &amp;filename, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style=<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a>) const</td></tr>
<tr class="separator:a17fde9ad56e01eed0648e56106e6bf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa900e3460a10639fc4d8703ef09a7c0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa900e3460a10639fc4d8703ef09a7c0a">log_parameters</a> (<a class="el" href="classLogStream.html">LogStream</a> &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style=<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a>)</td></tr>
<tr class="separator:aa900e3460a10639fc4d8703ef09a7c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15f2618f3b24c04eead226c5271be1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae15f2618f3b24c04eead226c5271be1a">log_parameters_section</a> (<a class="el" href="classLogStream.html">LogStream</a> &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style=<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a>)</td></tr>
<tr class="separator:ae15f2618f3b24c04eead226c5271be1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0342139603da3b30b132446d94a17b25"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a0342139603da3b30b132446d94a17b25">memory_consumption</a> () const</td></tr>
<tr class="separator:a0342139603da3b30b132446d94a17b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df38ff67c1c8352e04de490e0c0a39e"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a5df38ff67c1c8352e04de490e0c0a39e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a5df38ff67c1c8352e04de490e0c0a39e">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:a5df38ff67c1c8352e04de490e0c0a39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a09fd2ee6d01b78079f894893aacd6c4c">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac896adce1ec1db3f525f57811764879"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:aac896adce1ec1db3f525f57811764879"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aac896adce1ec1db3f525f57811764879">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:aac896adce1ec1db3f525f57811764879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede1a749bba8ee11876fd114a16c4f3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aede1a749bba8ee11876fd114a16c4f3e">operator==</a> (const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm2) const</td></tr>
<tr class="separator:aede1a749bba8ee11876fd114a16c4f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a299c29da8a837a1b8441039d0fa79"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa5a299c29da8a837a1b8441039d0fa79">get_entries_wrongly_not_set</a> () const</td></tr>
<tr class="separator:aa5a299c29da8a837a1b8441039d0fa79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af441ab90c4d310c1c7d12c5f0050024f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af441ab90c4d310c1c7d12c5f0050024f">assert_that_entries_have_been_set</a> () const</td></tr>
<tr class="separator:af441ab90c4d310c1c7d12c5f0050024f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga55b48a9b5ced390a0c292e8103afdf91"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga55b48a9b5ced390a0c292e8103afdf91">ExcEntryAlreadyExists</a> (std::string arg1)</td></tr>
<tr class="separator:ga55b48a9b5ced390a0c292e8103afdf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b16bc7be372c9270121d278858a672f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8b16bc7be372c9270121d278858a672f">ExcValueDoesNotMatchPattern</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga8b16bc7be372c9270121d278858a672f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9213c9ff33bbb3d167b67fa890a6d9ce"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9213c9ff33bbb3d167b67fa890a6d9ce">ExcAlreadyAtTopLevel</a> ()</td></tr>
<tr class="separator:ga9213c9ff33bbb3d167b67fa890a6d9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab8cc9a7fa6a9c6114a207b795007d5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga2ab8cc9a7fa6a9c6114a207b795007d5">ExcEntryUndeclared</a> (std::string arg1)</td></tr>
<tr class="separator:ga2ab8cc9a7fa6a9c6114a207b795007d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a05434eefbd2de0314b0a483247d96d"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0a05434eefbd2de0314b0a483247d96d">ExcUnbalancedSubsections</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga0a05434eefbd2de0314b0a483247d96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8136031b245c5a29ddac3940090f0ac"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad8136031b245c5a29ddac3940090f0ac">ExcNoSubsection</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gad8136031b245c5a29ddac3940090f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa620e44b3aa3cf356feaa424a516086e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa620e44b3aa3cf356feaa424a516086e">ExcCannotParseLine</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gaa620e44b3aa3cf356feaa424a516086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3cb505bbdd65d21ef66e3ef7e383bab"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad3cb505bbdd65d21ef66e3ef7e383bab">ExcInvalidEntryForPattern</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3, std::string arg4, std::string arg5)</td></tr>
<tr class="separator:gad3cb505bbdd65d21ef66e3ef7e383bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43bb6588e469c2e12a430fb7ea316da1"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga43bb6588e469c2e12a430fb7ea316da1">ExcInvalidXMLParameterFile</a> ()</td></tr>
<tr class="separator:ga43bb6588e469c2e12a430fb7ea316da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2febc2a5dd0328f971093085bf9b4fa"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2febc2a5dd0328f971093085bf9b4fa">ExcCannotOpenIncludeStatementFile</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac2febc2a5dd0328f971093085bf9b4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a309a5cd29993c8070462ec3ac70564cc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a309a5cd29993c8070462ec3ac70564cc">get_current_path</a> () const</td></tr>
<tr class="separator:a309a5cd29993c8070462ec3ac70564cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae05819ce1de5de30ad92322fc8fc8da"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aae05819ce1de5de30ad92322fc8fc8da">get_current_full_path</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:aae05819ce1de5de30ad92322fc8fc8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d7994d250bf62a83a4c3e119e8e1dd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a74d7994d250bf62a83a4c3e119e8e1dd">get_current_full_path</a> (const std::vector&lt; std::string &gt; &amp;sub_path, const std::string &amp;name) const</td></tr>
<tr class="separator:a74d7994d250bf62a83a4c3e119e8e1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bdedef2bd8e6a1fe405a92c4d19590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae9bdedef2bd8e6a1fe405a92c4d19590">scan_line</a> (std::string line, const std::string &amp;input_filename, const unsigned <a class="el" href="classint.html">int</a> current_line_n, const <a class="el" href="classbool.html">bool</a> skip_undefined)</td></tr>
<tr class="separator:ae9bdedef2bd8e6a1fe405a92c4d19590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acc4642bfc38ec36b4927eb520661db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a4acc4642bfc38ec36b4927eb520661db">recursively_print_parameters</a> (const boost::property_tree::ptree &amp;tree, const std::vector&lt; std::string &gt; &amp;target_subsection_path, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a> style, const unsigned <a class="el" href="classint.html">int</a> indent_level, std::ostream &amp;out) const</td></tr>
<tr class="separator:a4acc4642bfc38ec36b4927eb520661db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aefa5b69fc4d1d56dd6bc90e2dcf24d56"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aefa5b69fc4d1d56dd6bc90e2dcf24d56">subsection_path</a></td></tr>
<tr class="separator:aefa5b69fc4d1d56dd6bc90e2dcf24d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c753f43844f2c1196d4ef939048bb0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; boost::property_tree::ptree &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae3c753f43844f2c1196d4ef939048bb0">entries</a></td></tr>
<tr class="separator:ae3c753f43844f2c1196d4ef939048bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad871495dd6e1c35e2d36ecb3f66a53a"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::pair&lt; <a class="el" href="classbool.html">bool</a>, <a class="el" href="classbool.html">bool</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aad871495dd6e1c35e2d36ecb3f66a53a">entries_set_status</a></td></tr>
<tr class="separator:aad871495dd6e1c35e2d36ecb3f66a53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caa993b840f2e2d76fcfd7b94cbc799"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a3caa993b840f2e2d76fcfd7b94cbc799">patterns</a></td></tr>
<tr class="separator:a3caa993b840f2e2d76fcfd7b94cbc799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45eff738f43667037e3e59be30f04b0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::function&lt; void(const std::string &amp;)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ad45eff738f43667037e3e59be30f04b0">actions</a></td></tr>
<tr class="separator:ad45eff738f43667037e3e59be30f04b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a009fb8cb45463ac3a57f8cb371fbc82b"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a009fb8cb45463ac3a57f8cb371fbc82b">path_separator</a> = '.'</td></tr>
<tr class="separator:a009fb8cb45463ac3a57f8cb371fbc82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6cb3efd46790a1d4b58f5ffe7bb66c06"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6cb3efd46790a1d4b58f5ffe7bb66c06">MultipleParameterLoop</a></td></tr>
<tr class="separator:a6cb3efd46790a1d4b58f5ffe7bb66c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ParameterHandler类为输入文件提供了一个标准接口，该文件在运行时提供了程序参数，如时间步长、几何尺寸、右手边等。程序的输入是以文件、流或内存中的字符串的形式给出的，使用的文本包括 </p><div class="fragment"><div class="line"><span class="keyword">set</span> Time step size = 0.3</div><div class="line">set Geometry       = [0,1]x[0,3]</div></div><!-- fragment --><p> 输入可以被排序为分节树，以便给输入一个逻辑结构，输入文件可以包括其他文件。 ParameterHandler类在 <a class="el" href="step_29.html">step-29</a> , <a class="el" href="step_33.html">step-33</a> , 和 <a class="el" href="step_34.html">step-34</a> 中讨论。 </p><h3>Declaring entries</h3>
<p>为了使用ParameterHandler对象的设施，首先必须知道输入文件可能包含或不包含的不同条目。这可以通过以下方式完成。 </p><div class="fragment"><div class="line">...</div><div class="line">ParameterHandler prm;</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Time step size&quot;</span>,</div><div class="line">                   <span class="stringliteral">&quot;0.2&quot;</span>,</div><div class="line">                   <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(),</div><div class="line">                   <span class="stringliteral">&quot;Some documentation&quot;</span>);</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Geometry&quot;</span>,</div><div class="line">                   <span class="stringliteral">&quot;[0,1]x[0,1]&quot;</span>,</div><div class="line">                   <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>());</div><div class="line">...</div></div><!-- fragment --><p> 每个条目都要用函数 <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a>来声明。第一个参数是条目的名称（简而言之：条目）。第二个参数是在输入文件中没有指定条目时要采取的默认答案。第三个参数是一个正则表达式，输入（和默认答案）必须与之匹配。 Patterns中定义了几个这样的正则表达式。这个参数可以省略，在这种情况下，它将默认为 <a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>, ，即一个匹配每个输入字符串的模式。第四个参数可用于记录条目的意图或预期格式；在使用print_parameters()函数编写ParameterHandler对象的所有条目时，其值将作为注释打印出来，以便更容易理解参数文件。它也可以被省略，在这种情况下，将不会打印这样的文件。 条目可以位于子节中，形成一种输入树。例如，线性求解程序的输入参数应该被分类在一个名为<code>线性求解器</code>或任何其他合适名称的小节中。这可以通过以下方式实现。</p>
<div class="fragment"><div class="line">...</div><div class="line">LinEq eq;</div><div class="line">eq.declare_parameters (prm);</div><div class="line">...</div><div class="line"></div><div class="line">void LinEq::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Solver&quot;</span>,</div><div class="line">                     <span class="stringliteral">&quot;CG&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;CG|GMRES|GaussElim&quot;</span>),</div><div class="line">                     <span class="stringliteral">&quot;Name of a linear solver for the inner iteration&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Maximum number of iterations&quot;</span>, <span class="stringliteral">&quot;20&quot;</span>,</div><div class="line">                     ParameterHandler::RegularExpressions::Integer());</div><div class="line">  ...</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><p>分节可以是嵌套的。例如，一个非线性求解器可能有一个线性求解器作为成员对象。那么函数调用树会是这样的（如果类<code>NonLinEq</code>有一个成员变量<code>eq</code>类型<code>LinEq</code>）。 </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> NonLinEq::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Nonlinear method&quot;</span>,</div><div class="line">                     <span class="stringliteral">&quot;Newton-Raphson&quot;</span>,</div><div class="line">                     ParameterHandler::RegularExpressions::Anything());</div><div class="line">  eq.declare_parameters (prm);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><p>对于声明不同条目的类成员函数，我们建议使用通用名称<code>declare_parameters</code>。在一般情况下，这个方法可以是<code>静态的</code>，因为这些条目将不依赖于任何先前的知识。那些条目在逻辑上应该被分组为子段的类应该自己声明这些子段。如果一个类有两个或更多相同类型的成员变量，它们都应该有自己的参数，这个父类的方法<code>declare_parameters</code>负责将它们归入不同的子段。</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> NonLinEq::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver 1&quot;</span>);</div><div class="line">  {</div><div class="line">    eq1.declare_parameters (prm);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver 2&quot;</span>);</div><div class="line">  {</div><div class="line">    eq2.declare_parameters (prm);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><h3>Input files and special characters</h3>
<p>对于上面的第一个例子，输入文件将看起来像下面这样。 </p><div class="fragment"><div class="line">...</div><div class="line">subsection Nonlinear solver</div><div class="line">  <span class="keyword">set</span> Nonlinear method = Gradient</div><div class="line"><span class="preprocessor">  # this is a comment</span></div><div class="line">  subsection Linear solver</div><div class="line">    <span class="keyword">set</span> Solver                       = CG</div><div class="line">    <span class="keyword">set</span> Maximum number of iterations = 30</div><div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line">...                       # other stuff</div></div><!-- fragment --><p> <code>subsection</code>, <code>set</code>和<code>end</code>这些词可以用小写字母或大写字母书写。前面和后面的空白被删除，多个空白被浓缩成一个。由于后者也适用于条目的名称，如果在声明中使用了多个空白，条目名称将无法被识别。 在条目名称和值中，不允许使用以下字符。<code>#</code>, <code>{</code>, <code>}</code>, <code>|</code>. 它们的使用是为MultipleParameterLoop类保留的。 以#开头的注释被跳过。 通过字符<code>\</code>允许续行，该字符必须是该行的最后一个字符（除了空白处，空白处被忽略）。当一行是续行时（即前一行以<code>&lt;/tt&gt;结束），那么，与<code>C</code>预处理器的默认行为不同，该行开头的所有空白都被忽略了。 我们建议使用以下方案来命名条目：第一个词用大写字母开头，以后用小写字母。这同样适用于<code>=</code>符号右边的可能条目值。</code></p>
<p><code> </p><h3>Including other input files</h3>
<p></code></p>
<p><code> 一个输入文件可以包括其他包含文件，使用的语法是 </p><div class="fragment"><div class="line">...</div><div class="line">include some_other_file.prm</div><div class="line">...</div></div><!-- fragment --><p> 这样引用的文件是相对于当前目录搜索的（不是相对于包含参数文件所在的目录搜索的，因为这不是所有三个版本的parse_input()函数都知道的）。</code></p>
<p><code> </p><h3>Reading data from input sources</h3>
<p></code></p>
<p><code> 为了读取输入，有三种可能性：从一个 <code>std::istream</code> 对象中读取，从一个给定名称的文件中读取，以及从内存中的字符串中读取，其中各行由<code> \n</code> 字符分隔。这些可能性的使用情况如下。 </p><div class="fragment"><div class="line"><a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">...</div><div class="line"><span class="comment">// declaration of entries</span></div><div class="line">...</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a> (std::cin); <span class="comment">// read input from standard in,</span></div><div class="line"><span class="comment">// or</span></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a> (<span class="stringliteral">&quot;simulation.prm&quot;</span>);</div><div class="line"><span class="comment">// or</span></div><div class="line">charin = <span class="stringliteral">&quot;set Time step size = 0.3 \n ...&quot;</span>;</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a79bb8b2735fb7e9980ec73ff7b489f7f">parse_input_from_string</a> (in);</div><div class="line">...</div></div><!-- fragment --><p> 你可以连续使用几个输入源。被改变一次以上的条目在每次使用时都会被覆盖。 你不应该在使用parse_input()后，试图用 <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a>和 <a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection()</a>来声明条目，并使用尚不清楚的分段名称。这种情况下的结果是不明确的。 如果在读取输入时发生错误，错误信息将被写入 <code>std::cerr</code> ，并且阅读器函数的返回值为 <code>false</code> 。这与deal.II中几乎所有的其他函数相反，如果发生错误，通常会抛出一个异常；这种行为上的差异是一个遗留问题，即这个类在deal.II之前就已经存在，而且之前是为一个不同的项目编写的。</code></p>
<p><code> </p><h3>Using the ParameterHandler Graphical User Interface</h3>
<p></code></p>
<p><code> 除了使用上面显示的手写输入文件外，还有一种方法是使用伴随这个类的图形用户界面（GUI）。 更多细节见<a href="https://github.com/dealii/parameter_gui">the parameter_gui github repository</a>。 </p><h3>Getting entry values out of a ParameterHandler object</h3>
<p></code></p>
<p><code> 每个类通过调用get()成员函数，从ParameterHandler对象中获取数据，比如这样。 </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> NonLinEq::get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Nonlinear solver&quot;</span>);</div><div class="line">  std::string method = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Nonlinear method&quot;</span>);</div><div class="line">  eq.get_parameters (prm);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><p> <a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get()</a>返回给定条目的值。如果输入源中没有指定该条目，则返回默认值。你必须完全按照你在声明子段时的做法来输入和离开子段。你可以选择遍历子树的顺序。 可以通过向get()提供一个代表获取值的路径的字符串向量来避免对enter_subsection()和leave_subsection()的调用。例如，以下两个版本的get_parameters()将产生相同的结果。 </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> NonLinEq::get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 1 Settings&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">  solver_ = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Solver&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div></div><!-- fragment --><p></code></p>
<p><code></p><div class="fragment"><div class="line"><span class="keywordtype">void</span> NonLinEq::get_parameters (<span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  std::vector&lt;std::string&gt; path =</div><div class="line">    {<span class="stringliteral">&quot;Equation 1 Settings&quot;</span>, <span class="stringliteral">&quot;Linear solver&quot;</span>};</div><div class="line">  solver_ = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (path, <span class="stringliteral">&quot;Solver&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p></code></p>
<p><code>后一种方法允许ParameterHandler的引用是 <code>const</code>. 。 保证只返回与给定的正则表达式相匹配的条目，也就是说，不符合正则表达式的输入条目值不会被存储。 你可以使用get()来检索文本形式的参数，使用get_integer()来获得一个整数，或者使用get_double()来获得一个双数。你也可以使用get_bool()。如果字符串不能被转换为整数、双数或布尔，它将导致一个内部错误。不过，如果你为这个条目正确地指定了正则表达式，这就不应该发生；你不应该试图从一个没有设置相应正则表达式的条目中得到一个整数或双数。内部错误是通过Assert()宏程序提出的，它只在调试模式下工作。 如果你想打印出所有用户可选择的特征，请使用print_parameters()函数。一般来说，在日志文件的开头打印所有的参数是一个好主意，因为这样输入和输出都在一个文件中，这使得以后的匹配更加容易。此外，该函数也会打印那些在输入文件中没有被修改，因而被设置为默认值的条目；由于默认值在程序开发过程中可能会改变，所以你无法知道输入文件中没有指定的参数值。</code></p>
<p><code></p><h3>Adding Actions to Parameters</h3>
<p></code></p>
<p><code> 在读取一个参数值的时候，通常会有一些事情发生，这很方便。这可以是检查它是否有效</code></p>
<p><code>例如，在参数文件中列出的一个文件是否存在</code></p>
<p><code>或者启动其他的响应，比如在ParameterHandler之外设置一个变量（如下图所示的例子）。在几乎所有的情况下，这个 "动作
"也可以在通过parse_input()读取所有参数后启动，但有时<em>convenient</em>会马上进行。 <a class="el" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action()</a>函数可以在通过declare_entry()声明一个参数后调用，这就方便了。"动作
"实质上是指向将为具有相关动作的参数调用的函数的指针。这些函数把参数的值作为参数，然后可以对它做任何事情</code></p>
<p><code>例如，将其保存在ParameterHandler对象之外的某个地方。(具体什么时候调用动作，在add_action()函数的文档里有描述)。当然，在C++中，我们通常不会传递一个函数的地址，但是一个动作可以是一个类似于函数的对象（接受一个字符串作为参数），这个对象是通过调用诸如<a href="http://en.cppreference.com/w/cpp/language/lambda">lambda function</a>的形式产生的。</code></p>
<p><code></p><div class="fragment"><div class="line">[] (<span class="keyword">const</span> std::string &amp;<a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>) { ... <span class="keywordflow">do</span> something with the <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a> ... }</div></div><!-- fragment --><p> 并且附在一个特定的参数上。 这种行为的一个典型例子如下：假设你有一个程序，它声明了一个参数，表示它要运行的迭代次数，例如</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="keyword">class </span>MyAlgorithm</div><div class="line">{</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a> ();</div><div class="line">   <span class="keyword">private</span>:</div><div class="line">     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations;</div><div class="line">};</div></div><!-- fragment --><p> 那么人们可以使用 <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> 中的代码片段从参数文件中获得这个参数，如下所示。</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MyAlgorithm::run</a> ()</div><div class="line">{</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Number of iterations&quot;</span>,  <span class="comment">// name of parameter</span></div><div class="line">                     <span class="stringliteral">&quot;10&quot;</span>,                    <span class="comment">// default value</span></div><div class="line">                     <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1,100),<span class="comment">// allowed values: 1...100</span></div><div class="line">                     <span class="stringliteral">&quot;The number of ...&quot;</span>);    <span class="comment">// some documentation</span></div><div class="line"></div><div class="line">  <span class="comment">// next read the parameter from an input file...</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a> (<span class="stringliteral">&quot;my_algorithm.prm&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// ...and finally get the value for use in the program:</span></div><div class="line">  n_iterations = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Number of iterations&quot;</span>);</div><div class="line"></div><div class="line">  ... actual code doing something useful follows here...</div></div><!-- fragment --><p></code></p>
<p><code>这个两步过程</code></p>
<p><code></p><ul>
<li>首先声明参数，然后再读取它</li>
<li>有点麻烦，因为必须先声明<em>all</em>参数，以后再从ParameterHandler对象中检索参数。在大型程序中，这两件事也经常发生在不同的函数中。 为了避免这种情况，如果我们能把声明和检索都放在同一个地方就好了。这可以通过动作来实现，然后函数会看起来像这样。</li>
</ul>
<p></code></p>
<p><code></p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MyAlgorithm::run</a> ()</div><div class="line">{</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Number of iterations&quot;</span>,  <span class="comment">// name of parameter</span></div><div class="line">                     <span class="stringliteral">&quot;10&quot;</span>,                    <span class="comment">// default value</span></div><div class="line">                     <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1,100),<span class="comment">// allowed values: 1...100</span></div><div class="line">                     <span class="stringliteral">&quot;The number of ...&quot;</span>);    <span class="comment">// some documentation</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action</a> (<span class="stringliteral">&quot;Number of iterations&quot;</span>,</div><div class="line">                  [&amp;](<span class="keyword">const</span> std::string &amp;value)</div><div class="line">                  {</div><div class="line">                    this-&gt;n_iterations = <a class="code" href="namespaceUtilities.html#af7e8ff146c677d8a2408b88e4936f57d">Utilities::string_to_int</a>(value);</div><div class="line">                  });</div><div class="line"></div><div class="line">  <span class="comment">// next read the parameter from an input file...</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a> (<span class="stringliteral">&quot;my_algorithm.prm&quot;</span>);</div><div class="line"></div><div class="line">  ... actual code doing something useful follows here...</div></div><!-- fragment --><p> 这里，动作由一个lambda函数组成，它将这个参数的值作为一个字符串，然后将其转换为一个整数，存储在它所属的变量中。这个动作是在调用 <code>prm.parse_input()</code> 时执行的，所以现在不再需要在以后提取参数的值。此外，设置成员变量的代码就在实际声明参数的地方旁边，所以我们不再需要在代码库中设置两个单独的部分来处理输入参数。 当然，我们有可能执行比上面所示的设置成员变量更多的动作，尽管这只是一个典型的案例。</code></p>
<p><code> </p><h3>Style guide for data retrieval</h3>
<p></code></p>
<p><code> 我们建议每个从ParameterHandler对象中获取数据的类都提供一个名为<code>get_parameters</code>的函数。这应该被声明为<code>虚拟的</code>。派生类中的<code>get_parameters</code>函数应该调用 <code>BaseClass::get_parameters</code> 函数。</code></p>
<p><code> </p><h3>Experience with large parameter lists</h3>
<p></code></p>
<p><code> 经验表明，在定义大量参数的程序中（例如超过50个），定义一个额外的类来保存这些参数是有利的。这个类更像一个C风格的结构，有大量的变量，通常是公共变量。然后它至少有两个函数，用来声明和解析参数。在主程序中，主类有一个这个参数类的对象，并将参数的声明和解析委托给这个对象。 这种方法的好处是，你可以不把技术细节（声明和解析）放在主类之外，另外也不用用几十个或更多的变量来表示参数，使你的主类变得混乱。</code></p>
<p><code></p><h3>Worked Example</h3>
<p></code></p>
<p><code> 这就是代码。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"><span class="keyword">class </span>LinearEquation</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">  <span class="keywordtype">void</span> get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::string method;</div><div class="line">  <span class="keywordtype">int</span>         max_iterations;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>Problem</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  LinearEquation eq1, eq2;</div><div class="line">  std::string matrix1, matrix2;</div><div class="line">  std::string outfile;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">  <span class="keywordtype">void</span> get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> do_something ();</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LinearEquation::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  <span class="comment">// declare parameters for the linear solver in a subsection</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Solver&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;CG&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;CG|BiCGStab|GMRES&quot;</span>),</div><div class="line">                       <span class="stringliteral">&quot;Name of a linear solver for the inner iteration&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Maximum number of iterations&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;20&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>());</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> LinearEquation::get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Linear solver&quot;</span>);</div><div class="line">  {</div><div class="line">    method         = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Solver&quot;</span>);</div><div class="line">    max_iterations = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (<span class="stringliteral">&quot;Maximum number of iterations&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  LinearEquation: method=&quot;</span> &lt;&lt; method</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;, max_iterations=&quot;</span> &lt;&lt; max_iterations</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Problem::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  <span class="comment">// first some global parameter entries</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (</div><div class="line">    <span class="stringliteral">&quot;Output file&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;out&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">    <span class="stringliteral">&quot;Name of the output file, either relative or absolute&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Equation 1&quot;</span>, <span class="stringliteral">&quot;Laplace&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                     <span class="stringliteral">&quot;String identifying the equation we want to solve&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Equation 2&quot;</span>,</div><div class="line">                     <span class="stringliteral">&quot;Elasticity&quot;</span>,</div><div class="line">                     <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>());</div><div class="line"></div><div class="line">  <span class="comment">// declare parameters for the first equation</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 1 Settings&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;Sparse&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;Full|Sparse|Diagonal&quot;</span>),</div><div class="line">                       <span class="stringliteral">&quot;Type of the matrix to be used, either full, &quot;</span></div><div class="line">                       <span class="stringliteral">&quot;sparse, or diagonal&quot;</span>);</div><div class="line">    LinearEquation::declare_parameters (prm);  <span class="comment">// for eq1</span></div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">  <span class="comment">// declare parameters for the second equation</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 2 Settings&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>,</div><div class="line">                       <span class="stringliteral">&quot;Sparse&quot;</span>,</div><div class="line">                       <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;Full|Sparse|Diagonal&quot;</span>));</div><div class="line">    LinearEquation::declare_parameters (prm);  <span class="comment">// for eq2</span></div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Problem::get_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  <span class="comment">// entries of the problem class</span></div><div class="line">  outfile = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Output file&quot;</span>);</div><div class="line">  std::string equation1 = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Equation 1&quot;</span>),</div><div class="line">              equation2 = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Equation 2&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// get parameters for the first equation</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 1 Settings&quot;</span>);</div><div class="line">  {</div><div class="line">    matrix1 = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>);</div><div class="line">    eq1.get_parameters (prm); <span class="comment">// for eq1</span></div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line"></div><div class="line">  <span class="comment">// get parameters for the second equation</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Equation 2 Settings&quot;</span>);</div><div class="line">  {</div><div class="line">    matrix2 = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (<span class="stringliteral">&quot;Matrix type&quot;</span>);</div><div class="line">    eq2.get_parameters (prm); <span class="comment">// for eq2</span></div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div><div class="line">  std::cout</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;  Problem: outfile=&quot;</span> &lt;&lt; outfile &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;           eq1=&quot;</span>     &lt;&lt; equation1 &lt;&lt; <span class="stringliteral">&quot;, eq2=&quot;</span> &lt;&lt; equation2 &lt;&lt; <span class="charliteral">&#39;\n&#39;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;           matrix1=&quot;</span> &lt;&lt; matrix1 &lt;&lt; <span class="stringliteral">&quot;, matrix2=&quot;</span> &lt;&lt; matrix2</div><div class="line">    &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Problem::do_something ()</div><div class="line">{</div><div class="line">  <span class="comment">// While this example does nothing here, at this point in the program</span></div><div class="line">  <span class="comment">// all of the parameters are known so we can start doing computations.</span></div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">  Problem p;</div><div class="line">  p.declare_parameters (prm);</div><div class="line">  <span class="comment">// read input from &quot;prmtest.prm&quot;; giving argv[1] would also be a</span></div><div class="line">  <span class="comment">// good idea</span></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a> (<span class="stringliteral">&quot;prmtest.prm&quot;</span>);</div><div class="line">  <span class="comment">// print parameters to std::cout as ASCII text</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a> (std::cout, <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div><div class="line">  <span class="comment">// get parameters into the program</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span> &lt;&lt; <span class="stringliteral">&quot;Getting parameters:&quot;</span> &lt;&lt; std::endl;</div><div class="line">  p.get_parameters (prm);</div><div class="line">  <span class="comment">// now run the program with these input parameters</span></div><div class="line">  p.do_something ();</div><div class="line">}</div></div><!-- fragment --><p></code></p>
<p><code> 这是输入文件（名为 "prmtest.prm"）。 </p><div class="fragment"><div class="line"><span class="preprocessor"># first declare the types of equations</span></div><div class="line"><span class="keyword">set</span> Equation 1 = Poisson</div><div class="line"><span class="keyword">set</span> Equation 2 = Stokes</div><div class="line"></div><div class="line">subsection Equation 1 <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a></div><div class="line">  <span class="keyword">set</span> Matrix type = Sparse</div><div class="line">  subsection Linear solver # parameters <span class="keywordflow">for</span> linear solver 1</div><div class="line">    <span class="keyword">set</span> Solver                       = Gauss-Seidel</div><div class="line">    <span class="keyword">set</span> Maximum number of iterations = 40</div><div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"></div><div class="line">subsection Equation 2 <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a></div><div class="line">  <span class="keyword">set</span> Matrix type = Full</div><div class="line">  subsection Linear solver</div><div class="line">    <span class="keyword">set</span> Solver                       = CG</div><div class="line">    <span class="keyword">set</span> Maximum number of iterations = 100</div><div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div></div><!-- fragment --><p></code></p>
<p><code>这里是程序的输出。 </p><div class="fragment"><div class="line">Line &lt;8&gt; of file &lt;prmtest.prm&gt;:</div><div class="line">    The entry value</div><div class="line">        Gauss-Seidel</div><div class="line">    <span class="keywordflow">for</span> the entry named</div><div class="line">        Solver</div><div class="line">    does not match the given pattern</div><div class="line">        [Selection CG|BiCGStab|GMRES ]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor"># Listing of Parameters</span></div><div class="line"><span class="preprocessor">#</span></div><div class="line"></div><div class="line">---------------------</div><div class="line"><span class="preprocessor"># String identifying the equation we want to solve</span></div><div class="line"><span class="keyword">set</span> Equation 1  = Poisson # <span class="keywordflow">default</span>: Laplace</div><div class="line"><span class="keyword">set</span> Equation 2  = Stokes  # <span class="keywordflow">default</span>: Elasticity</div><div class="line"></div><div class="line"><span class="preprocessor"># Name of the output file, either relative to the present path or absolute</span></div><div class="line"><span class="keyword">set</span> Output file = out</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">subsection Equation 1 <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a></div><div class="line"><span class="preprocessor">  # Type of the matrix to be used, either full, sparse, or diagonal</span></div><div class="line">  <span class="keyword">set</span> Matrix type = Sparse</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  subsection Linear solver</div><div class="line">    <span class="keyword">set</span> Maximum number of iterations = 40 # <span class="keywordflow">default</span>: 20</div><div class="line"><span class="preprocessor">    # Name of a linear solver for the inner iteration</span></div><div class="line">    <span class="keyword">set</span> Solver                       = CG</div><div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"></div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">subsection Equation 2 <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a></div><div class="line">  <span class="keyword">set</span> Matrix type = Full # <span class="keywordflow">default</span>: Sparse</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  subsection Linear solver</div><div class="line">    <span class="keyword">set</span> Maximum number of iterations = 100 # <span class="keywordflow">default</span>: 20</div><div class="line"><span class="preprocessor">    # Name of a linear solver for the inner iteration</span></div><div class="line">    <span class="keyword">set</span> Solver                       = CG</div><div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"></div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">Getting parameters:</div><div class="line">  LinearEquation: method=CG, max_iterations=40</div><div class="line">  LinearEquation: method=CG, max_iterations=100</div><div class="line">  Problem: outfile=out</div><div class="line">           eq1=Poisson, eq2=Stokes</div><div class="line">           matrix1=Sparse, matrix2=Full</div></div><!-- fragment --><p></code></p>
<p><code> </p><h3>Representation of Parameters</h3>
<p></code></p>
<p><code> 下面是一些关于参数表示法的更多内部信息。 从逻辑上讲，参数和它们所排列的嵌套部分可以被认为是一个分层的目录结构，或者说是一棵树。以下面的代码为例，它声明了一组参数和它们所在的部分。 </p><div class="fragment"><div class="line"><a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line"></div><div class="line">prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (<span class="stringliteral">&quot;Maximal number of iterations&quot;</span>,</div><div class="line">                   <span class="stringliteral">&quot;10&quot;</span>,</div><div class="line">                   <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a> (1, 1000),</div><div class="line">                   <span class="stringliteral">&quot;A parameter that describes the maximal number of &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;iterations the CG method is to take before giving &quot;</span></div><div class="line">                   <span class="stringliteral">&quot;up on a matrix.&quot;</span>);</div><div class="line">prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (<span class="stringliteral">&quot;Preconditioner&quot;</span>);</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;Kind&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;SSOR&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a> (<span class="stringliteral">&quot;SSOR|Jacobi&quot;</span>),</div><div class="line">    <span class="stringliteral">&quot;A string that describes the kind of preconditioner to use.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;Relaxation factor&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;1.0&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a> (0, 1),</div><div class="line">    <span class="stringliteral">&quot;The numerical value (between zero and one) for the &quot;</span></div><div class="line">    <span class="stringliteral">&quot;relaxation factor to use in the preconditioner.&quot;</span>);</div><div class="line">}</div><div class="line">prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ();</div></div><!-- fragment --><p></code></p>
<p><code>我们可以把这样安排的参数看作一个文件系统，其中每个参数都是一个目录。这个目录的名称是参数的名称，在这个目录中存在着描述参数的文件。在编写本文档时，这些文件是（其他字段，如表示 "行动 "的字段也可能存在于每个目录中）。</code></p>
<p><code></p><ul>
<li><code>value</code> : 这个文件的内容是这个参数的当前值；最初，这个文件的内容等于参数的默认值。</li>
<li><code>default_value</code> : 这个文件的内容是该参数的默认值。</li>
<li><code>pattern</code> : 描述参数可能值的模式的文字表述。</li>
<li><code>pattern_index</code> : 一个索引 <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> 对象的数字，该对象用于描述该参数。</li>
<li><code>documentation</code> : 这个文件的内容是为作为 <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">ParameterHandler::declare_entry</a> 调用的最后一个参数的参数提供的文件。除了 <code>value</code> 文件外，文件的内容在声明一个参数后永远不会改变。 另外，这个文件系统中的一个目录可能没有一个叫做 <code>value</code> 的文件在里面。在这种情况下，该目录代表上面声明的一个分节，目录的名称将与分节的名称相对应。然后，它里面根本没有文件，但它可能有更多的目录：其中一些目录将是参数（通过文件的存在表示）或进一步嵌套的子节。 鉴于这种解释，上面的代码将导致数据的分层表示，看起来像这样（文件的内容在右边用不同的字体表示）。 <div class="image">
<img src="parameter_handler.png" alt="parameter_handler.png"/>
</div>
 一旦参数被读入， <code>value</code> "文件
"的内容可能会有所不同，而其他文件则保持不动。 使用 <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">ParameterHandler::print_parameters()</a> 函数，将 <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510">ParameterHandler::XML</a> 作为第二个参数，我们可以得到这个数据结构在XML中的完整表示。它将看起来像这样。 <div class="fragment"><div class="line">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> encoding=<span class="stringliteral">&quot;utf-8&quot;</span>?&gt;</div><div class="line">&lt;<a class="code" href="classParameterHandler.html">ParameterHandler</a>&gt;</div><div class="line">  &lt;Maximal_20number_20of_20iterations&gt;</div><div class="line">    &lt;value&gt;10&lt;/value&gt;</div><div class="line">    &lt;default_value&gt;10&lt;/default_value&gt;</div><div class="line">    &lt;documentation&gt;</div><div class="line">      A parameter that describes the maximal number of iterations the CG</div><div class="line">      method is to take before giving up on a <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>.</div><div class="line">    &lt;/documentation&gt;</div><div class="line">    &lt;pattern&gt;0&lt;/pattern&gt;</div><div class="line">    &lt;pattern_description&gt;</div><div class="line">      [Integer range 1...1000 (inclusive)]</div><div class="line">    &lt;/pattern_description&gt;</div><div class="line">  &lt;/Maximal_20number_20of_20iterations&gt;</div><div class="line">  &lt;Preconditioner&gt;</div><div class="line">    &lt;Kind&gt;&lt;value&gt;SSOR&lt;/value&gt;</div><div class="line">      &lt;default_value&gt;SSOR&lt;/default_value&gt;</div><div class="line">      &lt;documentation&gt;</div><div class="line">        A <span class="keywordtype">string</span> that describes the kind of preconditioner to use.</div><div class="line">      &lt;/documentation&gt;</div><div class="line">      &lt;pattern&gt;1&lt;/pattern&gt;</div><div class="line">      &lt;pattern_description&gt;SSOR|Jacobi&lt;/pattern_description&gt;</div><div class="line">    &lt;/Kind&gt;</div><div class="line">    &lt;Relaxation_20factor&gt;</div><div class="line">      &lt;value&gt;1.0&lt;/value&gt;</div><div class="line">      &lt;default_value&gt;1.0&lt;/default_value&gt;</div><div class="line">      &lt;documentation&gt;</div><div class="line">        The numerical value (between <a class="code" href="namespaceLAPACKSupport.html#a0d8802698d585eec62a2a54e6387b05b">zero</a> and <a class="code" href="namespaceLAPACKSupport.html#aceda56512460bbad2f9fdb8a3d0e1e51">one</a>) <span class="keywordflow">for</span> the relaxation</div><div class="line">        factor to use in the preconditioner.</div><div class="line">      &lt;/documentation&gt;</div><div class="line">      &lt;pattern&gt;2&lt;/pattern&gt;</div><div class="line">      &lt;pattern_description&gt;</div><div class="line">        [Floating <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> range 0...1 (inclusive)]</div><div class="line">      &lt;/pattern_description&gt;</div><div class="line">    &lt;/Relaxation_20factor&gt;</div><div class="line">  &lt;/Preconditioner&gt;</div><div class="line">&lt;<a class="code" href="classParameterHandler.html">ParameterHandler</a>&gt;</div></div><!-- fragment --> 这种表示法与上面讨论的目录/文件结构非常相似。唯一不同的是，目录和文件名被篡改了：因为它们应该只包含字母和数字，所以它们名称中每一个不是字母或数字的字符都被下划线替换，后面是其两位数的十六进制表示。此外，特殊名称 "value
"在用作参数名称时也会被处理，因为这个名称也用于命名层次结构中的特殊文件。最后，整个树被包装成一个标签 <code>ParameterHandler</code> ，以满足XML的要求，即每个文件中只有一个顶级结构。 树状结构（及其XML表示）是图形用户界面（见上文）用来表示目录/文件集合等参数的。 </li>
</ul>
<p></code></p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l00715">715</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a8364dda711b93753c6809eefe2a8e827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8364dda711b93753c6809eefe2a8e827">&#9670;&nbsp;</a></span>OutputStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用于 <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">ParameterHandler::print_parameters()</a>. 等函数的可能输出格式列表 选项可分为两组。</p>
<ul>
<li>格式选项。PRM, LaTeX, Description, XML, JSON</li>
<li>文体选项。Short, KeepDeclarationOrder 每次只能指定一个格式选项。任何接受OutputStyle作为选项的函数，如果你指定了一个以上的选项，就会抛出。 我们提供了一些常用选项组合的快捷方式。 例如，ShortPRM以PRM格式打印参数，同时跳过文档。 </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48"></a>DefaultStyle&#160;</td><td class="fielddoc"><p>默认文体风格：打印文档，并按字母顺序排列所有参数。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f"></a>Short&#160;</td><td class="fielddoc"><p>为ParameterHandler写输入，没有注释或改变默认值。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a50ae66aa378db81bb360ce7cdf96e3e1"></a>KeepDeclarationOrder&#160;</td><td class="fielddoc"><p>保持参数的顺序，因为它们已经被声明了。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a9b48379ffc293bc0a49b7aa342dbc9bf"></a>PRM&#160;</td><td class="fielddoc"><p>编写适合由 <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> 再次读取的人类可读输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365"></a>Text&#160;</td><td class="fielddoc"><p>写出适合由 <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> 再次读取的人类可读输出。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>使用<code>PRM</code>而不是<code>Text</code>。</dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a3b5d289d79f36e819a7bd0d81a52ee37"></a>LaTeX&#160;</td><td class="fielddoc"><p>将参数写成LaTeX表格。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a5ed7026d01b66b89ee3c1aef3efbfd4a"></a>Description&#160;</td><td class="fielddoc"><p>写出声明的参数与描述和可能的值。 </p><dl class="section note"><dt>Note</dt><dd>这种格式不适合再读回来。 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510"></a>XML&#160;</td><td class="fielddoc"><p>将所有内容写成一个<a href="http://en.wikipedia.org/wiki/XML">XML</a>的文件，适合由 <a class="el" href="classParameterHandler.html#a12e7edb2a86419b76f4a1b69dfdd873a">ParameterHandler::parse_input_from_xml()</a> 再次读取。 关于输出的例子，请看这个类的一般文档。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a456d0f94d7d72f33234d02a8b2e9030c"></a>JSON&#160;</td><td class="fielddoc"><p>把所有的东西都写成一个<a href="http://en.wikipedia.org/wiki/JSON">JSON</a>文件，适合由 <a class="el" href="classParameterHandler.html#afb4afb8f5cc2451fb16be1fff32b4380">ParameterHandler::parse_input_from_json()</a> 再次读取。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827aadc1ef9748b3bb19e21e097bfe4f70b1"></a>ShortPRM&#160;</td><td class="fielddoc"><p>写出ParameterHandler的内容，没有注释或改变默认值。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a6d91eaf8deb52a5d3cba991a9bb23ac7"></a>ShortText&#160;</td><td class="fielddoc"><p>写下ParameterHandler的内容，不加评论或改变默认值。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>使用<code>ShortPRM</code>而不是<code>ShortText</code>。</dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827aadab70cda4e49776ec93690fd9e1bbd1"></a>ShortXML&#160;</td><td class="fielddoc"><p>把ParameterHandler的内容写成XML文件，不加注释或改变默认值。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a26b405ba447d5fcbeb3c178076c4580f"></a>ShortJSON&#160;</td><td class="fielddoc"><p>把ParameterHandler的内容写成JSON文件，不加注释或改变默认值。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a0fbe0a13822fbc6b4e28fd6b416eb9ca"></a>ShortLaTeX&#160;</td><td class="fielddoc"><p>把ParameterHandler的内容写成LaTeX文件，不加注释或改变默认值。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l00734">734</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7aebc6956ea423d376c5fe881b8d5c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aebc6956ea423d376c5fe881b8d5c4d">&#9670;&nbsp;</a></span>ParameterHandler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParameterHandler::ParameterHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00047">47</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae88837d277a9403e34572f0813ccffd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88837d277a9403e34572f0813ccffd9">&#9670;&nbsp;</a></span>~ParameterHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ParameterHandler::~ParameterHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解构器。声明这个只是为了有一个虚拟的析构器，这更安全，因为我们有虚拟函数。 它实际上没有什么了不起的作用。 </p>

</div>
</div>
<a id="a3b4eeb455a8c693e9824ff2355e44b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4eeb455a8c693e9824ff2355e44b76">&#9670;&nbsp;</a></span>ParameterHandler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ParameterHandler::ParameterHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>抑制自动的CopyConstructor。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afb9f6389423d58763d539e13e2b09234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9f6389423d58763d539e13e2b09234">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParameterHandler.html">ParameterHandler</a>&amp; ParameterHandler::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>抑制自动赋值运算符。 </p>

</div>
</div>
<a id="a0ddaa05c5463c6c0b7701e18005717a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddaa05c5463c6c0b7701e18005717a9">&#9670;&nbsp;</a></span>parse_input() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;input&#160;file&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解析流中的每一行，直到流返回<code>eof</code>条件或错误，以提供已知参数字段的值。第二个参数可以用来表示我们正在读取的文件的名称（如果那是输入流所代表的）；这只在为异常创建输出时使用。 如果提供了非空的 <code>last_line</code> ，ParameterHandler对象将在遇到 <code>last_line</code> 后停止解析行。 这在添加应被手动解析的额外数据时很方便。 如果 <code>skip_undefined</code> 是 <code>true</code> ，参数处理程序将跳过未定义的部分和条目。这对于部分解析参数文件非常有用，例如，只获得问题的空间维度。默认情况下，所有的条目和子节都应该被声明。 该函数将它在输入文件中遇到的所有参数的值设置为提供的值。在输入文件中没有明确列出的参数将保持其先前的值，这将是提供给 <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> 的默认值，除非先前读取过不同的输入文件。 每个参数的值都会与提供给 <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> 的该参数的模式相匹配，并对每个参数执行之前可能由 <a class="el" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action()</a> 设置的所有相关动作。如果一个参数不符合它的模式，或者一个相关的动作抛出了一个异常，那么为该参数提供的值就不会被设置，当前对象就会恢复到当前函数被调用之前的小节。对输入流不会有进一步的处理，也就是说，在参数的值不满足其模式之后的所有东西都被忽略了。 </p>

<p>Reimplemented in <a class="el" href="classMultipleParameterLoop.html#a978e161aae61a62c27a7dec2d7fd527b">MultipleParameterLoop</a>.</p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00399">399</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a647461d59c5de46d345d56e0f856d581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647461d59c5de46d345d56e0f856d581">&#9670;&nbsp;</a></span>parse_input() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>assert_mandatory_entries_are_found</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解析来自指定参数文件的输入 <code>filename</code> ，与正在使用的输入文件类型（prm、xml、json）无关。这个函数选择的代码路径是从文件名的结尾处提取的，所以用户必须确保输入文件的内容与文件名一致。 参数 <code>last_line</code> 将只用于.prm类型的参数文件。 参见其他parse_input函数的文档。 用户可以指定输入文件中未加入参数处理程序的参数是否会被 <code>skip_undefined</code> 跳过（启用部分解析），以及代码是否会断言所有用标志<code>has_to_be_set=true</code>声明的参数处理程序的参数确实在输入文件中找到。 如果函数是以<code>skip_undefined=true</code>调用的，建议同时设置<code>assert_mandatory_entries_are_found=true</code>。例如，这可以确保在输入文件中有错别字的参数不会被跳过，而这种错误在其他情况下仍然无法被识别。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00532">532</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a79bb8b2735fb7e9980ec73ff7b489f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bb8b2735fb7e9980ec73ff7b489f7f">&#9670;&nbsp;</a></span>parse_input_from_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input_from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一个字符串中解析输入，以填充已知的参数字段。字符串中的各行必须用<code> \n</code> 字符分开。 该函数实质上是将整个文件读入一个流，然后用该流调用其他的parse_input()函数。更多信息见那里。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00560">560</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a12e7edb2a86419b76f4a1b69dfdd873a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e7edb2a86419b76f4a1b69dfdd873a">&#9670;&nbsp;</a></span>parse_input_from_xml()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input_from_xml </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一个XML流中解析输入，以填充已知的参数字段。这可能来自一个最初由print_parameters()函数使用XML输出风格编写的文件，然后根据需要手工修改，或者来自一个使用该方法编写的文件，然后由图形化参数GUI修改（见该类的一般文档）。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00700">700</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="afb4afb8f5cc2451fb16be1fff32b4380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4afb8f5cc2451fb16be1fff32b4380">&#9670;&nbsp;</a></span>parse_input_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input_from_json </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解析来自JSON流的输入，以填充已知的参数字段。这可能来自于最初由print_parameters()函数使用JSON输出风格编写的文件，然后根据需要手工修改，或者来自一个知道如何为ParameterHandler输入编写JSON格式的单独程序。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00756">756</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a6184baed4eba575e422161dc86ed12e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6184baed4eba575e422161dc86ed12e3">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>清除所有内容。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00787">787</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a6d65f458be69e23a348221cb67fc411d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d65f458be69e23a348221cb67fc411d">&#9670;&nbsp;</a></span>declare_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::declare_entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em> = <code><a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>documentation</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>has_to_be_set</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明一个新的条目，名称为<code>entry</code>，默认为任何输入都必须与<code>pattern</code>相匹配（默认：任何模式）。 如果默认值与给定的模式不匹配，该函数会产生一个ExcValueDoesNotMatchPattern类型的异常，使用C++的抛出机制。然而，这个异常只在条目被创建时产生<em>after</em>；如果你的代码中不可能有合理的参数默认值，那么你可以捕捉并忽略这个异常。 参数 <code>documentation</code> 默认为一个空字符串，用于为每个条目添加记录文本，当这个类被要求使用print_parameters()函数将所有声明写到一个流中时，该文本将被打印出来作为注释。 可以使用参数 <code>has_to_be_set</code> 来声明这个参数，这个参数的默认值必须被这个类所提供的一个方法所覆盖。一个参数是否被成功设置，可以通过函数get_entries_wrongly_not_set()和assert_that_entries_have_been_set()进行查询。 </p><dl class="section note"><dt>Note</dt><dd>一个条目可以被声明多次而不产生错误，例如，为了覆盖一个早期的默认值。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00796">796</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a59f3996003757093fb0e050a6729e81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f3996003757093fb0e050a6729e81b">&#9670;&nbsp;</a></span>add_action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::add_action </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const std::string &amp;value)&gt; &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在当前章节中为名称为 <code>entry</code> 的参数附加一个动作。这个动作需要是一个类似于函数的对象，把参数的值作为一个（字符串）参数。关于动作的更多描述，请参见这个类的一般文档，以及例子。 该动作在三种不同的情况下被执行。</p>
<ul>
<li>在当前函数的末尾加上名称为 <code>name</code>, 的参数的默认值。这很有用，因为它允许动作对每个参数至少执行一次它需要做的事情，即使是那些实际上没有在输入文件中指定的参数（因此保持其默认值）。</li>
<li>在 <a class="el" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">ParameterHandler::set()</a> 函数中，明确地为一个参数设置一个值。</li>
<li>在parse_input()函数和类似的函数中，例如parse_input_from_string()。在这里，只要从输入中读取与之相关的参数，在确定所读取的值与该参数所对应的模式相匹配后，在实际保存该值之前，就会执行该动作。 为同一个参数添加多个动作是有效的。在这种情况下，它们将按照添加的顺序被执行。 <dl class="section note"><dt>Note</dt><dd>动作可以修改其范围内的所有种类的变量。一个动作唯一不应该修改的是它所连接的ParameterHandler对象。换句话说，它不允许进入或离开当前ParameterHandler对象的部分。原则上，在当前部分的其他参数上调用 <a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">ParameterHandler::get()</a> 和相关函数是可以接受的，但由于不能保证它们从输入文件中读取的顺序，你将不希望依赖这些函数将返回的值。 </dd>
<dd>
在一个动作中抛出一个异常通常不是一个好主意，但产生的结果与试图从一个文件中读取一个参数的结果基本相同，因为该参数的值不符合与该参数相关的模式。换句话说，刚刚读取的值被丢弃， <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> 停止从文件中读取任何进一步的内容。更多信息见 <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> 。 </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00842">842</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a04b75c02037d19fd7fd781785fcefc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b75c02037d19fd7fd781785fcefc79">&#9670;&nbsp;</a></span>add_parameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ParameterType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::add_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParameterType &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>documentation</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em> = <code>*<a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a>&lt;ParameterType&gt;::to_pattern()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>has_to_be_set</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明一个新的条目名称 <code>entry</code>, 将其默认值设置为变量 <code>parameter</code>, 的内容，并创建一个动作，当文件被解析，或条目被设置为新值时，将用更新的值填充 <code>参数。</code> 默认情况下，要使用的模式是通过调用函数 <a class="el" href="structPatterns_1_1Tools_1_1Convert.html#a3fb901bae7fe2de5dc27da09e989ad2c">Patterns::Tools::Convert&lt;T&gt;::to_pattern()</a>, 获得的，但也可以使用一个自定义的模式。 可以使用参数 <code>has_to_be_set</code> 来声明这个参数，其默认值必须被这个类提供的一个方法所覆盖。一个参数是否被成功设置，可以通过函数get_entries_wrongly_not_set()和assert_that_entries_have_been_set()进行查询。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01998">1998</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aecb847561585089c4c7fcf51eddece16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb847561585089c4c7fcf51eddece16">&#9670;&nbsp;</a></span>declare_alias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::declare_alias </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>existing_entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alias_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>alias_is_deprecated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为一个现有条目创建一个别名。这提供了一种方法，可以用另一个名字来引用输入文件中的一个参数。该别名将在当前部分，而被引用的条目需要是当前部分的一个现有条目。 这个函数的主要目的是允许用一种向后兼容的方式来改变应用程序输入文件中的名称，因为向后兼容很重要。这可以通过在调用 <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> 时改变参数的名称，然后创建一个别名将旧名称映射到新名称来实现。这样，旧的输入文件可以继续引用旧名称下的参数，它们将自动被映射到新的参数名称。 在一个输入文件中多次设置同一个参数是有效的。 在这种情况下，最终选择的值仅仅是最后设置的值。这个规则也适用于别名，参数的最终值是通过参数的当前名称或通过其可能的多个别名设置的最后一个值。例如，如果你有一个输入文件，看起来像 </p><div class="fragment"><div class="line"><span class="keyword">set</span> parm1       = 1</div><div class="line"><span class="keyword">set</span> parm1_alias = 2</div></div><!-- fragment --><p> 其中 <code>parm1_alias</code> 是一个通过以下方式声明的别名 </p><div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#aecb847561585089c4c7fcf51eddece16">declare_alias</a> (<span class="stringliteral">&quot;parm1&quot;</span>, <span class="stringliteral">&quot;parm1_alias&quot;</span>);</div></div><!-- fragment --><p> 那么名为 <code>parm1</code> 的参数的最终值将是2，而不是1。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">existing_entry_name</td><td>在当前章节中的一个现有参数的名称，该别名应该指的是这个。 </td></tr>
    <tr><td class="paramname">alias_name</td><td>第一个参数所引用的参数的另一个名称。 </td></tr>
    <tr><td class="paramname">alias_is_deprecated</td><td>如果为真，将该别名标记为已废弃。如果你调用print_parameters()，这将被列在别名的描述中，并且在读取包含这个已废弃的别名的输入文件时，你将在屏幕上得到一个警告。这个参数的目的是能够允许使用一个旧的参数名称（见上文），但是要明确这个旧名称最终会被删除。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00878">878</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af29c20cde6d44186806d559beb468696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29c20cde6d44186806d559beb468696">&#9670;&nbsp;</a></span>enter_subsection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::enter_subsection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subsection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>输入一个分节。如果它还不存在，就创建它。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00939">939</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a599462cacd492e2f712bf7369507dcff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599462cacd492e2f712bf7369507dcff">&#9670;&nbsp;</a></span>leave_subsection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::leave_subsection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>离开目前的分节。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00953">953</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae6142462087d1cd62d294eccb1f58867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6142462087d1cd62d294eccb1f58867">&#9670;&nbsp;</a></span>subsection_path_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::subsection_path_exists </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>检查当前树中是否存在一个分节或分节路径。 输入参数 <code>sub_path</code> 被认为是相对于当前选择的路径。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00966">966</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a91cfbaca954f444047302446a4e87125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cfbaca954f444047302446a4e87125">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>入口的返回值 <code>entry_string</code>. 如果入口被改变，则返回改变后的值，否则返回默认值。如果需要一个未声明的条目的值， <code>Assert</code> 将失败。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00987">987</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa08ccf6fbd95de45a35b53ba0c09f49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08ccf6fbd95de45a35b53ba0c09f49f">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>条目 <code>entry_string</code>. 的返回值 如果条目被改变，那么返回改变后的值，否则返回默认值。如果需要一个未声明的条目的值， <code>Assert</code> 将失败。 如果 <code>entry_subsection_path</code> 是非空的，那么将从该路径所代表的分节中获取数值，而不是当前分节。 <code>entry_subsection_path</code> 中的第一个字符串必须是当前分节的名称，接下来的每个字符串必须是前面一个分节的名称。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01004">1004</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a61fa98fdc0c52980a5b1de0ee1fc5bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fa98fdc0c52980a5b1de0ee1fc5bb2">&#9670;&nbsp;</a></span>get_integer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classint.html">int</a> ParameterHandler::get_integer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回条目 <code>entry_string</code> 的值为 <code>long int</code> 。（选择一个长的int，这样即使是非常大的无符号值也可以由这个函数返回）。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01025">1025</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a421a09eb0548f1fb3783d97d3e85fd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421a09eb0548f1fb3783d97d3e85fd5c">&#9670;&nbsp;</a></span>get_integer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classint.html">int</a> ParameterHandler::get_integer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>条目 <code>entry_string</code> 的返回值为 <code>long int</code> 。（选择一个长的int，这样即使是非常大的无符号值也能被这个函数返回）。 如果 <code>entry_subsection_path</code> 是非空的，那么该值将从该路径所代表的分节而不是当前分节中得到。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01044">1044</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aeaf3c7846747695b1f327677e3716ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf3c7846747695b1f327677e3716ec5">&#9670;&nbsp;</a></span>get_double() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> ParameterHandler::get_double </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回条目 <code>entry_name</code> 的值为 <code>double</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01068">1068</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a913289695be07bd949bf94aa5cd5ad54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913289695be07bd949bf94aa5cd5ad54">&#9670;&nbsp;</a></span>get_double() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> ParameterHandler::get_double </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果 <code>entry_subsection_path</code> 不是空的，将从该路径所代表的分节而不是当前分节中获取数值。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01088">1088</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a6bb45dc67787e3fab7882461929b5fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb45dc67787e3fab7882461929b5fbe">&#9670;&nbsp;</a></span>get_bool() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::get_bool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>条目 <code>entry_name</code> 的返回值为 <code>bool</code>. ，该条目对 <code>true</code>, 可以是 "真 "或 "是"，对 <code>false</code> 可以是 "假 "或 "否"。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01113">1113</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a209f365b60c5b0a76080b86693baa36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209f365b60c5b0a76080b86693baa36b">&#9670;&nbsp;</a></span>get_bool() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::get_bool </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>条目 <code>entry_name</code> 的返回值为 <code>bool</code>. 该条目对于 <code>true</code>, 可以分别为 "真 "或 "是"，对于 <code>false</code> 可以为 "假 "或 "否"。 如果 <code>entry_subsection_path</code> 不为空，则将从该路径所代表的分节中获取数值，而不是当前分节。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01130">1130</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa6418ea655b1b550b9dcf63513030196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6418ea655b1b550b9dcf63513030196">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将当前存储的<code>entry_name</code>的值改为第二个参数中给出的值。 该参数必须已经存在于当前分节中。 如果新值不符合该条目的模式，该函数会抛出一个ExcValueDoesNotMatchPattern类型的异常。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01152">1152</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af288e1fe38ac1a1baf1cef3058b63ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af288e1fe38ac1a1baf1cef3058b63ce1">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和上面一样，但有一个重载，第二个参数是一个字符指针。这是必要的，因为否则对 <code>set("abc","def")</code> 的调用将被映射为该函数以一个字符串和一个bool作为参数，这当然不是最常见的目的。 如果新值不符合这个条目的模式，该函数会抛出一个ExcValueDoesNotMatchPattern类型的异常。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01205">1205</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa89180ba36c54e207286a3545f8371b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89180ba36c54e207286a3545f8371b4">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将目前为<code>entry_name</code>存储的值改为第二个参数中给出的值。 该参数必须已经存在于本小节中。 如果新值不符合该条目的模式，该函数会抛出一个ExcValueDoesNotMatchPattern类型的异常。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01227">1227</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ad46b9dd6387d7e48ddca4add8baad2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46b9dd6387d7e48ddca4add8baad2aa">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将目前为<code>entry_name</code>存储的值改为第二个参数中给出的值。 该参数必须已经存在于本分节中。 为了内部的目的，新的值需要转换为一个字符串。 这是用16位数的精度完成的，所以设定的值和你用get_double()得到的值可能在第16位数上有所不同。 如果新值不符合这个条目的模式，该函数会抛出一个ExcValueDoesNotMatchPattern类型的异常。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01213">1213</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae417f9634872a427765365cd5ee9b160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae417f9634872a427765365cd5ee9b160">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将目前为<code>entry_name</code>存储的值改为第二个参数中给出的值。 该参数必须已经存在于本小节中。 如果新值不符合该条目的模式，该函数会抛出一个ExcValueDoesNotMatchPattern类型的异常。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01240">1240</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a4ac3a8b19ade16e96e8ea25906daf23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac3a8b19ade16e96e8ea25906daf23a">&#9670;&nbsp;</a></span>print_parameters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; ParameterHandler::print_parameters </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印所有具有给定 <code>style</code> 至 <code>out</code>. 的参数 在打印之前，所有当前参数和子部分默认按字母顺序排序。 这种行为可以通过设置可选的参数 <code>style</code> 来禁用<code>KeepDeclarationOrder</code>：在这种情况下，条目的打印顺序与它们被声明的顺序相同。 在<code>PRM</code>、<code>XML</code>和<code>JSON</code>格式中，输出的格式是可以用于以后再次输入。这对于记录特定运行的参数是最有用的，因为如果你用这个函数把参数输出到一个日志文件中，你总是可以通过简单地把输出复制到输入文件来恢复结果。 除了每个条目的名称和值之外，输出还包括条目的默认值（如果它与实际值不同），以及给 <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> 函数的记录字符串（如果有）。 通过使用标志<code>Short</code>与<code>PRM</code>、<code>XML</code>、<code>JSON</code>或<code>LaTeX</code>相结合（或通过使用快捷键<code>ShortPRM</code>。<code>ShortXML</code>, <code>ShortJSON</code>, 或 <code>ShortLaTeX</code>），可以生成一个缩小的输出，只包含数值，跳过文档。 在<code>XML</code>格式中，输出从一个根元素<code><a class="el" href="classParameterHandler.html">ParameterHandler</a></code>开始，以便得到一个有效的XML文档和它下面的所有子节。 在<code>LaTeX</code>格式中，输出包含同样的信息，但其格式是这样的：所产生的文件可以输入到一个latex文档中，例如这个对象处理运行时参数的代码的手册。然后，参数的各个部分由latex章节和分节命令以及嵌套的枚举来表示。 你可以通过为每个条目自动生成的标签来引用特定的参数部分和单个参数。标签的格式为 <code>parameters:section1/subsection1</code> 和 <code>parameters:section1/subsection1/someentry</code> 。由于特殊字符可能出现在章节和条目名称中，这些字符将被 "混杂"。在这里，除了 <code>[a-zA-Z0-9]</code> 以外的所有字符都被 <code>_XX</code>, where <code>XX</code> 所取代，该字符在十六进制编码中的两位数ascii代码（因此，例如，一个空格变成 <code>_20</code> ）。 虽然这个函数在大多数输出中（名称、默认值等）都转义了LaTeX特有的字符（反斜杠、下划线等），但文档字符串是按原样传递的。这意味着你可以在描述中使用数学环境和其他格式，但你需要自己转义引号、反斜线、下划线等。 此外，所有的参数名称都用 <code>\index</code> 语句列在两个索引中，称为 <code>prmindex</code> （每个参数的名称都列在索引中）和 <code>prmindexfull</code> ，参数名称按其存在的章节排序。默认情况下，LaTeX程序会忽略这些 <code>\index</code> 命令，但它们可以通过在latex文件的序言中使用以下命令来生成索引。 </p><div class="fragment"><div class="line">\usepackage{imakeidx}</div><div class="line">\makeindex[name=prmindex, title=Index of <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>-time parameter <a class="code" href="classParameterHandler.html#ae3c753f43844f2c1196d4ef939048bb0">entries</a>]</div><div class="line">\makeindex[name=prmindexfull,</div><div class="line">         title=Index of <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>-time parameters with section names]</div></div><!-- fragment --><p> 并在文件的结尾这样做。 </p><div class="fragment"><div class="line">\printindex[prmindex]</div><div class="line">\printindex[prmindexfull]</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01250">1250</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a17fde9ad56e01eed0648e56106e6bf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17fde9ad56e01eed0648e56106e6bf1e">&#9670;&nbsp;</a></span>print_parameters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::print_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em> = <code><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印所有参数到 <code>filename</code> 给定的文件中，并使用给定的输出样式 <code>style</code>. 这个函数从指定文件名的扩展名推断出输出格式。支持的扩展名是`prm', `xml', `tex', 和 `json'。因此，只要在文件名中加入这些扩展名之一，就没有必要通过 <code>style</code> 参数指定输出格式。不过，如果在 <code>style</code> 参数中指定了输出格式，输出格式必须与文件名的扩展名一致。 如果没有指定扩展名或不支持扩展名，输出格式将从 <code>style</code> 参数中推断出来。 如果既不支持扩展名，也不支持 <code>style</code> 参数中的格式规范，则会抛出一个断言。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>输出文件名。 </td></tr>
    <tr><td class="paramname">style</td><td>产生输出的样式。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01354">1354</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa900e3460a10639fc4d8703ef09a7c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa900e3460a10639fc4d8703ef09a7c0a">&#9670;&nbsp;</a></span>log_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::log_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLogStream.html">LogStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em> = <code><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印参数到一个日志流。这个函数允许将所有参数打印到一个日志文件中。各部分将以通常的日志文件风格缩进。 默认情况下，所有当前的参数和子部分都是按字母顺序排列的。 这种行为可以通过设置可选的参数 <code>style</code> 来禁用<code>KeepDeclarationOrder</code>：在这种情况下，条目的打印顺序与它们被声明的顺序相同。 </p><dl class="section note"><dt>Note</dt><dd><code>style</code> 中所有与排序无关的样式设置都被忽略了。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01757">1757</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae15f2618f3b24c04eead226c5271be1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15f2618f3b24c04eead226c5271be1a">&#9670;&nbsp;</a></span>log_parameters_section()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::log_parameters_section </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLogStream.html">LogStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em> = <code><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>本分节中的日志参数。该分节由<code>subsection_path</code>成员变量决定。这个变量通过enter_subsection()和leave_subsection()函数进入和离开子段来控制。 所有当前的参数和子段默认是按字母顺序排序的。 这种行为可以通过设置可选的参数 <code>style</code> 来禁用<code>KeepDeclarationOrder</code>：在这种情况下，条目的打印顺序与它们被声明的顺序相同。 </p><dl class="section note"><dt>Note</dt><dd><code>style</code> 中所有与排序无关的样式设置都被忽略了。 在大多数情况下，你不会想直接使用这个函数，而是让它被前面的函数递归调用。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01768">1768</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a0342139603da3b30b132446d94a17b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0342139603da3b30b132446d94a17b25">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ParameterHandler::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>确定这个对象的内存消耗（以字节为单位）的估计值。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02009">2009</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a5df38ff67c1c8352e04de490e0c0a39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df38ff67c1c8352e04de490e0c0a39e">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>将此对象的数据写入一个流中，以便进行序列化。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01960">1960</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="a09fd2ee6d01b78079f894893aacd6c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fd2ee6d01b78079f894893aacd6c4c">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>从一个流中读取此对象的数据，以达到序列化的目的。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01979">1979</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aac896adce1ec1db3f525f57811764879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac896adce1ec1db3f525f57811764879">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>从流中写入和读取此对象的数据，以达到序列化的目的。 </p>

</div>
</div>
<a id="aede1a749bba8ee11876fd114a16c4f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede1a749bba8ee11876fd114a16c4f3e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>检验是否相等。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02018">2018</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa5a299c29da8a837a1b8441039d0fa79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a299c29da8a837a1b8441039d0fa79">&#9670;&nbsp;</a></span>get_entries_wrongly_not_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; ParameterHandler::get_entries_wrongly_not_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一组参数名称（包括分段名称），对应于参数处理程序的那些条目，这些条目没有被一个从输入文件解析参数的函数或明确调用set()函数之一来设置，但已被声明为必须设置的强制性参数（通过 <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> 函数或 <a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">add_parameter()</a> 函数的最后参数）。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02043">2043</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af441ab90c4d310c1c7d12c5f0050024f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af441ab90c4d310c1c7d12c5f0050024f">&#9670;&nbsp;</a></span>assert_that_entries_have_been_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::assert_that_entries_have_been_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>断言参数处理程序中那些标记为<code>has_to_be_set = true</code>的条目已经被设置。如果这些参数中至少有一个没有被设置，就会出现异常。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02057">2057</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a309a5cd29993c8070462ec3ac70564cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309a5cd29993c8070462ec3ac70564cc">&#9670;&nbsp;</a></span>get_current_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get_current_path </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回标识当前进入属性树的路径的字符串。这只是一个路径，也就是说，它没有被path_separator字符终止。 这个函数只是调用collate_path_string()，参数为 <code>subsection_path</code> 。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00358">358</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aae05819ce1de5de30ad92322fc8fc8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae05819ce1de5de30ad92322fc8fc8da">&#9670;&nbsp;</a></span>get_current_full_path() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get_current_full_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给出条目名称作为参数，该函数使用当前分节计算出进入参数树的完整路径。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00366">366</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a74d7994d250bf62a83a4c3e119e8e1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d7994d250bf62a83a4c3e119e8e1dd">&#9670;&nbsp;</a></span>get_current_full_path() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get_current_full_path </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数给定一个来自当前分节的路径和一个条目的名称，计算一个进入参数树的全路径。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00380">380</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae9bdedef2bd8e6a1fe405a92c4d19590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bdedef2bd8e6a1fe405a92c4d19590">&#9670;&nbsp;</a></span>scan_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::scan_line </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>current_line_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>扫描一行的输入。<code>input_filename</code>和<code>current_line_n</code>是输入文件的名称和当前扫描的行数（这些在异常信息中用来显示哪里发生了解析错误）。如果该行包含一个未声明的分段或条目，如果该行的条目不符合其给定的模式，或者如果该行不能被理解为一个有效的参数文件表达式，这个函数将引发一个异常。 该函数修改了它的参数，但同时也以值的形式接受了它，所以调用者的变量没有被改变。 如果 <code>skip_undefined</code> 是 <code>true</code> ，解析器将跳过未定义的部分和条目。这对于部分解析参数文件是很有用的，例如，只获得问题的空间维度。默认情况下，所有的条目和子节都应该被声明。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01814">1814</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a4acc4642bfc38ec36b4927eb520661db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acc4642bfc38ec36b4927eb520661db">&#9670;&nbsp;</a></span>recursively_print_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::recursively_print_parameters </td>
          <td>(</td>
          <td class="paramtype">const boost::property_tree::ptree &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>indent_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>打印出由 <code>target_subsection_path</code> 参数给出的分节的参数，以及其中的所有分节的递归。这个函数是由print_parameters()函数调用的，并对所有 <code>style</code> 参数实现，除了XML和JSON（在那里我们可以通过BOOST函数输出整个参数集）。 <code>indent_level</code> 参数表示输出应该缩进多少个空格，以便子部分正确嵌套在更高部分的输出中。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01379">1379</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a6cb3efd46790a1d4b58f5ffe7bb66c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb3efd46790a1d4b58f5ffe7bb66c06">&#9670;&nbsp;</a></span>MultipleParameterLoop</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classMultipleParameterLoop.html">MultipleParameterLoop</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01559">1559</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a009fb8cb45463ac3a57f8cb371fbc82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009fb8cb45463ac3a57f8cb371fbc82b">&#9670;&nbsp;</a></span>path_separator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char ParameterHandler::path_separator = '.'</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>访问路径中的元素进入参数树时使用的分隔符。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01469">1469</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aefa5b69fc4d1d56dd6bc90e2dcf24d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa5b69fc4d1d56dd6bc90e2dcf24d56">&#9670;&nbsp;</a></span>subsection_path</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; ParameterHandler::subsection_path</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>目前选择的子部分的路径；空列表表示顶层 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01475">1475</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="ae3c753f43844f2c1196d4ef939048bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c753f43844f2c1196d4ef939048bb0">&#9670;&nbsp;</a></span>entries</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;boost::property_tree::ptree&gt; ParameterHandler::entries</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>完整的章节和条目树。关于数据如何存储在这个变量中的描述，请参见这个类的一般文档。 这个变量是一个指针，这样我们就可以使用一个不完整的类型，而不需要包括boost中的所有property_tree的东西。这可以解决gcc 4.5的一个问题。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01483">1483</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aad871495dd6e1c35e2d36ecb3f66a53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad871495dd6e1c35e2d36ecb3f66a53a">&#9670;&nbsp;</a></span>entries_set_status</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::pair&lt;<a class="el" href="classbool.html">bool</a>, <a class="el" href="classbool.html">bool</a>&gt; &gt; ParameterHandler::entries_set_status</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个地图，为每个添加到参数处理程序的条目存储一对布尔变量。第一个布尔变量描述了参数是否必须根据函数 <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> 或 <a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">add_parameter()</a> 的最后一个参数来设置，第二个布尔变量包含了参数是否被任何解析输入参数的函数或本类的设置函数设置过的信息。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01491">1491</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="a3caa993b840f2e2d76fcfd7b94cbc799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3caa993b840f2e2d76fcfd7b94cbc799">&#9670;&nbsp;</a></span>patterns</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unique_ptr&lt;const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a>&gt; &gt; ParameterHandler::patterns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个用于描述此对象的参数的模式列表。与参数相对应的属性树中的每一个节点都向这个数组存储一个索引。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01497">1497</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="ad45eff738f43667037e3e59be30f04b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45eff738f43667037e3e59be30f04b0">&#9670;&nbsp;</a></span>actions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::function&lt;void(const std::string &amp;)&gt; &gt; ParameterHandler::actions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个与参数相关的动作列表。这些是由add_action()函数添加的。与单个参数相对应的属性树中的节点在这个数组中存储索引，以便引用特定的动作。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01503">1503</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a></li>
<li>source/base/<a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
