<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSolverGMRES.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SolverGMRES&lt; VectorType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classSolverGMRES-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SolverGMRES&lt; VectorType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Solvers.html">Linear solver classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="solver__gmres_8h_source.html">deal.II/lac/solver_gmres.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SolverGMRES&lt; VectorType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSolverGMRES__inherit__graph.svg" width="210" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSolverGMRES_1_1AdditionalData.html">AdditionalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abe117f08879bcffbbcd348c4bb547b9b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverBase.html#abe117f08879bcffbbcd348c4bb547b9b">vector_type</a> = <a class="el" href="classVectorType.html">VectorType</a></td></tr>
<tr class="separator:abe117f08879bcffbbcd348c4bb547b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7daabdaa13f77bfd0af4b3c3079f2caf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#a7daabdaa13f77bfd0af4b3c3079f2caf">SolverGMRES</a> (<a class="el" href="classSolverControl.html">SolverControl</a> &amp;cn, <a class="el" href="classVectorMemory.html">VectorMemory</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;mem, const <a class="el" href="structSolverGMRES_1_1AdditionalData.html">AdditionalData</a> &amp;data=<a class="el" href="structSolverGMRES_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a7daabdaa13f77bfd0af4b3c3079f2caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9eab644dfb3f3cb2f7aaea962310ff8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#ad9eab644dfb3f3cb2f7aaea962310ff8">SolverGMRES</a> (<a class="el" href="classSolverControl.html">SolverControl</a> &amp;cn, const <a class="el" href="structSolverGMRES_1_1AdditionalData.html">AdditionalData</a> &amp;data=<a class="el" href="structSolverGMRES_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:ad9eab644dfb3f3cb2f7aaea962310ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fea69602a523fdb4314ad8d58f22eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#a20fea69602a523fdb4314ad8d58f22eb">SolverGMRES</a> (const <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;)=delete</td></tr>
<tr class="separator:a20fea69602a523fdb4314ad8d58f22eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb490cfb46f2708ba7e7c5b0fb09b646"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename PreconditionerType &gt; </td></tr>
<tr class="memitem:aeb490cfb46f2708ba7e7c5b0fb09b646"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#aeb490cfb46f2708ba7e7c5b0fb09b646">solve</a> (const MatrixType &amp;A, <a class="el" href="classVectorType.html">VectorType</a> &amp;x, const <a class="el" href="classVectorType.html">VectorType</a> &amp;b, const PreconditionerType &amp;preconditioner)</td></tr>
<tr class="separator:aeb490cfb46f2708ba7e7c5b0fb09b646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3025d81c3d7db3e1a1b0114bef794202"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#a3025d81c3d7db3e1a1b0114bef794202">connect_condition_number_slot</a> (const std::function&lt; void(<a class="el" href="classdouble.html">double</a>)&gt; &amp;slot, const <a class="el" href="classbool.html">bool</a> every_iteration=false)</td></tr>
<tr class="separator:a3025d81c3d7db3e1a1b0114bef794202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b1a77aca47611eb65497492efbb47a"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#ae5b1a77aca47611eb65497492efbb47a">connect_eigenvalues_slot</a> (const std::function&lt; void(const std::vector&lt; std::complex&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;)&gt; &amp;slot, const <a class="el" href="classbool.html">bool</a> every_iteration=false)</td></tr>
<tr class="separator:ae5b1a77aca47611eb65497492efbb47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b9eb969e086002cd467ae776927fae"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#a92b9eb969e086002cd467ae776927fae">connect_hessenberg_slot</a> (const std::function&lt; void(const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;)&gt; &amp;slot, const <a class="el" href="classbool.html">bool</a> every_iteration=true)</td></tr>
<tr class="separator:a92b9eb969e086002cd467ae776927fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370cfbff4b3ffb5e240e4e5ddbbe532b"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#a370cfbff4b3ffb5e240e4e5ddbbe532b">connect_krylov_space_slot</a> (const std::function&lt; void(const <a class="el" href="classinternal_1_1SolverGMRESImplementation_1_1TmpVectors.html">internal::SolverGMRESImplementation::TmpVectors</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;)&gt; &amp;slot)</td></tr>
<tr class="separator:a370cfbff4b3ffb5e240e4e5ddbbe532b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67544bf70ee0e38d72037834f22905b9"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#a67544bf70ee0e38d72037834f22905b9">connect_re_orthogonalization_slot</a> (const std::function&lt; void(<a class="el" href="classint.html">int</a>)&gt; &amp;slot)</td></tr>
<tr class="separator:a67544bf70ee0e38d72037834f22905b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea76e92ba3ad5ea03cc85c890db03f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#afea76e92ba3ad5ea03cc85c890db03f1">DeclException1</a> (ExcTooFewTmpVectors, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The number of temporary vectors you gave (&quot;&lt;&lt; arg1&lt;&lt; &quot;) is too small. It should be at least 10 for &quot;&lt;&lt; &quot;any results, and much more for reasonable ones.&quot;)</td></tr>
<tr class="separator:afea76e92ba3ad5ea03cc85c890db03f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9721e9769d3ee8b603a1622f33fe8a"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverBase.html#a9f9721e9769d3ee8b603a1622f33fe8a">connect</a> (const std::function&lt; <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaa">SolverControl::State</a>(const unsigned <a class="el" href="classint.html">int</a> iteration, const <a class="el" href="classdouble.html">double</a> check_value, const <a class="el" href="classVectorType.html">VectorType</a> &amp;current_iterate)&gt; &amp;slot)</td></tr>
<tr class="separator:a9f9721e9769d3ee8b603a1622f33fe8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af0c571625fc92827541eac994a43a6c9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#af0c571625fc92827541eac994a43a6c9">criterion</a> ()</td></tr>
<tr class="separator:af0c571625fc92827541eac994a43a6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837cc17747309383b705c2402e26a57f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#a837cc17747309383b705c2402e26a57f">givens_rotation</a> (<a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;h, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;b, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;ci, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;si, <a class="el" href="classint.html">int</a> col) const</td></tr>
<tr class="separator:a837cc17747309383b705c2402e26a57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ac98efb216917afc9d90201bd7445572b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#ac98efb216917afc9d90201bd7445572b">modified_gram_schmidt</a> (const <a class="el" href="classinternal_1_1SolverGMRESImplementation_1_1TmpVectors.html">internal::SolverGMRESImplementation::TmpVectors</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;orthogonal_vectors, const unsigned <a class="el" href="classint.html">int</a> dim, const unsigned <a class="el" href="classint.html">int</a> accumulated_iterations, <a class="el" href="classVectorType.html">VectorType</a> &amp;vv, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;h, <a class="el" href="classbool.html">bool</a> &amp;re_orthogonalize, const boost::signals2::signal&lt; void(<a class="el" href="classint.html">int</a>)&gt; &amp;<a class="el" href="classSolverGMRES.html#af991ee3afc429011d575d734f72582ea">re_orthogonalize_signal</a>=boost::signals2::signal&lt; void(<a class="el" href="classint.html">int</a>)&gt;())</td></tr>
<tr class="separator:ac98efb216917afc9d90201bd7445572b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5578afdf7f3aa3792647dd62fca664b2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#a5578afdf7f3aa3792647dd62fca664b2">compute_eigs_and_cond</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;H_orig, const unsigned <a class="el" href="classint.html">int</a> dim, const boost::signals2::signal&lt; void(const std::vector&lt; std::complex&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;)&gt; &amp;<a class="el" href="classSolverGMRES.html#a2e04bf076edf526a6eb6c2e9954d6f6c">eigenvalues_signal</a>, const boost::signals2::signal&lt; void(const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;)&gt; &amp;<a class="el" href="classSolverGMRES.html#a075575ce9a3856168840a5f3d0b3f767">hessenberg_signal</a>, const boost::signals2::signal&lt; void(<a class="el" href="classdouble.html">double</a>)&gt; &amp;cond_signal)</td></tr>
<tr class="separator:a5578afdf7f3aa3792647dd62fca664b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1258970549afb323a68a84ed1544ebd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSolverGMRES_1_1AdditionalData.html">AdditionalData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#a1258970549afb323a68a84ed1544ebd4">additional_data</a></td></tr>
<tr class="separator:a1258970549afb323a68a84ed1544ebd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c7a538d0a27e817bba2ef7d1dbc575"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(<a class="el" href="classdouble.html">double</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#a16c7a538d0a27e817bba2ef7d1dbc575">condition_number_signal</a></td></tr>
<tr class="separator:a16c7a538d0a27e817bba2ef7d1dbc575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ae1d36ec2370af5ed7060d79f8b64a"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(<a class="el" href="classdouble.html">double</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#af3ae1d36ec2370af5ed7060d79f8b64a">all_condition_numbers_signal</a></td></tr>
<tr class="separator:af3ae1d36ec2370af5ed7060d79f8b64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e04bf076edf526a6eb6c2e9954d6f6c"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(const std::vector&lt; std::complex&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#a2e04bf076edf526a6eb6c2e9954d6f6c">eigenvalues_signal</a></td></tr>
<tr class="separator:a2e04bf076edf526a6eb6c2e9954d6f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf671919b3400e91a5999a45c5cdb34"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(const std::vector&lt; std::complex&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#aaaf671919b3400e91a5999a45c5cdb34">all_eigenvalues_signal</a></td></tr>
<tr class="separator:aaaf671919b3400e91a5999a45c5cdb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075575ce9a3856168840a5f3d0b3f767"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#a075575ce9a3856168840a5f3d0b3f767">hessenberg_signal</a></td></tr>
<tr class="separator:a075575ce9a3856168840a5f3d0b3f767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d7f0281e2d297e360bfac83129d3ba"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#a48d7f0281e2d297e360bfac83129d3ba">all_hessenberg_signal</a></td></tr>
<tr class="separator:a48d7f0281e2d297e360bfac83129d3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420bf7dc093c87df4ae351fe75ddfe2a"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(const <a class="el" href="classinternal_1_1SolverGMRESImplementation_1_1TmpVectors.html">internal::SolverGMRESImplementation::TmpVectors</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#a420bf7dc093c87df4ae351fe75ddfe2a">krylov_space_signal</a></td></tr>
<tr class="separator:a420bf7dc093c87df4ae351fe75ddfe2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af991ee3afc429011d575d734f72582ea"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; void(<a class="el" href="classint.html">int</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#af991ee3afc429011d575d734f72582ea">re_orthogonalize_signal</a></td></tr>
<tr class="separator:af991ee3afc429011d575d734f72582ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add852363ae5b524d506d7aede794307f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#add852363ae5b524d506d7aede794307f">H</a></td></tr>
<tr class="separator:add852363ae5b524d506d7aede794307f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a0ef351baf2c8205479cbbd9e4872d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverGMRES.html#a65a0ef351baf2c8205479cbbd9e4872d">H1</a></td></tr>
<tr class="separator:a65a0ef351baf2c8205479cbbd9e4872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc03248bb340e9204a2429aa78dd3218"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverBase.html#acc03248bb340e9204a2429aa78dd3218">static_vector_memory</a></td></tr>
<tr class="separator:acc03248bb340e9204a2429aa78dd3218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb6cb40edde189c1a8efe4e7815ef86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorMemory.html">VectorMemory</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverBase.html#acdb6cb40edde189c1a8efe4e7815ef86">memory</a></td></tr>
<tr class="separator:acdb6cb40edde189c1a8efe4e7815ef86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62a92a9cbd7c3003fe5ffb3e4fe06c7"><td class="memItemLeft" align="right" valign="top">boost::signals2::signal&lt; <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaa">SolverControl::State</a>(const unsigned <a class="el" href="classint.html">int</a> iteration, const <a class="el" href="classdouble.html">double</a> check_value, const <a class="el" href="classVectorType.html">VectorType</a> &amp;current_iterate), <a class="el" href="structSolverBase_1_1StateCombiner.html">StateCombiner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSolverBase.html#ab62a92a9cbd7c3003fe5ffb3e4fe06c7">iteration_status</a></td></tr>
<tr class="separator:ab62a92a9cbd7c3003fe5ffb3e4fe06c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class VectorType = Vector&lt;double&gt;&gt;<br />
class SolverGMRES&lt; VectorType &gt;</h3>

<p>Implementation of the Restarted Preconditioned Direct Generalized Minimal Residual Method. The stopping criterion is the norm of the residual.</p>
<p>The <a class="el" href="structSolverGMRES_1_1AdditionalData.html">AdditionalData</a> structure contains the number of temporary vectors used. The size of the Arnoldi basis is this number minus three. Additionally, it allows you to choose between right or left preconditioning. The default is left preconditioning. Finally it includes a flag indicating whether or not the default residual is used as stopping criterion.</p>
<h3>Left versus right preconditioning</h3>
<p><code><a class="el" href="structSolverGMRES_1_1AdditionalData.html">AdditionalData</a></code> allows you to choose between left and right preconditioning. As expected, this switches between solving for the systems <em>P<sup>-1</sup>A</em> and <em>AP<sup>-1</sup></em>, respectively.</p>
<p>A second consequence is the type of residual which is used to measure convergence. With left preconditioning, this is the <b>preconditioned</b> residual, while with right preconditioning, it is the residual of the unpreconditioned system.</p>
<p>Optionally, this behavior can be overridden by using the flag <a class="el" href="structSolverGMRES_1_1AdditionalData.html#aab56ea490a9c4fbe55168a2958c571da">AdditionalData::use_default_residual</a>. A <code>true</code> value refers to the behavior described in the previous paragraph, while <code>false</code> reverts it. Be aware though that additional residuals have to be computed in this case, impeding the overall performance of the solver.</p>
<h3>The size of the Arnoldi basis</h3>
<p>The maximal basis size is controlled by <a class="el" href="structSolverGMRES_1_1AdditionalData.html#ac385db0e8c853c02d828469d5a5bdcca">AdditionalData::max_n_tmp_vectors</a>, and it is this number minus 2. If the number of iteration steps exceeds this number, all basis vectors are discarded and the iteration starts anew from the approximation obtained so far.</p>
<p>Note that the minimizing property of GMRes only pertains to the Krylov space spanned by the Arnoldi basis. Therefore, restarted GMRes is <b>not</b> minimizing anymore. The choice of the basis length is a trade- off between memory consumption and convergence speed, since a longer basis means minimization over a larger space.</p>
<p>For the requirements on matrices and vectors in order to work with this class, see the documentation of the Solver base class.</p>
<h3>Observing the progress of linear solver iterations</h3>
<p>The <a class="el" href="classSolverGMRES.html#aeb490cfb46f2708ba7e7c5b0fb09b646">solve()</a> function of this class uses the mechanism described in the Solver base class to determine convergence. This mechanism can also be used to observe the progress of the iteration.</p>
<h3>Eigenvalue and condition number estimates</h3>
<p>This class can estimate eigenvalues and condition number during the solution process. This is done by creating the Hessenberg matrix during the inner iterations. The eigenvalues are estimated as the eigenvalues of the Hessenberg matrix and the condition number is estimated as the ratio of the largest and smallest singular value of the Hessenberg matrix. The estimates can be obtained by connecting a function as a slot using <code>connect_condition_number_slot</code> and <code>connect_eigenvalues_slot</code>. These slots will then be called from the solver with the estimates as argument. </p>

<p class="definition">Definition at line <a class="el" href="solver__gmres_8h_source.html#l00175">175</a> of file <a class="el" href="solver__gmres_8h_source.html">solver_gmres.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abe117f08879bcffbbcd348c4bb547b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe117f08879bcffbbcd348c4bb547b9b">&#9670;&nbsp;</a></span>vector_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSolverBase.html">SolverBase</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::<a class="el" href="classSolverBase.html#abe117f08879bcffbbcd348c4bb547b9b">vector_type</a> =  <a class="el" href="classVectorType.html">VectorType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An alias for the underlying vector type </p>

<p class="definition">Definition at line <a class="el" href="solver_8h_source.html#l00347">347</a> of file <a class="el" href="solver_8h_source.html">solver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7daabdaa13f77bfd0af4b3c3079f2caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7daabdaa13f77bfd0af4b3c3079f2caf">&#9670;&nbsp;</a></span>SolverGMRES() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::<a class="el" href="classSolverGMRES.html">SolverGMRES</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSolverControl.html">SolverControl</a> &amp;&#160;</td>
          <td class="paramname"><em>cn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorMemory.html">VectorMemory</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSolverGMRES_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em> = <code><a class="el" href="structSolverGMRES_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a id="ad9eab644dfb3f3cb2f7aaea962310ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9eab644dfb3f3cb2f7aaea962310ff8">&#9670;&nbsp;</a></span>SolverGMRES() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::<a class="el" href="classSolverGMRES.html">SolverGMRES</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSolverControl.html">SolverControl</a> &amp;&#160;</td>
          <td class="paramname"><em>cn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSolverGMRES_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em> = <code><a class="el" href="structSolverGMRES_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Use an object of type <a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a> as a default to allocate memory. </p>

</div>
</div>
<a id="a20fea69602a523fdb4314ad8d58f22eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fea69602a523fdb4314ad8d58f22eb">&#9670;&nbsp;</a></span>SolverGMRES() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::<a class="el" href="classSolverGMRES.html">SolverGMRES</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The copy constructor is deleted. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeb490cfb46f2708ba7e7c5b0fb09b646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb490cfb46f2708ba7e7c5b0fb09b646">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType , typename PreconditionerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PreconditionerType &amp;&#160;</td>
          <td class="paramname"><em>preconditioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the linear system \(Ax=b\) for x. </p>

</div>
</div>
<a id="a3025d81c3d7db3e1a1b0114bef794202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3025d81c3d7db3e1a1b0114bef794202">&#9670;&nbsp;</a></span>connect_condition_number_slot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::connect_condition_number_slot </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="classdouble.html">double</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>every_iteration</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect a slot to retrieve the estimated condition number. Called on each outer iteration if every_iteration=true, otherwise called once when iterations are ended (i.e., either because convergence has been achieved, or because divergence has been detected). </p>

</div>
</div>
<a id="ae5b1a77aca47611eb65497492efbb47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b1a77aca47611eb65497492efbb47a">&#9670;&nbsp;</a></span>connect_eigenvalues_slot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::connect_eigenvalues_slot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect a slot to retrieve the estimated eigenvalues. Called on each outer iteration if every_iteration=true, otherwise called once when iterations are ended (i.e., either because convergence has been achieved, or because divergence has been detected). </p>

</div>
</div>
<a id="a92b9eb969e086002cd467ae776927fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b9eb969e086002cd467ae776927fae">&#9670;&nbsp;</a></span>connect_hessenberg_slot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::connect_hessenberg_slot </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>every_iteration</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect a slot to retrieve the Hessenberg matrix obtained by the projection of the initial matrix on the Krylov basis. Called on each outer iteration if every_iteration=true, otherwise called once when iterations are ended (i.e., either because convergence has been achieved, or because divergence has been detected). </p>

</div>
</div>
<a id="a370cfbff4b3ffb5e240e4e5ddbbe532b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370cfbff4b3ffb5e240e4e5ddbbe532b">&#9670;&nbsp;</a></span>connect_krylov_space_slot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::connect_krylov_space_slot </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classinternal_1_1SolverGMRESImplementation_1_1TmpVectors.html">internal::SolverGMRESImplementation::TmpVectors</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect a slot to retrieve the basis vectors of the Krylov space generated by the Arnoldi algorithm. Called at once when iterations are completed (i.e., either because convergence has been achieved, or because divergence has been detected). </p>

</div>
</div>
<a id="a67544bf70ee0e38d72037834f22905b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67544bf70ee0e38d72037834f22905b9">&#9670;&nbsp;</a></span>connect_re_orthogonalization_slot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::connect_re_orthogonalization_slot </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect a slot to retrieve a notification when the vectors are re-orthogonalized. </p>

</div>
</div>
<a id="afea76e92ba3ad5ea03cc85c890db03f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea76e92ba3ad5ea03cc85c890db03f1">&#9670;&nbsp;</a></span>DeclException1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcTooFewTmpVectors&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The number of temporary vectors you gave (&quot;&lt;&lt; arg1&lt;&lt; &quot;) is too small. It should be at least 10 for &quot;&lt;&lt; &quot;any&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">and much more for reasonable ones.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0c571625fc92827541eac994a43a6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c571625fc92827541eac994a43a6c9">&#9670;&nbsp;</a></span>criterion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::criterion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the computation of the norm of the residual. </p>

</div>
</div>
<a id="a837cc17747309383b705c2402e26a57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837cc17747309383b705c2402e26a57f">&#9670;&nbsp;</a></span>givens_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::givens_rotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>si</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transformation of an upper Hessenberg matrix into tridiagonal structure by givens rotation of the last column </p>

</div>
</div>
<a id="ac98efb216917afc9d90201bd7445572b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98efb216917afc9d90201bd7445572b">&#9670;&nbsp;</a></span>modified_gram_schmidt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdouble.html">double</a> <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::modified_gram_schmidt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1SolverGMRESImplementation_1_1TmpVectors.html">internal::SolverGMRESImplementation::TmpVectors</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>orthogonal_vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>accumulated_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>re_orthogonalize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::signals2::signal&lt; void(<a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>re_orthogonalize_signal</em> = <code>boost::signals2::signal&lt;&#160;void(<a class="el" href="classint.html">int</a>)&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Orthogonalize the vector <code>vv</code> against the <code>dim</code> (orthogonal) vectors given by the first argument using the modified Gram-Schmidt algorithm. The factors used for orthogonalization are stored in <code>h</code>. The boolean <code>re_orthogonalize</code> specifies whether the modified Gram-Schmidt algorithm should be applied twice. The algorithm checks loss of orthogonality in the procedure every fifth step and sets the flag to true in that case. All subsequent iterations use re-orthogonalization. Calls the signal re_orthogonalize_signal if it is connected. </p>

</div>
</div>
<a id="a5578afdf7f3aa3792647dd62fca664b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5578afdf7f3aa3792647dd62fca664b2">&#9670;&nbsp;</a></span>compute_eigs_and_cond()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::compute_eigs_and_cond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>H_orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Estimates the eigenvalues from the Hessenberg matrix, H_orig, generated during the inner iterations. Uses these estimate to compute the condition number. Calls the signals eigenvalues_signal and cond_signal with these estimates as arguments. </p>

</div>
</div>
<a id="a9f9721e9769d3ee8b603a1622f33fe8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9721e9769d3ee8b603a1622f33fe8a">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classSolverBase.html">SolverBase</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaa">SolverControl::State</a>(const unsigned <a class="el" href="classint.html">int</a> iteration, const <a class="el" href="classdouble.html">double</a> check_value, const <a class="el" href="classVectorType.html">VectorType</a> &amp;current_iterate)&gt; &amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Connect a function object that will be called periodically within iterative solvers. This function is used to attach monitors to iterative solvers, either to determine when convergence has happened, or simply to observe the progress of an iteration. See the documentation of this class for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A function object specified here will, with each call, receive the number of the current iteration, the value that is used to check for convergence (typically the residual of the current iterate with respect to the linear system to be solved) and the currently best available guess for the current iterate. Note that some solvers do not update the approximate solution in every iteration but only after convergence or failure has been determined (GMRES is an example); in such cases, the vector passed as the last argument to the signal is simply the best approximate at the time the signal is called, but not the vector that will be returned if the signal's return value indicates that the iteration should be terminated. The function object must return a <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaa">SolverControl::State</a> value that indicates whether the iteration should continue, has failed, or has succeeded. The results of all connected functions will then be combined to determine what should happen with the iteration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A connection object that represents the connection from the signal to the function object. It can be used to disconnect the function object again from the signal. See the documentation of the BOOST Signals2 library for more information on connection management. </dd></dl>

<p class="definition">Definition at line <a class="el" href="solver_8h_source.html#l00554">554</a> of file <a class="el" href="solver_8h_source.html">solver.h</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1258970549afb323a68a84ed1544ebd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1258970549afb323a68a84ed1544ebd4">&#9670;&nbsp;</a></span>additional_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSolverGMRES_1_1AdditionalData.html">AdditionalData</a> <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::additional_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Includes the maximum number of tmp vectors. </p>

<p class="definition">Definition at line <a class="el" href="solver__gmres_8h_source.html#l00317">317</a> of file <a class="el" href="solver__gmres_8h_source.html">solver_gmres.h</a>.</p>

</div>
</div>
<a id="a16c7a538d0a27e817bba2ef7d1dbc575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c7a538d0a27e817bba2ef7d1dbc575">&#9670;&nbsp;</a></span>condition_number_signal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt;void(<a class="el" href="classdouble.html">double</a>)&gt; <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::condition_number_signal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signal used to retrieve the estimated condition number. Called once when all iterations are ended. </p>

<p class="definition">Definition at line <a class="el" href="solver__gmres_8h_source.html#l00323">323</a> of file <a class="el" href="solver__gmres_8h_source.html">solver_gmres.h</a>.</p>

</div>
</div>
<a id="af3ae1d36ec2370af5ed7060d79f8b64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ae1d36ec2370af5ed7060d79f8b64a">&#9670;&nbsp;</a></span>all_condition_numbers_signal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt;void(<a class="el" href="classdouble.html">double</a>)&gt; <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::all_condition_numbers_signal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signal used to retrieve the estimated condition numbers. Called on each outer iteration. </p>

<p class="definition">Definition at line <a class="el" href="solver__gmres_8h_source.html#l00329">329</a> of file <a class="el" href="solver__gmres_8h_source.html">solver_gmres.h</a>.</p>

</div>
</div>
<a id="a2e04bf076edf526a6eb6c2e9954d6f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e04bf076edf526a6eb6c2e9954d6f6c">&#9670;&nbsp;</a></span>eigenvalues_signal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt;void(const std::vector&lt;std::complex&lt;<a class="el" href="classdouble.html">double</a>&gt;&gt; &amp;)&gt; <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::eigenvalues_signal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signal used to retrieve the estimated eigenvalues. Called once when all iterations are ended. </p>

<p class="definition">Definition at line <a class="el" href="solver__gmres_8h_source.html#l00336">336</a> of file <a class="el" href="solver__gmres_8h_source.html">solver_gmres.h</a>.</p>

</div>
</div>
<a id="aaaf671919b3400e91a5999a45c5cdb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf671919b3400e91a5999a45c5cdb34">&#9670;&nbsp;</a></span>all_eigenvalues_signal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt;void(const std::vector&lt;std::complex&lt;<a class="el" href="classdouble.html">double</a>&gt;&gt; &amp;)&gt; <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::all_eigenvalues_signal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signal used to retrieve the estimated eigenvalues. Called on each outer iteration. </p>

<p class="definition">Definition at line <a class="el" href="solver__gmres_8h_source.html#l00343">343</a> of file <a class="el" href="solver__gmres_8h_source.html">solver_gmres.h</a>.</p>

</div>
</div>
<a id="a075575ce9a3856168840a5f3d0b3f767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075575ce9a3856168840a5f3d0b3f767">&#9670;&nbsp;</a></span>hessenberg_signal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt;void(const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &amp;)&gt; <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::hessenberg_signal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signal used to retrieve the Hessenberg matrix. Called once when all iterations are ended. </p>

<p class="definition">Definition at line <a class="el" href="solver__gmres_8h_source.html#l00349">349</a> of file <a class="el" href="solver__gmres_8h_source.html">solver_gmres.h</a>.</p>

</div>
</div>
<a id="a48d7f0281e2d297e360bfac83129d3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d7f0281e2d297e360bfac83129d3ba">&#9670;&nbsp;</a></span>all_hessenberg_signal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt;void(const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &amp;)&gt; <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::all_hessenberg_signal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signal used to retrieve the Hessenberg matrix. Called on each outer iteration. </p>

<p class="definition">Definition at line <a class="el" href="solver__gmres_8h_source.html#l00356">356</a> of file <a class="el" href="solver__gmres_8h_source.html">solver_gmres.h</a>.</p>

</div>
</div>
<a id="a420bf7dc093c87df4ae351fe75ddfe2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420bf7dc093c87df4ae351fe75ddfe2a">&#9670;&nbsp;</a></span>krylov_space_signal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt;void( const <a class="el" href="classinternal_1_1SolverGMRESImplementation_1_1TmpVectors.html">internal::SolverGMRESImplementation::TmpVectors</a>&lt;<a class="el" href="classVectorType.html">VectorType</a>&gt; &amp;)&gt; <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::krylov_space_signal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signal used to retrieve the Krylov space basis vectors. Called once when all iterations are ended. </p>

<p class="definition">Definition at line <a class="el" href="solver__gmres_8h_source.html#l00364">364</a> of file <a class="el" href="solver__gmres_8h_source.html">solver_gmres.h</a>.</p>

</div>
</div>
<a id="af991ee3afc429011d575d734f72582ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af991ee3afc429011d575d734f72582ea">&#9670;&nbsp;</a></span>re_orthogonalize_signal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt;void(<a class="el" href="classint.html">int</a>)&gt; <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::re_orthogonalize_signal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signal used to retrieve a notification when the vectors are re-orthogonalized. </p>

<p class="definition">Definition at line <a class="el" href="solver__gmres_8h_source.html#l00370">370</a> of file <a class="el" href="solver__gmres_8h_source.html">solver_gmres.h</a>.</p>

</div>
</div>
<a id="add852363ae5b524d506d7aede794307f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add852363ae5b524d506d7aede794307f">&#9670;&nbsp;</a></span>H</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::H</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Projected system matrix </p>

<p class="definition">Definition at line <a class="el" href="solver__gmres_8h_source.html#l00430">430</a> of file <a class="el" href="solver__gmres_8h_source.html">solver_gmres.h</a>.</p>

</div>
</div>
<a id="a65a0ef351baf2c8205479cbbd9e4872d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a0ef351baf2c8205479cbbd9e4872d">&#9670;&nbsp;</a></span>H1</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classSolverGMRES.html">SolverGMRES</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::H1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Auxiliary matrix for inverting <code>H</code> </p>

<p class="definition">Definition at line <a class="el" href="solver__gmres_8h_source.html#l00435">435</a> of file <a class="el" href="solver__gmres_8h_source.html">solver_gmres.h</a>.</p>

</div>
</div>
<a id="acc03248bb340e9204a2429aa78dd3218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc03248bb340e9204a2429aa78dd3218">&#9670;&nbsp;</a></span>static_vector_memory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a>&lt;<a class="el" href="classVectorType.html">VectorType</a>&gt; <a class="el" href="classSolverBase.html">SolverBase</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::static_vector_memory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A static vector memory object to be used whenever no such object has been given to the constructor. </p>

<p class="definition">Definition at line <a class="el" href="solver_8h_source.html#l00415">415</a> of file <a class="el" href="solver_8h_source.html">solver.h</a>.</p>

</div>
</div>
<a id="acdb6cb40edde189c1a8efe4e7815ef86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb6cb40edde189c1a8efe4e7815ef86">&#9670;&nbsp;</a></span>memory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorMemory.html">VectorMemory</a>&lt;<a class="el" href="classVectorType.html">VectorType</a>&gt;&amp; <a class="el" href="classSolverBase.html">SolverBase</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::memory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A reference to an object that provides memory for auxiliary vectors. </p>

<p class="definition">Definition at line <a class="el" href="solver_8h_source.html#l00420">420</a> of file <a class="el" href="solver_8h_source.html">solver.h</a>.</p>

</div>
</div>
<a id="ab62a92a9cbd7c3003fe5ffb3e4fe06c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62a92a9cbd7c3003fe5ffb3e4fe06c7">&#9670;&nbsp;</a></span>iteration_status</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::signal&lt; <a class="el" href="classSolverControl.html#afcdeab4b55513dbd766b56e35efecbaa">SolverControl::State</a>(const unsigned <a class="el" href="classint.html">int</a> iteration, const <a class="el" href="classdouble.html">double</a> check_value, const <a class="el" href="classVectorType.html">VectorType</a> &amp; current_iterate), <a class="el" href="structSolverBase_1_1StateCombiner.html">StateCombiner</a>&gt; <a class="el" href="classSolverBase.html">SolverBase</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::iteration_status</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A signal that iterative solvers can execute at the end of every iteration (or in an otherwise periodic fashion) to find out whether we should continue iterating or not. The signal may call one or more slots that each will make this determination by themselves, and the result over all slots (function calls) will be determined by the StateCombiner object.</p>
<p>The arguments passed to the signal are (i) the number of the current iteration; (ii) the value that is used to determine convergence (oftentimes the residual, but in other cases other quantities may be used as long as they converge to zero as the iterate approaches the solution of the linear system); and (iii) a vector that corresponds to the current best guess for the solution at the point where the signal is called. Note that some solvers do not update the approximate solution in every iteration but only after convergence or failure has been determined (GMRES is an example); in such cases, the vector passed as the last argument to the signal is simply the best approximate at the time the signal is called, but not the vector that will be returned if the signal's return value indicates that the iteration should be terminated. </p>

<p class="definition">Definition at line <a class="el" href="solver_8h_source.html#l00471">471</a> of file <a class="el" href="solver_8h_source.html">solver.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="solver__gmres_8h_source.html">solver_gmres.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
