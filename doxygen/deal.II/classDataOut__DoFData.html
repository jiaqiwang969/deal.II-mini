<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classDataOut__DoFData.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DataOut_DoFData&lt; dim, patch_dim, spacedim, patch_spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classDataOut__DoFData-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataOut_DoFData&lt; dim, patch_dim, spacedim, patch_spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__output.html">Graphical output</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="data__out__dof__data_8h_source.html">deal.II/numerics/data_out_dof_data.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataOut_DoFData&lt; dim, patch_dim, spacedim, patch_spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classDataOut__DoFData__inherit__graph.svg" width="1927" height="240"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a062005bfe37e877e1f44e1c3e8e6cb27"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> { <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27a346ed8834d890734537f4dd6dd016ef8">type_dof_data</a>, 
<a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27a1272225f0fb10683c921dbd9f3e45980">type_cell_data</a>, 
<a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27a06a7819d088394bfea7a51fbba00f962">type_automatic</a>
 }</td></tr>
<tr class="separator:a062005bfe37e877e1f44e1c3e8e6cb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e258e00039c53ebb000c3de4a257fcf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a8e258e00039c53ebb000c3de4a257fcf">cell_iterator</a> = typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classDataOut__DoFData.html#a8e258e00039c53ebb000c3de4a257fcf">cell_iterator</a></td></tr>
<tr class="separator:a8e258e00039c53ebb000c3de4a257fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ade0bb550f4114ec376d702685cfb5b51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ade0bb550f4114ec376d702685cfb5b51">DataOut_DoFData</a> ()</td></tr>
<tr class="separator:ade0bb550f4114ec376d702685cfb5b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23da0635da2b5ba267b0ad7e9cbb53a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ac23da0635da2b5ba267b0ad7e9cbb53a">~DataOut_DoFData</a> () override</td></tr>
<tr class="separator:ac23da0635da2b5ba267b0ad7e9cbb53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed7c846331069f406b8c9933c37fda4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;)</td></tr>
<tr class="separator:a6ed7c846331069f406b8c9933c37fda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e0283e8014c775f0f7673b7a6e89b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ab3e0283e8014c775f0f7673b7a6e89b8">attach_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;)</td></tr>
<tr class="separator:ab3e0283e8014c775f0f7673b7a6e89b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cbe2f02f8dfb85026c71d783dbb703"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a79cbe2f02f8dfb85026c71d783dbb703"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const std::vector&lt; std::string &gt; &amp;names, const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> type=<a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27a06a7819d088394bfea7a51fbba00f962">type_automatic</a>, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a79cbe2f02f8dfb85026c71d783dbb703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cdf62daf18912e080ff012891ade0f"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:ae6cdf62daf18912e080ff012891ade0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ae6cdf62daf18912e080ff012891ade0f">add_data_vector</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const std::string &amp;name, const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> type=<a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27a06a7819d088394bfea7a51fbba00f962">type_automatic</a>, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:ae6cdf62daf18912e080ff012891ade0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9291a532df3e94ef08ebe750638e70"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a0a9291a532df3e94ef08ebe750638e70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a0a9291a532df3e94ef08ebe750638e70">add_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const std::vector&lt; std::string &gt; &amp;names, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a0a9291a532df3e94ef08ebe750638e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f3f6c09920c20d36c984c9123ff1e1"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a33f3f6c09920c20d36c984c9123ff1e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a33f3f6c09920c20d36c984c9123ff1e1">add_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const std::string &amp;name, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a33f3f6c09920c20d36c984c9123ff1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4983e86e29af6cbaf4a1b3bd6e9d8621"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a4983e86e29af6cbaf4a1b3bd6e9d8621"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a4983e86e29af6cbaf4a1b3bd6e9d8621">add_data_vector</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; spacedim &gt; &amp;data_postprocessor)</td></tr>
<tr class="separator:a4983e86e29af6cbaf4a1b3bd6e9d8621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c309b6a0db9808eee76ab1b6ba39239"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a3c309b6a0db9808eee76ab1b6ba39239"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a3c309b6a0db9808eee76ab1b6ba39239">add_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; spacedim &gt; &amp;data_postprocessor)</td></tr>
<tr class="separator:a3c309b6a0db9808eee76ab1b6ba39239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf39310f98aeaee50c2143ee2f68ab5"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a8cf39310f98aeaee50c2143ee2f68ab5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a8cf39310f98aeaee50c2143ee2f68ab5">add_mg_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;data, const std::vector&lt; std::string &gt; &amp;names, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a8cf39310f98aeaee50c2143ee2f68ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f8b5f94d56b40bfb67a4cdea74f764"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a99f8b5f94d56b40bfb67a4cdea74f764"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a99f8b5f94d56b40bfb67a4cdea74f764">add_mg_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;data, const std::string &amp;name)</td></tr>
<tr class="separator:a99f8b5f94d56b40bfb67a4cdea74f764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28da5487f291a1724cb4697c59c3f3d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a28da5487f291a1724cb4697c59c3f3d2">clear_data_vectors</a> ()</td></tr>
<tr class="separator:a28da5487f291a1724cb4697c59c3f3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d635fcfdbd6ebe7ccc1895524b8e615"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a8d635fcfdbd6ebe7ccc1895524b8e615">clear_input_data_references</a> ()</td></tr>
<tr class="separator:a8d635fcfdbd6ebe7ccc1895524b8e615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7605d51f91376a851ec77b0a7003aa"><td class="memTemplParams" colspan="2">template&lt;int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:a3c7605d51f91376a851ec77b0a7003aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a3c7605d51f91376a851ec77b0a7003aa">merge_patches</a> (const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim2, patch_dim, spacedim2, patch_spacedim &gt; &amp;source, const <a class="el" href="classPoint.html">Point</a>&lt; patch_spacedim &gt; &amp;shift=<a class="el" href="classPoint.html">Point</a>&lt; patch_spacedim &gt;())</td></tr>
<tr class="separator:a3c7605d51f91376a851ec77b0a7003aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ae001a1d3f270ae0d4a2b77f0d9696"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType2 &gt; </td></tr>
<tr class="memitem:aa8ae001a1d3f270ae0d4a2b77f0d9696"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#aa8ae001a1d3f270ae0d4a2b77f0d9696">merge_patches</a> (const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; DoFHandlerType2::dimension, patch_dim, DoFHandlerType2::space_dimension, patch_spacedim &gt; &amp;source, const <a class="el" href="classPoint.html">Point</a>&lt; patch_spacedim &gt; &amp;shift=<a class="el" href="classPoint.html">Point</a>&lt; patch_spacedim &gt;())</td></tr>
<tr class="separator:aa8ae001a1d3f270ae0d4a2b77f0d9696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3b3a19e7c1ed70079f8682a06b021a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a5c3b3a19e7c1ed70079f8682a06b021a">clear</a> ()</td></tr>
<tr class="separator:a5c3b3a19e7c1ed70079f8682a06b021a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bac22217cd4bf591eb5ac77d49b8fd"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a88bac22217cd4bf591eb5ac77d49b8fd">memory_consumption</a> () const</td></tr>
<tr class="separator:a88bac22217cd4bf591eb5ac77d49b8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc05be5cd920b234e68548735852446e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#afc05be5cd920b234e68548735852446e">write_dx</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:afc05be5cd920b234e68548735852446e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2031a2a6fe56c9b7d3f9f338f20882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#aea2031a2a6fe56c9b7d3f9f338f20882">write_eps</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:aea2031a2a6fe56c9b7d3f9f338f20882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f2c3305058c94333d8aa699286b807"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ae7f2c3305058c94333d8aa699286b807">write_gmv</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ae7f2c3305058c94333d8aa699286b807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85407e870a68179ebe62410d9efc153f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a85407e870a68179ebe62410d9efc153f">write_gnuplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a85407e870a68179ebe62410d9efc153f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a15f01cb0171da2956be68ad496cd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a33a15f01cb0171da2956be68ad496cd0">write_povray</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a33a15f01cb0171da2956be68ad496cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980b995a6f5944a75721097de39069c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a980b995a6f5944a75721097de39069c1">write_tecplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a980b995a6f5944a75721097de39069c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf06b8647892769140884b3ab44a08e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a2bf06b8647892769140884b3ab44a08e">write_ucd</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a2bf06b8647892769140884b3ab44a08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad99726038e4fca7f605fdffb3317e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:acad99726038e4fca7f605fdffb3317e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c780f93105e0daaa76c6c43694b4ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a93c780f93105e0daaa76c6c43694b4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df488dad82b811ceb08cb1adf9eafcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a> (const std::string &amp;filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a5df488dad82b811ceb08cb1adf9eafcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eff778443cd0431cd807c45b6ae16d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (std::ostream &amp;out, const std::vector&lt; std::string &gt; &amp;piece_names) const</td></tr>
<tr class="separator:a1eff778443cd0431cd807c45b6ae16d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0864e51eb173c87e2a3edc9391ea8009"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a> (const std::string &amp;directory, const std::string &amp;filename_without_extension, const unsigned <a class="el" href="classint.html">int</a> counter, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator, const unsigned <a class="el" href="classint.html">int</a> n_digits_for_counter=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const unsigned <a class="el" href="classint.html">int</a> n_groups=0) const</td></tr>
<tr class="separator:a0864e51eb173c87e2a3edc9391ea8009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56595d7d5aebfb2b3abfdaad51df20d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ab56595d7d5aebfb2b3abfdaad51df20d">write_svg</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ab56595d7d5aebfb2b3abfdaad51df20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affac60e1e3799ae884642113a8e2e723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#affac60e1e3799ae884642113a8e2e723">write_deal_II_intermediate</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:affac60e1e3799ae884642113a8e2e723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ef5cf2b6515c10ff080729a9901155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXDMFEntry.html">XDMFEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a45ef5cf2b6515c10ff080729a9901155">create_xdmf_entry</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;h5_filename, const <a class="el" href="classdouble.html">double</a> cur_time, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a45ef5cf2b6515c10ff080729a9901155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0b3eec5ee65bd7915c4e46272287eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXDMFEntry.html">XDMFEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a0f0b3eec5ee65bd7915c4e46272287eb">create_xdmf_entry</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;h5_mesh_filename, const std::string &amp;h5_solution_filename, const <a class="el" href="classdouble.html">double</a> cur_time, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a0f0b3eec5ee65bd7915c4e46272287eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfab5d02f11dcede67bb61ff3ae105d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#abfab5d02f11dcede67bb61ff3ae105d2">write_xdmf_file</a> (const std::vector&lt; <a class="el" href="classXDMFEntry.html">XDMFEntry</a> &gt; &amp;entries, const std::string &amp;filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:abfab5d02f11dcede67bb61ff3ae105d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29468f4e8eca1367d44b1a2431d39e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a29468f4e8eca1367d44b1a2431d39e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fdf1cc5071d85ecb2d707d798bf063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a78fdf1cc5071d85ecb2d707d798bf063">write_hdf5_parallel</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const <a class="el" href="classbool.html">bool</a> write_mesh_file, const std::string &amp;mesh_filename, const std::string &amp;solution_filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a78fdf1cc5071d85ecb2d707d798bf063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154d8192688eef96f052f50c2f669aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a154d8192688eef96f052f50c2f669aa8">write_filtered_data</a> (<a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;filtered_data) const</td></tr>
<tr class="separator:a154d8192688eef96f052f50c2f669aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e73ad285a8792ff0f9f227b82eb108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a> (std::ostream &amp;out, const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format=<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a>) const</td></tr>
<tr class="separator:a78e73ad285a8792ff0f9f227b82eb108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dab6e0fed8d4ad90d658f71a68eb32c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a6dab6e0fed8d4ad90d658f71a68eb32c">set_default_format</a> (const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> default_format)</td></tr>
<tr class="separator:a6dab6e0fed8d4ad90d658f71a68eb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7280a24690b117454acfb0fa058299c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a> (const FlagType &amp;flags)</td></tr>
<tr class="separator:ac7280a24690b117454acfb0fa058299c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36120ca3f536c90709e135161030f16c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a> (const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format=<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a>) const</td></tr>
<tr class="separator:a36120ca3f536c90709e135161030f16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a975649e4516ee7c7a67ae2f8dddd97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a> (<a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</td></tr>
<tr class="separator:a0a975649e4516ee7c7a67ae2f8dddd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1f2f1d644d9cb1c4d1714d5173d159f2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">declare_parameters</a> (<a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</td></tr>
<tr class="separator:a1f2f1d644d9cb1c4d1714d5173d159f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:af09d3320cfb06d2092ee8be96c632b8b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a> = ::<a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt; patch_dim, patch_spacedim &gt;</td></tr>
<tr class="separator:af09d3320cfb06d2092ee8be96c632b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8abd127577fe43595d9b169953b5f593"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a8abd127577fe43595d9b169953b5f593">get_patches</a> () const override</td></tr>
<tr class="separator:a8abd127577fe43595d9b169953b5f593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9ebc2f6ef4666df85bb686c7e95a90"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a6e9ebc2f6ef4666df85bb686c7e95a90">get_dataset_names</a> () const override</td></tr>
<tr class="separator:a6e9ebc2f6ef4666df85bb686c7e95a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2626aebbd6852ae06f7f407f85b615a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt;::<a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a2626aebbd6852ae06f7f407f85b615a5">get_fes</a> () const</td></tr>
<tr class="separator:a2626aebbd6852ae06f7f407f85b615a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490249234021ec9de79b356a1f7fa42e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a490249234021ec9de79b356a1f7fa42e">get_nonscalar_data_ranges</a> () const override</td></tr>
<tr class="separator:a490249234021ec9de79b356a1f7fa42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3292ed269dfb832d20ae35db4177473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ac3292ed269dfb832d20ae35db4177473">validate_dataset_names</a> () const</td></tr>
<tr class="separator:ac3292ed269dfb832d20ae35db4177473"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab87e6a1ac30aee2b4a134aeca8b38253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ab87e6a1ac30aee2b4a134aeca8b38253">triangulation</a></td></tr>
<tr class="separator:ab87e6a1ac30aee2b4a134aeca8b38253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512dc7e149e9d83b712e1707780b9afc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a512dc7e149e9d83b712e1707780b9afc">dofs</a></td></tr>
<tr class="separator:a512dc7e149e9d83b712e1707780b9afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6762a26e4dc93f133c175e271936e1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt; dim, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a4a6762a26e4dc93f133c175e271936e1">dof_data</a></td></tr>
<tr class="separator:a4a6762a26e4dc93f133c175e271936e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bbb02ee5dcd6752232e76bdecaecd4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt; dim, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a31bbb02ee5dcd6752232e76bdecaecd4">cell_data</a></td></tr>
<tr class="separator:a31bbb02ee5dcd6752232e76bdecaecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adac4a7d4453f2fe8e35a89add8590c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a3adac4a7d4453f2fe8e35a89add8590c">patches</a></td></tr>
<tr class="separator:a3adac4a7d4453f2fe8e35a89add8590c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072edd6d53d1c5a1e4c71af22a123228"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a072edd6d53d1c5a1e4c71af22a123228">default_subdivisions</a></td></tr>
<tr class="separator:a072edd6d53d1c5a1e4c71af22a123228"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a43345d23752a9c26cc4c15b69c15ce69"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a43345d23752a9c26cc4c15b69c15ce69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a43345d23752a9c26cc4c15b69c15ce69">add_data_vector_internal</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; *dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const std::vector&lt; std::string &gt; &amp;names, const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> type, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation, const <a class="el" href="classbool.html">bool</a> deduce_output_names)</td></tr>
<tr class="separator:a43345d23752a9c26cc4c15b69c15ce69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa64afbed42a6c5af21ea4bd9c7105b83"><td class="memTemplParams" colspan="2">template&lt;int , int , int , int &gt; </td></tr>
<tr class="memitem:aa64afbed42a6c5af21ea4bd9c7105b83"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#aa64afbed42a6c5af21ea4bd9c7105b83">DataOut_DoFData</a></td></tr>
<tr class="separator:aa64afbed42a6c5af21ea4bd9c7105b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae170ec886e67fab2559372e83cfacf4f"><td class="memTemplParams" colspan="2">template&lt;int , class &gt; </td></tr>
<tr class="memitem:ae170ec886e67fab2559372e83cfacf4f"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ae170ec886e67fab2559372e83cfacf4f">MGDataOut</a></td></tr>
<tr class="separator:ae170ec886e67fab2559372e83cfacf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt;<br />
class DataOut_DoFData&lt; dim, patch_dim, spacedim, patch_spacedim &gt;</h3>

<p>这是一个抽象的类，它提供了从网格上的数据向量生成基类输出的补丁的功能。它允许将一个或多个指针附加到DoFHandler上，并附加节点和单元数据，表示网格上的功能，这些功能以后将以任何实现的数据格式写入。</p>
<h3>User visible interface</h3>
<p>该类的用户可见界面允许用户以两种不同的方式指定数据。一种是让这个类知道一个DoFHandler对象，并添加数据向量，这些数据向量都对应于这个DoFHandler或网格单元，这些网格单元以后将以某种格式写入文件中。第二种方法是将一个DoFHandler对象与向量一起传递。这允许以一种整洁的方式设置来自不同DoFHandler的数据（当然，它们都需要基于相同的三角测量）。与其思考不同的函数，第一种的例子可能是最好的解释。</p>
<div class="fragment"><div class="line">...</div><div class="line">...   <span class="comment">// compute solution, which contains nodal values</span></div><div class="line">...</div><div class="line">...   <span class="comment">// compute error_estimator, which contains one value per cell</span></div><div class="line"></div><div class="line">std::vector&lt;std::string&gt; solution_names;</div><div class="line">solution_names.emplace_back (<span class="stringliteral">&quot;x-displacement&quot;</span>);</div><div class="line">solution_names.emplace_back (<span class="stringliteral">&quot;y-displacement&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a> (dof_handler);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a> (solution, solution_names);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a> (error_estimator, <span class="stringliteral">&quot;estimated_error&quot;</span>);</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a> ();</div><div class="line"></div><div class="line">ofstream output_file (<span class="stringliteral">&quot;output&quot;</span>);</div><div class="line">data_out.write_xxx (output_file);</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a5c3b3a19e7c1ed70079f8682a06b021a">clear</a>();</div></div><!-- fragment --><p><a class="el" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler()</a>告诉这个类，所有未来的操作都要通过DoFHandler对象和它所在的三角形来进行。然后我们添加解决方案向量和误差估计器；注意它们有不同的尺寸，因为解决方案是一个节点向量，这里由两个分量（"x-位移
"和 "y-位移"）组成，而误差估计器可能是一个容纳单元数据的向量。当附加一个数据向量时，你必须给向量的每个分量一个名字，这是通过一个<code>vector&lt;string&gt;/tt&gt;类型的对象作为第二个参数来完成的；如果向量中只有一个分量，例如我们像第二种情况那样添加单元数据，或者如果DoFHandler使用的有限元只有一个分量，那么你可以使用第二个add_data_vector()函数，它需要一个 <code>string</code> ] 而不是<code>vector&lt;string&gt;</code>。 <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector()</a>函数有额外的参数（有默认值），可以用来指定某些转换。特别是，它允许附加DataPostprocessor参数，以便在场将被评估的每一点上从数据向量中计算出派生信息，从而可以将其写入文件（例如，可以从密度和速度中计算出高超声速流的马赫数； <a class="el" href="step_29.html">step-29</a> ]也展示了一个例子）；另一个通过参数指定的默认值的信息是如何解释某些输出成分，即数据的每个成分在逻辑上是否是一个独立的标量场，或者其中一些成分在逻辑上是否形成一个矢量场（见 <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> 枚举，以及 <a class="el" href="step_22.html">step_22 </a>step-22"  " 教程程序）。 由于内存消耗的原因，这个类不会通过add_data_vector()函数复制给它的向量。它只存储一个引用，所以你有责任确保数据向量存在足够长的时间。 在添加完所有的数据向量后，你需要调用一个函数，该函数生成补丁（即一些中间数据表示），用于从存储的数据中输出。派生类将这个函数命名为build_patches()。最后，你以一种格式或其他方式将数据写入（）到一个文件中。 在上面的例子中，使用了一个DataOut类型的对象，也就是一个派生类的对象。这是必要的，因为当前的类并没有提供实际生成补丁的方法，只是提供了存储和访问数据的帮助。任何真正的功能都在派生类中实现，如DataOut。 请注意，这个类的基类，DataOutInterface提供了几个函数，以缓解运行时可确定的输出格式的编程（即你不需要通过调用上面例子中的 DataOutInterface::write_xxx 来使用固定的格式，但你可以通过运行时参数来选择它，而不必自己写<code>if () ... else ... </code>条款），还有一些函数和类提供了通过为每个输出格式设置标志来控制输出外观的方法。</code></p>
<p><code> </p><h3>Information for derived classes</h3>
<p></code></p>
<p><code> 这个类所缺乏的是一种从存储的数据和自由度信息中产生输出补丁的方法。因为这个任务通常是依赖于应用的，所以它被留给了派生类。例如，在许多应用中，可能希望将输出的深度限制在一定数量的细化水平上，并且仅以插值的方式将数据从较细的单元写入较粗的单元，以减少输出的数量。另外，在形成一个补丁时，可能希望在不同的单元上使用不同数量的细分，例如在不同的单元上完成对试验空间的不同多项式程度的划分。另外，输出不一定由每个单元的补丁组成，而可能是由面的补丁组成的，还有其他的东西。看看派生类在这方面有什么可能。 由于这个原因，它留给派生类提供一个函数，名称通常是build_patches()或类似的，用来填充这个类的::patches数组。 关于这个类的模板，它需要三个值：首先是三角形和DoF处理程序操作的空间维度，其次是补丁所代表的对象的维度。 虽然在大多数情况下它们是相等的，但也有一些类不成立，例如，如果一个人输出利用原域的旋转对称性的计算结果（在这种情况下，输出的空间维度将比DoF处理程序的维度高一个，见DataOut_Rotation()类），或者我们可以设想，我们可以写一个类，只输出在域的切面上的解决方案，在这种情况下，输出的空间维度小于DoF处理程序的。最后一个模板参数表示嵌入补丁的空间维度；通常，这个维度与补丁本身的维度相同（这也是模板参数的默认值），但可能有一些情况并非如此。例如，在DataOut_Faces()类中，补丁是由三角形的面生成的。因此，补丁的维度比嵌入空间的维度少一个，在这种情况下，嵌入空间的维度等于三角形和DoF处理器的维度。然而，对于上述领域的切口，如果切口是直的，那么切口可以被嵌入到一个比三角形维度低一个维度的空间中，因此最后一个模板参数的值与第二个参数相同。 </code></p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00495">495</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8e258e00039c53ebb000c3de4a257fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e258e00039c53ebb000c3de4a257fcf">&#9670;&nbsp;</a></span>cell_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::<a class="el" href="classDataOut__DoFData.html#a8e258e00039c53ebb000c3de4a257fcf">cell_iterator</a> =  typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::<a class="el" href="classDataOut__DoFData.html#a8e258e00039c53ebb000c3de4a257fcf">cell_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对所考虑的dof处理程序类的迭代器类型的类型定义。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00502">502</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="af09d3320cfb06d2092ee8be96c632b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09d3320cfb06d2092ee8be96c632b8b">&#9670;&nbsp;</a></span>Patch</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::<a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a> =  ::<a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt;patch_dim, patch_spacedim&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>缩写有点冗长的Patch类的名字。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00781">781</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a062005bfe37e877e1f44e1c3e8e6cb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062005bfe37e877e1f44e1c3e8e6cb27">&#9670;&nbsp;</a></span>DataVectorType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataOut_DoFData::DataVectorType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>描述给add_data_vector()的向量是什么的类型：在DoFHandler对象中每个自由度有一个条目的向量（如解决方案向量），或者在DoFHandler对象基础的三角形中每个单元有一个条目（如每个单元的误差数据）。值::type_automatic告诉add_data_vector()自己找出来（关于使用的方法，见add_data_vector()的文档）。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a062005bfe37e877e1f44e1c3e8e6cb27a346ed8834d890734537f4dd6dd016ef8"></a>type_dof_data&#160;</td><td class="fielddoc"><p>数据向量条目与自由度有关 </p>
</td></tr>
<tr><td class="fieldname"><a id="a062005bfe37e877e1f44e1c3e8e6cb27a1272225f0fb10683c921dbd9f3e45980"></a>type_cell_data&#160;</td><td class="fielddoc"><p>数据向量条目为每个网格单元一个 </p>
</td></tr>
<tr><td class="fieldname"><a id="a062005bfe37e877e1f44e1c3e8e6cb27a06a7819d088394bfea7a51fbba00f962"></a>type_automatic&#160;</td><td class="fielddoc"><p>自动找出 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00509">509</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ade0bb550f4114ec376d702685cfb5b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0bb550f4114ec376d702685cfb5b51">&#9670;&nbsp;</a></span>DataOut_DoFData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::<a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数 </p>

</div>
</div>
<a id="ac23da0635da2b5ba267b0ad7e9cbb53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23da0635da2b5ba267b0ad7e9cbb53a">&#9670;&nbsp;</a></span>~DataOut_DoFData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::~<a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解构器。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6ed7c846331069f406b8c9933c37fda4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed7c846331069f406b8c9933c37fda4">&#9670;&nbsp;</a></span>attach_dof_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::attach_dof_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>指定一个dof处理程序，用来提取几何数据以及节点和节点值之间的映射。如果所有添加的数据向量都补充了DoFHandler参数，那么这个调用就没有必要。 这个调用是可选的：如果你用指定的DoFHandler对象添加数据向量，那么这就包含了生成输出所需的所有信息。 </p>

</div>
</div>
<a id="ab3e0283e8014c775f0f7673b7a6e89b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e0283e8014c775f0f7673b7a6e89b8">&#9670;&nbsp;</a></span>attach_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::attach_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>指定一个用于提取几何数据和节点与节点值之间的映射的三角测量。 这个调用是可选的：如果你用指定的DoFHandler对象添加数据向量，那么这就包含了生成输出所需的所有信息。 当你只输出单元格向量而完全没有DoFHandler时，这个调用很有用，在这种情况下，它提供了几何图形。 </p>

</div>
</div>
<a id="a79cbe2f02f8dfb85026c71d783dbb703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cbe2f02f8dfb85026c71d783dbb703">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim, int patch_spacedim&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27a06a7819d088394bfea7a51fbba00f962">type_automatic</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>添加一个数据向量和它的名字。 一个指向该向量的指针被存储，所以你必须确保该向量至少在你调用<code>write_*</code>函数时存在于该地址。 假设该向量的分量与自由度处理程序中的自由度数量相同，在这种情况下，它被认为是一个存储节点数据的向量；或者大小可能是目前网格上活动单元的数量，在这种情况下，它被认为是一个单元数据向量。由于自由度和单元的数量通常不相等，函数可以自行决定给定哪种类型的向量。然而，在一些角落里，这种自动判断并不奏效。 一个例子是如果你用片状常数元素计算，并且有一个标量解决方案，那么有多少个单元就有多少个自由度（尽管它们的编号可能不同）。 另一种可能是，如果你有一个嵌入2D空间的1D网格，并且该网格由单元的封闭曲线组成；在这种情况下，有多少节点就有多少单元，当使用Q1元素时，你会有多少自由度就有多少单元。 在这种情况下，你可以将函数的最后一个参数从默认值::type_automatic改为::type_dof_data或::type_cell_data，这取决于矢量代表什么。除了这种角落里的情况，你可以把参数留在默认值上，让函数决定向量本身的类型。 如果它是一个持有DoF数据的向量，给出的名称应是底层有限元的每个分量。 如果它是一个仅由一个子元素组成的有限元，那么下面还有一个函数，它接受一个单一的名字而不是一个名字的向量。 data_component_interpretation参数包含关于如何解释由多个数据集组成的输出文件的各个组成部分的信息。 例如，如果一个人有一个2D的斯托克斯方程的有限元，代表组件（u,v,p），我们希望表明前两个，u和v，代表一个逻辑矢量，这样以后当我们生成图形输出时，我们可以把它们交给一个可视化程序，该程序将自动知道把它们作为一个矢量场来渲染，而不是作为两个独立的标量场。 这个参数的默认值（即一个空的矢量）对应于一个值的矢量 <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>, ，表示所有的输出组件都是独立的标量场。然而，如果给定的数据向量代表逻辑向量，你可以传入一个包含数值 <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>. 的向量。 在上面的例子中，人们会传入一个包含(u,v,p)的组件 (<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>) 的向量。 数据向量的名称只能包含字母、下划线和其他一些字符。请参考本类中声明的ExcInvalidCharacter异常，看看哪些字符是有效的，哪些是无效的。 </p><dl class="section note"><dt>Note</dt><dd>矢量参数的实际类型可以是任何矢量类型，FEValues可以使用 <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> 函数从单元格上提取数值。 </dd>
<dd>
当并行工作时，要写入的向量需要对本地拥有的单元上的所有自由度进行读取访问的幽灵化，详见 <a class="el" href="step_40.html">step-40</a> 或 <a class="el" href="step_37.html">step-37</a> 教程程序，即可能需要调用data.update_ghost_values（）。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00902">902</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="ae6cdf62daf18912e080ff012891ade0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cdf62daf18912e080ff012891ade0f">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim, int patch_spacedim&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27a06a7819d088394bfea7a51fbba00f962">type_automatic</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数是上面那个函数的缩写（关于各种参数的讨论见那里），旨在用于不是由子元素组成的有限元。在这种情况下，每个数据向量只需要给出一个名称，这就是这个函数的作用。它只是在将 <code>name</code> 转换为字符串矢量后，将其参数转发给上面的另一个add_data_vector()函数。 如果 <code>data</code> 是一个有多个成分的向量，这个函数将通过在 <code>name</code> 中附加下划线和每个成分的编号来为所有成分生成不同的名称。 模板参数的实际类型可以是任何向量类型，FEValues可以使用 <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> 函数在单元格中提取值。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00883">883</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a0a9291a532df3e94ef08ebe750638e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9291a532df3e94ef08ebe750638e70">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim, int patch_spacedim&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数是上面那个函数的扩展（除了第一个参数，其他参数的讨论见那里），允许用自己的DoFHandler对象设置一个向量。这个DoFHandler需要与调用 <code>add_data_vector或</code> <code>attach_dof_handler</code>, 分配的其他DoFHandler对象兼容，即所有的DoFHandler对象都需要基于相同的三角测量。这个函数允许你从描述不同解决方案组件的多个DoFHandler对象导出数据。在 <a class="el" href="step_61.html">step-61</a> 中给出了一个使用此函数的例子。 由于这个函数接受一个DoFHandler对象，因此自然地代表了dof数据，上面其他方法中出现的数据矢量类型参数就没有必要了。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00941">941</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a33f3f6c09920c20d36c984c9123ff1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f3f6c09920c20d36c984c9123ff1e1">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim, int patch_spacedim&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数是上述函数的缩写，只给出一个标量 <code>dof_handler</code> 和一个数据名称。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00920">920</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a4983e86e29af6cbaf4a1b3bd6e9d8621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4983e86e29af6cbaf4a1b3bd6e9d8621">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim, int patch_spacedim&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_postprocessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数是上述函数的一个替代品，允许输出派生量而不是给定的数据。这种转换必须在一个派生自DataPostprocessor的类中完成。这个函数在 <a class="el" href="step_29.html">step-29</a> 中使用。其他用途见 <a class="el" href="step_32.html">step-32</a> 和 <a class="el" href="step_33.html">step-33</a> 。 这些派生量的名称由 <code>data_postprocessor参数提供。同样，其他add_data_vector()函数的data_component_interpretation参数也是由data_postprocessor参数提供的。由于只有类型为</code> <code>type_dof_data</code> 的数据可以被转换，这个类型也是隐含地知道的，不需要给出。 </p><dl class="section note"><dt>Note</dt><dd>矢量参数的实际类型可以是任何矢量类型，FEValues可以使用 <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> 函数从单元格上提取数值。 </dd>
<dd>
数据后处理器对象（即实际上是你的派生类的对象）必须活到DataOut对象被销毁为止，因为后者保持着一个指向前者的指针，如果指向的对象被销毁，而后者仍有一个指向它的指针，就会抱怨。如果数据后处理器和DataOut对象都是一个函数的局部变量（例如，在 <a class="el" href="step_29.html">step-29</a> 中就是如此），那么你可以通过在DataOut变量之前声明数据后处理器变量来避免这个错误，因为对象的销毁顺序与声明顺序相反。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00961">961</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a3c309b6a0db9808eee76ab1b6ba39239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c309b6a0db9808eee76ab1b6ba39239">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_postprocessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面的函数相同，但有一个DoFHandler对象，不需要与最初设置的DoFHandler重合。注意，后处理器只能从给定的DoFHandler和求解向量中读取数据，而不是其他求解向量或DoFHandler。 </p>

</div>
</div>
<a id="a8cf39310f98aeaee50c2143ee2f68ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf39310f98aeaee50c2143ee2f68ab5">&#9670;&nbsp;</a></span>add_mg_data_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_mg_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>添加一个多级数据向量。 这个函数将属于DoFHandler <code>dof_handler的每一级的向量形式的向量值多级向量</code> <code>data</code> 添加到图形输出中。这个函数通常与调用set_cell_selection()一起使用，该函数选择的是特定层次上的单元，而不是活动单元（默认）。 矢量 <code>data</code> 可以通过几种方式获得，例如在多网格循环期间或之后使用 <a class="el" href="classMultigrid.html#a2614db3c885e19f89b2df14422634c22">Multigrid::solution</a> 或 <a class="el" href="classMultigrid.html#adecf4e39189911da5096d1112c91680b">Multigrid::defect</a> ，或者通过 <a class="el" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">MGTransferMatrixFree::interpolate_to_mg()</a>. 对解进行插值处理 <code>names</code> 和 <code>data_component_interpretation</code> 与add_data_vector（）函数相同。 </p>

</div>
</div>
<a id="a99f8b5f94d56b40bfb67a4cdea74f764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f8b5f94d56b40bfb67a4cdea74f764">&#9670;&nbsp;</a></span>add_mg_data_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_mg_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>上述函数的标量版本。 </p>

</div>
</div>
<a id="a28da5487f291a1724cb4697c59c3f3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28da5487f291a1724cb4697c59c3f3d2">&#9670;&nbsp;</a></span>clear_data_vectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::clear_data_vectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>释放指向数据向量的指针。这允许输出一组新的向量，而无需再次提供DoF处理程序。因此，DataOut对象可以在代数背景下使用。注意，除了数据向量，已经计算的补丁也会被删除。 </p>

</div>
</div>
<a id="a8d635fcfdbd6ebe7ccc1895524b8e615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d635fcfdbd6ebe7ccc1895524b8e615">&#9670;&nbsp;</a></span>clear_input_data_references()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::clear_input_data_references </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>释放指向所有输入数据元素的指针，即指向数据向量和DoF处理器对象的指针。当你调用了派生类的 <code>build_patches</code> 函数时，这个函数可能很有用，因为此时补丁已经建立，不再需要输入数据，也不需要引用它。然后你就可以从主线程中分离出来输出补丁，而不需要再确保在输出线程结束之前，DoF处理程序对象和向量不能被删除。 </p>

</div>
</div>
<a id="a3c7605d51f91376a851ec77b0a7003aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7605d51f91376a851ec77b0a7003aa">&#9670;&nbsp;</a></span>merge_patches() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim, int patch_spacedim&gt; </div>
<div class="memtemplate">
template&lt;int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::merge_patches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim2, patch_dim, spacedim2, patch_spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; patch_spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;patch_spacedim&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数可以用来将使用作为参数的对象的 <code>build_patches</code> 函数创建的补丁合并到这个对象创建的补丁列表中。例如，如果有一个领域分解算法，其中每个块都由它自己的DoFHandler表示，但人们想同时输出所有块上的解决方案，这有时是很方便的。 要做到这一点，给定的参数和这个对象需要有相同数量的输出向量，并且它们需要使用相同数量的每个补丁的细分。如果两个对象中的补丁在空间上有重叠，那么输出结果可能会看起来相当有趣。 如果你在合并补丁后为这个对象调用build_patches()，之前的状态会被覆盖，而合并的补丁会丢失。 第二个参数允许将第一个参数中传递的对象中的补丁的每个节点移动一定量。这对于生成一个区块集合的 "爆炸 "视图有时是有用的。 如果这个对象或另一个对象还没有设置任何补丁，这个函数将会失败。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00975">975</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="aa8ae001a1d3f270ae0d4a2b77f0d9696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ae001a1d3f270ae0d4a2b77f0d9696">&#9670;&nbsp;</a></span>merge_patches() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim, int patch_spacedim&gt; </div>
<div class="memtemplate">
template&lt;typename DoFHandlerType2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::merge_patches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; DoFHandlerType2::dimension, patch_dim, DoFHandlerType2::space_dimension, patch_spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; patch_spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;patch_spacedim&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000084">Deprecated:</a></b></dt><dd>用merge_patches()代替DoFHandlerType2模板。</dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l01066">1066</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a5c3b3a19e7c1ed70079f8682a06b021a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3b3a19e7c1ed70079f8682a06b021a">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>释放指向数据向量和DoF处理程序的指针。你必须使用add_data_vector()函数重新设置所有的数据条目。Dof处理程序的指针也被清空，连同所有其他数据一起。 实际上，这个函数把所有的东西都重设为一个处女状态。 </p>

</div>
</div>
<a id="a88bac22217cd4bf591eb5ac77d49b8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bac22217cd4bf591eb5ac77d49b8fd">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>确定这个对象的内存消耗（以字节为单位）的估计值。 </p>

</div>
</div>
<a id="a8abd127577fe43595d9b169953b5f593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abd127577fe43595d9b169953b5f593">&#9670;&nbsp;</a></span>get_patches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;<a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a>&gt;&amp; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::get_patches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>函数，基类的函数通过这个函数知道他们应该把哪些补丁写到文件中。 </p>

<p>Implements <a class="el" href="classDataOutInterface.html#a7c3eeef4bc56cdb85c31e05dc09dae72">DataOutInterface&lt; patch_dim, patch_spacedim &gt;</a>.</p>

</div>
</div>
<a id="a6e9ebc2f6ef4666df85bb686c7e95a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9ebc2f6ef4666df85bb686c7e95a90">&#9670;&nbsp;</a></span>get_dataset_names()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::get_dataset_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>虚拟函数，基类的输出函数通过它获得数据集的名称。 </p>

<p>Implements <a class="el" href="classDataOutInterface.html#a128e5dec286cc1a429b94e29dd55ab81">DataOutInterface&lt; patch_dim, patch_spacedim &gt;</a>.</p>

</div>
</div>
<a id="a2626aebbd6852ae06f7f407f85b615a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2626aebbd6852ae06f7f407f85b615a5">&#9670;&nbsp;</a></span>get_fes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;::<a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt;dim, spacedim&gt; &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::get_fes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>提取存储在dof_data对象中的有限元，包括一个FE_DGQ&lt;dim&gt;(0)的假对象，以防只使用三角法。 </p>

</div>
</div>
<a id="a490249234021ec9de79b356a1f7fa42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490249234021ec9de79b356a1f7fa42e">&#9670;&nbsp;</a></span>get_nonscalar_data_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::tuple&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::get_nonscalar_data_ranges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>相关的 <a class="el" href="classDataOutInterface.html#a05d5d72abcf81f4174e15fd984f1267c">DataOutInterface::get_nonscalar_data_ranges()</a> 函数的重载。参见那里有更多的文档。 </p>

<p>Reimplemented from <a class="el" href="classDataOutInterface.html#a05d5d72abcf81f4174e15fd984f1267c">DataOutInterface&lt; patch_dim, patch_spacedim &gt;</a>.</p>

</div>
</div>
<a id="a43345d23752a9c26cc4c15b69c15ce69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43345d23752a9c26cc4c15b69c15ce69">&#9670;&nbsp;</a></span>add_data_vector_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_data_vector_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>deduce_output_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>由四个公共的add_data_vector方法调用的通用函数。 </p>

</div>
</div>
<a id="afc05be5cd920b234e68548735852446e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc05be5cd920b234e68548735852446e">&#9670;&nbsp;</a></span>write_dx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_dx </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以OpenDX格式写入<code>out</code>。见 <a class="el" href="namespaceDataOutBase.html#a75750d50e3d27159f8a1e4de7f0a8f32">DataOutBase::write_dx</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07130">7130</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="aea2031a2a6fe56c9b7d3f9f338f20882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2031a2a6fe56c9b7d3f9f338f20882">&#9670;&nbsp;</a></span>write_eps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_eps </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以EPS格式写到<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#a98914588b1516419a572a1718b1bf3d5">DataOutBase::write_eps</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07182">7182</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ae7f2c3305058c94333d8aa699286b807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f2c3305058c94333d8aa699286b807">&#9670;&nbsp;</a></span>write_gmv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_gmv </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据并以GMV格式写入<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#afa4389cfc36770d2881867f6889bc348">DataOutBase::write_gmv</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07195">7195</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a85407e870a68179ebe62410d9efc153f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85407e870a68179ebe62410d9efc153f">&#9670;&nbsp;</a></span>write_gnuplot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_gnuplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获得数据并以GNUPLOT格式写入<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#a3cfd561a7b5262f83e3cdc4020b377f4">DataOutBase::write_gnuplot</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07156">7156</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a33a15f01cb0171da2956be68ad496cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a15f01cb0171da2956be68ad496cd0">&#9670;&nbsp;</a></span>write_povray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_povray </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以POVRAY格式写到<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#ae661c9d7979da0c39b5f08fd715ed947">DataOutBase::write_povray</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07169">7169</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a980b995a6f5944a75721097de39069c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980b995a6f5944a75721097de39069c1">&#9670;&nbsp;</a></span>write_tecplot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_tecplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以Tecplot格式写到<code>out</code>。见 <a class="el" href="namespaceDataOutBase.html#ab9f9f33c200120450b6844d986a83604">DataOutBase::write_tecplot</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07208">7208</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a2bf06b8647892769140884b3ab44a08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf06b8647892769140884b3ab44a08e">&#9670;&nbsp;</a></span>write_ucd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_ucd </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以UCD格式写入<code>out</code>，用于AVS。参见 <a class="el" href="namespaceDataOutBase.html#a5ec32be3e3379b7c83dc339f52cf2ad6">DataOutBase::write_ucd</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07143">7143</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="acad99726038e4fca7f605fdffb3317e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad99726038e4fca7f605fdffb3317e4">&#9670;&nbsp;</a></span>write_vtk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtk </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以Vtk格式写到<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#a336d97147011f5f8f3746cac0a3ca4ab">DataOutBase::write_vtk</a>. </p><dl class="section note"><dt>Note</dt><dd>VTK是一种遗留格式，在很大程度上已经被VTU格式（VTK的XML结构版本）所取代了。特别是，VTU允许对数据进行压缩，因此导致大文件的文件大小要比VTK文件小得多。由于所有支持VTK的可视化程序也支持VTU，你应该考虑使用后者的文件格式，通过使用write_vtu()函数来代替。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07221">7221</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a93c780f93105e0daaa76c6c43694b4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c780f93105e0daaa76c6c43694b4ae">&#9670;&nbsp;</a></span>write_vtu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtu </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以Vtu（VTK的XML）格式写到<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#a3aec479936b78bd0ec2ecc3674e24584">DataOutBase::write_vtu</a>. 一些可视化程序，如ParaView，可以读取几个独立的VTU文件以实现可视化的并行化。在这种情况下，你需要一个 <code>.pvtu</code> 文件来描述哪些VTU文件构成一个组。 <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a> 函数可以生成这样一个集中的记录。同样， <a class="el" href="namespaceDataOutBase.html#a482d9621dcc87d6a43cf8a9651e16cd8">DataOutInterface::write_visit_record()</a> 对旧版本的VisIt也有同样的作用（尽管VisIt从2.5.1版本开始也可以读取 <code>pvtu</code> 记录）。最后， <a class="el" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutInterface::write_pvd_record()</a> 可以用来将共同构成时间相关模拟的文件分组。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07232">7232</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a5df488dad82b811ceb08cb1adf9eafcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df488dad82b811ceb08cb1adf9eafcd">&#9670;&nbsp;</a></span>write_vtu_in_parallel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtu_in_parallel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>集体MPI调用，将所有参与节点（给定通信器中的节点）的解决方案写入共享文件系统上的一个压缩的.vtu文件。 该通信器可以是计算所使用的通信器的一个子通信器。 这个程序使用MPI I/O来实现并行文件系统上的高性能。也可参见 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07254">7254</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a1eff778443cd0431cd807c45b6ae16d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eff778443cd0431cd807c45b6ae16d9">&#9670;&nbsp;</a></span>write_pvtu_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_pvtu_record </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>piece_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一些可视化程序，如ParaView，可以读取几个独立的VTU文件，这些文件都是同一模拟的一部分，以实现可视化的并行化。在这种情况下，你需要一个 <code>.pvtu</code> 文件来描述哪些VTU文件（例如，通过 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> 函数写入）构成一个组。 当前的函数可以生成这样一个集中记录。 该函数生成的中央记录文件包含一个（标量或矢量）字段列表，描述哪些字段实际上可以在构成平行VTU文件组的各个文件中找到，以及这些文件的名称。这个函数通过本类的get_dataset_names()和get_nonscalar_data_ranges()函数获得字段的名称和类型。这个函数的第二个参数指定了构成平行集的文件名。 </p><dl class="section note"><dt>Note</dt><dd>使用 <a class="el" href="namespaceDataOutBase.html#a3aec479936b78bd0ec2ecc3674e24584">DataOutBase::write_vtu()</a> 和 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> 来写每一块。还要注意，只有一个并行进程需要调用当前函数，列出所有并行进程写入的文件名。 </dd>
<dd>
这个函数的使用在 <a class="el" href="step_40.html">step-40</a> 中解释。 </dd>
<dd>
为了告诉Paraview将多个 <code>pvtu</code> 文件组合在一起，每个文件描述一个与时间有关的仿真的一个时间步骤，请参见 <a class="el" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record()</a> 函数。 </dd>
<dd>
旧版本的VisIt（2.5.1之前），不能读取 <code>pvtu</code> 记录。然而，它可以读取由write_visit_record()函数写入的访问记录。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07357">7357</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a0864e51eb173c87e2a3edc9391ea8009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0864e51eb173c87e2a3edc9391ea8009">&#9670;&nbsp;</a></span>write_vtu_with_pvtu_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtu_with_pvtu_record </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_without_extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_digits_for_counter</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_groups</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数并行地写入几个.vtu文件和一个.pvtu记录，并自动构建文件名。它是 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> 或 <a class="el" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">DataOutInterface::write_vtu_in_parallel()</a>, 和 <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a>. 的组合。例如，在10个进程中运行<code> write_vtu_with_pvtu_record("output/", "solution", 3, comm, 4, 2) </code>会生成这些文件 </p><div class="fragment"><div class="line">output/solution_0003.0.<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a></div><div class="line">output/solution_0003.1.<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a></div><div class="line">output/solution_0003.pvtu</div></div><!-- fragment --><p> 其中<code>.0.vtu</code>文件包含前一半进程的输出分组，而<code>.1.vtu</code>是其余一半进程的数据。 一个指定的 <code>directory</code> 和一个 <code>filename_without_extension</code> 构成文件名的第一部分。然后用 <code>counter</code> 扩展文件名，标明当前的时间步数/迭代次数/等等，处理器ID，最后是.vtu/.pvtu结尾。由于要写入的时间步数取决于应用，在文件名中保留的数字可以作为参数 <code>n_digits_for_counter</code>, 来指定，如果该参数保持默认值，则数字不加前导零 <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>. 如果需要一个以上的文件标识符（例如时间步数和求解器的迭代计数器），最后一个标识符作为 <code>counter</code>, 使用，而所有其他标识符必须在调用该函数时加入 <code>filename_without_extension</code> 。 在并行设置中，每个时间步长通常要写几个文件。并行写入的文件数量取决于MPI进程的数量（见参数 <code>mpi_communicator</code>), 和默认值为0的指定数量 <code>n_groups</code> 。其背景是VTU文件输出支持在并行文件系统上写入时，使用MPI I/O将几个CPU的文件分组为给定数量的文件。 <code>n_groups</code> 的默认值是0，意味着每个MPI等级将写入一个文件。1的值将生成一个包含整个域的解决方案的大文件，而更大的值将创建 <code>n_groups</code> 个文件（但不会超过MPI等级的数量）。 请注意，只有一个处理器需要生成.pvtu文件，其中零号处理器被选择来承担这项工作。 返回值是pvtu记录的集中文件的文件名。 </p><dl class="section note"><dt>Note</dt><dd>代码简单地结合了字符串 <code>directory</code> 和 <code>filename_without_extension</code>, ，即用户必须确保 <code>directory</code> 包含一个尾部字符，例如"/"，将目录和文件名分开。 </dd>
<dd>
如果要将输出写入当前工作目录，则使用空字符串""作为第一个参数。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07370">7370</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ab56595d7d5aebfb2b3abfdaad51df20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56595d7d5aebfb2b3abfdaad51df20d">&#9670;&nbsp;</a></span>write_svg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_svg </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以SVG格式写到<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#ad20ab1f2f5ec29122aefe1f016ff6eac">DataOutBase::write_svg</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07243">7243</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="affac60e1e3799ae884642113a8e2e723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affac60e1e3799ae884642113a8e2e723">&#9670;&nbsp;</a></span>write_deal_II_intermediate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_deal_II_intermediate </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以deal.II中间格式写到&lt;tt&gt;out中。参见 <a class="el" href="namespaceDataOutBase.html#a70b0a895fd8b48c1555fa1c34f2cd176">DataOutBase::write_deal_II_intermediate</a>. 注意，中间格式就像它的名字一样：内部数据的直接表示。它不是标准化的，每当我们改变内部表示时，它就会改变。你只能期望使用用于编写的相同版本的deal.II来处理以这种格式编写的文件。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07452">7452</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a45ef5cf2b6515c10ff080729a9901155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ef5cf2b6515c10ff080729a9901155">&#9670;&nbsp;</a></span>create_xdmf_entry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXDMFEntry.html">XDMFEntry</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::create_xdmf_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>h5_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>cur_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>基于data_filter中的数据创建一个XDMFEntry。这假设网格和求解数据被写到一个文件中。参见write_xdmf_file()中的使用实例。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07465">7465</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a0f0b3eec5ee65bd7915c4e46272287eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0b3eec5ee65bd7915c4e46272287eb">&#9670;&nbsp;</a></span>create_xdmf_entry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXDMFEntry.html">XDMFEntry</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::create_xdmf_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>h5_mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>h5_solution_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>cur_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>基于data_filter中的数据，创建一个XDMFEntry。这假设网格和解的数据被写入不同的文件。参见write_xdmf_file()中的使用实例。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07479">7479</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="abfab5d02f11dcede67bb61ff3ae105d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfab5d02f11dcede67bb61ff3ae105d2">&#9670;&nbsp;</a></span>write_xdmf_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_xdmf_file </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classXDMFEntry.html">XDMFEntry</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>根据提供的XDMFEntry对象的向量，写一个XDMF文件。 下面是一个如何用HDF5和DataOutFilter使用这个函数的例子。 </p><div class="fragment"><div class="line"><a class="code" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutBase::DataOutFilterFlags</a> flags(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> data_filter(flags);</div><div class="line">std::vector&lt;XDMFEntry&gt; xdmf_entries;</div><div class="line"><span class="comment">// Filter the data and store it in data_filter</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a154d8192688eef96f052f50c2f669aa8">write_filtered_data</a>(data_filter);</div><div class="line"><span class="comment">// Write the filtered data to HDF5</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a>(data_filter, <span class="stringliteral">&quot;solution.h5&quot;</span>, MPI_COMM_WORLD);</div><div class="line"><span class="comment">// Create an XDMF entry detailing the HDF5 file</span></div><div class="line"><span class="keyword">auto</span> new_xdmf_entry = data_out.<a class="code" href="classDataOutInterface.html#a45ef5cf2b6515c10ff080729a9901155">create_xdmf_entry</a>(data_filter,</div><div class="line">                                               <span class="stringliteral">&quot;solution.h5&quot;</span>,</div><div class="line">                                               simulation_time,</div><div class="line">                                               MPI_COMM_WORLD);</div><div class="line"><span class="comment">// Add the XDMF entry to the list</span></div><div class="line">xdmf_entries.push_back(new_xdmf_entry);</div><div class="line"><span class="comment">// Create an XDMF file from all stored entries</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#abfab5d02f11dcede67bb61ff3ae105d2">write_xdmf_file</a>(xdmf_entries, <span class="stringliteral">&quot;solution.xdmf&quot;</span>, MPI_COMM_WORLD);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07552">7552</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a29468f4e8eca1367d44b1a2431d39e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29468f4e8eca1367d44b1a2431d39e91">&#9670;&nbsp;</a></span>write_hdf5_parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将 <code>data_filter</code> 中的数据写入一个单一的HDF5文件，包含网格和解的数值。下面是一个如何使用这个函数与DataOutFilter的例子。 </p><div class="fragment"><div class="line"><a class="code" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutBase::DataOutFilterFlags</a> flags(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> data_filter(flags);</div><div class="line"><span class="comment">// Filter the data and store it in data_filter</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a154d8192688eef96f052f50c2f669aa8">write_filtered_data</a>(data_filter);</div><div class="line"><span class="comment">// Write the filtered data to HDF5</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a>(data_filter, <span class="stringliteral">&quot;solution.h5&quot;</span>, MPI_COMM_WORLD);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07730">7730</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a78fdf1cc5071d85ecb2d707d798bf063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fdf1cc5071d85ecb2d707d798bf063">&#9670;&nbsp;</a></span>write_hdf5_parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>write_mesh_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solution_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将data_filter中的数据写到HDF5文件中。如果write_mesh_file为false，网格数据将不会被写入，而解文件将只包含解的数值。如果write_mesh_file为true，且文件名相同，则生成的文件将同时包含网格数据和求解值。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07742">7742</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a154d8192688eef96f052f50c2f669aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154d8192688eef96f052f50c2f669aa8">&#9670;&nbsp;</a></span>write_filtered_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_filtered_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filtered_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DataOutFilter是一种中间数据格式，可以减少将被写入文件的数据量。这个函数所填充的对象随后可以再次用于写入具体文件格式的数据；例如，见 <a class="el" href="namespaceDataOutBase.html#af5a956cffba0fa383f85a82bb2a4ca63">DataOutBase::write_hdf5_parallel()</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07602">7602</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a78e73ad285a8792ff0f9f227b82eb108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e73ad285a8792ff0f9f227b82eb108">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td>
          <td class="paramname"><em>output_format</em> = <code><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>根据给定的数据格式向<code>out</code>写入数据和网格。 这个函数只是调用相应的<code>write_*</code>函数。如果没有要求输出格式，将写入<code>default_format</code>。 如果没有提供格式，而默认格式是<code>default_format</code>，则会发生错误。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08134">8134</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a6dab6e0fed8d4ad90d658f71a68eb32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dab6e0fed8d4ad90d658f71a68eb32c">&#9670;&nbsp;</a></span>set_default_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::set_default_format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td>
          <td class="paramname"><em>default_format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置默认格式。这里设置的值在任何时候都会被使用，要求输出格式为<code>default_format</code>。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08200">8200</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ac7280a24690b117454acfb0fa058299c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7280a24690b117454acfb0fa058299c">&#9670;&nbsp;</a></span>set_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::set_flags </td>
          <td>(</td>
          <td class="paramtype">const FlagType &amp;&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置用于输出的标志。这个方法希望<code>flags</code>是<code>OutputFlagsBase</code>的一个子类中的成员。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08210">8210</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a36120ca3f536c90709e135161030f16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36120ca3f536c90709e135161030f16c">&#9670;&nbsp;</a></span>default_suffix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::default_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td>
          <td class="paramname"><em>output_format</em> = <code><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个函数，返回与基类中相应函数相同的字符串；唯一的例外是，如果省略了参数，则返回当前默认格式的值，即在调用此函数之前通过set_default_format()或parse_parameters()设置的格式的正确后缀。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08245">8245</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a1f2f1d644d9cb1c4d1714d5173d159f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2f1d644d9cb1c4d1714d5173d159f2">&#9670;&nbsp;</a></span>declare_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::declare_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过在每个输出格式的参数文件中声明子段来声明所有输出格式的参数，并调用每个输出格式的标志类的相应<code>declare_parameters</code>函数。 如果相应的格式不输出任何标志，那么某些声明的子段可能不包含条目。 请注意，表示每个补丁的分区数量和输出格式的顶层参数没有被声明，因为它们只被传递给虚拟函数，而不被存储在这种类型的对象中。你必须自己声明它们。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08258">8258</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a0a975649e4516ee7c7a67ae2f8dddd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a975649e4516ee7c7a67ae2f8dddd97">&#9670;&nbsp;</a></span>parse_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::parse_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>读取 <a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">declare_parameters()</a> 中声明的参数，并为输出格式设置相应的标志。 这样得到的标志会覆盖之前所有默认构建的或由set_flags()函数设置的标志对象的内容。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08311">8311</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ac3292ed269dfb832d20ae35db4177473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3292ed269dfb832d20ae35db4177473">&#9670;&nbsp;</a></span>validate_dataset_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::validate_dataset_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>验证get_dataset_names()和get_nonscalar_data_ranges()返回的数据集的名称是否有效。目前这包括检查名称是否被多次使用。如果遇到一个无效的状态，将在调试模式下触发一个Assert()。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08393">8393</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aa64afbed42a6c5af21ea4bd9c7105b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64afbed42a6c5af21ea4bd9c7105b83">&#9670;&nbsp;</a></span>DataOut_DoFData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<div class="memtemplate">
template&lt;int , int , int , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000085">Deprecated:</a></b></dt><dd>使用没有DoFHandlerType模板的 <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a> 代替。</dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00853">853</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="ae170ec886e67fab2559372e83cfacf4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae170ec886e67fab2559372e83cfacf4f">&#9670;&nbsp;</a></span>MGDataOut</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<div class="memtemplate">
template&lt;int , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class MGDataOut</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00858">858</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab87e6a1ac30aee2b4a134aeca8b38253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87e6a1ac30aee2b4a134aeca8b38253">&#9670;&nbsp;</a></span>triangulation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::triangulation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向三角测量对象的指针。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00787">787</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a512dc7e149e9d83b712e1707780b9afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512dc7e149e9d83b712e1707780b9afc">&#9670;&nbsp;</a></span>dofs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::dofs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向可选的处理程序对象的指针。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00793">793</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a4a6762a26e4dc93f133c175e271936e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6762a26e4dc93f133c175e271936e1">&#9670;&nbsp;</a></span>dof_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt;dim, spacedim&gt; &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::dof_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>带有每个自由度数值向量的数据元素的列表。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00801">801</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a31bbb02ee5dcd6752232e76bdecaecd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31bbb02ee5dcd6752232e76bdecaecd4">&#9670;&nbsp;</a></span>cell_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt;dim, spacedim&gt; &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::cell_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>带有每个单元值向量的数据元素的列表。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00809">809</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a3adac4a7d4453f2fe8e35a89add8590c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adac4a7d4453f2fe8e35a89add8590c">&#9670;&nbsp;</a></span>patches</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int patch_dim, int spacedim = dim, int patch_spacedim = patch_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a>&gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::patches</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这是一个补丁列表，每次调用build_patches()时都会创建一个补丁。这些补丁在基类的输出例程中使用。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00815">815</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a072edd6d53d1c5a1e4c71af22a123228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072edd6d53d1c5a1e4c71af22a123228">&#9670;&nbsp;</a></span>default_subdivisions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::default_subdivisions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>补丁的默认分区数。这是由parse_parameters()填充的，并且应该被派生类中的build_patches()遵守。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l02440">2440</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/numerics/<a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
