<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classDataOutFaces.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DataOutFaces&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDataOutFaces-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataOutFaces&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__output.html">Graphical output</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="data__out__faces_8h_source.html">deal.II/numerics/data_out_faces.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataOutFaces&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classDataOutFaces__inherit__graph.svg" width="1443" height="100"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2e21509efc66035d0edd456ee57af48b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutFaces.html#a2e21509efc66035d0edd456ee57af48b">cell_iterator</a> = typename <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::<a class="el" href="classDataOutFaces.html#a2e21509efc66035d0edd456ee57af48b">cell_iterator</a></td></tr>
<tr class="separator:a2e21509efc66035d0edd456ee57af48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b032789cecdae4344783a34cdf8712"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutFaces.html#a67b032789cecdae4344783a34cdf8712">FaceDescriptor</a> = typename std::pair&lt; <a class="el" href="classDataOutFaces.html#a2e21509efc66035d0edd456ee57af48b">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;</td></tr>
<tr class="separator:a67b032789cecdae4344783a34cdf8712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062005bfe37e877e1f44e1c3e8e6cb27"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> </td></tr>
<tr class="separator:a062005bfe37e877e1f44e1c3e8e6cb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adebf4a7dae2b492e5bc6a15ac62caa41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutFaces.html#adebf4a7dae2b492e5bc6a15ac62caa41">DataOutFaces</a> (const <a class="el" href="classbool.html">bool</a> <a class="el" href="classDataOutFaces.html#a666a918df0f8acf7373c0cf21250e4b7">surface_only</a>=true)</td></tr>
<tr class="separator:adebf4a7dae2b492e5bc6a15ac62caa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99986520842823e0e2f933084ee6317e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutFaces.html#a99986520842823e0e2f933084ee6317e">build_patches</a> (const unsigned <a class="el" href="classint.html">int</a> n_subdivisions=0)</td></tr>
<tr class="separator:a99986520842823e0e2f933084ee6317e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b4bc35f4ec57f4a2141e59298e9f42"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutFaces.html#a01b4bc35f4ec57f4a2141e59298e9f42">build_patches</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const unsigned <a class="el" href="classint.html">int</a> n_subdivisions=0)</td></tr>
<tr class="separator:a01b4bc35f4ec57f4a2141e59298e9f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53579b046aa2618f92631a029fb7a14"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDataOutFaces.html#a67b032789cecdae4344783a34cdf8712">FaceDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutFaces.html#ae53579b046aa2618f92631a029fb7a14">first_face</a> ()</td></tr>
<tr class="separator:ae53579b046aa2618f92631a029fb7a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56504e26abcc6789e45204195d67ce4d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDataOutFaces.html#a67b032789cecdae4344783a34cdf8712">FaceDescriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutFaces.html#a56504e26abcc6789e45204195d67ce4d">next_face</a> (const <a class="el" href="classDataOutFaces.html#a67b032789cecdae4344783a34cdf8712">FaceDescriptor</a> &amp;face)</td></tr>
<tr class="separator:a56504e26abcc6789e45204195d67ce4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed7c846331069f406b8c9933c37fda4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;)</td></tr>
<tr class="separator:a6ed7c846331069f406b8c9933c37fda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e0283e8014c775f0f7673b7a6e89b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ab3e0283e8014c775f0f7673b7a6e89b8">attach_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;)</td></tr>
<tr class="separator:ab3e0283e8014c775f0f7673b7a6e89b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cbe2f02f8dfb85026c71d783dbb703"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const std::vector&lt; std::string &gt; &amp;names, const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> type=<a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27a06a7819d088394bfea7a51fbba00f962">type_automatic</a>, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a79cbe2f02f8dfb85026c71d783dbb703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cdf62daf18912e080ff012891ade0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ae6cdf62daf18912e080ff012891ade0f">add_data_vector</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const std::string &amp;name, const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> type=<a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27a06a7819d088394bfea7a51fbba00f962">type_automatic</a>, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:ae6cdf62daf18912e080ff012891ade0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9291a532df3e94ef08ebe750638e70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a0a9291a532df3e94ef08ebe750638e70">add_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const std::vector&lt; std::string &gt; &amp;names, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a0a9291a532df3e94ef08ebe750638e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f3f6c09920c20d36c984c9123ff1e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a33f3f6c09920c20d36c984c9123ff1e1">add_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const std::string &amp;name, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a33f3f6c09920c20d36c984c9123ff1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4983e86e29af6cbaf4a1b3bd6e9d8621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a4983e86e29af6cbaf4a1b3bd6e9d8621">add_data_vector</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; spacedim &gt; &amp;data_postprocessor)</td></tr>
<tr class="separator:a4983e86e29af6cbaf4a1b3bd6e9d8621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c309b6a0db9808eee76ab1b6ba39239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a3c309b6a0db9808eee76ab1b6ba39239">add_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; spacedim &gt; &amp;data_postprocessor)</td></tr>
<tr class="separator:a3c309b6a0db9808eee76ab1b6ba39239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf39310f98aeaee50c2143ee2f68ab5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a8cf39310f98aeaee50c2143ee2f68ab5">add_mg_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;data, const std::vector&lt; std::string &gt; &amp;names, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a8cf39310f98aeaee50c2143ee2f68ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f8b5f94d56b40bfb67a4cdea74f764"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a99f8b5f94d56b40bfb67a4cdea74f764">add_mg_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;data, const std::string &amp;name)</td></tr>
<tr class="separator:a99f8b5f94d56b40bfb67a4cdea74f764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28da5487f291a1724cb4697c59c3f3d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a28da5487f291a1724cb4697c59c3f3d2">clear_data_vectors</a> ()</td></tr>
<tr class="separator:a28da5487f291a1724cb4697c59c3f3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d635fcfdbd6ebe7ccc1895524b8e615"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a8d635fcfdbd6ebe7ccc1895524b8e615">clear_input_data_references</a> ()</td></tr>
<tr class="separator:a8d635fcfdbd6ebe7ccc1895524b8e615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7605d51f91376a851ec77b0a7003aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a3c7605d51f91376a851ec77b0a7003aa">merge_patches</a> (const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim2, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim2, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt; &amp;source, const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt; &amp;shift=<a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;())</td></tr>
<tr class="separator:a3c7605d51f91376a851ec77b0a7003aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ae001a1d3f270ae0d4a2b77f0d9696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#aa8ae001a1d3f270ae0d4a2b77f0d9696">merge_patches</a> (const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; DoFHandlerType2::dimension, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, DoFHandlerType2::space_dimension, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt; &amp;source, const <a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt; &amp;shift=<a class="el" href="classPoint.html">Point</a>&lt; <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;())</td></tr>
<tr class="separator:aa8ae001a1d3f270ae0d4a2b77f0d9696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3b3a19e7c1ed70079f8682a06b021a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a5c3b3a19e7c1ed70079f8682a06b021a">clear</a> ()</td></tr>
<tr class="separator:a5c3b3a19e7c1ed70079f8682a06b021a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bac22217cd4bf591eb5ac77d49b8fd"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a88bac22217cd4bf591eb5ac77d49b8fd">memory_consumption</a> () const</td></tr>
<tr class="separator:a88bac22217cd4bf591eb5ac77d49b8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc05be5cd920b234e68548735852446e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#afc05be5cd920b234e68548735852446e">write_dx</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:afc05be5cd920b234e68548735852446e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2031a2a6fe56c9b7d3f9f338f20882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#aea2031a2a6fe56c9b7d3f9f338f20882">write_eps</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:aea2031a2a6fe56c9b7d3f9f338f20882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f2c3305058c94333d8aa699286b807"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ae7f2c3305058c94333d8aa699286b807">write_gmv</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ae7f2c3305058c94333d8aa699286b807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85407e870a68179ebe62410d9efc153f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a85407e870a68179ebe62410d9efc153f">write_gnuplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a85407e870a68179ebe62410d9efc153f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a15f01cb0171da2956be68ad496cd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a33a15f01cb0171da2956be68ad496cd0">write_povray</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a33a15f01cb0171da2956be68ad496cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980b995a6f5944a75721097de39069c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a980b995a6f5944a75721097de39069c1">write_tecplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a980b995a6f5944a75721097de39069c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf06b8647892769140884b3ab44a08e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a2bf06b8647892769140884b3ab44a08e">write_ucd</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a2bf06b8647892769140884b3ab44a08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad99726038e4fca7f605fdffb3317e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:acad99726038e4fca7f605fdffb3317e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c780f93105e0daaa76c6c43694b4ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a93c780f93105e0daaa76c6c43694b4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df488dad82b811ceb08cb1adf9eafcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a> (const std::string &amp;filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a5df488dad82b811ceb08cb1adf9eafcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eff778443cd0431cd807c45b6ae16d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (std::ostream &amp;out, const std::vector&lt; std::string &gt; &amp;piece_names) const</td></tr>
<tr class="separator:a1eff778443cd0431cd807c45b6ae16d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0864e51eb173c87e2a3edc9391ea8009"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a> (const std::string &amp;directory, const std::string &amp;filename_without_extension, const unsigned <a class="el" href="classint.html">int</a> counter, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator, const unsigned <a class="el" href="classint.html">int</a> n_digits_for_counter=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const unsigned <a class="el" href="classint.html">int</a> n_groups=0) const</td></tr>
<tr class="separator:a0864e51eb173c87e2a3edc9391ea8009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56595d7d5aebfb2b3abfdaad51df20d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ab56595d7d5aebfb2b3abfdaad51df20d">write_svg</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ab56595d7d5aebfb2b3abfdaad51df20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affac60e1e3799ae884642113a8e2e723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#affac60e1e3799ae884642113a8e2e723">write_deal_II_intermediate</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:affac60e1e3799ae884642113a8e2e723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ef5cf2b6515c10ff080729a9901155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXDMFEntry.html">XDMFEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a45ef5cf2b6515c10ff080729a9901155">create_xdmf_entry</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;h5_filename, const <a class="el" href="classdouble.html">double</a> cur_time, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a45ef5cf2b6515c10ff080729a9901155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0b3eec5ee65bd7915c4e46272287eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXDMFEntry.html">XDMFEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a0f0b3eec5ee65bd7915c4e46272287eb">create_xdmf_entry</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;h5_mesh_filename, const std::string &amp;h5_solution_filename, const <a class="el" href="classdouble.html">double</a> cur_time, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a0f0b3eec5ee65bd7915c4e46272287eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfab5d02f11dcede67bb61ff3ae105d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#abfab5d02f11dcede67bb61ff3ae105d2">write_xdmf_file</a> (const std::vector&lt; <a class="el" href="classXDMFEntry.html">XDMFEntry</a> &gt; &amp;entries, const std::string &amp;filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:abfab5d02f11dcede67bb61ff3ae105d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29468f4e8eca1367d44b1a2431d39e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a29468f4e8eca1367d44b1a2431d39e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fdf1cc5071d85ecb2d707d798bf063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a78fdf1cc5071d85ecb2d707d798bf063">write_hdf5_parallel</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const <a class="el" href="classbool.html">bool</a> write_mesh_file, const std::string &amp;mesh_filename, const std::string &amp;solution_filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a78fdf1cc5071d85ecb2d707d798bf063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154d8192688eef96f052f50c2f669aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a154d8192688eef96f052f50c2f669aa8">write_filtered_data</a> (<a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;filtered_data) const</td></tr>
<tr class="separator:a154d8192688eef96f052f50c2f669aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e73ad285a8792ff0f9f227b82eb108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a> (std::ostream &amp;out, const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format=<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a>) const</td></tr>
<tr class="separator:a78e73ad285a8792ff0f9f227b82eb108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dab6e0fed8d4ad90d658f71a68eb32c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a6dab6e0fed8d4ad90d658f71a68eb32c">set_default_format</a> (const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> default_format)</td></tr>
<tr class="separator:a6dab6e0fed8d4ad90d658f71a68eb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7280a24690b117454acfb0fa058299c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a> (const FlagType &amp;flags)</td></tr>
<tr class="separator:ac7280a24690b117454acfb0fa058299c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36120ca3f536c90709e135161030f16c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a> (const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format=<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a>) const</td></tr>
<tr class="separator:a36120ca3f536c90709e135161030f16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a975649e4516ee7c7a67ae2f8dddd97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a> (<a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</td></tr>
<tr class="separator:a0a975649e4516ee7c7a67ae2f8dddd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1f2f1d644d9cb1c4d1714d5173d159f2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">declare_parameters</a> (<a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</td></tr>
<tr class="separator:a1f2f1d644d9cb1c4d1714d5173d159f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a017a2140a823793072507240a8fc619a"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a> = dim - 1</td></tr>
<tr class="separator:a017a2140a823793072507240a8fc619a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33d49fd332116eafa8a3b15554d5e97"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> = spacedim</td></tr>
<tr class="separator:ab33d49fd332116eafa8a3b15554d5e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:af09d3320cfb06d2092ee8be96c632b8b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a> = ::<a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt; <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;</td></tr>
<tr class="separator:af09d3320cfb06d2092ee8be96c632b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8abd127577fe43595d9b169953b5f593"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a8abd127577fe43595d9b169953b5f593">get_patches</a> () const override</td></tr>
<tr class="separator:a8abd127577fe43595d9b169953b5f593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9ebc2f6ef4666df85bb686c7e95a90"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a6e9ebc2f6ef4666df85bb686c7e95a90">get_dataset_names</a> () const override</td></tr>
<tr class="separator:a6e9ebc2f6ef4666df85bb686c7e95a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2626aebbd6852ae06f7f407f85b615a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt;::<a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a2626aebbd6852ae06f7f407f85b615a5">get_fes</a> () const</td></tr>
<tr class="separator:a2626aebbd6852ae06f7f407f85b615a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490249234021ec9de79b356a1f7fa42e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a490249234021ec9de79b356a1f7fa42e">get_nonscalar_data_ranges</a> () const override</td></tr>
<tr class="separator:a490249234021ec9de79b356a1f7fa42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3292ed269dfb832d20ae35db4177473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ac3292ed269dfb832d20ae35db4177473">validate_dataset_names</a> () const</td></tr>
<tr class="separator:ac3292ed269dfb832d20ae35db4177473"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab87e6a1ac30aee2b4a134aeca8b38253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ab87e6a1ac30aee2b4a134aeca8b38253">triangulation</a></td></tr>
<tr class="separator:ab87e6a1ac30aee2b4a134aeca8b38253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512dc7e149e9d83b712e1707780b9afc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a512dc7e149e9d83b712e1707780b9afc">dofs</a></td></tr>
<tr class="separator:a512dc7e149e9d83b712e1707780b9afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6762a26e4dc93f133c175e271936e1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt; dim, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a4a6762a26e4dc93f133c175e271936e1">dof_data</a></td></tr>
<tr class="separator:a4a6762a26e4dc93f133c175e271936e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bbb02ee5dcd6752232e76bdecaecd4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt; dim, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a31bbb02ee5dcd6752232e76bdecaecd4">cell_data</a></td></tr>
<tr class="separator:a31bbb02ee5dcd6752232e76bdecaecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adac4a7d4453f2fe8e35a89add8590c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a3adac4a7d4453f2fe8e35a89add8590c">patches</a></td></tr>
<tr class="separator:a3adac4a7d4453f2fe8e35a89add8590c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072edd6d53d1c5a1e4c71af22a123228"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a072edd6d53d1c5a1e4c71af22a123228">default_subdivisions</a></td></tr>
<tr class="separator:a072edd6d53d1c5a1e4c71af22a123228"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0e5a2c5c256a3e0d5fc0666b402f60fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutFaces.html#a0e5a2c5c256a3e0d5fc0666b402f60fa">build_one_patch</a> (const <a class="el" href="classDataOutFaces.html#a67b032789cecdae4344783a34cdf8712">FaceDescriptor</a> *cell_and_face, <a class="el" href="structinternal_1_1DataOutFacesImplementation_1_1ParallelData.html">internal::DataOutFacesImplementation::ParallelData</a>&lt; dim, spacedim &gt; &amp;data, <a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt; <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt; &amp;patch)</td></tr>
<tr class="separator:a0e5a2c5c256a3e0d5fc0666b402f60fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a666a918df0f8acf7373c0cf21250e4b7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutFaces.html#a666a918df0f8acf7373c0cf21250e4b7">surface_only</a></td></tr>
<tr class="separator:a666a918df0f8acf7373c0cf21250e4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class DataOutFaces&lt; dim, spacedim &gt;</h3>

<p>这个类从三角形的面生成输出。它可能只用于生成三角形表面的输出（这是该类的默认值），或者用于活动单元的所有面，如构造函数中指定的那样。这个类的输出是一组补丁（如类 <a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch()</a>), 所定义的，每个面都要生成输出。这些补丁可以通过基础类的功能写成几种图形数据格式。 </p><h3>Interface</h3>
<p>这个类的接口是从DataOut类复制过来的。此外，它们共享共同的父类DataOut_DoFData。关于接口的讨论，请看这两个类的参考资料。</p>
<h3>Extending this class</h3>
<p>生成补丁的面的序列是以与DataOut类相同的方式生成的；关于各自接口的描述见那里。产生面片序列的函数将被用于生成输出，这些函数被称为first_face()和next_face()。 由于我们需要用这些函数生成的面来初始化FEValues类型的对象，所以它们只返回面的迭代器是不够的。相反，我们需要一对单元格和面的编号，因为有限元场的值在一个面上不一定是唯一的（想想不连续的有限元，有限元场的值取决于你接近一个面的方向，因此有必要使用一对单元格和面，而不是只有一个面的迭代器）。因此，这个类定义了一个 <code>alias</code> ，它创建了一个类型 <code>FaceDescriptor</code> ，是一对单元格迭代器和面数的缩写。函数 <code>first_face</code> 和 <code>next_face</code> 对该类型的对象进行操作。 例如，如果你只想从边界的某些部分输出，例如由各自面的边界指示器指示的，那么扩展这个类可能是有用的。然而，我们也可以想象，我们不是从边界面生成补丁，而是从根据其他标准选择的内部面生成补丁；一种应用可能是只使用那些解的一个分量达到某个值的面，以便在这些面上显示其他解分量的值。其他的应用当然也存在，对于这些应用，作者没有足够的想象力。 </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000035">Todo:</a></b></dt><dd>使用实际的FEFaceValues和MeshWorker重新实现这整个类。</dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__faces_8h_source.html#l00080">80</a> of file <a class="el" href="data__out__faces_8h_source.html">data_out_faces.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2e21509efc66035d0edd456ee57af48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e21509efc66035d0edd456ee57af48b">&#9670;&nbsp;</a></span>cell_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDataOutFaces.html">DataOutFaces</a>&lt; dim, spacedim &gt;::<a class="el" href="classDataOutFaces.html#a2e21509efc66035d0edd456ee57af48b">cell_iterator</a> =  typename <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt;dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a>&gt;:: <a class="el" href="classDataOutFaces.html#a2e21509efc66035d0edd456ee57af48b">cell_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对所考虑的dof处理程序类的迭代器类型的别名。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__faces_8h_source.html#l00098">98</a> of file <a class="el" href="data__out__faces_8h_source.html">data_out_faces.h</a>.</p>

</div>
</div>
<a id="a67b032789cecdae4344783a34cdf8712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b032789cecdae4344783a34cdf8712">&#9670;&nbsp;</a></span>FaceDescriptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDataOutFaces.html">DataOutFaces</a>&lt; dim, spacedim &gt;::<a class="el" href="classDataOutFaces.html#a67b032789cecdae4344783a34cdf8712">FaceDescriptor</a> =  typename std::pair&lt;<a class="el" href="classDataOutFaces.html#a2e21509efc66035d0edd456ee57af48b">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明一种描述我们希望产生输出的面的方式。通常的方法当然是使用 <code><a class="el" href="group__Iterators.html#ga5c58f6795f69ef6645afd10906343141">DoFHandler&lt;dim&gt;::face_iterator</a></code>, 类型的对象，但由于我们必须对FEValues类型的对象描述面孔，我们只能用单元格和面孔的编号对来表示面孔。这一对在这里被别名为一个名字，最好是输入。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__faces_8h_source.html#l00134">134</a> of file <a class="el" href="data__out__faces_8h_source.html">data_out_faces.h</a>.</p>

</div>
</div>
<a id="af09d3320cfb06d2092ee8be96c632b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09d3320cfb06d2092ee8be96c632b8b">&#9670;&nbsp;</a></span>Patch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::<a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a> =  ::<a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt;<a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>缩写有点冗长的Patch类的名字。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00781">781</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a062005bfe37e877e1f44e1c3e8e6cb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062005bfe37e877e1f44e1c3e8e6cb27">&#9670;&nbsp;</a></span>DataVectorType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataOut_DoFData::DataVectorType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>描述给add_data_vector()的向量是什么的类型：在DoFHandler对象中每个自由度有一个条目的向量（如解决方案向量），或者在DoFHandler对象基础的三角形中每个单元有一个条目（如每个单元的误差数据）。值::type_automatic告诉add_data_vector()自己找出来（关于使用的方法，见add_data_vector()的文档）。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00509">509</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adebf4a7dae2b492e5bc6a15ac62caa41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adebf4a7dae2b492e5bc6a15ac62caa41">&#9670;&nbsp;</a></span>DataOutFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOutFaces.html">DataOutFaces</a>&lt; dim, spacedim &gt;::<a class="el" href="classDataOutFaces.html">DataOutFaces</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>surface_only</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>决定是否写入表面网（默认）或整个线筐的构造函数。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__faces_8cc_source.html#l00089">89</a> of file <a class="el" href="data__out__faces_8cc_source.html">data_out_faces.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a99986520842823e0e2f933084ee6317e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99986520842823e0e2f933084ee6317e">&#9670;&nbsp;</a></span>build_patches() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutFaces.html">DataOutFaces</a>&lt; dim, spacedim &gt;::build_patches </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_subdivisions</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这是该类的核心功能，因为它建立了由基类的低级函数写入的补丁列表。从本质上讲，补丁是三角形和DoFHandler对象的每个面上的数据的一些中间表示，然后可以用来以某种可视化程序可读的格式编写文件。 你可以在这个类的一般文档中找到关于这个函数的使用概述。在这个类的基类DataOut_DoFData的文档中也提供了一个例子。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_subdivisions</td><td>参见 <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a> 关于这个参数的广泛描述。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="data__out__faces_8cc_source.html#l00320">320</a> of file <a class="el" href="data__out__faces_8cc_source.html">data_out_faces.cc</a>.</p>

</div>
</div>
<a id="a01b4bc35f4ec57f4a2141e59298e9f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b4bc35f4ec57f4a2141e59298e9f42">&#9670;&nbsp;</a></span>build_patches() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutFaces.html">DataOutFaces</a>&lt; dim, spacedim &gt;::build_patches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_subdivisions</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与上述相同，只是额外的第一个参数定义了一个映射，该映射将用于生成输出。如果<code>n_subdivisions&gt;1</code>，源于域的边界单元的细分斑块内部的点可以用映射来计算，也就是说，高阶映射导致通过使用更多的细分来表示弯曲的边界。 即使对于非弯曲的单元，映射参数也可以用于欧拉映射（见MappingQ1Eulerian类），在这里，映射不仅用于确定单元内部的点的位置，也用于确定顶点的位置。 它提供了一个机会，可以在实际进行计算的变形三角形上观察解决方案，即使网格在内部是以未变形的配置存储的，变形只是通过一个额外的向量来跟踪每个顶点的变形情况。 </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000036">Todo:</a></b></dt><dd>如果是具有hp-capabilities的DoFHandler， <code>mapping</code> 参数应该被 <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a> 取代。</dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__faces_8cc_source.html#l00329">329</a> of file <a class="el" href="data__out__faces_8cc_source.html">data_out_faces.cc</a>.</p>

</div>
</div>
<a id="ae53579b046aa2618f92631a029fb7a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53579b046aa2618f92631a029fb7a14">&#9670;&nbsp;</a></span>first_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOutFaces.html">DataOutFaces</a>&lt; dim, spacedim &gt;::<a class="el" href="classDataOutFaces.html#a67b032789cecdae4344783a34cdf8712">FaceDescriptor</a> <a class="el" href="classDataOutFaces.html">DataOutFaces</a>&lt; dim, spacedim &gt;::first_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回我们想要输出的第一个面。默认的实现是返回一个（本地拥有的）活动单元的第一个面，或者，如果在析构器中设置了 <code>surface_only</code> 选项（如默认），则返回位于边界上的第一个此类面。 如果你想使用不同的逻辑来决定哪些面应该有助于图形输出的创建，你可以在派生类中重载这个函数。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__faces_8cc_source.html#l00416">416</a> of file <a class="el" href="data__out__faces_8cc_source.html">data_out_faces.cc</a>.</p>

</div>
</div>
<a id="a56504e26abcc6789e45204195d67ce4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56504e26abcc6789e45204195d67ce4d">&#9670;&nbsp;</a></span>next_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOutFaces.html">DataOutFaces</a>&lt; dim, spacedim &gt;::<a class="el" href="classDataOutFaces.html#a67b032789cecdae4344783a34cdf8712">FaceDescriptor</a> <a class="el" href="classDataOutFaces.html">DataOutFaces</a>&lt; dim, spacedim &gt;::next_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutFaces.html#a67b032789cecdae4344783a34cdf8712">FaceDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回我们想要输出的下一个面。如果没有更多的面，<code>dofs-&gt;<a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end()</a></code>将作为返回值的第一个组成部分返回。 默认的实现是返回一个（本地拥有的）活动单元的下一个面，或者边界上的下一个这样的面（取决于是否向构造函数提供了 <code>surface_only</code> 选项）。 这个函数逐个遍历网格中的活动单元（仅限于本地拥有的单元），然后遍历该单元的所有面。因此，内部面会被输出两次，这个特性对于不连续的Galerkin方法或使用数据后处理器可能产生的结果在单元之间不连续的情况下是很有用的）。) 这个函数可以在派生类中被重载，以选择不同的面组。请注意，默认实现假设给定的 <code>face</code> 是有效的，只要first_face()也是从默认实现中使用，就可以保证。只重载这两个函数中的一个应该谨慎行事。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__faces_8cc_source.html#l00435">435</a> of file <a class="el" href="data__out__faces_8cc_source.html">data_out_faces.cc</a>.</p>

</div>
</div>
<a id="a0e5a2c5c256a3e0d5fc0666b402f60fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5a2c5c256a3e0d5fc0666b402f60fa">&#9670;&nbsp;</a></span>build_one_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutFaces.html">DataOutFaces</a>&lt; dim, spacedim &gt;::build_one_patch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutFaces.html#a67b032789cecdae4344783a34cdf8712">FaceDescriptor</a> *&#160;</td>
          <td class="paramname"><em>cell_and_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1DataOutFacesImplementation_1_1ParallelData.html">internal::DataOutFacesImplementation::ParallelData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt; <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>建立一个补丁。这个函数是在WorkStream上下文中调用的。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__faces_8cc_source.html#l00097">97</a> of file <a class="el" href="data__out__faces_8cc_source.html">data_out_faces.cc</a>.</p>

</div>
</div>
<a id="a6ed7c846331069f406b8c9933c37fda4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed7c846331069f406b8c9933c37fda4">&#9670;&nbsp;</a></span>attach_dof_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::attach_dof_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指定一个dof处理程序，用来提取几何数据以及节点和节点值之间的映射。如果所有添加的数据向量都补充了DoFHandler参数，那么这个调用就没有必要。 这个调用是可选的：如果你用指定的DoFHandler对象添加数据向量，那么这就包含了生成输出所需的所有信息。 </p>

</div>
</div>
<a id="ab3e0283e8014c775f0f7673b7a6e89b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e0283e8014c775f0f7673b7a6e89b8">&#9670;&nbsp;</a></span>attach_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::attach_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指定一个用于提取几何数据和节点与节点值之间的映射的三角测量。 这个调用是可选的：如果你用指定的DoFHandler对象添加数据向量，那么这就包含了生成输出所需的所有信息。 当你只输出单元格向量而完全没有DoFHandler时，这个调用很有用，在这种情况下，它提供了几何图形。 </p>

</div>
</div>
<a id="a79cbe2f02f8dfb85026c71d783dbb703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cbe2f02f8dfb85026c71d783dbb703">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27a06a7819d088394bfea7a51fbba00f962">type_automatic</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>添加一个数据向量和它的名字。 一个指向该向量的指针被存储，所以你必须确保该向量至少在你调用<code>write_*</code>函数时存在于该地址。 假设该向量的分量与自由度处理程序中的自由度数量相同，在这种情况下，它被认为是一个存储节点数据的向量；或者大小可能是目前网格上活动单元的数量，在这种情况下，它被认为是一个单元数据向量。由于自由度和单元的数量通常不相等，函数可以自行决定给定哪种类型的向量。然而，在一些角落里，这种自动判断并不奏效。 一个例子是如果你用片状常数元素计算，并且有一个标量解决方案，那么有多少个单元就有多少个自由度（尽管它们的编号可能不同）。 另一种可能是，如果你有一个嵌入2D空间的1D网格，并且该网格由单元的封闭曲线组成；在这种情况下，有多少节点就有多少单元，当使用Q1元素时，你会有多少自由度就有多少单元。 在这种情况下，你可以将函数的最后一个参数从默认值::type_automatic改为::type_dof_data或::type_cell_data，这取决于矢量代表什么。除了这种角落里的情况，你可以把参数留在默认值上，让函数决定向量本身的类型。 如果它是一个持有DoF数据的向量，给出的名称应是底层有限元的每个分量。 如果它是一个仅由一个子元素组成的有限元，那么下面还有一个函数，它接受一个单一的名字而不是一个名字的向量。 data_component_interpretation参数包含关于如何解释由多个数据集组成的输出文件的各个组成部分的信息。 例如，如果一个人有一个2D的斯托克斯方程的有限元，代表组件（u,v,p），我们希望表明前两个，u和v，代表一个逻辑矢量，这样以后当我们生成图形输出时，我们可以把它们交给一个可视化程序，该程序将自动知道把它们作为一个矢量场来渲染，而不是作为两个独立的标量场。 这个参数的默认值（即一个空的矢量）对应于一个值的矢量 <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>, ，表示所有的输出组件都是独立的标量场。然而，如果给定的数据向量代表逻辑向量，你可以传入一个包含数值 <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>. 的向量。 在上面的例子中，人们会传入一个包含(u,v,p)的组件 (<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>) 的向量。 数据向量的名称只能包含字母、下划线和其他一些字符。请参考本类中声明的ExcInvalidCharacter异常，看看哪些字符是有效的，哪些是无效的。 </p><dl class="section note"><dt>Note</dt><dd>矢量参数的实际类型可以是任何矢量类型，FEValues可以使用 <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> 函数从单元格上提取数值。 </dd>
<dd>
当并行工作时，要写入的向量需要对本地拥有的单元上的所有自由度进行读取访问的幽灵化，详见 <a class="el" href="step_40.html">step-40</a> 或 <a class="el" href="step_37.html">step-37</a> 教程程序，即可能需要调用data.update_ghost_values（）。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00902">902</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="ae6cdf62daf18912e080ff012891ade0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cdf62daf18912e080ff012891ade0f">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27a06a7819d088394bfea7a51fbba00f962">type_automatic</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数是上面那个函数的缩写（关于各种参数的讨论见那里），旨在用于不是由子元素组成的有限元。在这种情况下，每个数据向量只需要给出一个名称，这就是这个函数的作用。它只是在将 <code>name</code> 转换为字符串矢量后，将其参数转发给上面的另一个add_data_vector()函数。 如果 <code>data</code> 是一个有多个成分的向量，这个函数将通过在 <code>name</code> 中附加下划线和每个成分的编号来为所有成分生成不同的名称。 模板参数的实际类型可以是任何向量类型，FEValues可以使用 <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> 函数在单元格中提取值。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00883">883</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a0a9291a532df3e94ef08ebe750638e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9291a532df3e94ef08ebe750638e70">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数是上面那个函数的扩展（除了第一个参数，其他参数的讨论见那里），允许用自己的DoFHandler对象设置一个向量。这个DoFHandler需要与调用 <code>add_data_vector或</code> <code>attach_dof_handler</code>, 分配的其他DoFHandler对象兼容，即所有的DoFHandler对象都需要基于相同的三角测量。这个函数允许你从描述不同解决方案组件的多个DoFHandler对象导出数据。在 <a class="el" href="step_61.html">step-61</a> 中给出了一个使用此函数的例子。 由于这个函数接受一个DoFHandler对象，因此自然地代表了dof数据，上面其他方法中出现的数据矢量类型参数就没有必要了。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00941">941</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a33f3f6c09920c20d36c984c9123ff1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f3f6c09920c20d36c984c9123ff1e1">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数是上述函数的缩写，只给出一个标量 <code>dof_handler</code> 和一个数据名称。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00920">920</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a4983e86e29af6cbaf4a1b3bd6e9d8621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4983e86e29af6cbaf4a1b3bd6e9d8621">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_postprocessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数是上述函数的一个替代品，允许输出派生量而不是给定的数据。这种转换必须在一个派生自DataPostprocessor的类中完成。这个函数在 <a class="el" href="step_29.html">step-29</a> 中使用。其他用途见 <a class="el" href="step_32.html">step-32</a> 和 <a class="el" href="step_33.html">step-33</a> 。 这些派生量的名称由 <code>data_postprocessor参数提供。同样，其他add_data_vector()函数的data_component_interpretation参数也是由data_postprocessor参数提供的。由于只有类型为</code> <code>type_dof_data</code> 的数据可以被转换，这个类型也是隐含地知道的，不需要给出。 </p><dl class="section note"><dt>Note</dt><dd>矢量参数的实际类型可以是任何矢量类型，FEValues可以使用 <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> 函数从单元格上提取数值。 </dd>
<dd>
数据后处理器对象（即实际上是你的派生类的对象）必须活到DataOut对象被销毁为止，因为后者保持着一个指向前者的指针，如果指向的对象被销毁，而后者仍有一个指向它的指针，就会抱怨。如果数据后处理器和DataOut对象都是一个函数的局部变量（例如，在 <a class="el" href="step_29.html">step-29</a> 中就是如此），那么你可以通过在DataOut变量之前声明数据后处理器变量来避免这个错误，因为对象的销毁顺序与声明顺序相反。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00961">961</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a3c309b6a0db9808eee76ab1b6ba39239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c309b6a0db9808eee76ab1b6ba39239">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_postprocessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与上面的函数相同，但有一个DoFHandler对象，不需要与最初设置的DoFHandler重合。注意，后处理器只能从给定的DoFHandler和求解向量中读取数据，而不是其他求解向量或DoFHandler。 </p>

</div>
</div>
<a id="a8cf39310f98aeaee50c2143ee2f68ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf39310f98aeaee50c2143ee2f68ab5">&#9670;&nbsp;</a></span>add_mg_data_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::add_mg_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>添加一个多级数据向量。 这个函数将属于DoFHandler <code>dof_handler的每一级的向量形式的向量值多级向量</code> <code>data</code> 添加到图形输出中。这个函数通常与调用set_cell_selection()一起使用，该函数选择的是特定层次上的单元，而不是活动单元（默认）。 矢量 <code>data</code> 可以通过几种方式获得，例如在多网格循环期间或之后使用 <a class="el" href="classMultigrid.html#a2614db3c885e19f89b2df14422634c22">Multigrid::solution</a> 或 <a class="el" href="classMultigrid.html#adecf4e39189911da5096d1112c91680b">Multigrid::defect</a> ，或者通过 <a class="el" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">MGTransferMatrixFree::interpolate_to_mg()</a>. 对解进行插值处理 <code>names</code> 和 <code>data_component_interpretation</code> 与add_data_vector（）函数相同。 </p>

</div>
</div>
<a id="a99f8b5f94d56b40bfb67a4cdea74f764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f8b5f94d56b40bfb67a4cdea74f764">&#9670;&nbsp;</a></span>add_mg_data_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::add_mg_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数的标量版本。 </p>

</div>
</div>
<a id="a28da5487f291a1724cb4697c59c3f3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28da5487f291a1724cb4697c59c3f3d2">&#9670;&nbsp;</a></span>clear_data_vectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::clear_data_vectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>释放指向数据向量的指针。这允许输出一组新的向量，而无需再次提供DoF处理程序。因此，DataOut对象可以在代数背景下使用。注意，除了数据向量，已经计算的补丁也会被删除。 </p>

</div>
</div>
<a id="a8d635fcfdbd6ebe7ccc1895524b8e615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d635fcfdbd6ebe7ccc1895524b8e615">&#9670;&nbsp;</a></span>clear_input_data_references()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::clear_input_data_references </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>释放指向所有输入数据元素的指针，即指向数据向量和DoF处理器对象的指针。当你调用了派生类的 <code>build_patches</code> 函数时，这个函数可能很有用，因为此时补丁已经建立，不再需要输入数据，也不需要引用它。然后你就可以从主线程中分离出来输出补丁，而不需要再确保在输出线程结束之前，DoF处理程序对象和向量不能被删除。 </p>

</div>
</div>
<a id="a3c7605d51f91376a851ec77b0a7003aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7605d51f91376a851ec77b0a7003aa">&#9670;&nbsp;</a></span>merge_patches() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::merge_patches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim2, patch_dim, spacedim2, patch_spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; patch_spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;patch_spacedim&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数可以用来将使用作为参数的对象的 <code>build_patches</code> 函数创建的补丁合并到这个对象创建的补丁列表中。例如，如果有一个领域分解算法，其中每个块都由它自己的DoFHandler表示，但人们想同时输出所有块上的解决方案，这有时是很方便的。 要做到这一点，给定的参数和这个对象需要有相同数量的输出向量，并且它们需要使用相同数量的每个补丁的细分。如果两个对象中的补丁在空间上有重叠，那么输出结果可能会看起来相当有趣。 如果你在合并补丁后为这个对象调用build_patches()，之前的状态会被覆盖，而合并的补丁会丢失。 第二个参数允许将第一个参数中传递的对象中的补丁的每个节点移动一定量。这对于生成一个区块集合的 "爆炸 "视图有时是有用的。 如果这个对象或另一个对象还没有设置任何补丁，这个函数将会失败。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00975">975</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="aa8ae001a1d3f270ae0d4a2b77f0d9696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ae001a1d3f270ae0d4a2b77f0d9696">&#9670;&nbsp;</a></span>merge_patches() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::merge_patches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; DoFHandlerType2::dimension, patch_dim, DoFHandlerType2::space_dimension, patch_spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; patch_spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;patch_spacedim&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000084">Deprecated:</a></b></dt><dd>用merge_patches()代替DoFHandlerType2模板。</dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l01066">1066</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a5c3b3a19e7c1ed70079f8682a06b021a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3b3a19e7c1ed70079f8682a06b021a">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>释放指向数据向量和DoF处理程序的指针。你必须使用add_data_vector()函数重新设置所有的数据条目。Dof处理程序的指针也被清空，连同所有其他数据一起。 实际上，这个函数把所有的东西都重设为一个处女状态。 </p>

</div>
</div>
<a id="a88bac22217cd4bf591eb5ac77d49b8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bac22217cd4bf591eb5ac77d49b8fd">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>确定这个对象的内存消耗（以字节为单位）的估计值。 </p>

</div>
</div>
<a id="a8abd127577fe43595d9b169953b5f593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abd127577fe43595d9b169953b5f593">&#9670;&nbsp;</a></span>get_patches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;<a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a>&gt;&amp; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::get_patches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>函数，基类的函数通过这个函数知道他们应该把哪些补丁写到文件中。 </p>

<p>Implements <a class="el" href="classDataOutInterface.html#a7c3eeef4bc56cdb85c31e05dc09dae72">DataOutInterface&lt; patch_dim, patch_spacedim &gt;</a>.</p>

</div>
</div>
<a id="a6e9ebc2f6ef4666df85bb686c7e95a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9ebc2f6ef4666df85bb686c7e95a90">&#9670;&nbsp;</a></span>get_dataset_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::get_dataset_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>虚拟函数，基类的输出函数通过它获得数据集的名称。 </p>

<p>Implements <a class="el" href="classDataOutInterface.html#a128e5dec286cc1a429b94e29dd55ab81">DataOutInterface&lt; patch_dim, patch_spacedim &gt;</a>.</p>

</div>
</div>
<a id="a2626aebbd6852ae06f7f407f85b615a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2626aebbd6852ae06f7f407f85b615a5">&#9670;&nbsp;</a></span>get_fes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;::<a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt;dim, spacedim&gt; &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::get_fes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>提取存储在dof_data对象中的有限元，包括一个FE_DGQ&lt;dim&gt;(0)的假对象，以防只使用三角法。 </p>

</div>
</div>
<a id="a490249234021ec9de79b356a1f7fa42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490249234021ec9de79b356a1f7fa42e">&#9670;&nbsp;</a></span>get_nonscalar_data_ranges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::tuple&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::get_nonscalar_data_ranges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>相关的 <a class="el" href="classDataOutInterface.html#a05d5d72abcf81f4174e15fd984f1267c">DataOutInterface::get_nonscalar_data_ranges()</a> 函数的重载。参见那里有更多的文档。 </p>

<p>Reimplemented from <a class="el" href="classDataOutInterface.html#a05d5d72abcf81f4174e15fd984f1267c">DataOutInterface&lt; patch_dim, patch_spacedim &gt;</a>.</p>

</div>
</div>
<a id="afc05be5cd920b234e68548735852446e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc05be5cd920b234e68548735852446e">&#9670;&nbsp;</a></span>write_dx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_dx </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以OpenDX格式写入<code>out</code>。见 <a class="el" href="namespaceDataOutBase.html#a75750d50e3d27159f8a1e4de7f0a8f32">DataOutBase::write_dx</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07130">7130</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="aea2031a2a6fe56c9b7d3f9f338f20882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2031a2a6fe56c9b7d3f9f338f20882">&#9670;&nbsp;</a></span>write_eps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_eps </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以EPS格式写到<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#a98914588b1516419a572a1718b1bf3d5">DataOutBase::write_eps</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07182">7182</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ae7f2c3305058c94333d8aa699286b807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f2c3305058c94333d8aa699286b807">&#9670;&nbsp;</a></span>write_gmv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_gmv </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据并以GMV格式写入<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#afa4389cfc36770d2881867f6889bc348">DataOutBase::write_gmv</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07195">7195</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a85407e870a68179ebe62410d9efc153f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85407e870a68179ebe62410d9efc153f">&#9670;&nbsp;</a></span>write_gnuplot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_gnuplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获得数据并以GNUPLOT格式写入<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#a3cfd561a7b5262f83e3cdc4020b377f4">DataOutBase::write_gnuplot</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07156">7156</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a33a15f01cb0171da2956be68ad496cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a15f01cb0171da2956be68ad496cd0">&#9670;&nbsp;</a></span>write_povray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_povray </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以POVRAY格式写到<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#ae661c9d7979da0c39b5f08fd715ed947">DataOutBase::write_povray</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07169">7169</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a980b995a6f5944a75721097de39069c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980b995a6f5944a75721097de39069c1">&#9670;&nbsp;</a></span>write_tecplot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_tecplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以Tecplot格式写到<code>out</code>。见 <a class="el" href="namespaceDataOutBase.html#ab9f9f33c200120450b6844d986a83604">DataOutBase::write_tecplot</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07208">7208</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a2bf06b8647892769140884b3ab44a08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf06b8647892769140884b3ab44a08e">&#9670;&nbsp;</a></span>write_ucd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_ucd </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以UCD格式写入<code>out</code>，用于AVS。参见 <a class="el" href="namespaceDataOutBase.html#a5ec32be3e3379b7c83dc339f52cf2ad6">DataOutBase::write_ucd</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07143">7143</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="acad99726038e4fca7f605fdffb3317e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad99726038e4fca7f605fdffb3317e4">&#9670;&nbsp;</a></span>write_vtk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtk </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以Vtk格式写到<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#a336d97147011f5f8f3746cac0a3ca4ab">DataOutBase::write_vtk</a>. </p><dl class="section note"><dt>Note</dt><dd>VTK是一种遗留格式，在很大程度上已经被VTU格式（VTK的XML结构版本）所取代了。特别是，VTU允许对数据进行压缩，因此导致大文件的文件大小要比VTK文件小得多。由于所有支持VTK的可视化程序也支持VTU，你应该考虑使用后者的文件格式，通过使用write_vtu()函数来代替。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07221">7221</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a93c780f93105e0daaa76c6c43694b4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c780f93105e0daaa76c6c43694b4ae">&#9670;&nbsp;</a></span>write_vtu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtu </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以Vtu（VTK的XML）格式写到<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#a3aec479936b78bd0ec2ecc3674e24584">DataOutBase::write_vtu</a>. 一些可视化程序，如ParaView，可以读取几个独立的VTU文件以实现可视化的并行化。在这种情况下，你需要一个 <code>.pvtu</code> 文件来描述哪些VTU文件构成一个组。 <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a> 函数可以生成这样一个集中的记录。同样， <a class="el" href="namespaceDataOutBase.html#a482d9621dcc87d6a43cf8a9651e16cd8">DataOutInterface::write_visit_record()</a> 对旧版本的VisIt也有同样的作用（尽管VisIt从2.5.1版本开始也可以读取 <code>pvtu</code> 记录）。最后， <a class="el" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutInterface::write_pvd_record()</a> 可以用来将共同构成时间相关模拟的文件分组。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07232">7232</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a5df488dad82b811ceb08cb1adf9eafcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df488dad82b811ceb08cb1adf9eafcd">&#9670;&nbsp;</a></span>write_vtu_in_parallel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtu_in_parallel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>集体MPI调用，将所有参与节点（给定通信器中的节点）的解决方案写入共享文件系统上的一个压缩的.vtu文件。 该通信器可以是计算所使用的通信器的一个子通信器。 这个程序使用MPI I/O来实现并行文件系统上的高性能。也可参见 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07254">7254</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a1eff778443cd0431cd807c45b6ae16d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eff778443cd0431cd807c45b6ae16d9">&#9670;&nbsp;</a></span>write_pvtu_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_pvtu_record </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>piece_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一些可视化程序，如ParaView，可以读取几个独立的VTU文件，这些文件都是同一模拟的一部分，以实现可视化的并行化。在这种情况下，你需要一个 <code>.pvtu</code> 文件来描述哪些VTU文件（例如，通过 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> 函数写入）构成一个组。 当前的函数可以生成这样一个集中记录。 该函数生成的中央记录文件包含一个（标量或矢量）字段列表，描述哪些字段实际上可以在构成平行VTU文件组的各个文件中找到，以及这些文件的名称。这个函数通过本类的get_dataset_names()和get_nonscalar_data_ranges()函数获得字段的名称和类型。这个函数的第二个参数指定了构成平行集的文件名。 </p><dl class="section note"><dt>Note</dt><dd>使用 <a class="el" href="namespaceDataOutBase.html#a3aec479936b78bd0ec2ecc3674e24584">DataOutBase::write_vtu()</a> 和 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> 来写每一块。还要注意，只有一个并行进程需要调用当前函数，列出所有并行进程写入的文件名。 </dd>
<dd>
这个函数的使用在 <a class="el" href="step_40.html">step-40</a> 中解释。 </dd>
<dd>
为了告诉Paraview将多个 <code>pvtu</code> 文件组合在一起，每个文件描述一个与时间有关的仿真的一个时间步骤，请参见 <a class="el" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record()</a> 函数。 </dd>
<dd>
旧版本的VisIt（2.5.1之前），不能读取 <code>pvtu</code> 记录。然而，它可以读取由write_visit_record()函数写入的访问记录。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07357">7357</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a0864e51eb173c87e2a3edc9391ea8009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0864e51eb173c87e2a3edc9391ea8009">&#9670;&nbsp;</a></span>write_vtu_with_pvtu_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtu_with_pvtu_record </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_without_extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_digits_for_counter</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_groups</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数并行地写入几个.vtu文件和一个.pvtu记录，并自动构建文件名。它是 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> 或 <a class="el" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">DataOutInterface::write_vtu_in_parallel()</a>, 和 <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a>. 的组合。例如，在10个进程中运行<code> write_vtu_with_pvtu_record("output/", "solution", 3, comm, 4, 2) </code>会生成这些文件 </p><div class="fragment"><div class="line">output/solution_0003.0.<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a></div><div class="line">output/solution_0003.1.<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a></div><div class="line">output/solution_0003.pvtu</div></div><!-- fragment --><p> 其中<code>.0.vtu</code>文件包含前一半进程的输出分组，而<code>.1.vtu</code>是其余一半进程的数据。 一个指定的 <code>directory</code> 和一个 <code>filename_without_extension</code> 构成文件名的第一部分。然后用 <code>counter</code> 扩展文件名，标明当前的时间步数/迭代次数/等等，处理器ID，最后是.vtu/.pvtu结尾。由于要写入的时间步数取决于应用，在文件名中保留的数字可以作为参数 <code>n_digits_for_counter</code>, 来指定，如果该参数保持默认值，则数字不加前导零 <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>. 如果需要一个以上的文件标识符（例如时间步数和求解器的迭代计数器），最后一个标识符作为 <code>counter</code>, 使用，而所有其他标识符必须在调用该函数时加入 <code>filename_without_extension</code> 。 在并行设置中，每个时间步长通常要写几个文件。并行写入的文件数量取决于MPI进程的数量（见参数 <code>mpi_communicator</code>), 和默认值为0的指定数量 <code>n_groups</code> 。其背景是VTU文件输出支持在并行文件系统上写入时，使用MPI I/O将几个CPU的文件分组为给定数量的文件。 <code>n_groups</code> 的默认值是0，意味着每个MPI等级将写入一个文件。1的值将生成一个包含整个域的解决方案的大文件，而更大的值将创建 <code>n_groups</code> 个文件（但不会超过MPI等级的数量）。 请注意，只有一个处理器需要生成.pvtu文件，其中零号处理器被选择来承担这项工作。 返回值是pvtu记录的集中文件的文件名。 </p><dl class="section note"><dt>Note</dt><dd>代码简单地结合了字符串 <code>directory</code> 和 <code>filename_without_extension</code>, ，即用户必须确保 <code>directory</code> 包含一个尾部字符，例如"/"，将目录和文件名分开。 </dd>
<dd>
如果要将输出写入当前工作目录，则使用空字符串""作为第一个参数。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07370">7370</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ab56595d7d5aebfb2b3abfdaad51df20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56595d7d5aebfb2b3abfdaad51df20d">&#9670;&nbsp;</a></span>write_svg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_svg </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以SVG格式写到<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#ad20ab1f2f5ec29122aefe1f016ff6eac">DataOutBase::write_svg</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07243">7243</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="affac60e1e3799ae884642113a8e2e723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affac60e1e3799ae884642113a8e2e723">&#9670;&nbsp;</a></span>write_deal_II_intermediate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_deal_II_intermediate </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以deal.II中间格式写到&lt;tt&gt;out中。参见 <a class="el" href="namespaceDataOutBase.html#a70b0a895fd8b48c1555fa1c34f2cd176">DataOutBase::write_deal_II_intermediate</a>. 注意，中间格式就像它的名字一样：内部数据的直接表示。它不是标准化的，每当我们改变内部表示时，它就会改变。你只能期望使用用于编写的相同版本的deal.II来处理以这种格式编写的文件。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07452">7452</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a45ef5cf2b6515c10ff080729a9901155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ef5cf2b6515c10ff080729a9901155">&#9670;&nbsp;</a></span>create_xdmf_entry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXDMFEntry.html">XDMFEntry</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::create_xdmf_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>h5_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>cur_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>基于data_filter中的数据创建一个XDMFEntry。这假设网格和求解数据被写到一个文件中。参见write_xdmf_file()中的使用实例。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07465">7465</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a0f0b3eec5ee65bd7915c4e46272287eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0b3eec5ee65bd7915c4e46272287eb">&#9670;&nbsp;</a></span>create_xdmf_entry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXDMFEntry.html">XDMFEntry</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::create_xdmf_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>h5_mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>h5_solution_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>cur_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>基于data_filter中的数据，创建一个XDMFEntry。这假设网格和解的数据被写入不同的文件。参见write_xdmf_file()中的使用实例。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07479">7479</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="abfab5d02f11dcede67bb61ff3ae105d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfab5d02f11dcede67bb61ff3ae105d2">&#9670;&nbsp;</a></span>write_xdmf_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_xdmf_file </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classXDMFEntry.html">XDMFEntry</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>根据提供的XDMFEntry对象的向量，写一个XDMF文件。 下面是一个如何用HDF5和DataOutFilter使用这个函数的例子。 </p><div class="fragment"><div class="line"><a class="code" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutBase::DataOutFilterFlags</a> flags(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> data_filter(flags);</div><div class="line">std::vector&lt;XDMFEntry&gt; xdmf_entries;</div><div class="line"><span class="comment">// Filter the data and store it in data_filter</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a154d8192688eef96f052f50c2f669aa8">write_filtered_data</a>(data_filter);</div><div class="line"><span class="comment">// Write the filtered data to HDF5</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a>(data_filter, <span class="stringliteral">&quot;solution.h5&quot;</span>, MPI_COMM_WORLD);</div><div class="line"><span class="comment">// Create an XDMF entry detailing the HDF5 file</span></div><div class="line"><span class="keyword">auto</span> new_xdmf_entry = data_out.<a class="code" href="classDataOutInterface.html#a45ef5cf2b6515c10ff080729a9901155">create_xdmf_entry</a>(data_filter,</div><div class="line">                                               <span class="stringliteral">&quot;solution.h5&quot;</span>,</div><div class="line">                                               simulation_time,</div><div class="line">                                               MPI_COMM_WORLD);</div><div class="line"><span class="comment">// Add the XDMF entry to the list</span></div><div class="line">xdmf_entries.push_back(new_xdmf_entry);</div><div class="line"><span class="comment">// Create an XDMF file from all stored entries</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#abfab5d02f11dcede67bb61ff3ae105d2">write_xdmf_file</a>(xdmf_entries, <span class="stringliteral">&quot;solution.xdmf&quot;</span>, MPI_COMM_WORLD);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07552">7552</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a29468f4e8eca1367d44b1a2431d39e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29468f4e8eca1367d44b1a2431d39e91">&#9670;&nbsp;</a></span>write_hdf5_parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将 <code>data_filter</code> 中的数据写入一个单一的HDF5文件，包含网格和解的数值。下面是一个如何使用这个函数与DataOutFilter的例子。 </p><div class="fragment"><div class="line"><a class="code" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutBase::DataOutFilterFlags</a> flags(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> data_filter(flags);</div><div class="line"><span class="comment">// Filter the data and store it in data_filter</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a154d8192688eef96f052f50c2f669aa8">write_filtered_data</a>(data_filter);</div><div class="line"><span class="comment">// Write the filtered data to HDF5</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a>(data_filter, <span class="stringliteral">&quot;solution.h5&quot;</span>, MPI_COMM_WORLD);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07730">7730</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a78fdf1cc5071d85ecb2d707d798bf063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fdf1cc5071d85ecb2d707d798bf063">&#9670;&nbsp;</a></span>write_hdf5_parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>write_mesh_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solution_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将data_filter中的数据写到HDF5文件中。如果write_mesh_file为false，网格数据将不会被写入，而解文件将只包含解的数值。如果write_mesh_file为true，且文件名相同，则生成的文件将同时包含网格数据和求解值。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07742">7742</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a154d8192688eef96f052f50c2f669aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154d8192688eef96f052f50c2f669aa8">&#9670;&nbsp;</a></span>write_filtered_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_filtered_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filtered_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DataOutFilter是一种中间数据格式，可以减少将被写入文件的数据量。这个函数所填充的对象随后可以再次用于写入具体文件格式的数据；例如，见 <a class="el" href="namespaceDataOutBase.html#af5a956cffba0fa383f85a82bb2a4ca63">DataOutBase::write_hdf5_parallel()</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07602">7602</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a78e73ad285a8792ff0f9f227b82eb108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e73ad285a8792ff0f9f227b82eb108">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td>
          <td class="paramname"><em>output_format</em> = <code><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>根据给定的数据格式向<code>out</code>写入数据和网格。 这个函数只是调用相应的<code>write_*</code>函数。如果没有要求输出格式，将写入<code>default_format</code>。 如果没有提供格式，而默认格式是<code>default_format</code>，则会发生错误。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08134">8134</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a6dab6e0fed8d4ad90d658f71a68eb32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dab6e0fed8d4ad90d658f71a68eb32c">&#9670;&nbsp;</a></span>set_default_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::set_default_format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td>
          <td class="paramname"><em>default_format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置默认格式。这里设置的值在任何时候都会被使用，要求输出格式为<code>default_format</code>。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08200">8200</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ac7280a24690b117454acfb0fa058299c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7280a24690b117454acfb0fa058299c">&#9670;&nbsp;</a></span>set_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::set_flags </td>
          <td>(</td>
          <td class="paramtype">const FlagType &amp;&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置用于输出的标志。这个方法希望<code>flags</code>是<code>OutputFlagsBase</code>的一个子类中的成员。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08210">8210</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a36120ca3f536c90709e135161030f16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36120ca3f536c90709e135161030f16c">&#9670;&nbsp;</a></span>default_suffix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::default_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td>
          <td class="paramname"><em>output_format</em> = <code><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个函数，返回与基类中相应函数相同的字符串；唯一的例外是，如果省略了参数，则返回当前默认格式的值，即在调用此函数之前通过set_default_format()或parse_parameters()设置的格式的正确后缀。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08245">8245</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a1f2f1d644d9cb1c4d1714d5173d159f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2f1d644d9cb1c4d1714d5173d159f2">&#9670;&nbsp;</a></span>declare_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::declare_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过在每个输出格式的参数文件中声明子段来声明所有输出格式的参数，并调用每个输出格式的标志类的相应<code>declare_parameters</code>函数。 如果相应的格式不输出任何标志，那么某些声明的子段可能不包含条目。 请注意，表示每个补丁的分区数量和输出格式的顶层参数没有被声明，因为它们只被传递给虚拟函数，而不被存储在这种类型的对象中。你必须自己声明它们。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08258">8258</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a0a975649e4516ee7c7a67ae2f8dddd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a975649e4516ee7c7a67ae2f8dddd97">&#9670;&nbsp;</a></span>parse_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::parse_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>读取 <a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">declare_parameters()</a> 中声明的参数，并为输出格式设置相应的标志。 这样得到的标志会覆盖之前所有默认构建的或由set_flags()函数设置的标志对象的内容。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08311">8311</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ac3292ed269dfb832d20ae35db4177473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3292ed269dfb832d20ae35db4177473">&#9670;&nbsp;</a></span>validate_dataset_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::validate_dataset_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>验证get_dataset_names()和get_nonscalar_data_ranges()返回的数据集的名称是否有效。目前这包括检查名称是否被多次使用。如果遇到一个无效的状态，将在调试模式下触发一个Assert()。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08393">8393</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a017a2140a823793072507240a8fc619a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017a2140a823793072507240a8fc619a">&#9670;&nbsp;</a></span>patch_dim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> <a class="el" href="classDataOutFaces.html">DataOutFaces</a>&lt; dim, spacedim &gt;::patch_dim = dim - 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>补丁的尺寸参数。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__faces_8h_source.html#l00089">89</a> of file <a class="el" href="data__out__faces_8h_source.html">data_out_faces.h</a>.</p>

</div>
</div>
<a id="ab33d49fd332116eafa8a3b15554d5e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33d49fd332116eafa8a3b15554d5e97">&#9670;&nbsp;</a></span>patch_spacedim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> <a class="el" href="classDataOutFaces.html">DataOutFaces</a>&lt; dim, spacedim &gt;::patch_spacedim = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="data__out__faces_8h_source.html#l00090">90</a> of file <a class="el" href="data__out__faces_8h_source.html">data_out_faces.h</a>.</p>

</div>
</div>
<a id="a666a918df0f8acf7373c0cf21250e4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666a918df0f8acf7373c0cf21250e4b7">&#9670;&nbsp;</a></span>surface_only</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> <a class="el" href="classDataOutFaces.html">DataOutFaces</a>&lt; dim, spacedim &gt;::surface_only</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在表面网格和全线篮之间决定的参数。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__faces_8h_source.html#l00165">165</a> of file <a class="el" href="data__out__faces_8h_source.html">data_out_faces.h</a>.</p>

</div>
</div>
<a id="ab87e6a1ac30aee2b4a134aeca8b38253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87e6a1ac30aee2b4a134aeca8b38253">&#9670;&nbsp;</a></span>triangulation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::triangulation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向三角测量对象的指针。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00787">787</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a512dc7e149e9d83b712e1707780b9afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512dc7e149e9d83b712e1707780b9afc">&#9670;&nbsp;</a></span>dofs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::dofs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向可选的处理程序对象的指针。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00793">793</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a4a6762a26e4dc93f133c175e271936e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6762a26e4dc93f133c175e271936e1">&#9670;&nbsp;</a></span>dof_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt;dim, spacedim&gt; &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::dof_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>带有每个自由度数值向量的数据元素的列表。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00801">801</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a31bbb02ee5dcd6752232e76bdecaecd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31bbb02ee5dcd6752232e76bdecaecd4">&#9670;&nbsp;</a></span>cell_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt;dim, spacedim&gt; &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::cell_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>带有每个单元值向量的数据元素的列表。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00809">809</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a3adac4a7d4453f2fe8e35a89add8590c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adac4a7d4453f2fe8e35a89add8590c">&#9670;&nbsp;</a></span>patches</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a>&gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, <a class="el" href="classDataOutFaces.html#a017a2140a823793072507240a8fc619a">patch_dim</a>, spacedim, <a class="el" href="classDataOutFaces.html#ab33d49fd332116eafa8a3b15554d5e97">patch_spacedim</a> &gt;::patches</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这是一个补丁列表，每次调用build_patches()时都会创建一个补丁。这些补丁在基类的输出例程中使用。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00815">815</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a072edd6d53d1c5a1e4c71af22a123228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072edd6d53d1c5a1e4c71af22a123228">&#9670;&nbsp;</a></span>default_subdivisions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::default_subdivisions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>补丁的默认分区数。这是由parse_parameters()填充的，并且应该被派生类中的build_patches()遵守。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l02440">2440</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/numerics/<a class="el" href="data__out__faces_8h_source.html">data_out_faces.h</a></li>
<li>source/numerics/<a class="el" href="data__out__faces_8cc_source.html">data_out_faces.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
