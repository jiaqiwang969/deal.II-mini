<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTrilinosWrappers_1_1SparseMatrix.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TrilinosWrappers::SparseMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></li><li class="navelem"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTrilinosWrappers_1_1SparseMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TrilinosWrappers::SparseMatrix Class Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__TrilinosWrappers.html">TrilinosWrappers</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo;  &#124; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="trilinos__sparse__matrix_8h_source.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TrilinosWrappers::SparseMatrix:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTrilinosWrappers_1_1SparseMatrix__inherit__graph.svg" width="192" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTrilinosWrappers_1_1SparseMatrix_1_1Traits.html">Traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a301d937415bb2c99478d00f4cb5cce7a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> = ::<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:a301d937415bb2c99478d00f4cb5cce7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7757ad30700692bed81a328a4b6ee1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a> = <a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt; false &gt;</td></tr>
<tr class="separator:a1d7757ad30700692bed81a328a4b6ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae308c2134b631d8553164329dfee584b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a> = <a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt; true &gt;</td></tr>
<tr class="separator:ae308c2134b631d8553164329dfee584b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac77967448da926f12fb1fa6bc37a4d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afac77967448da926f12fb1fa6bc37a4d">value_type</a> = <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a></td></tr>
<tr class="separator:afac77967448da926f12fb1fa6bc37a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b339047bea78c496cb6f6bb3ab9341c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1b339047bea78c496cb6f6bb3ab9341c">DeclException1</a> (ExcAccessToNonlocalRow, std::size_t,&lt;&lt; &quot;You tried to access row &quot;&lt;&lt; arg1&lt;&lt; &quot; of a non-contiguous locally owned row set.&quot;&lt;&lt; &quot; The row &quot;&lt;&lt; arg1&lt;&lt; &quot; is not stored locally and can't be accessed.&quot;)</td></tr>
<tr class="separator:a1b339047bea78c496cb6f6bb3ab9341c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa91c2a8575019cbaf8a9217fd0f5d02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaaa91c2a8575019cbaf8a9217fd0f5d02">DeclException1</a> (ExcTrilinosError, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;An error with error number &quot;&lt;&lt; arg1&lt;&lt; &quot; occurred while calling a Trilinos function&quot;)</td></tr>
<tr class="separator:gaaa91c2a8575019cbaf8a9217fd0f5d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab14d48834fa571cc16129076c9bcd0c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab14d48834fa571cc16129076c9bcd0c8">DeclException2</a> (ExcInvalidIndex, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>,&lt;&lt; &quot;The entry with index &lt;&quot;&lt;&lt; arg1&lt;&lt; ','&lt;&lt; arg2&lt;&lt; &quot;&gt; does not exist.&quot;)</td></tr>
<tr class="separator:gab14d48834fa571cc16129076c9bcd0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32e89990301f92c60811d85de63fd90d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32e89990301f92c60811d85de63fd90d">DeclExceptionMsg</a> (ExcSourceEqualsDestination, &quot;You are attempting an operation on two matrices that &quot; &quot;are the same object, but the operation requires that the &quot; &quot;two objects are in fact different.&quot;)</td></tr>
<tr class="separator:ga32e89990301f92c60811d85de63fd90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7426cdb9e8078ac7cd442857a786545c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7426cdb9e8078ac7cd442857a786545c">DeclException0</a> (ExcMatrixNotCompressed)</td></tr>
<tr class="separator:ga7426cdb9e8078ac7cd442857a786545c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd4fe5958a3c39f2c7651935936eb6c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacd4fe5958a3c39f2c7651935936eb6c7">DeclException4</a> (ExcAccessToNonLocalElement, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>,&lt;&lt; &quot;You tried to access element (&quot;&lt;&lt; arg1&lt;&lt; &quot;/&quot;&lt;&lt; arg2&lt;&lt; &quot;)&quot;&lt;&lt; &quot; of a distributed <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1f3f26ae4997382b25a2eb9604200a75">matrix</a>, but only rows in range [&quot;&lt;&lt; arg3&lt;&lt; &quot;,&quot;&lt;&lt; arg4&lt;&lt; &quot;] are stored locally and can be accessed.&quot;)</td></tr>
<tr class="separator:gacd4fe5958a3c39f2c7651935936eb6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb9160e213bcaf3e98adb55bb34f9089"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gabb9160e213bcaf3e98adb55bb34f9089">DeclException2</a> (ExcAccessToNonPresentElement, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>,&lt;&lt; &quot;You tried to access element (&quot;&lt;&lt; arg1&lt;&lt; &quot;/&quot;&lt;&lt; arg2&lt;&lt; &quot;)&quot;&lt;&lt; &quot; of a sparse <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1f3f26ae4997382b25a2eb9604200a75">matrix</a>, but it appears to not&quot;&lt;&lt; &quot; exist in the Trilinos sparsity pattern.&quot;)</td></tr>
<tr class="separator:gabb9160e213bcaf3e98adb55bb34f9089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d16939e4c35144a316076f5b1c2f91"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af8d16939e4c35144a316076f5b1c2f91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af8d16939e4c35144a316076f5b1c2f91">set</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> row, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> n_cols, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> *col_indices, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values)</td></tr>
<tr class="separator:af8d16939e4c35144a316076f5b1c2f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">构造函数和初始化。</div></td></tr>
<tr class="memitem:a637dbbd4e8ca9fc07a447c8f31e21647"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a637dbbd4e8ca9fc07a447c8f31e21647">SparseMatrix</a> ()</td></tr>
<tr class="separator:a637dbbd4e8ca9fc07a447c8f31e21647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3900dae374f5a71e5134840682662d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab3900dae374f5a71e5134840682662d8">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m</a>, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a371d418cc093230813c36578f32f0966">n</a>, const unsigned <a class="el" href="classint.html">int</a> n_max_entries_per_row)</td></tr>
<tr class="separator:ab3900dae374f5a71e5134840682662d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944e51f3f5f0202024e04b679172ec9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a944e51f3f5f0202024e04b679172ec9e">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m</a>, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a371d418cc093230813c36578f32f0966">n</a>, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a944e51f3f5f0202024e04b679172ec9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2b62a80dac30c548e1d20c3e77beae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0b2b62a80dac30c548e1d20c3e77beae">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;InputSparsityPattern)</td></tr>
<tr class="separator:a0b2b62a80dac30c548e1d20c3e77beae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0c3506eddcfd2bff3c8b4658b7d493"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a7d0c3506eddcfd2bff3c8b4658b7d493">SparseMatrix</a> (<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a7d0c3506eddcfd2bff3c8b4658b7d493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc6e5a99462abbc7d9324b4824be576"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aafc6e5a99462abbc7d9324b4824be576">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;)=delete</td></tr>
<tr class="separator:aafc6e5a99462abbc7d9324b4824be576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6980b4f220e3d41b00d5ffa38623d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aec6980b4f220e3d41b00d5ffa38623d7">operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;)=delete</td></tr>
<tr class="separator:aec6980b4f220e3d41b00d5ffa38623d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe89a97bc7ef4bbc16e5e04b72bb19e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#adbe89a97bc7ef4bbc16e5e04b72bb19e">~SparseMatrix</a> () override=default</td></tr>
<tr class="separator:adbe89a97bc7ef4bbc16e5e04b72bb19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614ca8e186fe3c61e03a52369437157e"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a614ca8e186fe3c61e03a52369437157e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a> (const SparsityPatternType &amp;sparsity_pattern)</td></tr>
<tr class="separator:a614ca8e186fe3c61e03a52369437157e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602232080f91baba93c85684937765d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a602232080f91baba93c85684937765d5">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern)</td></tr>
<tr class="separator:a602232080f91baba93c85684937765d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbc81d639cb5c12f2e2b59072e64f39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a5cbc81d639cb5c12f2e2b59072e64f39">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;sparse_matrix)</td></tr>
<tr class="separator:a5cbc81d639cb5c12f2e2b59072e64f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688b87cdf4067fc28483d5385b1dabda"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a688b87cdf4067fc28483d5385b1dabda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a688b87cdf4067fc28483d5385b1dabda">reinit</a> (const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const <a class="el" href="classdouble.html">double</a> drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=nullptr)</td></tr>
<tr class="separator:a688b87cdf4067fc28483d5385b1dabda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743888addc7cfd057c70ceff1e03cc02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a743888addc7cfd057c70ceff1e03cc02">reinit</a> (const Epetra_CrsMatrix &amp;input_matrix, const <a class="el" href="classbool.html">bool</a> copy_values=true)</td></tr>
<tr class="separator:a743888addc7cfd057c70ceff1e03cc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">使用IndexSet描述的构造器和初始化</div></td></tr>
<tr class="memitem:abf1eceecf61d5aacdb1192a6a0bded7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#abf1eceecf61d5aacdb1192a6a0bded7e">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const unsigned <a class="el" href="classint.html">int</a> n_max_entries_per_row=0)</td></tr>
<tr class="separator:abf1eceecf61d5aacdb1192a6a0bded7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d44ae4cf732744c50027c8d36f2a758"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a9d44ae4cf732744c50027c8d36f2a758">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a9d44ae4cf732744c50027c8d36f2a758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60748f3e8d3fbea4b3a4c192ff7d8455"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a60748f3e8d3fbea4b3a4c192ff7d8455">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> n_max_entries_per_row=0)</td></tr>
<tr class="separator:a60748f3e8d3fbea4b3a4c192ff7d8455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128b8b864bec45fa1115e43206861f22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a128b8b864bec45fa1115e43206861f22">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a128b8b864bec45fa1115e43206861f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5f926afa37ddbe5ffe18ecb1f037a8"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:abb5f926afa37ddbe5ffe18ecb1f037a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#abb5f926afa37ddbe5ffe18ecb1f037a8">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> exchange_data=false)</td></tr>
<tr class="separator:abb5f926afa37ddbe5ffe18ecb1f037a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a6a199cb405506baaf5fbe09bab1c9"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ae0a6a199cb405506baaf5fbe09bab1c9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !std::is_same&lt; SparsityPatternType, ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae0a6a199cb405506baaf5fbe09bab1c9">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> exchange_data=false)</td></tr>
<tr class="separator:ae0a6a199cb405506baaf5fbe09bab1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4023e59f650260e3002a7a7ec2548313"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a4023e59f650260e3002a7a7ec2548313"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4023e59f650260e3002a7a7ec2548313">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classdouble.html">double</a> drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=nullptr)</td></tr>
<tr class="separator:a4023e59f650260e3002a7a7ec2548313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7443128fe3987f117365d755839f62"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a2f7443128fe3987f117365d755839f62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2f7443128fe3987f117365d755839f62">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classdouble.html">double</a> drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=nullptr)</td></tr>
<tr class="separator:a2f7443128fe3987f117365d755839f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">矩阵的信息</div></td></tr>
<tr class="memitem:ab9cf2620cc3350eb189597bd2831570a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m</a> () const</td></tr>
<tr class="separator:ab9cf2620cc3350eb189597bd2831570a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371d418cc093230813c36578f32f0966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a371d418cc093230813c36578f32f0966">n</a> () const</td></tr>
<tr class="separator:a371d418cc093230813c36578f32f0966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a8c1f20e048f5a7b9711218779fad5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2a8c1f20e048f5a7b9711218779fad5">local_size</a> () const</td></tr>
<tr class="separator:ac2a8c1f20e048f5a7b9711218779fad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557eb5dabea73fb2d3e2ba70226cdfcf"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a557eb5dabea73fb2d3e2ba70226cdfcf">local_range</a> () const</td></tr>
<tr class="separator:a557eb5dabea73fb2d3e2ba70226cdfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998d6f1a926b04ec7c1a967f46775282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a998d6f1a926b04ec7c1a967f46775282">in_local_range</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> index) const</td></tr>
<tr class="separator:a998d6f1a926b04ec7c1a967f46775282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26d73bf5ba9422c98651107cc9dfbac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae26d73bf5ba9422c98651107cc9dfbac">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:ae26d73bf5ba9422c98651107cc9dfbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa245c41459e8f4100994de6dfb876fdf"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aa245c41459e8f4100994de6dfb876fdf">row_length</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> row) const</td></tr>
<tr class="separator:aa245c41459e8f4100994de6dfb876fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a559b1529540ca031728b25f63962c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a91a559b1529540ca031728b25f63962c">is_compressed</a> () const</td></tr>
<tr class="separator:a91a559b1529540ca031728b25f63962c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0241e5308043f439e44bf1285a0ac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a3b0241e5308043f439e44bf1285a0ac6">memory_consumption</a> () const</td></tr>
<tr class="separator:a3b0241e5308043f439e44bf1285a0ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b528da50ca77670b997382dc38a77b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a14b528da50ca77670b997382dc38a77b">get_mpi_communicator</a> () const</td></tr>
<tr class="separator:a14b528da50ca77670b997382dc38a77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">修改条目</div></td></tr>
<tr class="memitem:ae2e30c191f788f4e668df2a51fc0aad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae2e30c191f788f4e668df2a51fc0aad3">operator=</a> (const <a class="el" href="classdouble.html">double</a> d)</td></tr>
<tr class="separator:ae2e30c191f788f4e668df2a51fc0aad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e58c65baa9a70517d6dcd6d3371a525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a5e58c65baa9a70517d6dcd6d3371a525">clear</a> ()</td></tr>
<tr class="separator:a5e58c65baa9a70517d6dcd6d3371a525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ef7c7e43574dacfdbdd6d007708a38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:a77ef7c7e43574dacfdbdd6d007708a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0279858faded0f95d78c901b4e655317"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0279858faded0f95d78c901b4e655317">set</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> j, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> value)</td></tr>
<tr class="separator:a0279858faded0f95d78c901b4e655317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4eb1ed3db64694a143ff796028ed36f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae4eb1ed3db64694a143ff796028ed36f">set</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ae4eb1ed3db64694a143ff796028ed36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e7e8afef3f71bc0c685bd4b84fd69e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a03e7e8afef3f71bc0c685bd4b84fd69e">set</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a03e7e8afef3f71bc0c685bd4b84fd69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1793ec909cb013dc94609e65f72acfe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1793ec909cb013dc94609e65f72acfe2">set</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> row, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;col_indices, const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a1793ec909cb013dc94609e65f72acfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b15e7295291562879e3c526d0322ec"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ae1b15e7295291562879e3c526d0322ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae1b15e7295291562879e3c526d0322ec">set</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> row, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> n_cols, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> *col_indices, const Number *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ae1b15e7295291562879e3c526d0322ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2822f0aed012ede4516df69f53d0d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2822f0aed012ede4516df69f53d0d13">add</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> j, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> value)</td></tr>
<tr class="separator:ac2822f0aed012ede4516df69f53d0d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6253cdd3795e76d753099065189078ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a6253cdd3795e76d753099065189078ee">add</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a6253cdd3795e76d753099065189078ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b87b4a845b1c52815be6447e24341e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a8b87b4a845b1c52815be6447e24341e4">add</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a8b87b4a845b1c52815be6447e24341e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1fd0cf7019f1ead364e4cf4b806202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aad1fd0cf7019f1ead364e4cf4b806202">add</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> row, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;col_indices, const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:aad1fd0cf7019f1ead364e4cf4b806202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2468a28250ecc0ef4989b66dacdea55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aa2468a28250ecc0ef4989b66dacdea55">add</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> row, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> n_cols, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> *col_indices, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:aa2468a28250ecc0ef4989b66dacdea55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b02a77bbf81ac8ee1dbf558e1b1d849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1b02a77bbf81ac8ee1dbf558e1b1d849">operator*=</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> factor)</td></tr>
<tr class="separator:a1b02a77bbf81ac8ee1dbf558e1b1d849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a74de71c2fa3233b48ee71a3daf72dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a7a74de71c2fa3233b48ee71a3daf72dd">operator/=</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> factor)</td></tr>
<tr class="separator:a7a74de71c2fa3233b48ee71a3daf72dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce2618df5a059715d3d55c83f085763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a9ce2618df5a059715d3d55c83f085763">copy_from</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;source)</td></tr>
<tr class="separator:a9ce2618df5a059715d3d55c83f085763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bac02815f056cd6b235367edf83d31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae2bac02815f056cd6b235367edf83d31">add</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> factor, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1f3f26ae4997382b25a2eb9604200a75">matrix</a>)</td></tr>
<tr class="separator:ae2bac02815f056cd6b235367edf83d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1c4f2ee1e8ae2fadf5102c320c54cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4e1c4f2ee1e8ae2fadf5102c320c54cd">clear_row</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> row, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> new_diag_value=0)</td></tr>
<tr class="separator:a4e1c4f2ee1e8ae2fadf5102c320c54cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900a42baea388ebcc9b4c7bcf96f71b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a900a42baea388ebcc9b4c7bcf96f71b4">clear_rows</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;rows, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> new_diag_value=0)</td></tr>
<tr class="separator:a900a42baea388ebcc9b4c7bcf96f71b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7a578fb46241991114a6ffa99cd3fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1a7a578fb46241991114a6ffa99cd3fe">transpose</a> ()</td></tr>
<tr class="separator:a1a7a578fb46241991114a6ffa99cd3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">入口访问</div></td></tr>
<tr class="memitem:acd63c0d5ac1357d24b5fa7ffa4b1d3c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#acd63c0d5ac1357d24b5fa7ffa4b1d3c7">operator()</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> j) const</td></tr>
<tr class="separator:acd63c0d5ac1357d24b5fa7ffa4b1d3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e40cf415aa2630fd0f56e1878eadb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a92e40cf415aa2630fd0f56e1878eadb4">el</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> j) const</td></tr>
<tr class="separator:a92e40cf415aa2630fd0f56e1878eadb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe41a4a1feb344a2281a85d138d679ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> i) const</td></tr>
<tr class="separator:abe41a4a1feb344a2281a85d138d679ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">乘法运算</div></td></tr>
<tr class="memitem:a4aedd84e99cda48dce634a2bbf8763fd"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a4aedd84e99cda48dce634a2bbf8763fd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4aedd84e99cda48dce634a2bbf8763fd">vmult</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a4aedd84e99cda48dce634a2bbf8763fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318f6ff9df006a316365680fb08d3e4f"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a318f6ff9df006a316365680fb08d3e4f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a318f6ff9df006a316365680fb08d3e4f">vmult</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a318f6ff9df006a316365680fb08d3e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4d7979e74e7d74d329a5b9a3d0014c"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a9f4d7979e74e7d74d329a5b9a3d0014c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a9f4d7979e74e7d74d329a5b9a3d0014c">Tvmult</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a9f4d7979e74e7d74d329a5b9a3d0014c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7adf13a14a8342e246d3a3e58cc4a4e"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:aa7adf13a14a8342e246d3a3e58cc4a4e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aa7adf13a14a8342e246d3a3e58cc4a4e">Tvmult</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:aa7adf13a14a8342e246d3a3e58cc4a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6792587fa97254fae30dea0e8d770f0c"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a6792587fa97254fae30dea0e8d770f0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a6792587fa97254fae30dea0e8d770f0c">vmult_add</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a6792587fa97254fae30dea0e8d770f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849653e0230720b0f0ab58591974c0f2"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a849653e0230720b0f0ab58591974c0f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a849653e0230720b0f0ab58591974c0f2">Tvmult_add</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a849653e0230720b0f0ab58591974c0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be0bd695cbfabf512cea6ef3c9c28ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a3be0bd695cbfabf512cea6ef3c9c28ba">matrix_norm_square</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;v) const</td></tr>
<tr class="separator:a3be0bd695cbfabf512cea6ef3c9c28ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3575cd95bb79786665f996816023b11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae3575cd95bb79786665f996816023b11">matrix_scalar_product</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;u, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;v) const</td></tr>
<tr class="separator:ae3575cd95bb79786665f996816023b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d1cabc336bbc45ca182972ce02c82d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a95d1cabc336bbc45ca182972ce02c82d">residual</a> (<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;dst, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;x, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;b) const</td></tr>
<tr class="separator:a95d1cabc336bbc45ca182972ce02c82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbabb70ef99a4be889474c4c5dc4756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1dbabb70ef99a4be889474c4c5dc4756">mmult</a> (<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;C, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;B, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;V=<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()) const</td></tr>
<tr class="separator:a1dbabb70ef99a4be889474c4c5dc4756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446bb9a2e86487360cd8c73c021197e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a446bb9a2e86487360cd8c73c021197e4">Tmmult</a> (<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;C, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;B, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;V=<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()) const</td></tr>
<tr class="separator:a446bb9a2e86487360cd8c73c021197e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">矩阵规范</div></td></tr>
<tr class="memitem:a1e599d765970ef68e126aa9d5e93583e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1e599d765970ef68e126aa9d5e93583e">l1_norm</a> () const</td></tr>
<tr class="separator:a1e599d765970ef68e126aa9d5e93583e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bb09f66dde1c1969a23b4cccd17f04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a32bb09f66dde1c1969a23b4cccd17f04">linfty_norm</a> () const</td></tr>
<tr class="separator:a32bb09f66dde1c1969a23b4cccd17f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26df1c42b8f8973246287cfee4d20b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aa26df1c42b8f8973246287cfee4d20b4">frobenius_norm</a> () const</td></tr>
<tr class="separator:aa26df1c42b8f8973246287cfee4d20b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">访问底层Trilinos数据</div></td></tr>
<tr class="memitem:a2706d65ed111bced458694502fc56a3c"><td class="memItemLeft" align="right" valign="top">const Epetra_CrsMatrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2706d65ed111bced458694502fc56a3c">trilinos_matrix</a> () const</td></tr>
<tr class="separator:a2706d65ed111bced458694502fc56a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5601f390c0d339f5e087cf29951906d8"><td class="memItemLeft" align="right" valign="top">const Epetra_CrsGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a5601f390c0d339f5e087cf29951906d8">trilinos_sparsity_pattern</a> () const</td></tr>
<tr class="separator:a5601f390c0d339f5e087cf29951906d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">分割器</div></td></tr>
<tr class="memitem:a95be9f345182496414c8f74f81ad9502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a95be9f345182496414c8f74f81ad9502">locally_owned_domain_indices</a> () const</td></tr>
<tr class="separator:a95be9f345182496414c8f74f81ad9502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4255ce516797c98c4448a293ee4f523f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4255ce516797c98c4448a293ee4f523f">locally_owned_range_indices</a> () const</td></tr>
<tr class="separator:a4255ce516797c98c4448a293ee4f523f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">迭代器</div></td></tr>
<tr class="memitem:a53bc4c91231034a9924a89cb45bea7df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a53bc4c91231034a9924a89cb45bea7df">begin</a> () const</td></tr>
<tr class="separator:a53bc4c91231034a9924a89cb45bea7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432dd81dc9b1c3446d2b35dd902af016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a432dd81dc9b1c3446d2b35dd902af016">begin</a> ()</td></tr>
<tr class="separator:a432dd81dc9b1c3446d2b35dd902af016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46e2e5d966499c1b4e9da1798445eef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae46e2e5d966499c1b4e9da1798445eef">end</a> () const</td></tr>
<tr class="separator:ae46e2e5d966499c1b4e9da1798445eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818f02479da77b15b295090b8d379bb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a818f02479da77b15b295090b8d379bb5">end</a> ()</td></tr>
<tr class="separator:a818f02479da77b15b295090b8d379bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad11df47057376b44f5e495727ea9d72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aad11df47057376b44f5e495727ea9d72">begin</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> r) const</td></tr>
<tr class="separator:aad11df47057376b44f5e495727ea9d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac801a93ef57d40f3fbe36ca10909e47f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac801a93ef57d40f3fbe36ca10909e47f">begin</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> r)</td></tr>
<tr class="separator:ac801a93ef57d40f3fbe36ca10909e47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d0dcda5cd5cfd144526471a8c99d9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77d0dcda5cd5cfd144526471a8c99d9a">end</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> r) const</td></tr>
<tr class="separator:a77d0dcda5cd5cfd144526471a8c99d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4773e90eb187a3432dd2b69fe28273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aba4773e90eb187a3432dd2b69fe28273">end</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> r)</td></tr>
<tr class="separator:aba4773e90eb187a3432dd2b69fe28273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">输入/输出</div></td></tr>
<tr class="memitem:ad2297e8c999fc04057a3c2370b0db96c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ad2297e8c999fc04057a3c2370b0db96c">write_ascii</a> ()</td></tr>
<tr class="separator:ad2297e8c999fc04057a3c2370b0db96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4270ebaea8467f2862cf2baf38986815"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4270ebaea8467f2862cf2baf38986815">print</a> (std::ostream &amp;out, const <a class="el" href="classbool.html">bool</a> write_extended_trilinos_info=false) const</td></tr>
<tr class="separator:a4270ebaea8467f2862cf2baf38986815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a536e7d727e8394586b4c2dde99b39ba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a536e7d727e8394586b4c2dde99b39ba3">prepare_add</a> ()</td></tr>
<tr class="separator:a536e7d727e8394586b4c2dde99b39ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a6620012e379b4c660fb4431d817fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a68a6620012e379b4c660fb4431d817fb">prepare_set</a> ()</td></tr>
<tr class="separator:a68a6620012e379b4c660fb4431d817fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0c0bbe2fbaf13b7faf696d83f2e3a8f6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Epetra_Map &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0c0bbe2fbaf13b7faf696d83f2e3a8f6">column_space_map</a></td></tr>
<tr class="separator:a0c0bbe2fbaf13b7faf696d83f2e3a8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3f26ae4997382b25a2eb9604200a75"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Epetra_FECrsMatrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1f3f26ae4997382b25a2eb9604200a75">matrix</a></td></tr>
<tr class="separator:a1f3f26ae4997382b25a2eb9604200a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af574b90695c223223c111c6591f3c57b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Epetra_CrsMatrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af574b90695c223223c111c6591f3c57b">nonlocal_matrix</a></td></tr>
<tr class="separator:af574b90695c223223c111c6591f3c57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc3fe319a247fc46bd3d052b558f969"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Epetra_Export &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1dc3fe319a247fc46bd3d052b558f969">nonlocal_matrix_exporter</a></td></tr>
<tr class="separator:a1dc3fe319a247fc46bd3d052b558f969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1d6236f2215737135912c25cc993b0"><td class="memItemLeft" align="right" valign="top">Epetra_CombineMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a3c1d6236f2215737135912c25cc993b0">last_action</a></td></tr>
<tr class="separator:a3c1d6236f2215737135912c25cc993b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896761c5d6156507d191a404ca7dc8c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a896761c5d6156507d191a404ca7dc8c3">compressed</a></td></tr>
<tr class="separator:a896761c5d6156507d191a404ca7dc8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0eb72d666c41a0ac3c16def795c0c99b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0eb72d666c41a0ac3c16def795c0c99b">BlockMatrixBase&lt; SparseMatrix &gt;</a></td></tr>
<tr class="separator:a0eb72d666c41a0ac3c16def795c0c99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>这个类实现了一个包装器，用于使用Trilinos分布式稀疏矩阵类Epetra_FECrsMatrix。这正是我们一直在处理的那种矩阵</p>
<ul>
<li>我们很可能从一些装配过程中得到它，其中不属于本地的条目也可能需要被写入，因此需要转发给所有者过程。 这个类被设计用来在分布式内存架构中使用，底部有一个MPI编译器，但也同样适用于串行进程。 该类工作的唯一要求是，Trilinos已经安装了与生成deal.II相同的编译器。 这个类的接口是以deal.II中现有的SparseMatrix类为模型的。它有几乎相同的成员函数，而且通常是可以交换的。然而，由于Trilinos只支持单一的标量类型（double），所以它没有模板化，只对double起作用。 请注意，Trilinos只保证在矩阵装配后调用了函数 <code>GlobalAssemble</code> 的情况下，操作才会达到你的期望。 因此，你需要在实际使用矩阵之前调用 <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">SparseMatrix::compress()</a> 。这也会调用 <code>FillComplete</code> ，通过丢弃未使用的元素来压缩稀疏矩阵的存储格式。 不过，Trilinos允许在调用这些函数后继续组装矩阵。 <h3>Thread safety of Trilinos matrices</h3>
</li>
</ul>
<p>当从共享内存中的几个线程向Trilinos矩阵写入时，必须记住几件事，因为这个类中没有内置锁来防止数据竞赛。在同一时间内同时访问同一矩阵行会导致数据竞赛，用户必须明确避免。然而，在以下三个条件下，可以从几个线程同时访问矩阵的<b>different</b>行。 </p><ul>
<li>
矩阵只使用一个MPI进程。 </li>
<li>
矩阵已经用reinit()方法进行了初始化，并采用了DynamicSparsityPattern（包括本地相关行的集合，即汇编程序可能写入的行）。 </li>
<li>
矩阵已经从一个 <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> 对象中初始化，该对象又被reinit函数初始化，指定了三个索引集，一个用于行，一个用于列，以及更大的 <code>可写行集，操作是一个加法。在未来的某个时间点，Trilinos的支持可能足够完整，以至于从一个已经被类似于</code> <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> 的函数填充的 <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> 初始化，总是会产生一个允许多个进程写入同一矩阵行的矩阵。 然而，Trilinos至少在11.12版本之前并不正确支持这一功能。 </li>
</ul>
<p>请注意， <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> 的所有其他reinit方法和构造函数都会导致矩阵需要按需分配非进程条目，这就破坏了线程安全。当然，对块状Trilinos稀疏模式和块状矩阵使用各自的reinit方法也会导致线程安全。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00470">470</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a301d937415bb2c99478d00f4cb5cce7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301d937415bb2c99478d00f4cb5cce7a">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">TrilinosWrappers::SparseMatrix::size_type</a> =  ::<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明容器大小的类型。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00477">477</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a1d7757ad30700692bed81a328a4b6ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7757ad30700692bed81a328a4b6ee1">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">TrilinosWrappers::SparseMatrix::iterator</a> =  <a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为迭代器类声明一个别名。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00507">507</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ae308c2134b631d8553164329dfee584b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae308c2134b631d8553164329dfee584b">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">TrilinosWrappers::SparseMatrix::const_iterator</a> =  <a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为常量迭代器类声明一个别名。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00513">513</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="afac77967448da926f12fb1fa6bc37a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac77967448da926f12fb1fa6bc37a4d">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afac77967448da926f12fb1fa6bc37a4d">TrilinosWrappers::SparseMatrix::value_type</a> =  <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为所有其他的容器类声明一个别名，以示类比。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00519">519</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a637dbbd4e8ca9fc07a447c8f31e21647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637dbbd4e8ca9fc07a447c8f31e21647">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>默认构造函数。生成一个空的（零大小）矩阵。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00210">210</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ab3900dae374f5a71e5134840682662d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3900dae374f5a71e5134840682662d8">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>生成一个完全存储在本地的矩阵，有::m行和::n列。 每行的列条目数被指定为最大条目数参数。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00222">222</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a944e51f3f5f0202024e04b679172ec9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944e51f3f5f0202024e04b679172ec9e">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>生成一个完全存储在本地的矩阵，有::m行和::n列。 向量<code>n_entries_per_row</code>指定了每一行的条目数。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00253">253</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a0b2b62a80dac30c548e1d20c3e77beae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2b62a80dac30c548e1d20c3e77beae">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>InputSparsityPattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从Trilinos稀疏模式对象生成一个矩阵。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00342">342</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a7d0c3506eddcfd2bff3c8b4658b7d493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0c3506eddcfd2bff3c8b4658b7d493">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动构造函数。通过窃取内部数据创建一个新的稀疏矩阵。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00359">359</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aafc6e5a99462abbc7d9324b4824be576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc6e5a99462abbc7d9324b4824be576">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制构造函数被删除。 </p>

</div>
</div>
<a id="adbe89a97bc7ef4bbc16e5e04b72bb19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe89a97bc7ef4bbc16e5e04b72bb19e">&#9670;&nbsp;</a></span>~SparseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TrilinosWrappers::SparseMatrix::~SparseMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解构器。做成了虚拟，这样就可以使用指向这个类的指针。 </p>

</div>
</div>
<a id="abf1eceecf61d5aacdb1192a6a0bded7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1eceecf61d5aacdb1192a6a0bded7e">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用一个IndexSet和一个MPI通信器的构造器来描述并行分区。参数 <code>n_max_entries_per_row</code> 设置将被分配的每一行中的非零条目的数量。注意，这个数字不需要精确，甚至允许实际的矩阵结构有比构造函数中指定的更多的非零条目。但是在这里提供良好的估计仍然是有利的，因为这将大大增加矩阵设置的性能。然而，对矩阵-向量乘积的性能没有影响，因为Trilinos在使用前（在compress()步骤中）重新组织了矩阵内存。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00275">275</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a9d44ae4cf732744c50027c8d36f2a758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d44ae4cf732744c50027c8d36f2a758">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与之前相同，但现在单独设置每个矩阵行中的非零的数量。因为在这种情况下，我们确切地知道矩阵中的元素数量，所以我们已经可以分配合适的内存数量，这使得创建过程（包括通过各自的 <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">SparseMatrix::reinit</a> 调用插入非零元素）大大加快。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00290">290</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a60748f3e8d3fbea4b3a4c192ff7d8455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60748f3e8d3fbea4b3a4c192ff7d8455">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个构造函数与上面的构造函数类似，但现在它为行和列采取了两个不同的 <a class="el" href="classIndexSet.html">IndexSet</a> 分区。这个接口是用来生成矩形矩阵的，其中第一个索引集描述了与矩阵行相关的自由度的平行分区，第二个索引集描述了矩阵列的分区。第二个索引集指定了这个矩阵要与之相乘的向量的分区，而不是实际出现在矩阵中的元素的分布。 参数 <code>n_max_entries_per_row</code> 定义了将为每一行分配多少内存。这个数字不需要准确，因为结构会在compress()调用中被重组。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00307">307</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a128b8b864bec45fa1115e43206861f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128b8b864bec45fa1115e43206861f22">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个构造函数与上面的构造函数类似，但它现在需要两个不同的Epetra映射来表示行和列。这个接口是用来生成矩形矩阵的，其中一个映射指定了与矩阵行相关的自由度的平行分布，第二个映射指定了与矩阵中的列相关的自由度的平行分布。第二个映射也为矩阵向量乘积中的内部排列提供信息（即这个矩阵要与之相乘的向量分布），但不用于列的分布&amp;ndash；相反，在任何情况下，一行的所有列元素都存储在同一个处理器上。向量<code>n_entries_per_row</code>指定了新生成的矩阵中每一行的条目数。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00324">324</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b339047bea78c496cb6f6bb3ab9341c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b339047bea78c496cb6f6bb3ab9341c">&#9670;&nbsp;</a></span>DeclException1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcAccessToNonlocalRow&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You tried to access row &quot;&lt;&lt; arg1&lt;&lt; &quot; of a non-contiguous locally owned row set.&quot;&lt;&lt; &quot; The row &quot;&lt;&lt; arg1&lt;&lt; &quot; is not stored locally and can't be accessed.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="aec6980b4f220e3d41b00d5ffa38623d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6980b4f220e3d41b00d5ffa38623d7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&amp; TrilinosWrappers::SparseMatrix::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>operator=被删除。 </p>

</div>
</div>
<a id="a614ca8e186fe3c61e03a52369437157e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614ca8e186fe3c61e03a52369437157e">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数用deal.II稀疏模式初始化Trilinos矩阵，也就是说，它使Trilinos Epetra矩阵根据稀疏模式知道非零项的位置。这个函数是为了在串行程序中使用，不需要指定矩阵如何在不同处理器之间分配。这个函数也可以在并行中使用，但建议使用Epetra_Map手动指定矩阵的并行分区。 当以并行方式运行时，目前需要每个处理器都持有sparsity_pattern结构，因为每个处理器都要设置其行数。 这是一个集体操作，需要在所有处理器上调用，以避免出现死锁。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00786">786</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a602232080f91baba93c85684937765d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602232080f91baba93c85684937765d5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数从一个（可能是分布式的）Trilinos稀疏模式重新初始化Trilinos稀疏矩阵。 这是一个集体操作，需要在所有处理器上调用，以避免出现死锁。 如果你想从几个线程写到矩阵并使用MPI，你需要使用这个reinit方法，并使用已经创建的明确说明可写行的稀疏度模式。在所有其他情况下，你不能把MPI和多线程写进矩阵中。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00830">830</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a5cbc81d639cb5c12f2e2b59072e64f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbc81d639cb5c12f2e2b59072e64f39">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>sparse_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数将 <code>sparse_matrix</code> 的布局复制到调用矩阵中。值不会被复制，但你可以使用copy_from()来实现。 这是一个集体操作，需要在所有处理器上调用，以避免出现死锁。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00855">855</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a688b87cdf4067fc28483d5385b1dabda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688b87cdf4067fc28483d5385b1dabda">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数使用deal.II稀疏矩阵和存储在其中的条目来初始化Trilinos矩阵。它使用一个阈值，只复制模数大于阈值的元素（所以deal.II矩阵中的零可以被过滤掉）。 可选参数<code>copy_values</code>决定是只使用输入矩阵的稀疏结构，还是也要复制矩阵的条目。 这是一个集体操作，需要在所有处理器上调用，以避免出现死锁。 </p><dl class="section note"><dt>Note</dt><dd>如果在最后一个参数中给出了不同的稀疏模式（即与第一个参数中给出的稀疏矩阵中使用的模式不同），那么生成的特里诺斯矩阵将具有如此给出的稀疏模式。当然，这也意味着给定的矩阵中所有不属于这个单独的稀疏模式的条目实际上将被删除。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00993">993</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a743888addc7cfd057c70ceff1e03cc02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743888addc7cfd057c70ceff1e03cc02">&#9670;&nbsp;</a></span>reinit() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_CrsMatrix &amp;&#160;</td>
          <td class="paramname"><em>input_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个reinit函数将一个Trilinos Epetra_CrsMatrix作为输入，并复制其稀疏性模式。如果有此要求，甚至连内容（值）也将被复制。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01011">1011</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="abb5f926afa37ddbe5ffe18ecb1f037a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5f926afa37ddbe5ffe18ecb1f037a8">&#9670;&nbsp;</a></span>reinit() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数是根据指定的稀疏性_模式初始化Tridinos Epetra矩阵，同时根据用户提供的索引集和并行通信器，将矩阵的行数重新分配给不同进程。在遵循教程程序风格的程序中，这个函数（以及对矩形矩阵的相应调用）是初始化矩阵大小、其在MPI进程中的分布（如果在parallel中运行）以及非零元素位置的自然方式。Trilinos在内部存储了稀疏模式，所以在这个调用之后就不再需要它了，与deal.II自己的对象相反。可选的参数 <code>exchange_data</code> 可用于重新初始化未完全构建的稀疏度模式。这个功能只对动态稀疏模式类型的输入稀疏模式实现。如果没有设置该标志，每个处理器只是设置疏散度模式中属于其行的元素。 这是一个集体操作，需要在所有处理器上调用，以避免出现死锁。 </p>

</div>
</div>
<a id="ae0a6a199cb405506baaf5fbe09bab1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a6a199cb405506baaf5fbe09bab1c9">&#9670;&nbsp;</a></span>reinit() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_same&lt; SparsityPatternType,::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;::value &gt;::type <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数类似于上面的另一个初始化函数，但现在也根据两个用户提供的索引集重新分配矩阵的行和列。 要用于矩形矩阵。可选的参数 <code>exchange_data</code> 可用于用未完全构建的稀疏模式进行重新初始化。这个功能只对动态稀疏模式类型的输入稀疏模式实现。 这是一个集体操作，需要在所有处理器上调用，以避免出现死锁。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00805">805</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a4023e59f650260e3002a7a7ec2548313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4023e59f650260e3002a7a7ec2548313">&#9670;&nbsp;</a></span>reinit() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数使用deal.II稀疏矩阵和存储在其中的条目来初始化Trilinos矩阵。它使用一个阈值，只复制模数大于阈值的元素（所以deal.II矩阵中的零可以被过滤掉）。与其他带有deal.II稀疏矩阵参数的reinit函数不同的是，该函数采用用户指定的并行分区，而不是内部生成的。 可选参数<code>copy_values</code>决定是只使用输入矩阵的稀疏结构还是也要复制矩阵条目。 这是一个集体操作，需要在所有处理器上调用，以避免出现死锁。 </p>

</div>
</div>
<a id="a2f7443128fe3987f117365d755839f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7443128fe3987f117365d755839f62">&#9670;&nbsp;</a></span>reinit() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数类似于上面的另一个初始化函数与deal.II稀疏矩阵输入，但现在需要矩阵的行和列的索引集。选用于矩形矩阵。 可选参数<code>copy_values</code>决定是只使用输入矩阵的稀疏结构还是也复制矩阵条目。 这是一个集体操作，需要在所有处理器上调用，以避免出现死锁。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00881">881</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ab9cf2620cc3350eb189597bd2831570a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cf2620cc3350eb189597bd2831570a">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> TrilinosWrappers::SparseMatrix::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个矩阵的行数。 </p>

</div>
</div>
<a id="a371d418cc093230813c36578f32f0966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371d418cc093230813c36578f32f0966">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> TrilinosWrappers::SparseMatrix::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回此矩阵中的列数。 </p>

</div>
</div>
<a id="ac2a8c1f20e048f5a7b9711218779fad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a8c1f20e048f5a7b9711218779fad5">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> TrilinosWrappers::SparseMatrix::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的本地维度，即存储在当前MPI进程中的行数。对于顺序矩阵，这个数字与m()相同，但对于并行矩阵，这个数字可能更小。 要想知道哪些元素被存储在本地，可以使用local_range()。 </p>

</div>
</div>
<a id="a557eb5dabea73fb2d3e2ba70226cdfcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557eb5dabea73fb2d3e2ba70226cdfcf">&#9670;&nbsp;</a></span>local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&gt; TrilinosWrappers::SparseMatrix::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一对指数，表明该矩阵的哪些行是本地存储的。第一个数字是存储的第一行的索引，第二个数字是本地存储的最后一行之后的那一行的索引。如果这是一个连续的矩阵，那么结果将是一对(0,m())，否则将是一对(i,i+n)，其中<code>n=<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2a8c1f20e048f5a7b9711218779fad5">local_size()</a></code>。 </p>

</div>
</div>
<a id="a998d6f1a926b04ec7c1a967f46775282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998d6f1a926b04ec7c1a967f46775282">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparseMatrix::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回 <code>index</code> 是否在本地范围内，另见local_range()。 </p>

</div>
</div>
<a id="ae26d73bf5ba9422c98651107cc9dfbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26d73bf5ba9422c98651107cc9dfbac">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> TrilinosWrappers::SparseMatrix::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个矩阵的非零元素的总数（所有MPI进程的总和）。 </p>

</div>
</div>
<a id="aa245c41459e8f4100994de6dfb876fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa245c41459e8f4100994de6dfb876fdf">&#9670;&nbsp;</a></span>row_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>特定行中的条目数。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01341">1341</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a91a559b1529540ca031728b25f63962c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a559b1529540ca031728b25f63962c">&#9670;&nbsp;</a></span>is_compressed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparseMatrix::is_compressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的状态，即在需要数据交换的操作之后是否需要调用compress()。当方法set()被调用时，也需要调用compress()（即使在串行工作时）。 </p>

</div>
</div>
<a id="a3b0241e5308043f439e44bf1285a0ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0241e5308043f439e44bf1285a0ac6">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">SparseMatrix::size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>确定这个对象的内存消耗（以字节为单位）的估计值。注意，如果在基于MPI的程序中调用这个方法，则只返回当前处理器上保留的内存。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02294">2294</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a14b528da50ca77670b997382dc38a77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b528da50ca77670b997382dc38a77b">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMPI__Comm.html">MPI_Comm</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回与该矩阵一起使用的MPI通信器对象。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02307">2307</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae2e30c191f788f4e668df2a51fc0aad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e30c191f788f4e668df2a51fc0aad3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个操作符将一个标量分配给一个矩阵。因为这通常没有什么意义（我们应该把所有的矩阵条目都设置为这个值吗？ 仅仅是稀疏模式的非零条目？），只有当要分配的实际值为零时，才允许这个操作。这个操作符的存在只是为了允许明显的符号<code>matrix=0</code>，它将矩阵的所有元素设置为零，但保留了之前使用的稀疏模式。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01767">1767</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a5e58c65baa9a70517d6dcd6d3371a525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e58c65baa9a70517d6dcd6d3371a525">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>释放所有内存并返回到与调用默认构造函数后相同的状态。 这是一个集体操作，需要在所有处理器上调用，以避免出现死锁。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01104">1104</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a77ef7c7e43574dacfdbdd6d007708a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ef7c7e43574dacfdbdd6d007708a38">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个命令做两件事。 </p><ul>
<li>
如果矩阵在初始化时没有稀疏模式，则使用set()命令手动添加元素。当这个过程完成后，对compress()的调用重组了内部数据结构（稀疏模式），这样就可以在矩阵-向量产品中快速访问数据。 </li>
<li>
如果矩阵结构已经被固定（通过初始化稀疏模式或在设置阶段调用compress()），该命令将进行数据的并行交换。 当我们在一个以上的（MPI）进程上进行装配时，这是必要的，因为这时一些非本地的行数据会积累在属于当前的处理器元素的节点上，但实际上是由另一个处理器持有的。这个命令通常在所有元素都被遍历后调用。 </li>
</ul>
<p>在这两种情况下，这个函数都会压缩数据结构，并允许产生的矩阵用于所有其他操作，如矩阵-向量乘积。这是一个集体操作，也就是说，在并行使用时，需要在所有处理器上运行。 更多信息见 <a class="el" href="DEALGlossary.html#GlossCompress">压缩分布式对象</a>。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01045">1045</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a0279858faded0f95d78c901b4e655317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0279858faded0f95d78c901b4e655317">&#9670;&nbsp;</a></span>set() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将元素（<em>i,j</em>）设置为 <code>value</code>. 只要compress()没有被调用，这个函数就能够在矩阵中插入新的元素，所以稀疏模式将被扩展。当compress()第一次被调用时（或者在矩阵被初始化为稀疏模式的情况下），不能添加新的元素，在未被初始化的位置插入元素会引发异常。 如果矩阵是在没有稀疏模式的情况下构建的，并且新的矩阵条目是按需添加的，请注意底层Epetra_FECrsMatrix数据结构施加的以下行为。 如果同一个矩阵条目被多次插入，那么即使 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a> 被指定为compress()的参数，矩阵条目也会在调用compress()时被添加（因为Epetra不会在最终调用compress()前跟踪同一个条目的值）。如果你不能确保矩阵条目只被设置一次，那么在插入元素之前，用稀疏模式初始化矩阵，固定矩阵结构。 </p>

</div>
</div>
<a id="ae4eb1ed3db64694a143ff796028ed36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4eb1ed3db64694a143ff796028ed36f">&#9670;&nbsp;</a></span>set() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将FullMatrix&lt;double&gt;中给出的所有元素设置到<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素写入调用的矩阵中，对矩阵的行和列都使用<code>indices</code>指定的本地到全球的索引。这个函数假设一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中的通常情况。 只要没有调用compress()，这个函数就能够在矩阵中插入新的元素，所以稀疏模式将被扩展。在第一次调用compress()后，或者矩阵被初始化为稀疏模式后，扩展稀疏模式就不再可能了，在未初始化的位置插入元素会产生一个异常。 可选参数<code>elide_zero_values</code>可以用来指定零值是否应该被插入，或者应该被过滤掉。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 对于矩阵的构建没有稀疏模式，新的矩阵条目是按需添加的情况，请注意底层Epetra_FECrsMatrix数据结构施加的以下行为。 如果同一个矩阵条目被多次插入，那么即使 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a> 被指定为compress()的参数，矩阵条目也会在调用compress()时被添加（因为Epetra不会在最终调用compress()前跟踪同一个条目的值）。如果你不能确保矩阵条目只被设置一次，那么在插入元素之前，用稀疏模式初始化矩阵，固定矩阵结构。 </p>

</div>
</div>
<a id="a03e7e8afef3f71bc0c685bd4b84fd69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e7e8afef3f71bc0c685bd4b84fd69e">&#9670;&nbsp;</a></span>set() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与之前的功能相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的局部到全局的索引。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01367">1367</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1793ec909cb013dc94609e65f72acfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1793ec909cb013dc94609e65f72acfe2">&#9670;&nbsp;</a></span>set() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将矩阵指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 只要没有调用compress()，这个函数就能够在矩阵中插入新的元素，所以稀疏模式将被扩展。在第一次调用compress()后，或者矩阵被初始化为稀疏模式后，扩展稀疏模式就不再可能了，在未初始化的位置插入元素将引发异常。 可选参数<code>elide_zero_values</code>可以用来指定零值是否应该被插入，或者应该被过滤掉。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 对于矩阵的构建没有稀疏模式，新的矩阵条目是按需添加的情况，请注意底层Epetra_FECrsMatrix数据结构施加的以下行为。 如果同一个矩阵条目被多次插入，那么即使 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a> 被指定为compress()的参数，矩阵条目也会在调用compress()时被添加（因为Epetra不会在最终调用compress()前跟踪同一条目的值）。如果你不能确保矩阵条目只被设置一次，那么在插入元素之前，用稀疏模式初始化矩阵，固定矩阵结构。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01388">1388</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae1b15e7295291562879e3c526d0322ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b15e7295291562879e3c526d0322ec">&#9670;&nbsp;</a></span>set() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将几个元素设置为<code>values</code>所给的值，在稀疏矩阵的col_indices所给的列中的某一行。 只要没有调用compress()，这个函数就能够在矩阵中插入新的元素，所以稀疏模式将被扩展。在第一次调用compress()后，或者矩阵被初始化为稀疏模式后，扩展稀疏模式就不再可能了，在未初始化的位置插入元素将引发异常。 可选参数<code>elide_zero_values</code>可以用来指定零值是否应该被插入，或者应该被过滤掉。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 对于矩阵的构建没有稀疏模式，新的矩阵条目是按需添加的情况，请注意底层Epetra_FECrsMatrix数据结构施加的以下行为。 如果同一个矩阵条目被多次插入，那么即使 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a> 被指定为compress()的参数，矩阵条目也会在调用compress()时被添加（因为Epetra不会在最终调用compress()前跟踪同一个条目的值）。如果你不能确保矩阵条目只被设置一次，那么在插入元素之前，用稀疏模式初始化矩阵，固定矩阵结构。 </p>

</div>
</div>
<a id="ac2822f0aed012ede4516df69f53d0d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2822f0aed012ede4516df69f53d0d13">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在元素（<em>i,j</em>）上添加 <code>value</code> 。 就像deal.II SparseMatrix&lt;Number&gt;类中的相应调用一样（但与基于PETSc的矩阵的情况不同），如果稀疏模式中不存在一个条目，这个函数会抛出一个异常。 此外，如果<code>value</code>不是一个有限的数字，也会抛出一个异常。 </p>

</div>
</div>
<a id="a6253cdd3795e76d753099065189078ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6253cdd3795e76d753099065189078ee">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将FullMatrix&lt;double&gt;中给出的所有元素添加到由<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素添加到调用矩阵的相应条目中，使用<code>indices</code>为矩阵的行和列指定的本地到全球索引。这个函数假设了一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中的通常情况。 就像deal.II SparseMatrix&lt;Number&gt;类中的相应调用一样（但与基于PETSc的矩阵的情况不同），如果稀疏模式中不存在一个条目，这个函数会抛出一个异常。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01541">1541</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a8b87b4a845b1c52815be6447e24341e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b87b4a845b1c52815be6447e24341e4">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01560">1560</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aad1fd0cf7019f1ead364e4cf4b806202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1fd0cf7019f1ead364e4cf4b806202">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将矩阵的指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 就像deal.II SparseMatrix&lt;Number&gt;类中的相应调用一样（但与基于PETSc的矩阵的情况不同），如果稀疏模式中不存在一个条目，这个函数会抛出一个异常。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01581">1581</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aa2468a28250ecc0ef4989b66dacdea55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2468a28250ecc0ef4989b66dacdea55">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在给定的全局矩阵行中，在稀疏矩阵中由col_indices指定的列中添加一个由<code>values</code>给出的数值阵列。 就像deal.II SparseMatrix&lt;Number&gt;类中的相应调用一样（但与基于PETSc的矩阵的情况不同），如果在稀疏模式中不存在条目，这个函数会抛出一个异常。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01599">1599</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1b02a77bbf81ac8ee1dbf558e1b1d849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b02a77bbf81ac8ee1dbf558e1b1d849">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将整个矩阵乘以一个固定系数。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01890">1890</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a7a74de71c2fa3233b48ee71a3daf72dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a74de71c2fa3233b48ee71a3daf72dd">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用整个矩阵除以一个固定系数。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01902">1902</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a9ce2618df5a059715d3d55c83f085763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce2618df5a059715d3d55c83f085763">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制给定的（Trilinos）矩阵（稀疏模式和条目）。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00374">374</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae2bac02815f056cd6b235367edf83d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bac02815f056cd6b235367edf83d31">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将<code>matrix</code>按<code>factor</code>的比例添加到该矩阵中，即<code>factor*matrix</code>的矩阵被添加到<code>this</code>。如果调用矩阵的稀疏性模式不包含输入矩阵的稀疏性模式中的所有元素，这个函数将抛出一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01785">1785</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a4e1c4f2ee1e8ae2fadf5102c320c54cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1c4f2ee1e8ae2fadf5102c320c54cd">&#9670;&nbsp;</a></span>clear_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::clear_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将此<code>行</code>中的所有元素设置为零，将其删除。这个函数并不修改分配的非零条目的数量，它只是将这些条目设置为零。 这个操作用于消除约束（例如由于挂起的节点），并确保我们可以将这个修改写入矩阵，而不必从矩阵中读取条目（例如非零元素的位置）&amp;mdash；如果没有这个操作，消除并行矩阵的约束是一个相当复杂的程序。 第二个参数可以用来将该行的对角线条目设置为一个不同于零的值。默认是将其设置为零。 </p><dl class="section note"><dt>Note</dt><dd>如果矩阵是使用MPI在多个处理器之间并行存储的，这个函数只触及本地存储的行，而简单地忽略所有其他行的索引。此外，在并行计算的背景下，如果你清除了某一行，而其他处理器对同一行仍有待处理的写入或添加，你会陷入麻烦。换句话说，如果另一个处理器仍然想向某行的某个元素添加东西，而你调用这个函数将该行清零，那么你下次调用compress()时可能会将远程值添加到你刚刚创建的零上。因此，你要在对矩阵进行最后一次修改后，在开始清空行之前调用compress()。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01123">1123</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a900a42baea388ebcc9b4c7bcf96f71b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900a42baea388ebcc9b4c7bcf96f71b4">&#9670;&nbsp;</a></span>clear_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::clear_rows </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与clear_row()相同，不同的是，它一次对若干行进行操作。 第二个参数可以用来将所有被清除的行的对角线项设置为不同于0的内容。请注意，所有这些对角线项都得到相同的值</p>
<ul>
<li>如果你想要不同的对角线条目的值，你必须手动设置它们。 <dl class="section note"><dt>Note</dt><dd>如果矩阵是用MPI在多个处理器之间并行存储的，这个函数只触及本地存储的行，而简单地忽略所有其他行的索引。此外，在并行计算的背景下，如果你清除了某一行，而其他处理器对同一行仍有待处理的写入或添加，你会陷入麻烦。换句话说，如果另一个处理器仍然想向某行的某个元素添加东西，而你调用这个函数将该行清零，那么你下次调用compress()时可能会将远程值添加到你刚刚创建的零上。因此，你要在对矩阵进行最后一次修改后，在开始清空行之前调用compress()。 </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01159">1159</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1a7a578fb46241991114a6ffa99cd3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7a578fb46241991114a6ffa99cd3fe">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置一个内部标志，使矩阵进行的所有操作，即乘法，都以转置的顺序进行。然而，这并不能直接将矩阵重塑为转置的形式，所以在使用这个标志时应该注意。 </p><dl class="section note"><dt>Note</dt><dd>连续调用此函数的任何偶数次，都将使对象返回到其原始状态。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01866">1866</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="acd63c0d5ac1357d24b5fa7ffa4b1d3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd63c0d5ac1357d24b5fa7ffa4b1d3c7">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回条目的值（<em>i,j</em>）。 这可能是一个昂贵的操作，你应该始终注意在哪里调用这个函数。 正如在deal.II稀疏矩阵类中，如果相应的条目不存在于该类的稀疏模式中，我们会抛出一个异常，这是从Trilinos中请求的。此外，如果要求的元素没有保存在调用过程中，也会抛出一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01169">1169</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a92e40cf415aa2630fd0f56e1878eadb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e40cf415aa2630fd0f56e1878eadb4">&#9670;&nbsp;</a></span>el()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵条目的值（<em>i,j</em>）。如果这个条目在稀疏模式中不存在，那么将返回0。虽然这在某些情况下可能很方便，但请注意，由于没有使用矩阵的稀疏性，写出的算法与最优解相比很简单，很慢。 另一方面，如果你想确定条目存在，你应该使用operator()来代替。 如果你有一个并行的矩阵，这个函数中缺乏错误检查，也会产生令人惊讶的结果。在这种情况下，你从这个函数中得到一个零的结果，并不意味着该条目在稀疏模式中不存在，或者它存在但数值为零。相反，也可能是它根本就没有存储在当前的处理器上；在这种情况下，它可能被存储在另一个处理器上，而且可能是以非零值存储的。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01248">1248</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="abe41a4a1feb344a2281a85d138d679ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe41a4a1feb344a2281a85d138d679ee">&#9670;&nbsp;</a></span>diag_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回第<em>i</em>行的主对角线元素。如果矩阵不是二次方的，这个函数会抛出一个错误，如果&lt;i&gt;(i,i)不是本地矩阵的元素，它也会抛出一个错误。 参见trilinos_sparse_matrix.cc中的注释。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01320">1320</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a4aedd84e99cda48dce634a2bbf8763fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aedd84e99cda48dce634a2bbf8763fd">&#9670;&nbsp;</a></span>vmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_same&lt; typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt;::value &gt;::type <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让<em>dst = M*src</em>与<em>M</em>为该矩阵。 源和目的不能是同一个向量。 这个函数可以用几种类型的向量对象来调用，即 <code>VectorType</code> 可以是 </p><ul>
<li>
<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, </li>
<li>
<a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html">LinearAlgebra::EpetraWrappers::Vector</a>, </li>
<li>
<a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html">LinearAlgebra::TpetraWrappers::Vector</a>, </li>
<li>
<a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>， </li>
<li>
LinearAlgebra::distributed::Vector&lt;double&gt;. </li>
</ul>
<p>当使用类型为 <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, ]的向量 <code>dst</code> 必须用用于矩阵行索引的相同IndexSet进行初始化，向量 <code>src</code> 必须用用于矩阵列索引的相同IndexSet进行初始化。 当矩阵对象和向量对象的底层数字类型相同时，这个函数将被调用。 尽管看起来很复杂，但其返回类型只是 "void"。 如果是一个串行向量，这个函数只有在一个处理器上运行时才会起作用，因为矩阵对象本身就是分布的。否则，会产生一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01976">1976</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a318f6ff9df006a316365680fb08d3e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318f6ff9df006a316365680fb08d3e4f">&#9670;&nbsp;</a></span>vmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same&lt;typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&gt;::value&gt;::type TrilinosWrappers::SparseMatrix::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面的函数相同，适用于矩阵对象的底层数字类型和向量对象的数字类型不一致的情况。 这种情况没有实现。调用它将导致一个运行时错误。 尽管看起来很复杂，但其返回类型只是 "void"。 </p>

</div>
</div>
<a id="a9f4d7979e74e7d74d329a5b9a3d0014c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4d7979e74e7d74d329a5b9a3d0014c">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_same&lt; typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt;::value &gt;::type <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让<em>dst = M<sup>T</sup>*src</em>与<em>M</em>是这个矩阵。这个函数与vmult()的作用相同，但需要转置的矩阵。 源和目的不能是同一个向量。 这个函数可以用几种类型的向量对象调用，见vmult()中关于 <code>VectorType</code> 的讨论。 当矩阵对象的底层数字类型和向量对象的底层数字类型相同时，该函数将被调用。 尽管看起来很复杂，但其返回类型只是 "void"。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02020">2020</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aa7adf13a14a8342e246d3a3e58cc4a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7adf13a14a8342e246d3a3e58cc4a4e">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same&lt;typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&gt;::value&gt;::type TrilinosWrappers::SparseMatrix::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面的函数相同，适用于矩阵对象的底层数字类型和向量对象的底层数字类型不一致的情况。 这种情况没有实现。调用它将导致一个运行时错误。 尽管看起来很复杂，但其返回类型只是 "void"。 </p>

</div>
</div>
<a id="a6792587fa97254fae30dea0e8d770f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6792587fa97254fae30dea0e8d770f0c">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::vmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>添加矩阵-向量的乘法。在<em>dst</em>上添加<em>M*src</em>，<em>M</em>为该矩阵。 源和目的不能是同一个向量。 这个函数可以用几种类型的向量对象调用，见vmult()中关于 <code>VectorType</code> 的讨论。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02060">2060</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a849653e0230720b0f0ab58591974c0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849653e0230720b0f0ab58591974c0f2">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>添加矩阵-向量的乘法。将<em>M<sup>T</sup>*src</em>加到<em>dst</em>，<em>M</em>是这个矩阵。这个函数的作用与vmult_add()相同，但取的是转置的矩阵。 来源和目的地不能是同一个向量。 这个函数可以用几种类型的向量对象调用，见vmult()中关于 <code>VectorType</code> 的讨论。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02076">2076</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a3be0bd695cbfabf512cea6ef3c9c28ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be0bd695cbfabf512cea6ef3c9c28ba">&#9670;&nbsp;</a></span>matrix_norm_square()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量 \(v\) 相对于该矩阵引起的规范的平方，即 \(\left(v,Mv\right)\) 。这很有用，例如在有限元背景下，一个函数的 \(L_2\) 规范等于相对于代表有限元函数节点值的向量的质量矩阵的矩阵规范。 很明显，对于这个操作，矩阵需要是二次的。 这个函数的实现没有deal.II中使用的 <code><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a></code> 类（即原始的，而不是Trilinos包装类）的效率高，因为Trilinos不支持这个操作，需要一个临时向量。 矢量必须用矩阵初始化的相同IndexSet进行初始化。 如果是一个本地化的Vector，这个函数只有在一个处理器上运行时才会起作用，因为矩阵对象本身就是分布的。否则，将抛出一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02091">2091</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae3575cd95bb79786665f996816023b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3575cd95bb79786665f996816023b11">&#9670;&nbsp;</a></span>matrix_scalar_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算矩阵标量乘积 \(\left(u,Mv\right)\) 。 这个函数的实现没有deal.II中使用的 <code><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a></code> 类（即原始的，而不是Trilinos包装类）的效率高，因为Trilinos不支持这个操作，需要一个临时矢量。 矢量 <code>u</code> 必须用用于矩阵行索引的相同IndexSet进行初始化，矢量 <code>v</code> 必须用用于矩阵列索引的相同IndexSet进行初始化。 如果是一个本地化的Vector，这个函数只有在一个处理器上运行时才会起作用，因为矩阵对象本身是分布式的。否则，将抛出一个异常。 这个函数只对方形矩阵实现。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02105">2105</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a95d1cabc336bbc45ca182972ce02c82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d1cabc336bbc45ca182972ce02c82d">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算方程<em>Mx=b</em>的残差，其中残差被定义为<em>r=b-Mx</em>。将残差写入 <code>dst</code>. 返回残差向量的<em>l<sub>2</sub></em>准则。 源<em>x</em>和目的<em>dst</em>不能是同一个向量。 向量 <code>dst</code> 和 <code>b</code> 必须用用于矩阵行索引的相同IndexSet进行初始化，向量 <code>x</code> 必须用用于矩阵列索引的相同IndexSet进行初始化。 如果是一个本地化的Vector，这个函数只有在一个处理器上运行时才会起作用，因为矩阵对象本身是分布式的。否则，将抛出一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02120">2120</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1dbabb70ef99a4be889474c4c5dc4756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbabb70ef99a4be889474c4c5dc4756">&#9670;&nbsp;</a></span>mmult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>执行矩阵-矩阵乘法<code>C = A B</code>，或者，如果给出一个可选的矢量参数，<code>C = A diag(V) B</code>，其中<code>diag(V)</code>定义了一个带有矢量条目的对角矩阵。 这个函数假定调用矩阵<code>A</code>和<code>B</code>的大小是兼容的。<code>C</code>的大小将在本函数中设置。 矩阵C的内容和稀疏模式将被这个函数改变，所以要确保稀疏模式没有在你的程序中其他地方使用。这是一个昂贵的操作，所以在使用这个函数之前请三思。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02231">2231</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a446bb9a2e86487360cd8c73c021197e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446bb9a2e86487360cd8c73c021197e4">&#9670;&nbsp;</a></span>Tmmult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用<code>this</code>的转置进行矩阵-矩阵相乘，即<code>C = A<sup>T</sup> B</code>，或者，如果给出了可选的矢量参数，<code>C = A<sup>T</sup> diag(V) B</code>，其中<code>diag(V)</code>定义了一个带有矢量项的对角矩阵。 这个函数假定调用矩阵<code>A</code>和<code>B</code>的大小兼容。<code>C</code>的大小将在本函数中设置。 矩阵C的内容和稀疏模式将被这个函数改变，所以要确保稀疏模式没有在你的程序中其他地方使用。这是一个昂贵的操作，所以在使用这个函数之前请三思。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02241">2241</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1e599d765970ef68e126aa9d5e93583e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e599d765970ef68e126aa9d5e93583e">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的<em>l</em><sub>1</sub>规范，即 \(|M|_1= \max_{\mathrm{all\ columns\ } j} \sum_{\mathrm{all\ rows\ } i} |M_{ij}|\) ，（最大列之和）。 这是自然的矩阵准则，与向量的l1准则兼容，即 \(|Mv|_1 \leq |M|_1 |v|_1\) 。 (参看Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01918">1918</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a32bb09f66dde1c1969a23b4cccd17f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bb09f66dde1c1969a23b4cccd17f04">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的linfty-norm，即 \(|M|_\infty=\max_{\mathrm{all\ rows\ } i}\sum_{\mathrm{all\ columns\ } j} |M_{ij}|\) , (行的最大和)。 这是一个自然的矩阵规范，与向量的linfty-norm兼容，即 \(|Mv|_\infty \leq |M|_\infty |v|_\infty\) 。 (参看Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01927">1927</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aa26df1c42b8f8973246287cfee4d20b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26df1c42b8f8973246287cfee4d20b4">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的frobenius norm，即矩阵中所有条目的平方之和的平方根。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01936">1936</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a2706d65ed111bced458694502fc56a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2706d65ed111bced458694502fc56a3c">&#9670;&nbsp;</a></span>trilinos_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_CrsMatrix&amp; TrilinosWrappers::SparseMatrix::trilinos_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回对底层Trilinos Epetra_CrsMatrix数据的一个常量引用。 </p>

</div>
</div>
<a id="a5601f390c0d339f5e087cf29951906d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5601f390c0d339f5e087cf29951906d8">&#9670;&nbsp;</a></span>trilinos_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_CrsGraph&amp; TrilinosWrappers::SparseMatrix::trilinos_sparsity_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个对底层Trilinos Epetra_CrsGraph数据的常量引用，该数据存储了矩阵的稀疏性模式。 </p>

</div>
</div>
<a id="a95be9f345182496414c8f74f81ad9502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95be9f345182496414c8f74f81ad9502">&#9670;&nbsp;</a></span>locally_owned_domain_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> TrilinosWrappers::SparseMatrix::locally_owned_domain_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该矩阵的域空间的分区，即该矩阵要与之相乘的向量的分区。 </p>

</div>
</div>
<a id="a4255ce516797c98c4448a293ee4f523f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4255ce516797c98c4448a293ee4f523f">&#9670;&nbsp;</a></span>locally_owned_range_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> TrilinosWrappers::SparseMatrix::locally_owned_range_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该矩阵的范围空间的划分，即由矩阵-向量乘积产生的向量的划分。 </p>

</div>
</div>
<a id="a53bc4c91231034a9924a89cb45bea7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53bc4c91231034a9924a89cb45bea7df">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个指向矩阵的第一个元素的迭代器。 迭代器在每一行中访问的元素是按照Trilinos的存储方式来排序的，尽管实现上保证了一行的所有元素在下一行的元素之前被访问。如果你的算法依赖于访问一行中的元素，你将需要咨询Trilinos文档，了解它存储数据的顺序。然而，如果你对元素进行迭代，依靠接收元素的顺序通常不是一个好的和长期稳定的想法。 当你遍历一个并行矩阵的元素时，你将只能访问本地拥有的行。(你也可以访问其他行，但它们看起来是空的。)在这种情况下，你可能想调用begin()函数，该函数将行作为一个参数，以限制要循环的元素范围。 </p>

</div>
</div>
<a id="a432dd81dc9b1c3446d2b35dd902af016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432dd81dc9b1c3446d2b35dd902af016">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像上面的函数一样，但对于非恒定矩阵。 </p>

</div>
</div>
<a id="ae46e2e5d966499c1b4e9da1798445eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46e2e5d966499c1b4e9da1798445eef">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个迭代器，指向这个矩阵的最后一个以上的元素。 </p>

</div>
</div>
<a id="a818f02479da77b15b295090b8d379bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818f02479da77b15b295090b8d379bb5">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像上面的函数一样，但对于非静态矩阵。 </p>

</div>
</div>
<a id="aad11df47057376b44f5e495727ea9d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad11df47057376b44f5e495727ea9d72">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个指向行 <code>r</code>. 第一个元素的迭代器 注意，如果给定的行是空的，即不包含任何非零条目，那么这个函数返回的迭代器就等于<code>end(r)</code>。在这种情况下，如果行 <code>r</code> 和下面的任何一行都不包含任何非零条目，那么返回的迭代器可能无法被解除引用。 迭代器在每一行中访问的元素是按照Trilinos的存储方式排序的，尽管实现上保证了一行的所有元素在下一行的元素之前被访问。如果你的算法依赖于访问一行中的元素，你将需要咨询Trilinos文档，了解它存储数据的顺序。然而，如果你对元素进行迭代，依靠接收元素的顺序通常不是一个好的和长期稳定的想法。 </p><dl class="section note"><dt>Note</dt><dd>当你访问一个并行矩阵的元素时，你只能访问实际存储在本地的行的元素。(你也可以访问其他行，但它们看起来是空的。)即使如此，如果另一个处理器后来写进或增加了存储在当前处理器上的矩阵元素，那么你仍然会看到这个条目的旧值，除非你在远程处理器上修改矩阵元素和在当前处理器上访问它之间调用compress()。更多信息请参见compress()函数的文档。 </dd></dl>

</div>
</div>
<a id="ac801a93ef57d40f3fbe36ca10909e47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac801a93ef57d40f3fbe36ca10909e47f">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像上面的函数一样，但是对于非恒定矩阵。 </p>

</div>
</div>
<a id="a77d0dcda5cd5cfd144526471a8c99d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d0dcda5cd5cfd144526471a8c99d9a">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个指向第 <code>r</code> 行最后一个元素的迭代器，如果第 <code>r</code> 行之后没有任何条目，则指向整个稀疏模式的末端。 请注意，结束迭代器不一定是可被解读的。特别是如果它是一个矩阵的最后一行的结束迭代器，情况更是如此。 </p>

</div>
</div>
<a id="aba4773e90eb187a3432dd2b69fe28273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4773e90eb187a3432dd2b69fe28273">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像上面的函数一样，但是对于非恒定矩阵。 </p>

</div>
</div>
<a id="ad2297e8c999fc04057a3c2370b0db96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2297e8c999fc04057a3c2370b0db96c">&#9670;&nbsp;</a></span>write_ascii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::write_ascii </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>抽象的Trilinos对象，帮助以ASCII格式查看其他Trilinos对象。目前这个功能还没有实现。 TODO：没有实现。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02251">2251</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a4270ebaea8467f2862cf2baf38986815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4270ebaea8467f2862cf2baf38986815">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>write_extended_trilinos_info</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印矩阵到给定的流中，使用格式&lt;tt&gt;(line,col) value，即每行一个非零的矩阵条目。可选的标志以Trilinos风格输出稀疏模式，在打印到流中时，数据根据处理器编号进行排序，以及矩阵的摘要，如全局大小。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02262">2262</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a536e7d727e8394586b4c2dde99b39ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536e7d727e8394586b4c2dde99b39ba3">&#9670;&nbsp;</a></span>prepare_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::prepare_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于某些矩阵存储格式，特别是PETSc分布式块矩阵，对单个元素的设置和添加操作不能自由混合。相反，当我们想从设置元素切换到添加元素时，我们必须同步操作。 BlockMatrixBase通过为每个块调用这个辅助函数来自动同步访问。 这个函数确保矩阵处于一个允许添加元素的状态；如果它之前已经处于这个状态，那么这个函数就不会做任何事情。 </p>

</div>
</div>
<a id="a68a6620012e379b4c660fb4431d817fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a6620012e379b4c660fb4431d817fb">&#9670;&nbsp;</a></span>prepare_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::prepare_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与prepare_add()相同，但如果该类中的元素表示法需要这样的操作，则为设置元素准备矩阵。 </p>

</div>
</div>
<a id="af8d16939e4c35144a316076f5b1c2f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d16939e4c35144a316076f5b1c2f91">&#9670;&nbsp;</a></span>set() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01407">1407</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0eb72d666c41a0ac3c16def795c0c99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb72d666c41a0ac3c16def795c0c99b">&#9670;&nbsp;</a></span>BlockMatrixBase< SparseMatrix ></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l01533">1533</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0c0bbe2fbaf13b7faf696d83f2e3a8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0bbe2fbaf13b7faf696d83f2e3a8f6">&#9670;&nbsp;</a></span>column_space_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Epetra_Map&gt; TrilinosWrappers::SparseMatrix::column_space_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向用户提供的矩阵列的Epetra Trilinos映射的指针，该映射将矩阵的一部分分配给各个进程。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l01499">1499</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a1f3f26ae4997382b25a2eb9604200a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3f26ae4997382b25a2eb9604200a75">&#9670;&nbsp;</a></span>matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Epetra_FECrsMatrix&gt; TrilinosWrappers::SparseMatrix::matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trilinos中的一个稀疏矩阵对象，用于基于有限元的问题，允许组装成非局部元素。 实际的类型是稀疏矩阵，在构造函数中设置。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l01506">1506</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="af574b90695c223223c111c6591f3c57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af574b90695c223223c111c6591f3c57b">&#9670;&nbsp;</a></span>nonlocal_matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Epetra_CrsMatrix&gt; TrilinosWrappers::SparseMatrix::nonlocal_matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trilinos中的一个稀疏矩阵对象，用于收集非局部元素，如果该矩阵是由Trilinos稀疏模式构建的，并有相应的选项。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l01512">1512</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a1dc3fe319a247fc46bd3d052b558f969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc3fe319a247fc46bd3d052b558f969">&#9670;&nbsp;</a></span>nonlocal_matrix_exporter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Epetra_Export&gt; TrilinosWrappers::SparseMatrix::nonlocal_matrix_exporter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个用于交流非本地矩阵的导出对象。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l01518">1518</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a3c1d6236f2215737135912c25cc993b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1d6236f2215737135912c25cc993b0">&#9670;&nbsp;</a></span>last_action</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_CombineMode TrilinosWrappers::SparseMatrix::last_action</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trilinos不允许混合添加矩阵条目和覆盖它们（以使并行计算的同步更简单）。我们的方法是，对于每个访问操作，存储它是插入还是添加。如果前一个是不同的类型，那么我们首先要刷新Trilinos缓冲区；否则，我们可以简单地继续下去。幸运的是，Trilinos有一个这样的对象，在这种情况下已经完成了所有的并行通信，所以我们只需使用他们的模型，它存储了上一个操作是加法还是插入。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l01524">1524</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a896761c5d6156507d191a404ca7dc8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896761c5d6156507d191a404ca7dc8c3">&#9670;&nbsp;</a></span>compressed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparseMatrix::compressed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个布尔变量，用来保存关于向量是否被压缩的信息。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l01530">1530</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a></li>
<li>source/lac/<a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
