<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTrilinosWrappers_1_1SparseMatrix.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TrilinosWrappers::SparseMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></li><li class="navelem"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTrilinosWrappers_1_1SparseMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TrilinosWrappers::SparseMatrix Class Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__TrilinosWrappers.html">TrilinosWrappers</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo;  &#124; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="trilinos__sparse__matrix_8h_source.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TrilinosWrappers::SparseMatrix:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTrilinosWrappers_1_1SparseMatrix__inherit__graph.svg" width="180" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTrilinosWrappers_1_1SparseMatrix_1_1Traits.html">Traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a301d937415bb2c99478d00f4cb5cce7a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> = ::<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:a301d937415bb2c99478d00f4cb5cce7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7757ad30700692bed81a328a4b6ee1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a> = <a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt; false &gt;</td></tr>
<tr class="separator:a1d7757ad30700692bed81a328a4b6ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae308c2134b631d8553164329dfee584b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a> = <a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt; true &gt;</td></tr>
<tr class="separator:ae308c2134b631d8553164329dfee584b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac77967448da926f12fb1fa6bc37a4d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afac77967448da926f12fb1fa6bc37a4d">value_type</a> = <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a></td></tr>
<tr class="separator:afac77967448da926f12fb1fa6bc37a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b339047bea78c496cb6f6bb3ab9341c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1b339047bea78c496cb6f6bb3ab9341c">DeclException1</a> (ExcAccessToNonlocalRow, std::size_t,&lt;&lt; &quot;You tried to access row &quot;&lt;&lt; arg1&lt;&lt; &quot; of a non-contiguous locally owned row set.&quot;&lt;&lt; &quot; The row &quot;&lt;&lt; arg1&lt;&lt; &quot; is not stored locally and can't be accessed.&quot;)</td></tr>
<tr class="separator:a1b339047bea78c496cb6f6bb3ab9341c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa91c2a8575019cbaf8a9217fd0f5d02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaaa91c2a8575019cbaf8a9217fd0f5d02">DeclException1</a> (ExcTrilinosError, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;An error with error number &quot;&lt;&lt; arg1&lt;&lt; &quot; occurred while calling a Trilinos function&quot;)</td></tr>
<tr class="separator:gaaa91c2a8575019cbaf8a9217fd0f5d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab14d48834fa571cc16129076c9bcd0c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab14d48834fa571cc16129076c9bcd0c8">DeclException2</a> (ExcInvalidIndex, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>,&lt;&lt; &quot;The entry with index &lt;&quot;&lt;&lt; arg1&lt;&lt; ','&lt;&lt; arg2&lt;&lt; &quot;&gt; does not exist.&quot;)</td></tr>
<tr class="separator:gab14d48834fa571cc16129076c9bcd0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32e89990301f92c60811d85de63fd90d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32e89990301f92c60811d85de63fd90d">DeclExceptionMsg</a> (ExcSourceEqualsDestination, &quot;You are attempting an operation on two matrices that &quot; &quot;are the same object, but the operation requires that the &quot; &quot;two objects are in fact different.&quot;)</td></tr>
<tr class="separator:ga32e89990301f92c60811d85de63fd90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7426cdb9e8078ac7cd442857a786545c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7426cdb9e8078ac7cd442857a786545c">DeclException0</a> (ExcMatrixNotCompressed)</td></tr>
<tr class="separator:ga7426cdb9e8078ac7cd442857a786545c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd4fe5958a3c39f2c7651935936eb6c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacd4fe5958a3c39f2c7651935936eb6c7">DeclException4</a> (ExcAccessToNonLocalElement, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>,&lt;&lt; &quot;You tried to access element (&quot;&lt;&lt; arg1&lt;&lt; &quot;/&quot;&lt;&lt; arg2&lt;&lt; &quot;)&quot;&lt;&lt; &quot; of a distributed <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1f3f26ae4997382b25a2eb9604200a75">matrix</a>, but only rows in range [&quot;&lt;&lt; arg3&lt;&lt; &quot;,&quot;&lt;&lt; arg4&lt;&lt; &quot;] are stored locally and can be accessed.&quot;)</td></tr>
<tr class="separator:gacd4fe5958a3c39f2c7651935936eb6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb9160e213bcaf3e98adb55bb34f9089"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gabb9160e213bcaf3e98adb55bb34f9089">DeclException2</a> (ExcAccessToNonPresentElement, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>,&lt;&lt; &quot;You tried to access element (&quot;&lt;&lt; arg1&lt;&lt; &quot;/&quot;&lt;&lt; arg2&lt;&lt; &quot;)&quot;&lt;&lt; &quot; of a sparse <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1f3f26ae4997382b25a2eb9604200a75">matrix</a>, but it appears to not&quot;&lt;&lt; &quot; exist in the Trilinos sparsity pattern.&quot;)</td></tr>
<tr class="separator:gabb9160e213bcaf3e98adb55bb34f9089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d16939e4c35144a316076f5b1c2f91"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af8d16939e4c35144a316076f5b1c2f91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af8d16939e4c35144a316076f5b1c2f91">set</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> row, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> n_cols, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> *col_indices, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values)</td></tr>
<tr class="separator:af8d16939e4c35144a316076f5b1c2f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization.</div></td></tr>
<tr class="memitem:a637dbbd4e8ca9fc07a447c8f31e21647"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a637dbbd4e8ca9fc07a447c8f31e21647">SparseMatrix</a> ()</td></tr>
<tr class="separator:a637dbbd4e8ca9fc07a447c8f31e21647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3900dae374f5a71e5134840682662d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab3900dae374f5a71e5134840682662d8">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m</a>, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a371d418cc093230813c36578f32f0966">n</a>, const unsigned <a class="el" href="classint.html">int</a> n_max_entries_per_row)</td></tr>
<tr class="separator:ab3900dae374f5a71e5134840682662d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944e51f3f5f0202024e04b679172ec9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a944e51f3f5f0202024e04b679172ec9e">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m</a>, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a371d418cc093230813c36578f32f0966">n</a>, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a944e51f3f5f0202024e04b679172ec9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2b62a80dac30c548e1d20c3e77beae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0b2b62a80dac30c548e1d20c3e77beae">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;InputSparsityPattern)</td></tr>
<tr class="separator:a0b2b62a80dac30c548e1d20c3e77beae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0c3506eddcfd2bff3c8b4658b7d493"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a7d0c3506eddcfd2bff3c8b4658b7d493">SparseMatrix</a> (<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a7d0c3506eddcfd2bff3c8b4658b7d493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc6e5a99462abbc7d9324b4824be576"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aafc6e5a99462abbc7d9324b4824be576">SparseMatrix</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;)=delete</td></tr>
<tr class="separator:aafc6e5a99462abbc7d9324b4824be576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6980b4f220e3d41b00d5ffa38623d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aec6980b4f220e3d41b00d5ffa38623d7">operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;)=delete</td></tr>
<tr class="separator:aec6980b4f220e3d41b00d5ffa38623d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe89a97bc7ef4bbc16e5e04b72bb19e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#adbe89a97bc7ef4bbc16e5e04b72bb19e">~SparseMatrix</a> () override=default</td></tr>
<tr class="separator:adbe89a97bc7ef4bbc16e5e04b72bb19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614ca8e186fe3c61e03a52369437157e"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a614ca8e186fe3c61e03a52369437157e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a> (const SparsityPatternType &amp;sparsity_pattern)</td></tr>
<tr class="separator:a614ca8e186fe3c61e03a52369437157e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602232080f91baba93c85684937765d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a602232080f91baba93c85684937765d5">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern)</td></tr>
<tr class="separator:a602232080f91baba93c85684937765d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbc81d639cb5c12f2e2b59072e64f39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a5cbc81d639cb5c12f2e2b59072e64f39">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;sparse_matrix)</td></tr>
<tr class="separator:a5cbc81d639cb5c12f2e2b59072e64f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688b87cdf4067fc28483d5385b1dabda"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a688b87cdf4067fc28483d5385b1dabda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a688b87cdf4067fc28483d5385b1dabda">reinit</a> (const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const <a class="el" href="classdouble.html">double</a> drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=nullptr)</td></tr>
<tr class="separator:a688b87cdf4067fc28483d5385b1dabda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743888addc7cfd057c70ceff1e03cc02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a743888addc7cfd057c70ceff1e03cc02">reinit</a> (const Epetra_CrsMatrix &amp;input_matrix, const <a class="el" href="classbool.html">bool</a> copy_values=true)</td></tr>
<tr class="separator:a743888addc7cfd057c70ceff1e03cc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization using an IndexSet description</div></td></tr>
<tr class="memitem:abf1eceecf61d5aacdb1192a6a0bded7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#abf1eceecf61d5aacdb1192a6a0bded7e">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const unsigned <a class="el" href="classint.html">int</a> n_max_entries_per_row=0)</td></tr>
<tr class="separator:abf1eceecf61d5aacdb1192a6a0bded7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d44ae4cf732744c50027c8d36f2a758"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a9d44ae4cf732744c50027c8d36f2a758">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a9d44ae4cf732744c50027c8d36f2a758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60748f3e8d3fbea4b3a4c192ff7d8455"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a60748f3e8d3fbea4b3a4c192ff7d8455">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> n_max_entries_per_row=0)</td></tr>
<tr class="separator:a60748f3e8d3fbea4b3a4c192ff7d8455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128b8b864bec45fa1115e43206861f22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a128b8b864bec45fa1115e43206861f22">SparseMatrix</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;n_entries_per_row)</td></tr>
<tr class="separator:a128b8b864bec45fa1115e43206861f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5f926afa37ddbe5ffe18ecb1f037a8"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:abb5f926afa37ddbe5ffe18ecb1f037a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#abb5f926afa37ddbe5ffe18ecb1f037a8">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> exchange_data=false)</td></tr>
<tr class="separator:abb5f926afa37ddbe5ffe18ecb1f037a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a6a199cb405506baaf5fbe09bab1c9"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ae0a6a199cb405506baaf5fbe09bab1c9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !std::is_same&lt; SparsityPatternType, ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae0a6a199cb405506baaf5fbe09bab1c9">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> exchange_data=false)</td></tr>
<tr class="separator:ae0a6a199cb405506baaf5fbe09bab1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4023e59f650260e3002a7a7ec2548313"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a4023e59f650260e3002a7a7ec2548313"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4023e59f650260e3002a7a7ec2548313">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classdouble.html">double</a> drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=nullptr)</td></tr>
<tr class="separator:a4023e59f650260e3002a7a7ec2548313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7443128fe3987f117365d755839f62"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a2f7443128fe3987f117365d755839f62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2f7443128fe3987f117365d755839f62">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;row_parallel_partitioning, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;col_parallel_partitioning, const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;dealii_sparse_matrix, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classdouble.html">double</a> drop_tolerance=1e-13, const bool copy_values=true, const ::SparsityPattern *use_this_sparsity=nullptr)</td></tr>
<tr class="separator:a2f7443128fe3987f117365d755839f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information on the matrix</div></td></tr>
<tr class="memitem:ab9cf2620cc3350eb189597bd2831570a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m</a> () const</td></tr>
<tr class="separator:ab9cf2620cc3350eb189597bd2831570a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371d418cc093230813c36578f32f0966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a371d418cc093230813c36578f32f0966">n</a> () const</td></tr>
<tr class="separator:a371d418cc093230813c36578f32f0966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a8c1f20e048f5a7b9711218779fad5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2a8c1f20e048f5a7b9711218779fad5">local_size</a> () const</td></tr>
<tr class="separator:ac2a8c1f20e048f5a7b9711218779fad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557eb5dabea73fb2d3e2ba70226cdfcf"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a557eb5dabea73fb2d3e2ba70226cdfcf">local_range</a> () const</td></tr>
<tr class="separator:a557eb5dabea73fb2d3e2ba70226cdfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998d6f1a926b04ec7c1a967f46775282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a998d6f1a926b04ec7c1a967f46775282">in_local_range</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> index) const</td></tr>
<tr class="separator:a998d6f1a926b04ec7c1a967f46775282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26d73bf5ba9422c98651107cc9dfbac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae26d73bf5ba9422c98651107cc9dfbac">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:ae26d73bf5ba9422c98651107cc9dfbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa245c41459e8f4100994de6dfb876fdf"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aa245c41459e8f4100994de6dfb876fdf">row_length</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> row) const</td></tr>
<tr class="separator:aa245c41459e8f4100994de6dfb876fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a559b1529540ca031728b25f63962c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a91a559b1529540ca031728b25f63962c">is_compressed</a> () const</td></tr>
<tr class="separator:a91a559b1529540ca031728b25f63962c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0241e5308043f439e44bf1285a0ac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a3b0241e5308043f439e44bf1285a0ac6">memory_consumption</a> () const</td></tr>
<tr class="separator:a3b0241e5308043f439e44bf1285a0ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b528da50ca77670b997382dc38a77b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a14b528da50ca77670b997382dc38a77b">get_mpi_communicator</a> () const</td></tr>
<tr class="separator:a14b528da50ca77670b997382dc38a77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifying entries</div></td></tr>
<tr class="memitem:ae2e30c191f788f4e668df2a51fc0aad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae2e30c191f788f4e668df2a51fc0aad3">operator=</a> (const <a class="el" href="classdouble.html">double</a> d)</td></tr>
<tr class="separator:ae2e30c191f788f4e668df2a51fc0aad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e58c65baa9a70517d6dcd6d3371a525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a5e58c65baa9a70517d6dcd6d3371a525">clear</a> ()</td></tr>
<tr class="separator:a5e58c65baa9a70517d6dcd6d3371a525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ef7c7e43574dacfdbdd6d007708a38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:a77ef7c7e43574dacfdbdd6d007708a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0279858faded0f95d78c901b4e655317"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0279858faded0f95d78c901b4e655317">set</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> j, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> value)</td></tr>
<tr class="separator:a0279858faded0f95d78c901b4e655317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4eb1ed3db64694a143ff796028ed36f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae4eb1ed3db64694a143ff796028ed36f">set</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ae4eb1ed3db64694a143ff796028ed36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e7e8afef3f71bc0c685bd4b84fd69e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a03e7e8afef3f71bc0c685bd4b84fd69e">set</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a03e7e8afef3f71bc0c685bd4b84fd69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1793ec909cb013dc94609e65f72acfe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1793ec909cb013dc94609e65f72acfe2">set</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> row, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;col_indices, const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a1793ec909cb013dc94609e65f72acfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b15e7295291562879e3c526d0322ec"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ae1b15e7295291562879e3c526d0322ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae1b15e7295291562879e3c526d0322ec">set</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> row, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> n_cols, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> *col_indices, const Number *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ae1b15e7295291562879e3c526d0322ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2822f0aed012ede4516df69f53d0d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2822f0aed012ede4516df69f53d0d13">add</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> j, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> value)</td></tr>
<tr class="separator:ac2822f0aed012ede4516df69f53d0d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6253cdd3795e76d753099065189078ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a6253cdd3795e76d753099065189078ee">add</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a6253cdd3795e76d753099065189078ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b87b4a845b1c52815be6447e24341e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a8b87b4a845b1c52815be6447e24341e4">add</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a8b87b4a845b1c52815be6447e24341e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1fd0cf7019f1ead364e4cf4b806202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aad1fd0cf7019f1ead364e4cf4b806202">add</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> row, const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;col_indices, const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:aad1fd0cf7019f1ead364e4cf4b806202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2468a28250ecc0ef4989b66dacdea55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aa2468a28250ecc0ef4989b66dacdea55">add</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> row, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> n_cols, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> *col_indices, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:aa2468a28250ecc0ef4989b66dacdea55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b02a77bbf81ac8ee1dbf558e1b1d849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1b02a77bbf81ac8ee1dbf558e1b1d849">operator*=</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> factor)</td></tr>
<tr class="separator:a1b02a77bbf81ac8ee1dbf558e1b1d849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a74de71c2fa3233b48ee71a3daf72dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a7a74de71c2fa3233b48ee71a3daf72dd">operator/=</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> factor)</td></tr>
<tr class="separator:a7a74de71c2fa3233b48ee71a3daf72dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce2618df5a059715d3d55c83f085763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a9ce2618df5a059715d3d55c83f085763">copy_from</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;source)</td></tr>
<tr class="separator:a9ce2618df5a059715d3d55c83f085763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bac02815f056cd6b235367edf83d31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae2bac02815f056cd6b235367edf83d31">add</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> factor, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1f3f26ae4997382b25a2eb9604200a75">matrix</a>)</td></tr>
<tr class="separator:ae2bac02815f056cd6b235367edf83d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1c4f2ee1e8ae2fadf5102c320c54cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4e1c4f2ee1e8ae2fadf5102c320c54cd">clear_row</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> row, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> new_diag_value=0)</td></tr>
<tr class="separator:a4e1c4f2ee1e8ae2fadf5102c320c54cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900a42baea388ebcc9b4c7bcf96f71b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a900a42baea388ebcc9b4c7bcf96f71b4">clear_rows</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;rows, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> new_diag_value=0)</td></tr>
<tr class="separator:a900a42baea388ebcc9b4c7bcf96f71b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7a578fb46241991114a6ffa99cd3fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1a7a578fb46241991114a6ffa99cd3fe">transpose</a> ()</td></tr>
<tr class="separator:a1a7a578fb46241991114a6ffa99cd3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Entry Access</div></td></tr>
<tr class="memitem:acd63c0d5ac1357d24b5fa7ffa4b1d3c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#acd63c0d5ac1357d24b5fa7ffa4b1d3c7">operator()</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> j) const</td></tr>
<tr class="separator:acd63c0d5ac1357d24b5fa7ffa4b1d3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e40cf415aa2630fd0f56e1878eadb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a92e40cf415aa2630fd0f56e1878eadb4">el</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> i, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> j) const</td></tr>
<tr class="separator:a92e40cf415aa2630fd0f56e1878eadb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe41a4a1feb344a2281a85d138d679ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> i) const</td></tr>
<tr class="separator:abe41a4a1feb344a2281a85d138d679ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Multiplications</div></td></tr>
<tr class="memitem:a4aedd84e99cda48dce634a2bbf8763fd"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a4aedd84e99cda48dce634a2bbf8763fd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4aedd84e99cda48dce634a2bbf8763fd">vmult</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a4aedd84e99cda48dce634a2bbf8763fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318f6ff9df006a316365680fb08d3e4f"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a318f6ff9df006a316365680fb08d3e4f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a318f6ff9df006a316365680fb08d3e4f">vmult</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a318f6ff9df006a316365680fb08d3e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4d7979e74e7d74d329a5b9a3d0014c"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a9f4d7979e74e7d74d329a5b9a3d0014c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a9f4d7979e74e7d74d329a5b9a3d0014c">Tvmult</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a9f4d7979e74e7d74d329a5b9a3d0014c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7adf13a14a8342e246d3a3e58cc4a4e"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:aa7adf13a14a8342e246d3a3e58cc4a4e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aa7adf13a14a8342e246d3a3e58cc4a4e">Tvmult</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:aa7adf13a14a8342e246d3a3e58cc4a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6792587fa97254fae30dea0e8d770f0c"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a6792587fa97254fae30dea0e8d770f0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a6792587fa97254fae30dea0e8d770f0c">vmult_add</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a6792587fa97254fae30dea0e8d770f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849653e0230720b0f0ab58591974c0f2"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a849653e0230720b0f0ab58591974c0f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a849653e0230720b0f0ab58591974c0f2">Tvmult_add</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a849653e0230720b0f0ab58591974c0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be0bd695cbfabf512cea6ef3c9c28ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a3be0bd695cbfabf512cea6ef3c9c28ba">matrix_norm_square</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;v) const</td></tr>
<tr class="separator:a3be0bd695cbfabf512cea6ef3c9c28ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3575cd95bb79786665f996816023b11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae3575cd95bb79786665f996816023b11">matrix_scalar_product</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;u, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;v) const</td></tr>
<tr class="separator:ae3575cd95bb79786665f996816023b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d1cabc336bbc45ca182972ce02c82d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a95d1cabc336bbc45ca182972ce02c82d">residual</a> (<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;dst, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;x, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;b) const</td></tr>
<tr class="separator:a95d1cabc336bbc45ca182972ce02c82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbabb70ef99a4be889474c4c5dc4756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1dbabb70ef99a4be889474c4c5dc4756">mmult</a> (<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;C, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;B, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;V=<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()) const</td></tr>
<tr class="separator:a1dbabb70ef99a4be889474c4c5dc4756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446bb9a2e86487360cd8c73c021197e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a446bb9a2e86487360cd8c73c021197e4">Tmmult</a> (<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;C, const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;B, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;V=<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()) const</td></tr>
<tr class="separator:a446bb9a2e86487360cd8c73c021197e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix norms</div></td></tr>
<tr class="memitem:a1e599d765970ef68e126aa9d5e93583e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1e599d765970ef68e126aa9d5e93583e">l1_norm</a> () const</td></tr>
<tr class="separator:a1e599d765970ef68e126aa9d5e93583e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bb09f66dde1c1969a23b4cccd17f04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a32bb09f66dde1c1969a23b4cccd17f04">linfty_norm</a> () const</td></tr>
<tr class="separator:a32bb09f66dde1c1969a23b4cccd17f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26df1c42b8f8973246287cfee4d20b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aa26df1c42b8f8973246287cfee4d20b4">frobenius_norm</a> () const</td></tr>
<tr class="separator:aa26df1c42b8f8973246287cfee4d20b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to underlying Trilinos data</div></td></tr>
<tr class="memitem:a2706d65ed111bced458694502fc56a3c"><td class="memItemLeft" align="right" valign="top">const Epetra_CrsMatrix &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a2706d65ed111bced458694502fc56a3c">trilinos_matrix</a> () const</td></tr>
<tr class="separator:a2706d65ed111bced458694502fc56a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5601f390c0d339f5e087cf29951906d8"><td class="memItemLeft" align="right" valign="top">const Epetra_CrsGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a5601f390c0d339f5e087cf29951906d8">trilinos_sparsity_pattern</a> () const</td></tr>
<tr class="separator:a5601f390c0d339f5e087cf29951906d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Partitioners</div></td></tr>
<tr class="memitem:a95be9f345182496414c8f74f81ad9502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a95be9f345182496414c8f74f81ad9502">locally_owned_domain_indices</a> () const</td></tr>
<tr class="separator:a95be9f345182496414c8f74f81ad9502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4255ce516797c98c4448a293ee4f523f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4255ce516797c98c4448a293ee4f523f">locally_owned_range_indices</a> () const</td></tr>
<tr class="separator:a4255ce516797c98c4448a293ee4f523f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a53bc4c91231034a9924a89cb45bea7df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a53bc4c91231034a9924a89cb45bea7df">begin</a> () const</td></tr>
<tr class="separator:a53bc4c91231034a9924a89cb45bea7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432dd81dc9b1c3446d2b35dd902af016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a432dd81dc9b1c3446d2b35dd902af016">begin</a> ()</td></tr>
<tr class="separator:a432dd81dc9b1c3446d2b35dd902af016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46e2e5d966499c1b4e9da1798445eef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae46e2e5d966499c1b4e9da1798445eef">end</a> () const</td></tr>
<tr class="separator:ae46e2e5d966499c1b4e9da1798445eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818f02479da77b15b295090b8d379bb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a818f02479da77b15b295090b8d379bb5">end</a> ()</td></tr>
<tr class="separator:a818f02479da77b15b295090b8d379bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad11df47057376b44f5e495727ea9d72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aad11df47057376b44f5e495727ea9d72">begin</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> r) const</td></tr>
<tr class="separator:aad11df47057376b44f5e495727ea9d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac801a93ef57d40f3fbe36ca10909e47f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac801a93ef57d40f3fbe36ca10909e47f">begin</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> r)</td></tr>
<tr class="separator:ac801a93ef57d40f3fbe36ca10909e47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d0dcda5cd5cfd144526471a8c99d9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77d0dcda5cd5cfd144526471a8c99d9a">end</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> r) const</td></tr>
<tr class="separator:a77d0dcda5cd5cfd144526471a8c99d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4773e90eb187a3432dd2b69fe28273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#aba4773e90eb187a3432dd2b69fe28273">end</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> r)</td></tr>
<tr class="separator:aba4773e90eb187a3432dd2b69fe28273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input/Output</div></td></tr>
<tr class="memitem:ad2297e8c999fc04057a3c2370b0db96c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ad2297e8c999fc04057a3c2370b0db96c">write_ascii</a> ()</td></tr>
<tr class="separator:ad2297e8c999fc04057a3c2370b0db96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4270ebaea8467f2862cf2baf38986815"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4270ebaea8467f2862cf2baf38986815">print</a> (std::ostream &amp;out, const <a class="el" href="classbool.html">bool</a> write_extended_trilinos_info=false) const</td></tr>
<tr class="separator:a4270ebaea8467f2862cf2baf38986815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a536e7d727e8394586b4c2dde99b39ba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a536e7d727e8394586b4c2dde99b39ba3">prepare_add</a> ()</td></tr>
<tr class="separator:a536e7d727e8394586b4c2dde99b39ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a6620012e379b4c660fb4431d817fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a68a6620012e379b4c660fb4431d817fb">prepare_set</a> ()</td></tr>
<tr class="separator:a68a6620012e379b4c660fb4431d817fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0c0bbe2fbaf13b7faf696d83f2e3a8f6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Epetra_Map &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0c0bbe2fbaf13b7faf696d83f2e3a8f6">column_space_map</a></td></tr>
<tr class="separator:a0c0bbe2fbaf13b7faf696d83f2e3a8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3f26ae4997382b25a2eb9604200a75"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Epetra_FECrsMatrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1f3f26ae4997382b25a2eb9604200a75">matrix</a></td></tr>
<tr class="separator:a1f3f26ae4997382b25a2eb9604200a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af574b90695c223223c111c6591f3c57b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Epetra_CrsMatrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#af574b90695c223223c111c6591f3c57b">nonlocal_matrix</a></td></tr>
<tr class="separator:af574b90695c223223c111c6591f3c57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc3fe319a247fc46bd3d052b558f969"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Epetra_Export &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1dc3fe319a247fc46bd3d052b558f969">nonlocal_matrix_exporter</a></td></tr>
<tr class="separator:a1dc3fe319a247fc46bd3d052b558f969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1d6236f2215737135912c25cc993b0"><td class="memItemLeft" align="right" valign="top">Epetra_CombineMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a3c1d6236f2215737135912c25cc993b0">last_action</a></td></tr>
<tr class="separator:a3c1d6236f2215737135912c25cc993b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896761c5d6156507d191a404ca7dc8c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a896761c5d6156507d191a404ca7dc8c3">compressed</a></td></tr>
<tr class="separator:a896761c5d6156507d191a404ca7dc8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0eb72d666c41a0ac3c16def795c0c99b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0eb72d666c41a0ac3c16def795c0c99b">BlockMatrixBase&lt; SparseMatrix &gt;</a></td></tr>
<tr class="separator:a0eb72d666c41a0ac3c16def795c0c99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements a wrapper to use the Trilinos distributed sparse matrix class Epetra_FECrsMatrix. This is precisely the kind of matrix we deal with all the time - we most likely get it from some assembly process, where also entries not locally owned might need to be written and hence need to be forwarded to the owner process. This class is designed to be used in a distributed memory architecture with an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> compiler on the bottom, but works equally well also for serial processes. The only requirement for this class to work is that Trilinos has been installed with the same compiler as is used for generating deal.II.</p>
<p>The interface of this class is modeled after the existing <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> class in deal.II. It has almost the same member functions, and is often exchangeable. However, since Trilinos only supports a single scalar type (double), it is not templated, and only works with doubles.</p>
<p>Note that Trilinos only guarantees that operations do what you expect if the functions <code>GlobalAssemble</code> has been called after matrix assembly. Therefore, you need to call <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">SparseMatrix::compress()</a> before you actually use the matrix. This also calls <code>FillComplete</code> that compresses the storage format for sparse matrices by discarding unused elements. Trilinos allows to continue with assembling the matrix after calls to these functions, though.</p>
<h3>Thread safety of Trilinos matrices</h3>
<p>When writing into Trilinos matrices from several threads in shared memory, several things must be kept in mind as there is no built-in locks in this class to prevent data races. Simultaneous access to the same matrix row at the same time can lead to data races and must be explicitly avoided by the user. However, it is possible to access <b>different</b> rows of the matrix from several threads simultaneously under the following three conditions: </p><ul>
<li>
The matrix uses only one <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> process. </li>
<li>
The matrix has been initialized with the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit()</a> method with a <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> (that includes the set of locally relevant rows, i.e., the rows that an assembly routine will possibly write into). </li>
<li>
The matrix has been initialized from a <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> object that in turn has been initialized with the reinit function specifying three index sets, one for the rows, one for the columns and for the larger set of <code>writeable_rows</code>, and the operation is an addition. At some point in the future, Trilinos support might be complete enough such that initializing from a <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> that has been filled by a function similar to <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> always results in a matrix that allows several processes to write into the same matrix row. However, Trilinos until version at least 11.12 does not correctly support this feature. </li>
</ul>
<p>Note that all other reinit methods and constructors of <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> will result in a matrix that needs to allocate off-processor entries on demand, which breaks thread-safety. Of course, using the respective reinit method for the block Trilinos sparsity pattern and block matrix also results in thread-safety. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00506">506</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a301d937415bb2c99478d00f4cb5cce7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301d937415bb2c99478d00f4cb5cce7a">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">TrilinosWrappers::SparseMatrix::size_type</a> =  ::<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type for container size. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00512">512</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a1d7757ad30700692bed81a328a4b6ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7757ad30700692bed81a328a4b6ee1">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">TrilinosWrappers::SparseMatrix::iterator</a> =  <a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare an alias for the iterator class. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00543">543</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ae308c2134b631d8553164329dfee584b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae308c2134b631d8553164329dfee584b">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">TrilinosWrappers::SparseMatrix::const_iterator</a> =  <a class="el" href="classTrilinosWrappers_1_1SparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare an alias for the const iterator class. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00548">548</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="afac77967448da926f12fb1fa6bc37a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac77967448da926f12fb1fa6bc37a4d">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#afac77967448da926f12fb1fa6bc37a4d">TrilinosWrappers::SparseMatrix::value_type</a> =  <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare an alias in analogy to all the other container classes. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l00553">553</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a637dbbd4e8ca9fc07a447c8f31e21647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637dbbd4e8ca9fc07a447c8f31e21647">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Generates an empty (zero-size) matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00208">208</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ab3900dae374f5a71e5134840682662d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3900dae374f5a71e5134840682662d8">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a matrix that is completely stored locally, having <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m</a> rows and <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a371d418cc093230813c36578f32f0966">n</a> columns.</p>
<p>The number of columns entries per row is specified as the maximum number of entries argument. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00220">220</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a944e51f3f5f0202024e04b679172ec9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944e51f3f5f0202024e04b679172ec9e">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a matrix that is completely stored locally, having <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m</a> rows and <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a371d418cc093230813c36578f32f0966">n</a> columns.</p>
<p>The vector <code>n_entries_per_row</code> specifies the number of entries in each row. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00251">251</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a0b2b62a80dac30c548e1d20c3e77beae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2b62a80dac30c548e1d20c3e77beae">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>InputSparsityPattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a matrix from a Trilinos sparsity pattern object. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00340">340</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a7d0c3506eddcfd2bff3c8b4658b7d493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0c3506eddcfd2bff3c8b4658b7d493">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Create a new sparse matrix by stealing the internal data. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00357">357</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aafc6e5a99462abbc7d9324b4824be576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc6e5a99462abbc7d9324b4824be576">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor is deleted. </p>

</div>
</div>
<a id="adbe89a97bc7ef4bbc16e5e04b72bb19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe89a97bc7ef4bbc16e5e04b72bb19e">&#9670;&nbsp;</a></span>~SparseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TrilinosWrappers::SparseMatrix::~SparseMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Made virtual so that one can use pointers to this class. </p>

</div>
</div>
<a id="abf1eceecf61d5aacdb1192a6a0bded7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1eceecf61d5aacdb1192a6a0bded7e">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor using an <a class="el" href="classIndexSet.html">IndexSet</a> and an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> communicator to describe the parallel partitioning. The parameter <code>n_max_entries_per_row</code> sets the number of nonzero entries in each row that will be allocated. Note that this number does not need to be exact, and it is even allowed that the actual matrix structure has more nonzero entries than specified in the constructor. However it is still advantageous to provide good estimates here since this will considerably increase the performance of the matrix setup. However, there is no effect in the performance of matrix- vector products, since Trilinos reorganizes the matrix memory prior to use (in the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> step). </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00273">273</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a9d44ae4cf732744c50027c8d36f2a758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d44ae4cf732744c50027c8d36f2a758">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but now set the number of nonzeros in each matrix row separately. Since we know the number of elements in the matrix exactly in this case, we can already allocate the right amount of memory, which makes the creation process including the insertion of nonzero elements by the respective <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">SparseMatrix::reinit</a> call considerably faster. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00288">288</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a60748f3e8d3fbea4b3a4c192ff7d8455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60748f3e8d3fbea4b3a4c192ff7d8455">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>n_max_entries_per_row</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different <a class="el" href="classIndexSet.html">IndexSet</a> partitions for row and columns. This interface is meant to be used for generating rectangular matrices, where the first index set describes the parallel partitioning of the degrees of freedom associated with the matrix rows and the second one the partitioning of the matrix columns. The second index set specifies the partitioning of the vectors this matrix is to be multiplied with, not the distribution of the elements that actually appear in the matrix.</p>
<p>The parameter <code>n_max_entries_per_row</code> defines how much memory will be allocated for each row. This number does not need to be accurate, as the structure is reorganized in the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> call. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00305">305</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a128b8b864bec45fa1115e43206861f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128b8b864bec45fa1115e43206861f22">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_entries_per_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor is similar to the one above, but it now takes two different Epetra maps for rows and columns. This interface is meant to be used for generating rectangular matrices, where one map specifies the parallel distribution of degrees of freedom associated with matrix rows and the second one specifies the parallel distribution the dofs associated with columns in the matrix. The second map also provides information for the internal arrangement in matrix vector products (i.e., the distribution of vector this matrix is to be multiplied with), but is not used for the distribution of the columns &ndash; rather, all column elements of a row are stored on the same processor in any case. The vector <code>n_entries_per_row</code> specifies the number of entries in each row of the newly generated matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00322">322</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b339047bea78c496cb6f6bb3ab9341c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b339047bea78c496cb6f6bb3ab9341c">&#9670;&nbsp;</a></span>DeclException1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::SparseMatrix::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcAccessToNonlocalRow&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You tried to access row &quot;&lt;&lt; arg1&lt;&lt; &quot; of a non-contiguous locally owned row set.&quot;&lt;&lt; &quot; The row &quot;&lt;&lt; arg1&lt;&lt; &quot; is not stored locally and can't be accessed.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="aec6980b4f220e3d41b00d5ffa38623d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6980b4f220e3d41b00d5ffa38623d7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&amp; TrilinosWrappers::SparseMatrix::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>operator= is deleted. </p>

</div>
</div>
<a id="a614ca8e186fe3c61e03a52369437157e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614ca8e186fe3c61e03a52369437157e">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the Trilinos matrix with a deal.II sparsity pattern, i.e. it makes the Trilinos Epetra matrix know the position of nonzero entries according to the sparsity pattern. This function is meant for use in serial programs, where there is no need to specify how the matrix is going to be distributed among different processors. This function works in parallel, too, but it is recommended to manually specify the parallel partitioning of the matrix using an Epetra_Map. When run in parallel, it is currently necessary that each processor holds the sparsity_pattern structure because each processor sets its rows.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00784">784</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a602232080f91baba93c85684937765d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602232080f91baba93c85684937765d5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function reinitializes the Trilinos sparse matrix from a (possibly distributed) Trilinos sparsity pattern.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock.</p>
<p>If you want to write to the matrix from several threads and use <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a>, you need to use this reinit method with a sparsity pattern that has been created with explicitly stating writeable rows. In all other cases, you cannot mix <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> with multithreaded writing into the matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00828">828</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a5cbc81d639cb5c12f2e2b59072e64f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbc81d639cb5c12f2e2b59072e64f39">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>sparse_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function copies the layout of <code>sparse_matrix</code> to the calling matrix. The values are not copied, but you can use <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a9ce2618df5a059715d3d55c83f085763">copy_from()</a> for this.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00853">853</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a688b87cdf4067fc28483d5385b1dabda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688b87cdf4067fc28483d5385b1dabda">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the Trilinos matrix using the deal.II sparse matrix and the entries stored therein. It uses a threshold to copy only elements with modulus larger than the threshold (so zeros in the deal.II matrix can be filtered away).</p>
<p>The optional parameter <code>copy_values</code> decides whether only the sparsity structure of the input matrix should be used or the matrix entries should be copied, too.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a deadlock.</p>
<dl class="section note"><dt>Note</dt><dd>If a different sparsity pattern is given in the last argument (i.e., one that differs from the one used in the sparse matrix given in the first argument), then the resulting Trilinos matrix will have the sparsity pattern so given. This of course also means that all entries in the given matrix that are not part of this separate sparsity pattern will in fact be dropped. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00991">991</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a743888addc7cfd057c70ceff1e03cc02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743888addc7cfd057c70ceff1e03cc02">&#9670;&nbsp;</a></span>reinit() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const Epetra_CrsMatrix &amp;&#160;</td>
          <td class="paramname"><em>input_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reinit function takes as input a Trilinos Epetra_CrsMatrix and copies its sparsity pattern. If so requested, even the content (values) will be copied. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01009">1009</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="abb5f926afa37ddbe5ffe18ecb1f037a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5f926afa37ddbe5ffe18ecb1f037a8">&#9670;&nbsp;</a></span>reinit() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is initializes the Trilinos Epetra matrix according to the specified sparsity_pattern, and also reassigns the matrix rows to different processes according to a user-supplied index set and parallel communicator. In programs following the style of the tutorial programs, this function (and the respective call for a rectangular matrix) are the natural way to initialize the matrix size, its distribution among the <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> processes (if run in parallel) as well as the location of non-zero elements. Trilinos stores the sparsity pattern internally, so it won't be needed any more after this call, in contrast to the deal.II own object. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>. If the flag is not set, each processor just sets the elements in the sparsity pattern that belong to its rows.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a id="ae0a6a199cb405506baaf5fbe09bab1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a6a199cb405506baaf5fbe09bab1c9">&#9670;&nbsp;</a></span>reinit() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_same&lt; SparsityPatternType,::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;::value &gt;::type <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>exchange_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is similar to the other initialization function above, but now also reassigns the matrix rows and columns according to two user-supplied index sets. To be used for rectangular matrices. The optional argument <code>exchange_data</code> can be used for reinitialization with a sparsity pattern that is not fully constructed. This feature is only implemented for input sparsity patterns of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00803">803</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a4023e59f650260e3002a7a7ec2548313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4023e59f650260e3002a7a7ec2548313">&#9670;&nbsp;</a></span>reinit() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the Trilinos matrix using the deal.II sparse matrix and the entries stored therein. It uses a threshold to copy only elements with modulus larger than the threshold (so zeros in the deal.II matrix can be filtered away). In contrast to the other reinit function with deal.II sparse matrix argument, this function takes a parallel partitioning specified by the user instead of internally generating it.</p>
<p>The optional parameter <code>copy_values</code> decides whether only the sparsity structure of the input matrix should be used or the matrix entries should be copied, too.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

</div>
</div>
<a id="a2f7443128fe3987f117365d755839f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7443128fe3987f117365d755839f62">&#9670;&nbsp;</a></span>reinit() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>row_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>col_parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dealii_sparse_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>drop_tolerance</em> = <code>1e-13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">SparsityPattern</a> *&#160;</td>
          <td class="paramname"><em>use_this_sparsity</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is similar to the other initialization function with deal.II sparse matrix input above, but now takes index sets for both the rows and the columns of the matrix. Chosen for rectangular matrices.</p>
<p>The optional parameter <code>copy_values</code> decides whether only the sparsity structure of the input matrix should be used or the matrix entries should be copied, too.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00879">879</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ab9cf2620cc3350eb189597bd2831570a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cf2620cc3350eb189597bd2831570a">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> TrilinosWrappers::SparseMatrix::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of rows in this matrix. </p>

</div>
</div>
<a id="a371d418cc093230813c36578f32f0966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371d418cc093230813c36578f32f0966">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> TrilinosWrappers::SparseMatrix::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of columns in this matrix. </p>

</div>
</div>
<a id="ac2a8c1f20e048f5a7b9711218779fad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a8c1f20e048f5a7b9711218779fad5">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> TrilinosWrappers::SparseMatrix::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local dimension of the matrix, i.e. the number of rows stored on the present <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> process. For sequential matrices, this number is the same as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m()</a>, but for parallel matrices it may be smaller.</p>
<p>To figure out which elements exactly are stored locally, use <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a557eb5dabea73fb2d3e2ba70226cdfcf">local_range()</a>. </p>

</div>
</div>
<a id="a557eb5dabea73fb2d3e2ba70226cdfcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557eb5dabea73fb2d3e2ba70226cdfcf">&#9670;&nbsp;</a></span>local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&gt; TrilinosWrappers::SparseMatrix::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pair of indices indicating which rows of this matrix are stored locally. The first number is the index of the first row stored, the second the index of the one past the last one that is stored locally. If this is a sequential matrix, then the result will be the pair (0,<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ab9cf2620cc3350eb189597bd2831570a">m()</a>), otherwise it will be a pair (i,i+n), where <code>n=<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2a8c1f20e048f5a7b9711218779fad5">local_size()</a></code>. </p>

</div>
</div>
<a id="a998d6f1a926b04ec7c1a967f46775282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998d6f1a926b04ec7c1a967f46775282">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparseMatrix::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether <code>index</code> is in the local range or not, see also <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a557eb5dabea73fb2d3e2ba70226cdfcf">local_range()</a>. </p>

</div>
</div>
<a id="ae26d73bf5ba9422c98651107cc9dfbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26d73bf5ba9422c98651107cc9dfbac">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> TrilinosWrappers::SparseMatrix::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of nonzero elements of this matrix (summed over all <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> processes). </p>

</div>
</div>
<a id="aa245c41459e8f4100994de6dfb876fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa245c41459e8f4100994de6dfb876fdf">&#9670;&nbsp;</a></span>row_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of entries in a specific row. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01339">1339</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a91a559b1529540ca031728b25f63962c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a559b1529540ca031728b25f63962c">&#9670;&nbsp;</a></span>is_compressed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparseMatrix::is_compressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the state of the matrix, i.e., whether <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> needs to be called after an operation requiring data exchange. A call to <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> is also needed when the method <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0279858faded0f95d78c901b4e655317">set()</a> has been called (even when working in serial). </p>

</div>
</div>
<a id="a3b0241e5308043f439e44bf1285a0ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0241e5308043f439e44bf1285a0ac6">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">SparseMatrix::size_type</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. Note that only the memory reserved on the current processor is returned in case this is called in an MPI-based program. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02292">2292</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a14b528da50ca77670b997382dc38a77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b528da50ca77670b997382dc38a77b">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMPI__Comm.html">MPI_Comm</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> communicator object in use with this matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02305">2305</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae2e30c191f788f4e668df2a51fc0aad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e30c191f788f4e668df2a51fc0aad3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This operator assigns a scalar to a matrix. Since this does usually not make much sense (should we set all matrix entries to this value? Only the nonzero entries of the sparsity pattern?), this operation is only allowed if the actual value to be assigned is zero. This operator only exists to allow for the obvious notation <code>matrix=0</code>, which sets all elements of the matrix to zero, but keeps the sparsity pattern previously used. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01765">1765</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a5e58c65baa9a70517d6dcd6d3371a525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e58c65baa9a70517d6dcd6d3371a525">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release all memory and return to a state just like after having called the default constructor.</p>
<p>This is a collective operation that needs to be called on all processors in order to avoid a dead lock. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01102">1102</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a77ef7c7e43574dacfdbdd6d007708a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ef7c7e43574dacfdbdd6d007708a38">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This command does two things: </p><ul>
<li>
If the matrix was initialized without a sparsity pattern, elements have been added manually using the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a0279858faded0f95d78c901b4e655317">set()</a> command. When this process is completed, a call to <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> reorganizes the internal data structures (sparsity pattern) so that a fast access to data is possible in matrix-vector products. </li>
<li>
If the matrix structure has already been fixed (either by initialization with a sparsity pattern or by calling <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> during the setup phase), this command does the parallel exchange of data. This is necessary when we perform assembly on more than one (<a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a>) process, because then some non-local row data will accumulate on nodes that belong to the current's processor element, but are actually held by another. This command is usually called after all elements have been traversed. </li>
</ul>
<p>In both cases, this function compresses the data structures and allows the resulting matrix to be used in all other operations like matrix- vector products. This is a collective operation, i.e., it needs to be run on all processors when used in parallel.</p>
<p>See <a class="el" href="DEALGlossary.html#GlossCompress">Compressing distributed objects</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01043">1043</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a0279858faded0f95d78c901b4e655317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0279858faded0f95d78c901b4e655317">&#9670;&nbsp;</a></span>set() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the element (<em>i,j</em>) to <code>value</code>.</p>
<p>This function is able to insert new elements into the matrix as long as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> has not been called, so the sparsity pattern will be extended. When <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> is called for the first time (or in case the matrix is initialized from a sparsity pattern), no new elements can be added and an insertion of elements at positions which have not been initialized will throw an exception.</p>
<p>For the case that the matrix is constructed without a sparsity pattern and new matrix entries are added on demand, please note the following behavior imposed by the underlying Epetra_FECrsMatrix data structure: If the same matrix entry is inserted more than once, the matrix entries will be added upon calling <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> (since Epetra does not track values to the same entry before the final <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> is called), even if <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a> is specified as argument to <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a>. In the case you cannot make sure that matrix entries are only set once, initialize the matrix with a sparsity pattern to fix the matrix structure before inserting elements. </p>

</div>
</div>
<a id="ae4eb1ed3db64694a143ff796028ed36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4eb1ed3db64694a143ff796028ed36f">&#9670;&nbsp;</a></span>set() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into the sparse matrix locations given by <code>indices</code>. In other words, this function writes the elements in <code>full_matrix</code> into the calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>This function is able to insert new elements into the matrix as long as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> has not been called, so the sparsity pattern will be extended. After <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> has been called for the first time or the matrix has been initialized from a sparsity pattern, extending the sparsity pattern is no longer possible and an insertion of elements at positions which have not been initialized will throw an exception.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced.</p>
<p>For the case that the matrix is constructed without a sparsity pattern and new matrix entries are added on demand, please note the following behavior imposed by the underlying Epetra_FECrsMatrix data structure: If the same matrix entry is inserted more than once, the matrix entries will be added upon calling <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> (since Epetra does not track values to the same entry before the final <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> is called), even if <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a> is specified as argument to <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a>. In the case you cannot make sure that matrix entries are only set once, initialize the matrix with a sparsity pattern to fix the matrix structure before inserting elements. </p>

</div>
</div>
<a id="a03e7e8afef3f71bc0c685bd4b84fd69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e7e8afef3f71bc0c685bd4b84fd69e">&#9670;&nbsp;</a></span>set() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01365">1365</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1793ec909cb013dc94609e65f72acfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1793ec909cb013dc94609e65f72acfe2">&#9670;&nbsp;</a></span>set() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>This function is able to insert new elements into the matrix as long as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> has not been called, so the sparsity pattern will be extended. After <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> has been called for the first time or the matrix has been initialized from a sparsity pattern, extending the sparsity pattern is no longer possible and an insertion of elements at positions which have not been initialized will throw an exception.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced.</p>
<p>For the case that the matrix is constructed without a sparsity pattern and new matrix entries are added on demand, please note the following behavior imposed by the underlying Epetra_FECrsMatrix data structure: If the same matrix entry is inserted more than once, the matrix entries will be added upon calling <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> (since Epetra does not track values to the same entry before the final <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> is called), even if <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a> is specified as argument to <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a>. In the case you cannot make sure that matrix entries are only set once, initialize the matrix with a sparsity pattern to fix the matrix structure before inserting elements. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01386">1386</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae1b15e7295291562879e3c526d0322ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b15e7295291562879e3c526d0322ec">&#9670;&nbsp;</a></span>set() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements to values given by <code>values</code> in a given row in columns given by col_indices into the sparse matrix.</p>
<p>This function is able to insert new elements into the matrix as long as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> has not been called, so the sparsity pattern will be extended. After <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> has been called for the first time or the matrix has been initialized from a sparsity pattern, extending the sparsity pattern is no longer possible and an insertion of elements at positions which have not been initialized will throw an exception.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced.</p>
<p>For the case that the matrix is constructed without a sparsity pattern and new matrix entries are added on demand, please note the following behavior imposed by the underlying Epetra_FECrsMatrix data structure: If the same matrix entry is inserted more than once, the matrix entries will be added upon calling <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> (since Epetra does not track values to the same entry before the final <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> is called), even if <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a> is specified as argument to <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a>. In the case you cannot make sure that matrix entries are only set once, initialize the matrix with a sparsity pattern to fix the matrix structure before inserting elements. </p>

</div>
</div>
<a id="ac2822f0aed012ede4516df69f53d0d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2822f0aed012ede4516df69f53d0d13">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add <code>value</code> to the element (<em>i,j</em>).</p>
<p>Just as the respective call in deal.II SparseMatrix&lt;Number&gt; class (but in contrast to the situation for PETSc based matrices), this function throws an exception if an entry does not exist in the sparsity pattern. Moreover, if <code>value</code> is not a finite number an exception is thrown. </p>

</div>
</div>
<a id="a6253cdd3795e76d753099065189078ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6253cdd3795e76d753099065189078ee">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into sparse matrix locations given by <code>indices</code>. In other words, this function adds the elements in <code>full_matrix</code> to the respective entries in calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>Just as the respective call in deal.II SparseMatrix&lt;Number&gt; class (but in contrast to the situation for PETSc based matrices), this function throws an exception if an entry does not exist in the sparsity pattern.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01539">1539</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a8b87b4a845b1c52815be6447e24341e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b87b4a845b1c52815be6447e24341e4">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01558">1558</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aad1fd0cf7019f1ead364e4cf4b806202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1fd0cf7019f1ead364e4cf4b806202">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>Just as the respective call in deal.II SparseMatrix&lt;Number&gt; class (but in contrast to the situation for PETSc based matrices), this function throws an exception if an entry does not exist in the sparsity pattern.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01579">1579</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aa2468a28250ecc0ef4989b66dacdea55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2468a28250ecc0ef4989b66dacdea55">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an array of values given by <code>values</code> in the given global matrix row at columns specified by col_indices in the sparse matrix.</p>
<p>Just as the respective call in deal.II SparseMatrix&lt;Number&gt; class (but in contrast to the situation for PETSc based matrices), this function throws an exception if an entry does not exist in the sparsity pattern.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01597">1597</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1b02a77bbf81ac8ee1dbf558e1b1d849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b02a77bbf81ac8ee1dbf558e1b1d849">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply the entire matrix by a fixed factor. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01888">1888</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a7a74de71c2fa3233b48ee71a3daf72dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a74de71c2fa3233b48ee71a3daf72dd">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide the entire matrix by a fixed factor. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01900">1900</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a9ce2618df5a059715d3d55c83f085763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce2618df5a059715d3d55c83f085763">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given (Trilinos) matrix (sparsity pattern and entries). </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l00372">372</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae2bac02815f056cd6b235367edf83d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bac02815f056cd6b235367edf83d31">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add <code>matrix</code> scaled by <code>factor</code> to this matrix, i.e. the matrix <code>factor*matrix</code> is added to <code>this</code>. If the sparsity pattern of the calling matrix does not contain all the elements in the sparsity pattern of the input matrix, this function will throw an exception. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01783">1783</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a4e1c4f2ee1e8ae2fadf5102c320c54cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1c4f2ee1e8ae2fadf5102c320c54cd">&#9670;&nbsp;</a></span>clear_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::clear_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all elements from this <code>row</code> by setting them to zero. The function does not modify the number of allocated nonzero entries, it only sets the entries to zero.</p>
<p>This operation is used in eliminating constraints (e.g. due to hanging nodes) and makes sure that we can write this modification to the matrix without having to read entries (such as the locations of non-zero elements) from it &mdash; without this operation, removing constraints on parallel matrices is a rather complicated procedure.</p>
<p>The second parameter can be used to set the diagonal entry of this row to a value different from zero. The default is to set it to zero.</p>
<dl class="section note"><dt>Note</dt><dd>If the matrix is stored in parallel across multiple processors using <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a>, this function only touches rows that are locally stored and simply ignores all other row indices. Further, in the context of parallel computations, you will get into trouble if you clear a row while other processors still have pending writes or additions into the same row. In other words, if another processor still wants to add something to an element of a row and you call this function to zero out the row, then the next time you call <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> may add the remote value to the zero you just created. Consequently, you will want to call <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> after you made the last modifications to a matrix and before starting to clear rows. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01121">1121</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a900a42baea388ebcc9b4c7bcf96f71b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900a42baea388ebcc9b4c7bcf96f71b4">&#9670;&nbsp;</a></span>clear_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::clear_rows </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4e1c4f2ee1e8ae2fadf5102c320c54cd">clear_row()</a>, except that it works on a number of rows at once.</p>
<p>The second parameter can be used to set the diagonal entries of all cleared rows to something different from zero. Note that all of these diagonal entries get the same value &ndash; if you want different values for the diagonal entries, you have to set them by hand.</p>
<dl class="section note"><dt>Note</dt><dd>If the matrix is stored in parallel across multiple processors using <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a>, this function only touches rows that are locally stored and simply ignores all other row indices. Further, in the context of parallel computations, you will get into trouble if you clear a row while other processors still have pending writes or additions into the same row. In other words, if another processor still wants to add something to an element of a row and you call this function to zero out the row, then the next time you call <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> may add the remote value to the zero you just created. Consequently, you will want to call <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> after you made the last modifications to a matrix and before starting to clear rows. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01157">1157</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1a7a578fb46241991114a6ffa99cd3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7a578fb46241991114a6ffa99cd3fe">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets an internal flag so that all operations performed by the matrix, i.e., multiplications, are done in transposed order. However, this does not reshape the matrix to transposed form directly, so care should be taken when using this flag.</p>
<dl class="section note"><dt>Note</dt><dd>Calling this function any even number of times in succession will return the object to its original state. </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01864">1864</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="acd63c0d5ac1357d24b5fa7ffa4b1d3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd63c0d5ac1357d24b5fa7ffa4b1d3c7">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the entry (<em>i,j</em>). This may be an expensive operation and you should always take care where to call this function. As in the deal.II sparse matrix class, we throw an exception if the respective entry doesn't exist in the sparsity pattern of this class, which is requested from Trilinos. Moreover, an exception will be thrown when the requested element is not saved on the calling process. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01167">1167</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a92e40cf415aa2630fd0f56e1878eadb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e40cf415aa2630fd0f56e1878eadb4">&#9670;&nbsp;</a></span>el()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the matrix entry (<em>i,j</em>). If this entry does not exist in the sparsity pattern, then zero is returned. While this may be convenient in some cases, note that it is simple to write algorithms that are slow compared to an optimal solution, since the sparsity of the matrix is not used. On the other hand, if you want to be sure the entry exists, you should use operator() instead.</p>
<p>The lack of error checking in this function can also yield surprising results if you have a parallel matrix. In that case, just because you get a zero result from this function does not mean that either the entry does not exist in the sparsity pattern or that it does but has a value of zero. Rather, it could also be that it simply isn't stored on the current processor; in that case, it may be stored on a different processor, and possibly so with a nonzero value. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01246">1246</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="abe41a4a1feb344a2281a85d138d679ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe41a4a1feb344a2281a85d138d679ee">&#9670;&nbsp;</a></span>diag_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the main diagonal element in the <em>i</em>th row. This function throws an error if the matrix is not quadratic and it also throws an error if <em>(i,i)</em> is not element of the local matrix. See also the comment in <a class="el" href="trilinos__sparse__matrix_8cc.html">trilinos_sparse_matrix.cc</a>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01318">1318</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a4aedd84e99cda48dce634a2bbf8763fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aedd84e99cda48dce634a2bbf8763fd">&#9670;&nbsp;</a></span>vmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_same&lt; typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt;::value &gt;::type <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M*src</em> with <em>M</em> being this matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>This function can be called with several types of vector objects, namely <code>VectorType</code> can be </p><ul>
<li>
<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, </li>
<li>
<a class="el" href="classLinearAlgebra_1_1EpetraWrappers_1_1Vector.html">LinearAlgebra::EpetraWrappers::Vector</a>, </li>
<li>
<a class="el" href="classLinearAlgebra_1_1TpetraWrappers_1_1Vector.html">LinearAlgebra::TpetraWrappers::Vector</a>, </li>
<li>
<a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>, </li>
<li>
LinearAlgebra::distributed::Vector&lt;double&gt;. </li>
</ul>
<p>When using vectors of type <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, the vector <code>dst</code> has to be initialized with the same <a class="el" href="classIndexSet.html">IndexSet</a> that was used for the row indices of the matrix and the vector <code>src</code> has to be initialized with the same <a class="el" href="classIndexSet.html">IndexSet</a> that was used for the column indices of the matrix.</p>
<p>This function will be called when the underlying number type for the matrix object and the one for the vector object are the same. Despite looking complicated, the return type is just <code>void</code>.</p>
<p>In case of a serial vector, this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, an exception will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01974">1974</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a318f6ff9df006a316365680fb08d3e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318f6ff9df006a316365680fb08d3e4f">&#9670;&nbsp;</a></span>vmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same&lt;typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&gt;::value&gt;::type TrilinosWrappers::SparseMatrix::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the function above for the case that the underlying number type for the matrix object and the one for the vector object do not coincide. This case is not implemented. Calling it will result in a runtime error. Despite looking complicated, the return type is just <code>void</code>. </p>

</div>
</div>
<a id="a9f4d7979e74e7d74d329a5b9a3d0014c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4d7979e74e7d74d329a5b9a3d0014c">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !std::is_same&lt; typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt;::value &gt;::type <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M<sup>T</sup>*src</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4aedd84e99cda48dce634a2bbf8763fd">vmult()</a> but takes the transposed matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>This function can be called with several types of vector objects, see the discussion about <code>VectorType</code> in <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4aedd84e99cda48dce634a2bbf8763fd">vmult()</a>.</p>
<p>This function will be called when the underlying number type for the matrix object and the one for the vector object are the same. Despite looking complicated, the return type is just <code>void</code>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02018">2018</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aa7adf13a14a8342e246d3a3e58cc4a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7adf13a14a8342e246d3a3e58cc4a4e">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same&lt;typename VectorType::value_type, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&gt;::value&gt;::type TrilinosWrappers::SparseMatrix::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the function above for the case that the underlying number type for the matrix object and the one for the vector object do not coincide. This case is not implemented. Calling it will result in a runtime error. Despite looking complicated, the return type is just <code>void</code>. </p>

</div>
</div>
<a id="a6792587fa97254fae30dea0e8d770f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6792587fa97254fae30dea0e8d770f0c">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::vmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding matrix-vector multiplication. Add <em>M*src</em> on <em>dst</em> with <em>M</em> being this matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>This function can be called with several types of vector objects, see the discussion about <code>VectorType</code> in <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4aedd84e99cda48dce634a2bbf8763fd">vmult()</a>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02058">2058</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a849653e0230720b0f0ab58591974c0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849653e0230720b0f0ab58591974c0f2">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding matrix-vector multiplication. Add <em>M<sup>T</sup>*src</em> to <em>dst</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a6792587fa97254fae30dea0e8d770f0c">vmult_add()</a> but takes the transposed matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>This function can be called with several types of vector objects, see the discussion about <code>VectorType</code> in <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a4aedd84e99cda48dce634a2bbf8763fd">vmult()</a>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02074">2074</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a3be0bd695cbfabf512cea6ef3c9c28ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be0bd695cbfabf512cea6ef3c9c28ba">&#9670;&nbsp;</a></span>matrix_norm_square()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the norm of the vector \(v\) with respect to the norm induced by this matrix, i.e., \(\left(v,Mv\right)\). This is useful, e.g. in the finite element context, where the \(L_2\) norm of a function equals the matrix norm with respect to the mass matrix of the vector representing the nodal values of the finite element function.</p>
<p>Obviously, the matrix needs to be quadratic for this operation.</p>
<p>The implementation of this function is not as efficient as the one in the <code><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a></code> class used in deal.II (i.e. the original one, not the Trilinos wrapper class) since Trilinos doesn't support this operation and needs a temporary vector.</p>
<p>The vector has to be initialized with the same <a class="el" href="classIndexSet.html">IndexSet</a> the matrix was initialized with.</p>
<p>In case of a localized <a class="el" href="classVector.html">Vector</a>, this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, an exception will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02089">2089</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae3575cd95bb79786665f996816023b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3575cd95bb79786665f996816023b11">&#9670;&nbsp;</a></span>matrix_scalar_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the matrix scalar product \(\left(u,Mv\right)\).</p>
<p>The implementation of this function is not as efficient as the one in the <code><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a></code> class used in deal.II (i.e. the original one, not the Trilinos wrapper class) since Trilinos doesn't support this operation and needs a temporary vector.</p>
<p>The vector <code>u</code> has to be initialized with the same <a class="el" href="classIndexSet.html">IndexSet</a> that was used for the row indices of the matrix and the vector <code>v</code> has to be initialized with the same <a class="el" href="classIndexSet.html">IndexSet</a> that was used for the column indices of the matrix.</p>
<p>In case of a localized <a class="el" href="classVector.html">Vector</a>, this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, an exception will be thrown.</p>
<p>This function is only implemented for square matrices. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02103">2103</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a95d1cabc336bbc45ca182972ce02c82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d1cabc336bbc45ca182972ce02c82d">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the residual of an equation <em>Mx=b</em>, where the residual is defined to be <em>r=b-Mx</em>. Write the residual into <code>dst</code>. The <em>l<sub>2</sub></em> norm of the residual vector is returned.</p>
<p>Source <em>x</em> and destination <em>dst</em> must not be the same vector.</p>
<p>The vectors <code>dst</code> and <code>b</code> have to be initialized with the same <a class="el" href="classIndexSet.html">IndexSet</a> that was used for the row indices of the matrix and the vector <code>x</code> has to be initialized with the same <a class="el" href="classIndexSet.html">IndexSet</a> that was used for the column indices of the matrix.</p>
<p>In case of a localized <a class="el" href="classVector.html">Vector</a>, this function will only work when running on one processor, since the matrix object is inherently distributed. Otherwise, an exception will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02118">2118</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1dbabb70ef99a4be889474c4c5dc4756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbabb70ef99a4be889474c4c5dc4756">&#9670;&nbsp;</a></span>mmult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the matrix-matrix multiplication <code>C = A * B</code>, or, if an optional vector argument is given, <code>C = A * diag(V) * B</code>, where <code>diag(V)</code> defines a diagonal matrix with the vector entries.</p>
<p>This function assumes that the calling matrix <code>A</code> and <code>B</code> have compatible sizes. The size of <code>C</code> will be set within this function.</p>
<p>The content as well as the sparsity pattern of the matrix C will be changed by this function, so make sure that the sparsity pattern is not used somewhere else in your program. This is an expensive operation, so think twice before you use this function. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02229">2229</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a446bb9a2e86487360cd8c73c021197e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446bb9a2e86487360cd8c73c021197e4">&#9670;&nbsp;</a></span>Tmmult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the matrix-matrix multiplication with the transpose of <code>this</code>, i.e., <code>C = A<sup>T</sup> * B</code>, or, if an optional vector argument is given, <code>C = A<sup>T</sup> * diag(V) * B</code>, where <code>diag(V)</code> defines a diagonal matrix with the vector entries.</p>
<p>This function assumes that the calling matrix <code>A</code> and <code>B</code> have compatible sizes. The size of <code>C</code> will be set within this function.</p>
<p>The content as well as the sparsity pattern of the matrix C will be changed by this function, so make sure that the sparsity pattern is not used somewhere else in your program. This is an expensive operation, so think twice before you use this function. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02239">2239</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1e599d765970ef68e126aa9d5e93583e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e599d765970ef68e126aa9d5e93583e">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <em>l</em><sub>1</sub>-norm of the matrix, that is \(|M|_1= \max_{\mathrm{all\ columns\ } j} \sum_{\mathrm{all\ rows\ } i} |M_{ij}|\), (max. sum of columns). This is the natural matrix norm that is compatible to the l1-norm for vectors, i.e. \(|Mv|_1 \leq |M|_1 |v|_1\). (cf. Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01916">1916</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a32bb09f66dde1c1969a23b4cccd17f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bb09f66dde1c1969a23b4cccd17f04">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the linfty-norm of the matrix, that is \(|M|_\infty=\max_{\mathrm{all\ rows\ } i}\sum_{\mathrm{all\ columns\ } j} |M_{ij}|\), (max. sum of rows). This is the natural matrix norm that is compatible to the linfty-norm of vectors, i.e. \(|Mv|_\infty \leq |M|_\infty |v|_\infty\). (cf. Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01925">1925</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aa26df1c42b8f8973246287cfee4d20b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26df1c42b8f8973246287cfee4d20b4">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the frobenius norm of the matrix, i.e. the square root of the sum of squares of all entries in the matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01934">1934</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a2706d65ed111bced458694502fc56a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2706d65ed111bced458694502fc56a3c">&#9670;&nbsp;</a></span>trilinos_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_CrsMatrix&amp; TrilinosWrappers::SparseMatrix::trilinos_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_CrsMatrix data. </p>

</div>
</div>
<a id="a5601f390c0d339f5e087cf29951906d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5601f390c0d339f5e087cf29951906d8">&#9670;&nbsp;</a></span>trilinos_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_CrsGraph&amp; TrilinosWrappers::SparseMatrix::trilinos_sparsity_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_CrsGraph data that stores the sparsity pattern of the matrix. </p>

</div>
</div>
<a id="a95be9f345182496414c8f74f81ad9502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95be9f345182496414c8f74f81ad9502">&#9670;&nbsp;</a></span>locally_owned_domain_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> TrilinosWrappers::SparseMatrix::locally_owned_domain_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the partitioning of the domain space of this matrix, i.e., the partitioning of the vectors this matrix has to be multiplied with. </p>

</div>
</div>
<a id="a4255ce516797c98c4448a293ee4f523f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4255ce516797c98c4448a293ee4f523f">&#9670;&nbsp;</a></span>locally_owned_range_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> TrilinosWrappers::SparseMatrix::locally_owned_range_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the partitioning of the range space of this matrix, i.e., the partitioning of the vectors that are result from matrix-vector products. </p>

</div>
</div>
<a id="a53bc4c91231034a9924a89cb45bea7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53bc4c91231034a9924a89cb45bea7df">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the first element of the matrix.</p>
<p>The elements accessed by iterators within each row are ordered in the way in which Trilinos stores them, though the implementation guarantees that all elements of one row are accessed before the elements of the next row. If your algorithm relies on visiting elements within one row, you will need to consult with the Trilinos documentation on the order in which it stores data. It is, however, generally not a good and long- term stable idea to rely on the order in which receive elements if you iterate over them.</p>
<p>When you iterate over the elements of a parallel matrix, you will only be able to access the locally owned rows. (You can access the other rows as well, but they will look empty.) In that case, you probably want to call the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a432dd81dc9b1c3446d2b35dd902af016">begin()</a> function that takes the row as an argument to limit the range of elements to loop over. </p>

</div>
</div>
<a id="a432dd81dc9b1c3446d2b35dd902af016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432dd81dc9b1c3446d2b35dd902af016">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the function above, but for non-const matrices. </p>

</div>
</div>
<a id="ae46e2e5d966499c1b4e9da1798445eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46e2e5d966499c1b4e9da1798445eef">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing the element past the last one of this matrix. </p>

</div>
</div>
<a id="a818f02479da77b15b295090b8d379bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818f02479da77b15b295090b8d379bb5">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the function above, but for non-const matrices. </p>

</div>
</div>
<a id="aad11df47057376b44f5e495727ea9d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad11df47057376b44f5e495727ea9d72">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the first element of row <code>r</code>.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. The returned iterator may not be dereferenceable in that case if neither row <code>r</code> nor any of the following rows contain any nonzero entries.</p>
<p>The elements accessed by iterators within each row are ordered in the way in which Trilinos stores them, though the implementation guarantees that all elements of one row are accessed before the elements of the next row. If your algorithm relies on visiting elements within one row, you will need to consult with the Trilinos documentation on the order in which it stores data. It is, however, generally not a good and long- term stable idea to rely on the order in which receive elements if you iterate over them.</p>
<dl class="section note"><dt>Note</dt><dd>When you access the elements of a parallel matrix, you can only access the elements of rows that are actually stored locally. (You can access the other rows as well, but they will look empty.) Even then, if another processor has since written into, or added to, an element of the matrix that is stored on the current processor, then you will still see the old value of this entry unless you have called <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> between modifying the matrix element on the remote processor and accessing it on the current processor. See the documentation of the <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress()</a> function for more information. </dd></dl>

</div>
</div>
<a id="ac801a93ef57d40f3fbe36ca10909e47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac801a93ef57d40f3fbe36ca10909e47f">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a> TrilinosWrappers::SparseMatrix::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the function above, but for non-const matrices. </p>

</div>
</div>
<a id="a77d0dcda5cd5cfd144526471a8c99d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d0dcda5cd5cfd144526471a8c99d9a">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#ae308c2134b631d8553164329dfee584b">const_iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing the element past the last one of row <code>r</code> , or past the end of the entire sparsity pattern if none of the rows after <code>r</code> contain any entries at all.</p>
<p>Note that the end iterator is not necessarily dereferenceable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<a id="aba4773e90eb187a3432dd2b69fe28273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4773e90eb187a3432dd2b69fe28273">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a1d7757ad30700692bed81a328a4b6ee1">iterator</a> TrilinosWrappers::SparseMatrix::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the function above, but for non-const matrices. </p>

</div>
</div>
<a id="ad2297e8c999fc04057a3c2370b0db96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2297e8c999fc04057a3c2370b0db96c">&#9670;&nbsp;</a></span>write_ascii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::write_ascii </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abstract Trilinos object that helps view in ASCII other Trilinos objects. Currently this function is not implemented. TODO: Not implemented. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02249">2249</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a4270ebaea8467f2862cf2baf38986815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4270ebaea8467f2862cf2baf38986815">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>write_extended_trilinos_info</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the matrix to the given stream, using the format <code>(line,col) value</code>, i.e. one nonzero entry of the matrix per line. The optional flag outputs the sparsity pattern in Trilinos style, where the data is sorted according to the processor number when printed to the stream, as well as a summary of the matrix like the global size. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l02260">2260</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a536e7d727e8394586b4c2dde99b39ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536e7d727e8394586b4c2dde99b39ba3">&#9670;&nbsp;</a></span>prepare_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::prepare_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For some matrix storage formats, in particular for the PETSc distributed blockmatrices, set and add operations on individual elements can not be freely mixed. Rather, one has to synchronize operations when one wants to switch from setting elements to adding to elements. <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> automatically synchronizes the access by calling this helper function for each block. This function ensures that the matrix is in a state that allows adding elements; if it previously already was in this state, the function does nothing. </p>

</div>
</div>
<a id="a68a6620012e379b4c660fb4431d817fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a6620012e379b4c660fb4431d817fb">&#9670;&nbsp;</a></span>prepare_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::prepare_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a536e7d727e8394586b4c2dde99b39ba3">prepare_add()</a> but prepare the matrix for setting elements if the representation of elements in this class requires such an operation. </p>

</div>
</div>
<a id="af8d16939e4c35144a316076f5b1c2f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d16939e4c35144a316076f5b1c2f91">&#9670;&nbsp;</a></span>set() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::SparseMatrix::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html#a301d937415bb2c99478d00f4cb5cce7a">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8cc_source.html#l01405">1405</a> of file <a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0eb72d666c41a0ac3c16def795c0c99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb72d666c41a0ac3c16def795c0c99b">&#9670;&nbsp;</a></span>BlockMatrixBase< SparseMatrix ></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">SparseMatrix</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l01917">1917</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0c0bbe2fbaf13b7faf696d83f2e3a8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0bbe2fbaf13b7faf696d83f2e3a8f6">&#9670;&nbsp;</a></span>column_space_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Epetra_Map&gt; TrilinosWrappers::SparseMatrix::column_space_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the user-supplied Epetra Trilinos mapping of the matrix columns that assigns parts of the matrix to the individual processes. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l01876">1876</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a1f3f26ae4997382b25a2eb9604200a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3f26ae4997382b25a2eb9604200a75">&#9670;&nbsp;</a></span>matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Epetra_FECrsMatrix&gt; TrilinosWrappers::SparseMatrix::matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A sparse matrix object in Trilinos to be used for finite element based problems which allows for assembling into non-local elements. The actual type, a sparse matrix, is set in the constructor. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l01883">1883</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="af574b90695c223223c111c6591f3c57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af574b90695c223223c111c6591f3c57b">&#9670;&nbsp;</a></span>nonlocal_matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Epetra_CrsMatrix&gt; TrilinosWrappers::SparseMatrix::nonlocal_matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A sparse matrix object in Trilinos to be used for collecting the non- local elements if the matrix was constructed from a Trilinos sparsity pattern with the respective option. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l01890">1890</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a1dc3fe319a247fc46bd3d052b558f969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc3fe319a247fc46bd3d052b558f969">&#9670;&nbsp;</a></span>nonlocal_matrix_exporter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Epetra_Export&gt; TrilinosWrappers::SparseMatrix::nonlocal_matrix_exporter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An export object used to communicate the nonlocal matrix. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l01895">1895</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a3c1d6236f2215737135912c25cc993b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1d6236f2215737135912c25cc993b0">&#9670;&nbsp;</a></span>last_action</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_CombineMode TrilinosWrappers::SparseMatrix::last_action</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trilinos doesn't allow to mix additions to matrix entries and overwriting them (to make synchronization of parallel computations simpler). The way we do it is to, for each access operation, store whether it is an insertion or an addition. If the previous one was of different type, then we first have to flush the Trilinos buffers; otherwise, we can simply go on. Luckily, Trilinos has an object for this which does already all the parallel communications in such a case, so we simply use their model, which stores whether the last operation was an addition or an insertion. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l01908">1908</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a896761c5d6156507d191a404ca7dc8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896761c5d6156507d191a404ca7dc8c3">&#9670;&nbsp;</a></span>compressed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::SparseMatrix::compressed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A boolean variable to hold information on whether the vector is compressed or not. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__sparse__matrix_8h_source.html#l01914">1914</a> of file <a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="trilinos__sparse__matrix_8h_source.html">trilinos_sparse_matrix.h</a></li>
<li>source/lac/<a class="el" href="trilinos__sparse__matrix_8cc_source.html">trilinos_sparse_matrix.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
