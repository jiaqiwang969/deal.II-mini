<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSUNDIALS_1_1ARKode.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SUNDIALS::ARKode&lt; VectorType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a></li><li class="navelem"><a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSUNDIALS_1_1ARKode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SUNDIALS::ARKode&lt; VectorType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="arkode_8h_source.html">deal.II/sundials/arkode.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode_1_1AdditionalData.html">AdditionalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4e3be1d10f890e6d84ce77031c94c4e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a4e3be1d10f890e6d84ce77031c94c4e2">ARKode</a> (const <a class="el" href="classSUNDIALS_1_1ARKode_1_1AdditionalData.html">AdditionalData</a> &amp;<a class="el" href="classSUNDIALS_1_1ARKode.html#a2aed7783bf6b72e641dde7a917c5248b">data</a>=<a class="el" href="classSUNDIALS_1_1ARKode_1_1AdditionalData.html">AdditionalData</a>(), const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_comm=MPI_COMM_WORLD)</td></tr>
<tr class="separator:a4e3be1d10f890e6d84ce77031c94c4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c2c2580d9ec558ecef754eaa9a1900"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a22c2c2580d9ec558ecef754eaa9a1900">~ARKode</a> ()</td></tr>
<tr class="separator:a22c2c2580d9ec558ecef754eaa9a1900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e1c95b536b38166a0ade22d6aa80eb"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#ad7e1c95b536b38166a0ade22d6aa80eb">solve_ode</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;solution)</td></tr>
<tr class="separator:ad7e1c95b536b38166a0ade22d6aa80eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e2588e64fdbc405b259d2777d66392"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#ae4e2588e64fdbc405b259d2777d66392">solve_ode_incrementally</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;solution, const <a class="el" href="classdouble.html">double</a> intermediate_time, const <a class="el" href="classbool.html">bool</a> reset_solver=false)</td></tr>
<tr class="separator:ae4e2588e64fdbc405b259d2777d66392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701e64deea214c0d4b70420fcbd98353"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a701e64deea214c0d4b70420fcbd98353">reset</a> (const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classdouble.html">double</a> h, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y)</td></tr>
<tr class="separator:a701e64deea214c0d4b70420fcbd98353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20eafd49c7cb1e4638f5d0d2f144ac0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#ae20eafd49c7cb1e4638f5d0d2f144ac0">get_arkode_memory</a> () const</td></tr>
<tr class="separator:ae20eafd49c7cb1e4638f5d0d2f144ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af83ea0d8b7abe2f38b9b9c03f4d2d4f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8h.html#a31651bfd4404c3cd66729f29b0ed36c4">DEAL_II_DEPRECATED</a> std::function&lt; void(<a class="el" href="classVectorType.html">VectorType</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#af83ea0d8b7abe2f38b9b9c03f4d2d4f3">reinit_vector</a></td></tr>
<tr class="separator:af83ea0d8b7abe2f38b9b9c03f4d2d4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889a8589e2f4cf541a4300ef97f3029f"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, <a class="el" href="classVectorType.html">VectorType</a> &amp;explicit_f)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a889a8589e2f4cf541a4300ef97f3029f">explicit_function</a></td></tr>
<tr class="separator:a889a8589e2f4cf541a4300ef97f3029f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05473c675587456ef625a86e72b1cc01"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, <a class="el" href="classVectorType.html">VectorType</a> &amp;res)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a05473c675587456ef625a86e72b1cc01">implicit_function</a></td></tr>
<tr class="separator:a05473c675587456ef625a86e72b1cc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da13c5a25ee3472c3f81e293cc244b6"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classint.html">int</a> convfail, const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classdouble.html">double</a> gamma, const <a class="el" href="classVectorType.html">VectorType</a> &amp;ypred, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fpred, <a class="el" href="classbool.html">bool</a> &amp;j_is_current)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a4da13c5a25ee3472c3f81e293cc244b6">setup_jacobian</a></td></tr>
<tr class="separator:a4da13c5a25ee3472c3f81e293cc244b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2c18936f05018c7ff524991537134a"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classdouble.html">double</a> gamma, const <a class="el" href="classVectorType.html">VectorType</a> &amp;ycur, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fcur, const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a0b2c18936f05018c7ff524991537134a">solve_jacobian_system</a></td></tr>
<tr class="separator:a0b2c18936f05018c7ff524991537134a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6309c70c543f72a7c473835ec7e6adc"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classdouble.html">double</a> t)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#ad6309c70c543f72a7c473835ec7e6adc">setup_mass</a></td></tr>
<tr class="separator:ad6309c70c543f72a7c473835ec7e6adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88738919b173e6b9dfb5544b4e53f805"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a88738919b173e6b9dfb5544b4e53f805">solve_mass_system</a></td></tr>
<tr class="separator:a88738919b173e6b9dfb5544b4e53f805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74a84a6617d873bc2977c2b63e82f17"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(<a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;v, <a class="el" href="classVectorType.html">VectorType</a> &amp;Mv)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#ab74a84a6617d873bc2977c2b63e82f17">mass_times_vector</a></td></tr>
<tr class="separator:ab74a84a6617d873bc2977c2b63e82f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b047d96fcc06bf9ef32093d698ddeb"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classdouble.html">double</a> t)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a67b047d96fcc06bf9ef32093d698ddeb">mass_times_setup</a></td></tr>
<tr class="separator:a67b047d96fcc06bf9ef32093d698ddeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e413e4500c1433c598c4adc21bb0e4"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;v, <a class="el" href="classVectorType.html">VectorType</a> &amp;Jv, <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fy)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a16e413e4500c1433c598c4adc21bb0e4">jacobian_times_vector</a></td></tr>
<tr class="separator:a16e413e4500c1433c598c4adc21bb0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a18c94bcb10bd60bf4f9df687609a8d"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(realtype t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fy)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a3a18c94bcb10bd60bf4f9df687609a8d">jacobian_times_setup</a></td></tr>
<tr class="separator:a3a18c94bcb10bd60bf4f9df687609a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481da5fd5c766f5f0e799c0bbc052837"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSUNDIALS.html#a40d4cc0c689ce20b29af0f5fdaa869c3">LinearSolveFunction</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a481da5fd5c766f5f0e799c0bbc052837">solve_linearized_system</a></td></tr>
<tr class="separator:a481da5fd5c766f5f0e799c0bbc052837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a7fcfde476976db3c04314f1f98eac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSUNDIALS.html#a40d4cc0c689ce20b29af0f5fdaa869c3">LinearSolveFunction</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#ac2a7fcfde476976db3c04314f1f98eac">solve_mass</a></td></tr>
<tr class="separator:ac2a7fcfde476976db3c04314f1f98eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ec7cbcd28b449284f694c4fddfa258"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(<a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fy, const <a class="el" href="classVectorType.html">VectorType</a> &amp;r, <a class="el" href="classVectorType.html">VectorType</a> &amp;z, <a class="el" href="classdouble.html">double</a> gamma, <a class="el" href="classdouble.html">double</a> tol, <a class="el" href="classint.html">int</a> lr)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#ac1ec7cbcd28b449284f694c4fddfa258">jacobian_preconditioner_solve</a></td></tr>
<tr class="separator:ac1ec7cbcd28b449284f694c4fddfa258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a20c65d3e14fbe4ab6b1c9283298fc4"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(<a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fy, <a class="el" href="classint.html">int</a> jok, <a class="el" href="classint.html">int</a> &amp;jcur, <a class="el" href="classdouble.html">double</a> gamma)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a7a20c65d3e14fbe4ab6b1c9283298fc4">jacobian_preconditioner_setup</a></td></tr>
<tr class="separator:a7a20c65d3e14fbe4ab6b1c9283298fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1501f015f3aac0b81a06d60d23e96d42"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(<a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;r, <a class="el" href="classVectorType.html">VectorType</a> &amp;z, <a class="el" href="classdouble.html">double</a> tol, <a class="el" href="classint.html">int</a> lr)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a1501f015f3aac0b81a06d60d23e96d42">mass_preconditioner_solve</a></td></tr>
<tr class="separator:a1501f015f3aac0b81a06d60d23e96d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e89560ed857ac602385e388f5343cea"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(<a class="el" href="classdouble.html">double</a> t)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a1e89560ed857ac602385e388f5343cea">mass_preconditioner_setup</a></td></tr>
<tr class="separator:a1e89560ed857ac602385e388f5343cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7944b20caba4bfe0f20951fc8e7e428"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;sol, const unsigned <a class="el" href="classint.html">int</a> step_number)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#ab7944b20caba4bfe0f20951fc8e7e428">output_step</a></td></tr>
<tr class="separator:ab7944b20caba4bfe0f20951fc8e7e428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3bd452bc13970e9af93810d3d3beff"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classbool.html">bool</a>(const <a class="el" href="classdouble.html">double</a> t, <a class="el" href="classVectorType.html">VectorType</a> &amp;sol)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a9d3bd452bc13970e9af93810d3d3beff">solver_should_restart</a></td></tr>
<tr class="separator:a9d3bd452bc13970e9af93810d3d3beff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2859448fdc44ba95106b5eec37fd9921"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classVectorType.html">VectorType</a> &amp;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a2859448fdc44ba95106b5eec37fd9921">get_local_tolerances</a></td></tr>
<tr class="separator:a2859448fdc44ba95106b5eec37fd9921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf73d8ab80def219c51585721e95e1a"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(void *<a class="el" href="classSUNDIALS_1_1ARKode.html#a0a1b36ecbb04b988ea96597e0d1c7513">arkode_mem</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#aedf73d8ab80def219c51585721e95e1a">custom_setup</a></td></tr>
<tr class="separator:aedf73d8ab80def219c51585721e95e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a852d8e3eb781d10ffa493996f3e50133"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a852d8e3eb781d10ffa493996f3e50133">DeclException1</a> (ExcFunctionNotProvided, std::string,&lt;&lt; &quot;Please provide an implementation for the function &lt;&lt; arg1&lt;&lt; &quot;\&quot;)</td></tr>
<tr class="separator:a852d8e3eb781d10ffa493996f3e50133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61362e4b440cc348443106ac79b05f2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a61362e4b440cc348443106ac79b05f2b">do_evolve_time</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;solution, ::<a class="el" href="classDiscreteTime.html">DiscreteTime</a> &amp;time, const <a class="el" href="classbool.html">bool</a> do_reset)</td></tr>
<tr class="separator:a61362e4b440cc348443106ac79b05f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9b9103795f966cd55e38edd80f069e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#ade9b9103795f966cd55e38edd80f069e">setup_system_solver</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;solution)</td></tr>
<tr class="separator:ade9b9103795f966cd55e38edd80f069e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a7f5699d02250f42449c56d700edf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a03a7f5699d02250f42449c56d700edf5">setup_mass_solver</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;solution)</td></tr>
<tr class="separator:a03a7f5699d02250f42449c56d700edf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96a0e7a1cfb847a78c0ea7b70c53cd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#ab96a0e7a1cfb847a78c0ea7b70c53cd4">set_functions_to_trigger_an_assert</a> ()</td></tr>
<tr class="separator:ab96a0e7a1cfb847a78c0ea7b70c53cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2aed7783bf6b72e641dde7a917c5248b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSUNDIALS_1_1ARKode_1_1AdditionalData.html">AdditionalData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a2aed7783bf6b72e641dde7a917c5248b">data</a></td></tr>
<tr class="separator:a2aed7783bf6b72e641dde7a917c5248b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1b36ecbb04b988ea96597e0d1c7513"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a0a1b36ecbb04b988ea96597e0d1c7513">arkode_mem</a></td></tr>
<tr class="separator:a0a1b36ecbb04b988ea96597e0d1c7513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991306f2cedcaaff57ee8d2b8f019eef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a991306f2cedcaaff57ee8d2b8f019eef">communicator</a></td></tr>
<tr class="separator:a991306f2cedcaaff57ee8d2b8f019eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead8f91b4dfb696765c750846c5da71d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#aead8f91b4dfb696765c750846c5da71d">last_end_time</a></td></tr>
<tr class="separator:aead8f91b4dfb696765c750846c5da71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ed46a55c6ee2c699de38f60e1144dc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classSUNDIALS_1_1internal_1_1LinearSolverWrapper.html">internal::LinearSolverWrapper</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#ac1ed46a55c6ee2c699de38f60e1144dc">linear_solver</a></td></tr>
<tr class="separator:ac1ed46a55c6ee2c699de38f60e1144dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7884fd6cdfbd98186e4ca97da177db94"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classSUNDIALS_1_1internal_1_1LinearSolverWrapper.html">internal::LinearSolverWrapper</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1ARKode.html#a7884fd6cdfbd98186e4ca97da177db94">mass_solver</a></td></tr>
<tr class="separator:a7884fd6cdfbd98186e4ca97da177db94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename VectorType = Vector&lt;double&gt;&gt;<br />
class SUNDIALS::ARKode&lt; VectorType &gt;</h3>

<p>Interface to <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> additive Runge-Kutta methods (<a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a>).</p>
<p>The class <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> is a wrapper to <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> variable-step, embedded, additive Runge-Kutta solver which is a general purpose solver for systems of ordinary differential equations characterized by the presence of both fast and slow dynamics.</p>
<p>Fast dynamics are treated implicitly, and slow dynamics are treated explicitly, using nested families of implicit and explicit Runge-Kutta solvers.</p>
<p>Citing directly from <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> documentation:</p>
<p><a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> solves ODE initial value problems (IVPs) in \(R^N\). These problems should be posed in explicit form as</p>
<p class="formulaDsp">
\[ M\dot y = f_E(t, y) + f_I (t, y), \qquad y(t_0) = y_0. \]
</p>
<p>Here, \(t\) is the independent variable (e.g. time), and the dependent variables are given by \(y \in R^N\), and we use notation \(\dot y\) to denote \(dy/dt\). \(M\) is a user-supplied nonsingular operator from \(R^N \to R^N\). This operator may depend on \(t\) but not on \(y\).</p>
<p>For standard systems of ordinary differential equations and for problems arising from the spatial semi-discretization of partial differential equations using finite difference or finite volume methods, \(M\) is typically the identity matrix, \(I\). For PDEs using a finite-element spatial semi-discretization \(M\) is typically a well-conditioned mass matrix.</p>
<p>The two right-hand side functions may be described as:</p>
<ul>
<li>\(f_E(t, y)\): contains the "slow" time scale components of the system. This will be integrated using explicit methods.</li>
<li>\(f_I(t, y)\): contains the "fast" time scale components of the system. This will be integrated using implicit methods.</li>
</ul>
<p><a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> may be used to solve stiff, nonstiff and multi-rate problems. Roughly speaking, stiffness is characterized by the presence of at least one rapidly damped mode, whose time constant is small compared to the time scale of the solution itself. In the implicit/explicit (ImEx) splitting above, these stiff components should be included in the right-hand side function \(f_I (t, y)\).</p>
<p>For multi-rate problems, a user should provide both of the functions \(f_E\) and \(f_I\) that define the IVP system.</p>
<p>For nonstiff problems, only \(f_E\) should be provided, and \(f_I\) is assumed to be zero, i.e. the system reduces to the non-split IVP:</p>
<p class="formulaDsp">
\[ M\dot y = f_E(t, y), \qquad y(t_0) = y_0. \]
</p>
<p>In this scenario, the ARK methods reduce to classical explicit Runge-Kutta methods (ERK). For these classes of methods, <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> allows orders of accuracy \(q = \{2, 3, 4, 5, 6, 8\}\), with embeddings of orders \(p = \{1, 2, 3, 4, 5, 7\}\). These default to the Heun-Euler-2-1-2, Bogacki-Shampine-4-2-3, Zonneveld-5-3-4, Cash-Karp-6-4-5, Verner-8-5-6 and Fehlberg-13-7-8 methods, respectively.</p>
<p>Finally, for stiff (linear or nonlinear) problems the user may provide only \(f_I\), implying that \(f_E = 0\), so that the system reduces to the non-split IVP</p>
<p class="formulaDsp">
\[ M\dot y = f_I(t, y), \qquad y(t_0) = y_0. \]
</p>
<p>Similarly to ERK methods, in this scenario the ARK methods reduce to classical diagonally-implicit Runge-Kutta methods (DIRK). For these classes of methods, <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> allows orders of accuracy \(q = \{2, 3, 4, 5\}\), with embeddings of orders \(p = \{1, 2, 3, 4\}\). These default to the SDIRK-2-1-2, ARK-4-2-3 (implicit), SDIRK-5-3-4 and ARK-8-4-5 (implicit) methods, respectively.</p>
<p>For both DIRK and ARK methods, an implicit system of the form </p><p class="formulaDsp">
\[ G(z_i) \dealcoloneq M z_i - h_n A^I_{i,i} f_I (t^I_{n,i}, z_i) - a_i = 0 \]
</p>
<p> must be solved for each stage \(z_i , i = 1, \ldots, s\), where we have the data </p><p class="formulaDsp">
\[ a_i \dealcoloneq M y_{n-1} + h_n \sum_{j=1}^{i-1} [ A^E_{i,j} f_E(t^E_{n,j}, z_j) + A^I_{i,j} f_I (t^I_{n,j}, z_j)] \]
</p>
<p> for the ARK methods, or </p><p class="formulaDsp">
\[ a_i \dealcoloneq M y_{n-1} + h_n \sum_{j=1}^{i-1} A^I_{i,j} f_I (t^I_{n,j}, z_j) \]
</p>
<p> for the DIRK methods. Here \(A^I_{i,j}\) and \(A^E_{i,j}\) are the Butcher's tables for the chosen solver.</p>
<p>If \(f_I(t,y)\) depends nonlinearly on \(y\) then the systems above correspond to a nonlinear system of equations; if \(f_I (t, y)\) depends linearly on \(y\) then this is a linear system of equations. By specifying the flag <code>implicit_function_is_linear</code>, <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> takes some shortcuts that allow a faster solution process.</p>
<p>For systems of either type, <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> allows a choice of solution strategy. The default solver choice is a variant of Newton's method, </p><p class="formulaDsp">
\[ z_i^{m+1} = z_i^m +\delta^{m+1}, \]
</p>
<p> where \(m\) is the Newton index, and the Newton update \(\delta^{m+1}\) requires the solution of the linear Newton system </p><p class="formulaDsp">
\[ N(z_i^m) \delta^{m+1} = -G(z_i^m), \]
</p>
<p> where </p><p class="formulaDsp">
\[ N \dealcoloneq M - \gamma J, \quad J \dealcoloneq \frac{\partial f_I}{\partial y}, \qquad \gamma\dealcoloneq h_n A^I_{i,i}. \]
</p>
<p>As an alternate to Newton's method, <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> may solve for each stage \(z_i ,i = 1, \ldots , s\) using an Anderson-accelerated fixed point iteration </p><p class="formulaDsp">
\[ z_i^{m+1} = g(z_i^{m}), m=0,1,\ldots. \]
</p>
<p>Unlike with Newton's method, this option does not require the solution of a linear system at each iteration, instead opting for solution of a low-dimensional least-squares solution to construct the nonlinear update.</p>
<p>Finally, if the user specifies <code>implicit_function_is_linear</code>, i.e., \(f_I(t, y)\) depends linearly on \(y\), and if the Newton-based nonlinear solver is chosen, then the system will be solved using only a single Newton iteration. Notice that in order for the Newton solver to be used, at least the <a class="el" href="classSUNDIALS_1_1ARKode.html#a16e413e4500c1433c598c4adc21bb0e4">jacobian_times_vector()</a> function (or <a class="el" href="classSUNDIALS_1_1ARKode.html#a0b2c18936f05018c7ff524991537134a">solve_jacobian_system()</a> for <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> version &gt; 4.0.0) should be supplied. If this function is not supplied, then only the fixed-point iteration will be supported, and the <code>implicit_function_is_linear</code> setting is ignored.</p>
<p>The optimal solver (Newton vs fixed-point) is highly problem-dependent. Since fixed-point solvers do not require the solution of any linear systems, each iteration may be significantly less costly than their Newton counterparts. However, this can come at the cost of slower convergence (or even divergence) in comparison with Newton-like methods. These fixed-point solvers do allow for user specification of the Anderson-accelerated subspace size, \(m_k\). While the required amount of solver memory grows proportionately to \(m_k N\), larger values of \(m_k\) may result in faster convergence.</p>
<p>This improvement may be significant even for "small" values, e.g. \(1 \leq m_k \leq 5\), and convergence may not improve (or even deteriorate) for larger values of \(m_k\). While <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> uses a Newton-based iteration as its default solver due to its increased robustness on very stiff problems, it is highly recommended that users also consider the fixed-point solver for their cases when attempting a new problem.</p>
<p>For either the Newton or fixed-point solvers, it is well-known that both the efficiency and robustness of the algorithm intimately depends on the choice of a good initial guess. In <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a>, the initial guess for either nonlinear solution method is a predicted value \(z_i(0)\) that is computed explicitly from the previously-computed data (e.g. \(y_{n-2}, y_{n-1}\), and \(z_j\) where \(j &lt; i\)). Additional information on the specific predictor algorithms implemented in <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> is provided in <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> documentation.</p>
<p>The user has to provide the implementation of at least one (or both) of the following <code>std::function</code>s:</p><ul>
<li><a class="el" href="classSUNDIALS_1_1ARKode.html#a05473c675587456ef625a86e72b1cc01">implicit_function()</a></li>
<li><a class="el" href="classSUNDIALS_1_1ARKode.html#a889a8589e2f4cf541a4300ef97f3029f">explicit_function()</a></li>
</ul>
<p>If the mass matrix is different from the identity, the user should supply</p><ul>
<li><a class="el" href="classSUNDIALS_1_1ARKode.html#ab74a84a6617d873bc2977c2b63e82f17">mass_times_vector()</a> (or <a class="el" href="classSUNDIALS_1_1ARKode.html#a88738919b173e6b9dfb5544b4e53f805">solve_mass_system()</a> for <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> version &lt; 4.0.0) and, optionally,</li>
<li><a class="el" href="classSUNDIALS_1_1ARKode.html#a67b047d96fcc06bf9ef32093d698ddeb">mass_times_setup()</a> (or <a class="el" href="classSUNDIALS_1_1ARKode.html#ad6309c70c543f72a7c473835ec7e6adc">setup_mass()</a> for <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> version &lt; 4.0.0)</li>
</ul>
<p>If the use of a Newton method is desired, then the user should also supply</p><ul>
<li>jacobian_times_vector (or <a class="el" href="classSUNDIALS_1_1ARKode.html#a0b2c18936f05018c7ff524991537134a">solve_jacobian_system()</a> for <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> version &lt; 4.0.0)</li>
<li>optional: <a class="el" href="classSUNDIALS_1_1ARKode.html#a3a18c94bcb10bd60bf4f9df687609a8d">jacobian_times_setup()</a> (or <a class="el" href="classSUNDIALS_1_1ARKode.html#a4da13c5a25ee3472c3f81e293cc244b6">setup_jacobian()</a> for <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> version &lt; 4.0.0)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Although <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> can provide a difference quotient approximation of the Jacobian, this is currently not supported through this wrapper.</dd></dl>
<p>Only for <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> version &gt; 4.0.0: A <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> default solver (SPGMR) is used to solve the linear systems. To use a custom linear solver for the mass matrix and/or Jacobian, set:</p><ul>
<li><a class="el" href="classSUNDIALS_1_1ARKode.html#ac2a7fcfde476976db3c04314f1f98eac">solve_mass()</a> and/or</li>
<li>solve_jacobian()</li>
</ul>
<p>Only for <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> version &gt; 4.0.0: To use a custom preconditioner with either a default or custom linear solver, set:</p><ul>
<li><a class="el" href="classSUNDIALS_1_1ARKode.html#ac1ec7cbcd28b449284f694c4fddfa258">jacobian_preconditioner_solve()</a> and/or <a class="el" href="classSUNDIALS_1_1ARKode.html#a1501f015f3aac0b81a06d60d23e96d42">mass_preconditioner_solve()</a> and, optionally,</li>
<li><a class="el" href="classSUNDIALS_1_1ARKode.html#a7a20c65d3e14fbe4ab6b1c9283298fc4">jacobian_preconditioner_setup()</a> and/or <a class="el" href="classSUNDIALS_1_1ARKode.html#a1e89560ed857ac602385e388f5343cea">mass_preconditioner_setup()</a></li>
</ul>
<p>Also the following functions could be rewritten. By default they do nothing, or are not required.</p><ul>
<li><a class="el" href="classSUNDIALS_1_1ARKode.html#a9d3bd452bc13970e9af93810d3d3beff">solver_should_restart()</a></li>
<li><a class="el" href="classSUNDIALS_1_1ARKode.html#a2859448fdc44ba95106b5eec37fd9921">get_local_tolerances()</a></li>
</ul>
<p>To produce output at fixed steps, set the function</p><ul>
<li><a class="el" href="classSUNDIALS_1_1ARKode.html#ab7944b20caba4bfe0f20951fc8e7e428">output_step()</a></li>
</ul>
<p>Any other custom settings of the ARKODE object can be specified in</p><ul>
<li><a class="el" href="classSUNDIALS_1_1ARKode.html#aedf73d8ab80def219c51585721e95e1a">custom_setup()</a></li>
</ul>
<p>To provide a simple example, consider the harmonic oscillator problem: </p><p class="formulaDsp">
\[ \begin{split} u&#39;&#39; &amp; = -k^2 u \\ u (0) &amp; = 0 \\ u&#39;(0) &amp; = k \end{split} \]
</p>
<p>We write it in terms of a first order ode: </p><p class="formulaDsp">
\[ \begin{matrix} y_0&#39; &amp; = y_1 \\ y_1&#39; &amp; = - k^2 y_0 \end{matrix} \]
</p>
<p>That is \(y&#39; = A y\) where </p><p class="formulaDsp">
\[ A \dealcoloneq \begin{matrix} 0 &amp; 1 \\ -k^2 &amp;0 \end{matrix} \]
</p>
<p> and \(y(0)=(0, k)\).</p>
<p>The exact solution is \(y_0(t) = \sin(k t)\), \(y_1(t) = y_0&#39;(t) = k \cos(k *t)\), \(y_1&#39;(t) = -k^2 \sin(k t)\).</p>
<p>A minimal implementation, using only explicit RK methods, is given by the following code snippet:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="classVectorType.html">VectorType</a> = <a class="code" href="classVector.html">Vector&lt;double&gt;</a>;</div><div class="line"></div><div class="line"><a class="code" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode&lt;VectorType&gt;</a> ode;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> kappa = 1.0;</div><div class="line"></div><div class="line">ode.<a class="code" href="classSUNDIALS_1_1ARKode.html#a889a8589e2f4cf541a4300ef97f3029f">explicit_function</a> = [kappa] (<a class="code" href="classdouble.html">double</a>,</div><div class="line">                                 <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;y,</div><div class="line">                                 <a class="code" href="classVectorType.html">VectorType</a> &amp;ydot) -&gt; <span class="keywordtype">int</span></div><div class="line">{</div><div class="line">  ydot[0] = y[1];</div><div class="line">  ydot[1] = -kappa*kappa*y[0];</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> y(2);</div><div class="line">y[1] = kappa;</div><div class="line"></div><div class="line">ode.<a class="code" href="classSUNDIALS_1_1ARKode.html#ad7e1c95b536b38166a0ade22d6aa80eb">solve_ode</a>(y);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l00333">333</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4e3be1d10f890e6d84ce77031c94c4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3be1d10f890e6d84ce77031c94c4e2">&#9670;&nbsp;</a></span>ARKode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::<a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSUNDIALS_1_1ARKode_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em> = <code><a class="el" href="classSUNDIALS_1_1ARKode_1_1AdditionalData.html">AdditionalData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. It is possible to fine tune the <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> solver by passing an AdditionalData() object that sets all of the solver parameters.</p>
<p>The MPI communicator is simply ignored in the serial case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td><a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> configuration data </td></tr>
    <tr><td class="paramname">mpi_comm</td><td>MPI communicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22c2c2580d9ec558ecef754eaa9a1900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c2c2580d9ec558ecef754eaa9a1900">&#9670;&nbsp;</a></span>~ARKode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::~<a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad7e1c95b536b38166a0ade22d6aa80eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e1c95b536b38166a0ade22d6aa80eb">&#9670;&nbsp;</a></span>solve_ode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve_ode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integrate the initial value problem. This function returns the final number of computed steps.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution</td><td>On input, this vector contains the initial condition. On output, it contains the solution at the final time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4e2588e64fdbc405b259d2777d66392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e2588e64fdbc405b259d2777d66392">&#9670;&nbsp;</a></span>solve_ode_incrementally()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve_ode_incrementally </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>intermediate_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>reset_solver</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integrate the initial value problem. Compared to the function above, this function allows to specify an <code>intermediate_time</code> for the next solution. Repeated calls of this function must use monotonously increasing values for <code>intermediate_time</code>. The last solution state is saved internally along with the <code>intermediate_time</code> and will be reused as initial condition for the next call.</p>
<p>Users may find this function useful when integrating <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> into an outer time loop of their own, especially when <a class="el" href="classSUNDIALS_1_1ARKode.html#ab7944b20caba4bfe0f20951fc8e7e428">output_step()</a> is too restrictive.</p>
<dl class="section note"><dt>Note</dt><dd><code>intermediate_time</code> may be larger than <a class="el" href="classSUNDIALS_1_1ARKode_1_1AdditionalData.html#af309087591ed96d6cd46b0b6a32b0df8">AdditionalData::final_time</a>, which is ignored by this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution</td><td>The final solution. If the solver restarts, either because it is the first ever solve or the flag <code>reset_solver</code> is set, the vector is also used as initial condition. </td></tr>
    <tr><td class="paramname">intermediate_time</td><td>The time for the incremental solution step. Must be greater than the last time that was used in a previous call to this function. </td></tr>
    <tr><td class="paramname">reset_solver</td><td>Optional flag to recreate all internal objects which may be desirable for spatial adaptivity methods. If set to <code>true</code>, <a class="el" href="classSUNDIALS_1_1ARKode.html#a701e64deea214c0d4b70420fcbd98353">reset()</a> is called before solving the ODE, which sets <code>solution</code> as initial condition. This will <em>not</em> reset the stored time from previous calls to this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a701e64deea214c0d4b70420fcbd98353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701e64deea214c0d4b70420fcbd98353">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear internal memory and start with clean objects. This function is called when the simulation starts and when the user returns true to a call to <a class="el" href="classSUNDIALS_1_1ARKode.html#a9d3bd452bc13970e9af93810d3d3beff">solver_should_restart()</a>.</p>
<p>By default <a class="el" href="classSUNDIALS_1_1ARKode.html#a9d3bd452bc13970e9af93810d3d3beff">solver_should_restart()</a> returns false. If the user needs to implement, for example, local adaptivity in space, he or she may assign a different function to <a class="el" href="classSUNDIALS_1_1ARKode.html#a9d3bd452bc13970e9af93810d3d3beff">solver_should_restart()</a> that performs all mesh changes, transfers the solution to the new mesh, and returns true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The new starting time </td></tr>
    <tr><td class="paramname">h</td><td>The new starting time step </td></tr>
    <tr><td class="paramname">y</td><td>The new initial solution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae20eafd49c7cb1e4638f5d0d2f144ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20eafd49c7cb1e4638f5d0d2f144ac0">&#9670;&nbsp;</a></span>get_arkode_memory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::get_arkode_memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides user access to the internally used ARKODE memory.</p>
<p>This functionality is intended for users who wish to query additional information directly from the ARKODE integrator, refer to the ARKODE manual for the various <code>ARKStepGet...</code> functions. The <code>ARKStepSet...</code> functions should not be called since this might lead to conflicts with various settings that are performed by this <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> object.</p>
<dl class="section note"><dt>Note</dt><dd>If custom settings of ARKODE functionality (that are not achievable via the interface of this class) are required, the function <a class="el" href="classSUNDIALS_1_1ARKode.html#aedf73d8ab80def219c51585721e95e1a">custom_setup()</a> should be used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the ARKODE memory block that can be passed to <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> functions </dd></dl>

</div>
</div>
<a id="a852d8e3eb781d10ffa493996f3e50133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852d8e3eb781d10ffa493996f3e50133">&#9670;&nbsp;</a></span>DeclException1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcFunctionNotProvided&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Please provide an implementation for the function \ arg1&lt;&lt; &quot;\&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Throw an exception when a function with the given name is not implemented. </p>

</div>
</div>
<a id="a61362e4b440cc348443106ac79b05f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61362e4b440cc348443106ac79b05f2b">&#9670;&nbsp;</a></span>do_evolve_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::do_evolve_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classDiscreteTime.html">DiscreteTime</a> &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>do_reset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal routine to call <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> repeatedly. </p>

</div>
</div>
<a id="ade9b9103795f966cd55e38edd80f069e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9b9103795f966cd55e38edd80f069e">&#9670;&nbsp;</a></span>setup_system_solver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::setup_system_solver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set up the (non)linear solver and preconditioners in the ARKODE memory object based on the user-specified functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution</td><td>The solution vector which is used as a template to create new vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03a7f5699d02250f42449c56d700edf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a7f5699d02250f42449c56d700edf5">&#9670;&nbsp;</a></span>setup_mass_solver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::setup_mass_solver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set up the solver and preconditioner for a non-identity mass matrix in the ARKODE memory object based on the user-specified functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution</td><td>The solution vector which is used as a template to create new vectors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab96a0e7a1cfb847a78c0ea7b70c53cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96a0e7a1cfb847a78c0ea7b70c53cd4">&#9670;&nbsp;</a></span>set_functions_to_trigger_an_assert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::set_functions_to_trigger_an_assert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is executed at construction time to set the std::function above to trigger an assert if they are not implemented. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af83ea0d8b7abe2f38b9b9c03f4d2d4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83ea0d8b7abe2f38b9b9c03f4d2d4f3">&#9670;&nbsp;</a></span>reinit_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8h.html#a31651bfd4404c3cd66729f29b0ed36c4">DEAL_II_DEPRECATED</a> std::function&lt;void(<a class="el" href="classVectorType.html">VectorType</a> &amp;)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::reinit_vector</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that was used to <code>reinit</code> the given vector. Setting this field does no longer have any effect and all auxiliary vectors are reinit-ed automatically based on the user-supplied vector in <a class="el" href="classSUNDIALS_1_1ARKode.html#ad7e1c95b536b38166a0ade22d6aa80eb">solve_ode()</a>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000097">Deprecated:</a></b></dt><dd>This function is no longer used and can be safely removed in user code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l00623">623</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a889a8589e2f4cf541a4300ef97f3029f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889a8589e2f4cf541a4300ef97f3029f">&#9670;&nbsp;</a></span>explicit_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, <a class="el" href="classVectorType.html">VectorType</a> &amp;explicit_f)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::explicit_function</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to compute the explicit part of the IVP right hand side. Sets \(explicit_f = f_E(t, y)\).</p>
<p>At least one of <a class="el" href="classSUNDIALS_1_1ARKode.html#a889a8589e2f4cf541a4300ef97f3029f">explicit_function()</a> or <a class="el" href="classSUNDIALS_1_1ARKode.html#a05473c675587456ef625a86e72b1cc01">implicit_function()</a> must be provided. According to which one is provided, explicit, implicit, or mixed RK methods are used.</p>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error, <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> will reattempt the solution and call this function again.</li>
<li>&lt;0: Unrecoverable error, the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l00643">643</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a05473c675587456ef625a86e72b1cc01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05473c675587456ef625a86e72b1cc01">&#9670;&nbsp;</a></span>implicit_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, <a class="el" href="classVectorType.html">VectorType</a> &amp;res)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::implicit_function</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to compute the implicit part of the IVP right hand side. Sets \(implicit_f = f_I(t, y)\).</p>
<p>At least one of <a class="el" href="classSUNDIALS_1_1ARKode.html#a889a8589e2f4cf541a4300ef97f3029f">explicit_function()</a> or <a class="el" href="classSUNDIALS_1_1ARKode.html#a05473c675587456ef625a86e72b1cc01">implicit_function()</a> must be provided. According to which one is provided, explicit, implicit, or mixed RK methods are used.</p>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error, <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> will reattempt the solution and call this function again.</li>
<li>&lt;0: Unrecoverable error, the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l00662">662</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a4da13c5a25ee3472c3f81e293cc244b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da13c5a25ee3472c3f81e293cc244b6">&#9670;&nbsp;</a></span>setup_jacobian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classint.html">int</a> convfail, const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classdouble.html">double</a> gamma, const <a class="el" href="classVectorType.html">VectorType</a> &amp;ypred, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fpred, <a class="el" href="classbool.html">bool</a> &amp; j_is_current)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::setup_jacobian</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to prepare the linear solver for subsequent calls to <a class="el" href="classSUNDIALS_1_1ARKode.html#a0b2c18936f05018c7ff524991537134a">solve_jacobian_system()</a>.</p>
<p>Make sure that after a call to this function, we know how to compute solutions of systems \(A x = b\), where \(A\) is some approximation to the Newton matrix, \(M - \gamma \partial f_I/\partial y\). This function is optional. If the user does not provide it, then <a class="el" href="classSUNDIALS_1_1ARKode.html#a0b2c18936f05018c7ff524991537134a">solve_jacobian_system()</a> is assumed to also perform the setup internally.</p>
<p>The <a class="el" href="classSUNDIALS_1_1ARKode.html#a4da13c5a25ee3472c3f81e293cc244b6">setup_jacobian()</a> function may call a user-supplied function to compute needed data related to the Jacobian matrix. Alternatively, it may choose to retrieve and use stored values of this data. In either case, <a class="el" href="classSUNDIALS_1_1ARKode.html#a4da13c5a25ee3472c3f81e293cc244b6">setup_jacobian()</a> may also preprocess that data as needed for <a class="el" href="classSUNDIALS_1_1ARKode.html#a0b2c18936f05018c7ff524991537134a">solve_jacobian_system()</a>, which may involve calling a generic function (such as for LU factorization).</p>
<p>This data may be intended either for direct use (in a direct linear solver) or for use in a preconditioner (in a preconditioned iterative linear solver). The <a class="el" href="classSUNDIALS_1_1ARKode.html#a4da13c5a25ee3472c3f81e293cc244b6">setup_jacobian()</a> function is not called at every stage solve (or even every time step), but only as frequently as the solver determines that it is appropriate to perform the setup task. In this way, Jacobian-related data generated by <a class="el" href="classSUNDIALS_1_1ARKode.html#a4da13c5a25ee3472c3f81e293cc244b6">setup_jacobian()</a> is expected to be used over a number of time steps.</p>
<p>If the user uses a matrix based computation of the Jacobian, then this is the right place where an assembly routine shoulde be called to assemble both a matrix and a preconditioner for the Jacobian system. Subsequent calls (possibly more than one) to <a class="el" href="classSUNDIALS_1_1ARKode.html#a0b2c18936f05018c7ff524991537134a">solve_jacobian_system()</a> can assume that this function has been called at least once.</p>
<p>Notice that no assumption is made by this interface on what the user should do in this function. <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> only assumes that after a call to <a class="el" href="classSUNDIALS_1_1ARKode.html#a4da13c5a25ee3472c3f81e293cc244b6">setup_jacobian()</a> it is possible to call <a class="el" href="classSUNDIALS_1_1ARKode.html#a0b2c18936f05018c7ff524991537134a">solve_jacobian_system()</a>, to obtain a solution \(x\) to the system \(J x = b\). If this function is not provided, then it is never called.</p>
<p>Arguments to the function are</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>the current time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gamma</td><td>the current factor to use in the jacobian computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ypred</td><td>is the predicted \(y\) vector for the current <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> internal step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fpred</td><td>is the value of the implicit right-hand side at ypred, \(f_I (t_n, ypred)\).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">convfail</td><td>Input flag used to indicate any problem that occurred during the solution of the nonlinear equation on the current time step for which the linear solver is being used. This flag can be used to help decide whether the Jacobian data kept by a linear solver needs to be updated or not. Its possible values are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>ARK_NO_FAILURES: this value is passed if either this is the first call for this step, or the local error test failed on the previous attempt at this step (but the Newton iteration converged).</li>
<li>ARK_FAIL_BAD_J: this value is passed if (a) the previous Newton corrector iteration did not converge and the linear solver's setup function indicated that its Jacobian-related data is not current, or (b) during the previous Newton corrector iteration, the linear solver's solve function failed in a recoverable manner and the linear solver's setup function indicated that its Jacobian-related data is not current.</li>
<li>ARK_FAIL_OTHER: this value is passed if during the current internal step try, the previous Newton iteration failed to converge even though the linear solver was using current Jacobian-related data.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">j_is_current</td><td>a boolean to be filled in by <a class="el" href="classSUNDIALS_1_1ARKode.html#a4da13c5a25ee3472c3f81e293cc244b6">setup_jacobian()</a>. The value should be set to <code>true</code> if the Jacobian data is current after the call, and should be set to <code>false</code> if its Jacobian data is not current. If <a class="el" href="classSUNDIALS_1_1ARKode.html#a4da13c5a25ee3472c3f81e293cc244b6">setup_jacobian()</a> calls for re-evaluation of Jacobian data (based on convfail and <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> state data), then it should set <code>j_is_current</code> to <code>true</code> unconditionally, otherwise an infinite loop can result.</td></tr>
  </table>
  </dd>
</dl>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error (ARKodeReinit will be called if this happens, and then last function will be attempted again</li>
<li>&lt;0: Unrecoverable error the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l00755">755</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a0b2c18936f05018c7ff524991537134a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2c18936f05018c7ff524991537134a">&#9670;&nbsp;</a></span>solve_jacobian_system</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classdouble.html">double</a> gamma, const <a class="el" href="classVectorType.html">VectorType</a> &amp;ycur, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fcur, const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp; dst)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve_jacobian_system</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to solve the Jacobian linear system. This function will be called by <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> (possibly several times) after <a class="el" href="classSUNDIALS_1_1ARKode.html#a4da13c5a25ee3472c3f81e293cc244b6">setup_jacobian()</a> has been called at least once. <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> tries to do its best to call <a class="el" href="classSUNDIALS_1_1ARKode.html#a4da13c5a25ee3472c3f81e293cc244b6">setup_jacobian()</a> the minimum amount of times. If convergence can be achieved without updating the Jacobian, then <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> does not call <a class="el" href="classSUNDIALS_1_1ARKode.html#a4da13c5a25ee3472c3f81e293cc244b6">setup_jacobian()</a> again. If, on the contrary, internal <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> convergence tests fail, then <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> calls again <a class="el" href="classSUNDIALS_1_1ARKode.html#a4da13c5a25ee3472c3f81e293cc244b6">setup_jacobian()</a> with updated vectors and coefficients so that successive calls to solve_jacobian_systems() lead to better convergence in the Newton process.</p>
<p>If you do not specify a <a class="el" href="classSUNDIALS_1_1ARKode.html#a0b2c18936f05018c7ff524991537134a">solve_jacobian_system()</a> function, then a fixed point iteration is used instead of a Newton method. Notice that this may not converge, or may converge very slowly.</p>
<p>The jacobian \(J\) should be (an approximation of) the system Jacobian </p><p class="formulaDsp">
\[ J = M - \gamma \frac{\partial f_I}{\partial y} \]
</p>
<p> evaluated at <code>t</code>, <code>ycur</code>. <code>fcur</code> is \(f_I(t,ycur)\).</p>
<p>A call to this function should store in <code>dst</code> the result of \(J^{-1}\) applied to <code>src</code>, i.e., <code>J*dst = src</code>. It is the users responsibility to set up proper solvers and preconditioners inside this function.</p>
<p>Arguments to the function are</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>the current time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gamma</td><td>the current factor to use in the jacobian computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ycur</td><td>is the current \(y\) vector for the current <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> internal step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fcur</td><td>is the current value of the implicit right-hand side at ycur, \(f_I (t_n, ypred)\).</td></tr>
  </table>
  </dd>
</dl>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error (ARKodeReinit will be called if this happens, and then last function will be attempted again</li>
<li>&lt;0: Unrecoverable error the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l00807">807</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="ad6309c70c543f72a7c473835ec7e6adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6309c70c543f72a7c473835ec7e6adc">&#9670;&nbsp;</a></span>setup_mass</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classdouble.html">double</a> t)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::setup_mass</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to set up the mass matrix. This function is called by <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> any time a mass matrix update is required. The user should compute the mass matrix (or update all the variables that allow the application of the mass matrix). This function is called by <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> once, before any call to <a class="el" href="classSUNDIALS_1_1ARKode.html#a88738919b173e6b9dfb5544b4e53f805">solve_mass_system()</a>.</p>
<p><a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> supports the case where the mass matrix may depend on time, but not the case where the mass matrix depends on the solution itself.</p>
<p>If the user does not provide a solve_mass_matrix() function, then the identity is used. If the <a class="el" href="classSUNDIALS_1_1ARKode.html#ad6309c70c543f72a7c473835ec7e6adc">setup_mass()</a> function is not provided, then <a class="el" href="classSUNDIALS_1_1ARKode.html#a88738919b173e6b9dfb5544b4e53f805">solve_mass_system()</a> should do all the work by itself.</p>
<p>If the user uses a matrix based computation of the mass matrix, then this is the right place where an assembly routine shoulde be called to assemble both a matrix and a preconditioner. Subsequent calls (possibly more than one) to <a class="el" href="classSUNDIALS_1_1ARKode.html#a88738919b173e6b9dfb5544b4e53f805">solve_mass_system()</a> can assume that this function has been called at least once.</p>
<p>Notice that no assumption is made by this interface on what the user should do in this function. <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> only assumes that after a call to <a class="el" href="classSUNDIALS_1_1ARKode.html#ad6309c70c543f72a7c473835ec7e6adc">setup_mass()</a> it is possible to call <a class="el" href="classSUNDIALS_1_1ARKode.html#a88738919b173e6b9dfb5544b4e53f805">solve_mass_system()</a>, to obtain a solution \(x\) to the system \(M x = b\).</p>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error (ARKodeReinit will be called if this happens, and then last function will be attempted again</li>
<li>&lt;0: Unrecoverable error the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l00843">843</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a88738919b173e6b9dfb5544b4e53f805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88738919b173e6b9dfb5544b4e53f805">&#9670;&nbsp;</a></span>solve_mass_system</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve_mass_system</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to solve the mass matrix linear system. This function will be called by <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> (possibly several times) after <a class="el" href="classSUNDIALS_1_1ARKode.html#ad6309c70c543f72a7c473835ec7e6adc">setup_mass()</a> has been called at least once. <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> tries to do its best to call <a class="el" href="classSUNDIALS_1_1ARKode.html#ad6309c70c543f72a7c473835ec7e6adc">setup_mass()</a> the minimum amount of times.</p>
<p>A call to this function should store in <code>dst</code> the result of \(M^{-1}\) applied to <code>src</code>, i.e., <code>M*dst = src</code>. It is the users responsibility to set up proper solvers and preconditioners inside this function.</p>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error (ARKodeReinit will be called if this happens, and then last function will be attempted again</li>
<li>&lt;0: Unrecoverable error the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l00864">864</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="ab74a84a6617d873bc2977c2b63e82f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74a84a6617d873bc2977c2b63e82f17">&#9670;&nbsp;</a></span>mass_times_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(<a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;v, <a class="el" href="classVectorType.html">VectorType</a> &amp;Mv)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::mass_times_vector</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to compute the product of the mass matrix with a given vector <code>v</code>. This function will be called by <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> (possibly several times) after <a class="el" href="classSUNDIALS_1_1ARKode.html#a67b047d96fcc06bf9ef32093d698ddeb">mass_times_setup()</a> has been called at least once. <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> tries to do its best to call <a class="el" href="classSUNDIALS_1_1ARKode.html#a67b047d96fcc06bf9ef32093d698ddeb">mass_times_setup()</a> the minimum amount of times.</p>
<p>A call to this function should store in <code>Mv</code> the result of \(M\) applied to <code>v</code>.</p>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error, <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> will reattempt the solution and call this function again.</li>
<li>&lt;0: Unrecoverable error, the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l00885">885</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a67b047d96fcc06bf9ef32093d698ddeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b047d96fcc06bf9ef32093d698ddeb">&#9670;&nbsp;</a></span>mass_times_setup</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classdouble.html">double</a> t)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::mass_times_setup</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to set up the mass matrix. This function is called by <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> any time a mass matrix update is required. The user should compute the mass matrix (or update all the variables that allow the application of the mass matrix). This function is guaranteed to be called by <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> at least once, before any call to <a class="el" href="classSUNDIALS_1_1ARKode.html#ab74a84a6617d873bc2977c2b63e82f17">mass_times_vector()</a>.</p>
<p><a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> supports the case where the mass matrix may depend on time, but not the case where the mass matrix depends on the solution itself.</p>
<p>If the user does not provide a <a class="el" href="classSUNDIALS_1_1ARKode.html#ab74a84a6617d873bc2977c2b63e82f17">mass_times_vector()</a> function, then the identity is used. If the <a class="el" href="classSUNDIALS_1_1ARKode.html#a67b047d96fcc06bf9ef32093d698ddeb">mass_times_setup()</a> function is not provided, then <a class="el" href="classSUNDIALS_1_1ARKode.html#ab74a84a6617d873bc2977c2b63e82f17">mass_times_vector()</a> should do all the work by itself.</p>
<p>If the user uses a matrix-based computation of the mass matrix, then this is the right place where an assembly routine should be called to assemble the matrix. Subsequent calls (possibly more than one) to <a class="el" href="classSUNDIALS_1_1ARKode.html#ab74a84a6617d873bc2977c2b63e82f17">mass_times_vector()</a> can assume that this function has been called at least once.</p>
<dl class="section note"><dt>Note</dt><dd>No assumption is made by this interface on what the user should do in this function. <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> only assumes that after a call to <a class="el" href="classSUNDIALS_1_1ARKode.html#a67b047d96fcc06bf9ef32093d698ddeb">mass_times_setup()</a> it is possible to call <a class="el" href="classSUNDIALS_1_1ARKode.html#ab74a84a6617d873bc2977c2b63e82f17">mass_times_vector()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The current evaluation time</td></tr>
  </table>
  </dd>
</dl>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error, <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> will reattempt the solution and call this function again.</li>
<li>&lt;0: Unrecoverable error, the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l00921">921</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a16e413e4500c1433c598c4adc21bb0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e413e4500c1433c598c4adc21bb0e4">&#9670;&nbsp;</a></span>jacobian_times_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;v, <a class="el" href="classVectorType.html">VectorType</a> &amp; Jv, <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fy)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::jacobian_times_vector</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to compute the product of the Jacobian matrix with a given vector <code>v</code>. The Jacobian here refers to \(J=\frac{\partial f_I}{\partial y}\), i.e., the Jacobian of the user-specified implicit_function.</p>
<p>A call to this function should store in <code>Jv</code> the result of \(J\) applied to <code>v</code>.</p>
<p>Arguments to the function are</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The vector to be multiplied by the Jacobian </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Jv</td><td>The vector to be filled with the product J*v </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The current time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The current \(y\) vector for the current <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> internal step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fy</td><td>The current value of the implicit right-hand side at y, \(f_I (t_n, y)\).</td></tr>
  </table>
  </dd>
</dl>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error, <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> will reattempt the solution and call this function again.</li>
<li>&lt;0: Unrecoverable error, the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l00954">954</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a3a18c94bcb10bd60bf4f9df687609a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a18c94bcb10bd60bf4f9df687609a8d">&#9670;&nbsp;</a></span>jacobian_times_setup</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(realtype t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fy)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::jacobian_times_setup</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to set up all data necessary for the application of <a class="el" href="classSUNDIALS_1_1ARKode.html#a16e413e4500c1433c598c4adc21bb0e4">jacobian_times_vector()</a>. This function is called by <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> any time a Jacobian update is required. The user should compute the Jacobian (or update all the variables that allow the application of Jacobian). This function is guaranteed to be called by <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> at least once, before any call to <a class="el" href="classSUNDIALS_1_1ARKode.html#a16e413e4500c1433c598c4adc21bb0e4">jacobian_times_vector()</a>.</p>
<p>If the <a class="el" href="classSUNDIALS_1_1ARKode.html#a3a18c94bcb10bd60bf4f9df687609a8d">jacobian_times_setup()</a> function is not provided, then <a class="el" href="classSUNDIALS_1_1ARKode.html#a16e413e4500c1433c598c4adc21bb0e4">jacobian_times_vector()</a> should do all the work by itself.</p>
<p>If the user uses a matrix based computation of the Jacobian, then this is the right place where an assembly routine should be called to assemble the matrix. Subsequent calls (possibly more than one) to <a class="el" href="classSUNDIALS_1_1ARKode.html#a16e413e4500c1433c598c4adc21bb0e4">jacobian_times_vector()</a> can assume that this function has been called at least once.</p>
<dl class="section note"><dt>Note</dt><dd>No assumption is made by this interface on what the user should do in this function. <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> only assumes that after a call to <a class="el" href="classSUNDIALS_1_1ARKode.html#a3a18c94bcb10bd60bf4f9df687609a8d">jacobian_times_setup()</a> it is possible to call <a class="el" href="classSUNDIALS_1_1ARKode.html#a16e413e4500c1433c598c4adc21bb0e4">jacobian_times_vector()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The current time </td></tr>
    <tr><td class="paramname">y</td><td>The current <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> internal solution vector \(y\) </td></tr>
    <tr><td class="paramname">fy</td><td>The implicit right-hand side function evaluated at the current time \(t\) and state \(y\), i.e., \(f_I(y,t)\)</td></tr>
  </table>
  </dd>
</dl>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error, <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> will reattempt the solution and call this function again.</li>
<li>&lt;0: Unrecoverable error, the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l00991">991</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a481da5fd5c766f5f0e799c0bbc052837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481da5fd5c766f5f0e799c0bbc052837">&#9670;&nbsp;</a></span>solve_linearized_system</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSUNDIALS.html#a40d4cc0c689ce20b29af0f5fdaa869c3">LinearSolveFunction</a>&lt;<a class="el" href="classVectorType.html">VectorType</a>&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve_linearized_system</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A LinearSolveFunction object that users may supply and that is intended to solve the linearized system \(Ax=b\), where \(A = M-\gamma J\) is the Jacobian of the nonlinear residual. The application of the mass matrix \(M\) and Jacobian \(J\) are known through the functions <a class="el" href="classSUNDIALS_1_1ARKode.html#ab74a84a6617d873bc2977c2b63e82f17">mass_times_vector()</a> and <a class="el" href="classSUNDIALS_1_1ARKode.html#a16e413e4500c1433c598c4adc21bb0e4">jacobian_times_vector()</a> and \(\gamma\) is a factor provided by <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a>. The matrix-vector product \(Ax\) is encoded in the supplied <a class="el" href="structSUNDIALS_1_1SundialsOperator.html">SundialsOperator</a>. If a preconditioner was set through <a class="el" href="classSUNDIALS_1_1ARKode.html#ac1ec7cbcd28b449284f694c4fddfa258">jacobian_preconditioner_solve()</a>, it is encoded in the <a class="el" href="structSUNDIALS_1_1SundialsPreconditioner.html">SundialsPreconditioner</a>. If no preconditioner was supplied this way, the preconditioner is the identity matrix, i.e., no preconditioner. The user is free to use a custom preconditioner in this function object that is not supplied through <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a>.</p>
<p>If you do not specify a <a class="el" href="classSUNDIALS_1_1ARKode.html#a481da5fd5c766f5f0e799c0bbc052837">solve_linearized_system()</a> function, then a <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> packaged SPGMR solver with default settings is used.</p>
<p>For more details on the function type refer to LinearSolveFunction. </p>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01012">1012</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="ac2a7fcfde476976db3c04314f1f98eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a7fcfde476976db3c04314f1f98eac">&#9670;&nbsp;</a></span>solve_mass</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSUNDIALS.html#a40d4cc0c689ce20b29af0f5fdaa869c3">LinearSolveFunction</a>&lt;<a class="el" href="classVectorType.html">VectorType</a>&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve_mass</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A LinearSolveFunction object that users may supply and that is intended to solve the mass system \(Mx=b\). The matrix-vector product \(Mx\) is encoded in the supplied <a class="el" href="structSUNDIALS_1_1SundialsOperator.html">SundialsOperator</a>. If a preconditioner was set through <a class="el" href="classSUNDIALS_1_1ARKode.html#a1501f015f3aac0b81a06d60d23e96d42">mass_preconditioner_solve()</a>, it is encoded in the <a class="el" href="structSUNDIALS_1_1SundialsPreconditioner.html">SundialsPreconditioner</a>. If no preconditioner was supplied this way, the preconditioner is the identity matrix, i.e., no preconditioner. The user is free to use a custom preconditioner in this function object that is not supplied through <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a>.</p>
<p>The user must specify this function if a non-identity mass matrix is used and applied in <a class="el" href="classSUNDIALS_1_1ARKode.html#ab74a84a6617d873bc2977c2b63e82f17">mass_times_vector()</a>.</p>
<p>For more details on the function type refer to LinearSolveFunction. </p>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01029">1029</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="ac1ec7cbcd28b449284f694c4fddfa258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ec7cbcd28b449284f694c4fddfa258">&#9670;&nbsp;</a></span>jacobian_preconditioner_solve</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(<a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fy, const <a class="el" href="classVectorType.html">VectorType</a> &amp;r, <a class="el" href="classVectorType.html">VectorType</a> &amp; z, <a class="el" href="classdouble.html">double</a> gamma, <a class="el" href="classdouble.html">double</a> tol, <a class="el" href="classint.html">int</a> lr)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::jacobian_preconditioner_solve</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply to either pass a preconditioner to a <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> built-in solver or to apply a custom preconditioner within the user's own linear solve specified in <a class="el" href="classSUNDIALS_1_1ARKode.html#a481da5fd5c766f5f0e799c0bbc052837">solve_linearized_system()</a>.</p>
<p>This function should compute the solution to the preconditioner equation \(Pz=r\) and store it in <code>z</code>. In this equation \(P\) should approximate the Jacobian \(M-\gamma J\) of the nonlinear system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The current time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The current \(y\) vector for the current <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> internal step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fy</td><td>The current value of the implicit right-hand side at y, \(f_I (t_n, y)\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>The right-hand side of the preconditioner equation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">z</td><td>The solution of applying the preconditioner, i.e., solving \(Pz=r\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gamma</td><td>The value \(\gamma\) in the preconditioner equation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>The tolerance up to which the system should be solved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lr</td><td>An input flag indicating whether the preconditioner solve is to use the left preconditioner (lr = 1) or the right preconditioner (lr = 2). Only relevant if used with a <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> packaged solver. If used with a custom <a class="el" href="classSUNDIALS_1_1ARKode.html#ac2a7fcfde476976db3c04314f1f98eac">solve_mass()</a> function this will be set to zero.</td></tr>
  </table>
  </dd>
</dl>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error, <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> will reattempt the solution and call this function again.</li>
<li>&lt;0: Unrecoverable error, the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01071">1071</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a7a20c65d3e14fbe4ab6b1c9283298fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a20c65d3e14fbe4ab6b1c9283298fc4">&#9670;&nbsp;</a></span>jacobian_preconditioner_setup</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(<a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fy, <a class="el" href="classint.html">int</a> jok, <a class="el" href="classint.html">int</a> &amp; jcur, <a class="el" href="classdouble.html">double</a> gamma)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::jacobian_preconditioner_setup</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply to set up a preconditioner specified in <a class="el" href="classSUNDIALS_1_1ARKode.html#ac1ec7cbcd28b449284f694c4fddfa258">jacobian_preconditioner_solve()</a>.</p>
<p>This function should prepare the solution of the preconditioner equation \(Pz=r\). In this equation \(P\) should approximate the Jacobian \(M-\gamma J\) of the nonlinear system.</p>
<p>If the <a class="el" href="classSUNDIALS_1_1ARKode.html#a7a20c65d3e14fbe4ab6b1c9283298fc4">jacobian_preconditioner_setup()</a> function is not provided, then <a class="el" href="classSUNDIALS_1_1ARKode.html#ac1ec7cbcd28b449284f694c4fddfa258">jacobian_preconditioner_solve()</a> should do all the work by itself.</p>
<dl class="section note"><dt>Note</dt><dd>No assumption is made by this interface on what the user should do in this function. <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> only assumes that after a call to <a class="el" href="classSUNDIALS_1_1ARKode.html#a7a20c65d3e14fbe4ab6b1c9283298fc4">jacobian_preconditioner_setup()</a> it is possible to call <a class="el" href="classSUNDIALS_1_1ARKode.html#ac1ec7cbcd28b449284f694c4fddfa258">jacobian_preconditioner_solve()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The current time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The current \(y\) vector for the current <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> internal step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fy</td><td>The current value of the implicit right-hand side at y, \(f_I (t_n, y)\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jok</td><td>An input flag indicating whether the Jacobian-related data needs to be updated. The jok argument provides for the reuse of Jacobian data in the preconditioner solve function. When jok = SUNFALSE, the Jacobian-related data should be recomputed from scratch. When jok = SUNTRUE the Jacobian data, if saved from the previous call to this function, can be reused (with the current value of gamma). A call with jok = SUNTRUE can only occur after a call with jok = SUNFALSE. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">jcur</td><td>On output this should be set to SUNTRUE if Jacobian data was recomputed, or set to SUNFALSE if Jacobian data was not recomputed, but saved data was still reused. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gamma</td><td>The value \(\gamma\) in \(M-\gamma J\). The preconditioner should approximate the inverse of this matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error, <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> will reattempt the solution and call this function again.</li>
<li>&lt;0: Unrecoverable error, the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01121">1121</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a1501f015f3aac0b81a06d60d23e96d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1501f015f3aac0b81a06d60d23e96d42">&#9670;&nbsp;</a></span>mass_preconditioner_solve</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="classint.html">int</a>(<a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;r, <a class="el" href="classVectorType.html">VectorType</a> &amp;z, <a class="el" href="classdouble.html">double</a> tol, <a class="el" href="classint.html">int</a> lr)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::mass_preconditioner_solve</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply to either pass a preconditioner to a <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> built-in solver or to apply a custom preconditioner within the user's own linear solve specified in <a class="el" href="classSUNDIALS_1_1ARKode.html#ac2a7fcfde476976db3c04314f1f98eac">solve_mass()</a>.</p>
<p>This function should compute the solution to the preconditioner equation \(Pz=r\) and store it in <code>z</code>. In this equation \(P\) should approximate the mass matrix \(M\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The current time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>The right-hand side of the preconditioner equation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">z</td><td>The solution of applying the preconditioner, i.e., solving \(Pz=r\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gamma</td><td>The value \(\gamma\) in the preconditioner equation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>The tolerance up to which the system should be solved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lr</td><td>An input flag indicating whether the preconditioner solve is to use the left preconditioner (lr = 1) or the right preconditioner (lr = 2). Only relevant if used with a <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> packaged solver. If used with a custom <a class="el" href="classSUNDIALS_1_1ARKode.html#ac2a7fcfde476976db3c04314f1f98eac">solve_mass()</a> function this will be set to zero.</td></tr>
  </table>
  </dd>
</dl>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error, <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> will reattempt the solution and call this function again.</li>
<li>&lt;0: Unrecoverable error, the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01152">1152</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a1e89560ed857ac602385e388f5343cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e89560ed857ac602385e388f5343cea">&#9670;&nbsp;</a></span>mass_preconditioner_setup</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(<a class="el" href="classdouble.html">double</a> t)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::mass_preconditioner_setup</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply to set up a preconditioner specified in <a class="el" href="classSUNDIALS_1_1ARKode.html#a1501f015f3aac0b81a06d60d23e96d42">mass_preconditioner_solve()</a>.</p>
<p>This function should prepare the solution of the preconditioner equation \(Pz=r\). In this equation \(P\) should approximate the mass matrix \(M\).</p>
<p>If the <a class="el" href="classSUNDIALS_1_1ARKode.html#a1e89560ed857ac602385e388f5343cea">mass_preconditioner_setup()</a> function is not provided, then <a class="el" href="classSUNDIALS_1_1ARKode.html#a1501f015f3aac0b81a06d60d23e96d42">mass_preconditioner_solve()</a> should do all the work by itself.</p>
<dl class="section note"><dt>Note</dt><dd>No assumption is made by this interface on what the user should do in this function. <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> only assumes that after a call to <a class="el" href="classSUNDIALS_1_1ARKode.html#a1e89560ed857ac602385e388f5343cea">mass_preconditioner_setup()</a> it is possible to call <a class="el" href="classSUNDIALS_1_1ARKode.html#a1501f015f3aac0b81a06d60d23e96d42">mass_preconditioner_solve()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The current time</td></tr>
  </table>
  </dd>
</dl>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error, <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> will reattempt the solution and call this function again.</li>
<li>&lt;0: Unrecoverable error, the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01178">1178</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="ab7944b20caba4bfe0f20951fc8e7e428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7944b20caba4bfe0f20951fc8e7e428">&#9670;&nbsp;</a></span>output_step</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp; sol, const unsigned <a class="el" href="classint.html">int</a> step_number)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::output_step</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to postprocess the solution. This function is called by <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> at fixed time increments (every <code>output_period</code> seconds), and it is passed a polynomial interpolation of the solution, computed using the current ARK order and the (internally stored) previously computed solution steps.</p>
<dl class="section note"><dt>Note</dt><dd>It is well possible that internally <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> computes a time step which is much larger than the <code>output_period</code> step, and therefore calls this function consecutively several times by simply performing all intermediate interpolations. There is no relationship between how many times this function is called and how many time steps have actually been computed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01198">1198</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a9d3bd452bc13970e9af93810d3d3beff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3bd452bc13970e9af93810d3d3beff">&#9670;&nbsp;</a></span>solver_should_restart</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classbool.html">bool</a>(const <a class="el" href="classdouble.html">double</a> t, <a class="el" href="classVectorType.html">VectorType</a> &amp;sol)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solver_should_restart</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to evaluate whether the solver should be restarted (for example because the number of degrees of freedom has changed).</p>
<p>This function is supposed to perform all operations that are necessary in <code>sol</code> to make sure that the resulting vectors are consistent, and of the correct final size.</p>
<p>For example, one may decide that a local refinement is necessary at time t. This function should then return true, and change the dimension of <code>sol</code> to reflect the new dimension. Since <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> does not know about the new dimension, an internal reset is necessary.</p>
<p>The default implementation simply returns <code>false</code>, i.e., no restart is performed during the evolution. </p>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01217">1217</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a2859448fdc44ba95106b5eec37fd9921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2859448fdc44ba95106b5eec37fd9921">&#9670;&nbsp;</a></span>get_local_tolerances</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classVectorType.html">VectorType</a> &amp;()&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::get_local_tolerances</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to return a vector whose components are the weights used by <a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> to compute the vector norm. The implementation of this function is optional, and it is used only if implemented. </p>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01225">1225</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="aedf73d8ab80def219c51585721e95e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf73d8ab80def219c51585721e95e1a">&#9670;&nbsp;</a></span>custom_setup</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(void *<a class="el" href="classSUNDIALS_1_1ARKode.html#a0a1b36ecbb04b988ea96597e0d1c7513">arkode_mem</a>)&gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::custom_setup</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and which is intended to perform custom settings on the supplied <code>arkode_mem</code> object. Refer to the <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> documentation for valid options.</p>
<p>For instance, the following code attaches two files for diagnostic and error output of the internal ARKODE implementation:</p>
<div class="fragment"><div class="line">ode.<a class="code" href="classSUNDIALS_1_1ARKode.html#aedf73d8ab80def219c51585721e95e1a">custom_setup</a> = [&amp;](<span class="keywordtype">void</span> *<a class="code" href="classSUNDIALS_1_1ARKode.html#a0a1b36ecbb04b988ea96597e0d1c7513">arkode_mem</a>) {</div><div class="line">  ARKStepSetErrFile(<a class="code" href="classSUNDIALS_1_1ARKode.html#a0a1b36ecbb04b988ea96597e0d1c7513">arkode_mem</a>, errfile);</div><div class="line">  ARKStepSetDiagnostics(<a class="code" href="classSUNDIALS_1_1ARKode.html#a0a1b36ecbb04b988ea96597e0d1c7513">arkode_mem</a>, diagnostics_file);</div><div class="line">};</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function will be called at the end of all other set up right before the actual time evloution is started or continued with <a class="el" href="classSUNDIALS_1_1ARKode.html#ad7e1c95b536b38166a0ade22d6aa80eb">solve_ode()</a>. This function is also called when the solver is restarted, see <a class="el" href="classSUNDIALS_1_1ARKode.html#a9d3bd452bc13970e9af93810d3d3beff">solver_should_restart()</a>. Consult the <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> manual to see which options are still available at this point.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arkode_mem</td><td>pointer to the ARKODE memory block which can be used for custom calls to <code>ARKStepSet...</code> methods. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01251">1251</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a2aed7783bf6b72e641dde7a917c5248b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aed7783bf6b72e641dde7a917c5248b">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1ARKode_1_1AdditionalData.html">AdditionalData</a> <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> configuration data. </p>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01304">1304</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a0a1b36ecbb04b988ea96597e0d1c7513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1b36ecbb04b988ea96597e0d1c7513">&#9670;&nbsp;</a></span>arkode_mem</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::arkode_mem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSUNDIALS_1_1ARKode.html">ARKode</a> memory object. </p>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01309">1309</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a991306f2cedcaaff57ee8d2b8f019eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991306f2cedcaaff57ee8d2b8f019eef">&#9670;&nbsp;</a></span>communicator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMPI__Comm.html">MPI_Comm</a> <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>MPI communicator. <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> solver runs happily in parallel. Note that if the library is compiled without MPI support, MPI_Comm is aliased as int. </p>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01316">1316</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="aead8f91b4dfb696765c750846c5da71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead8f91b4dfb696765c750846c5da71d">&#9670;&nbsp;</a></span>last_end_time</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::last_end_time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The final time in the last call to <a class="el" href="classSUNDIALS_1_1ARKode.html#ad7e1c95b536b38166a0ade22d6aa80eb">solve_ode()</a>. </p>

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01321">1321</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="ac1ed46a55c6ee2c699de38f60e1144dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ed46a55c6ee2c699de38f60e1144dc">&#9670;&nbsp;</a></span>linear_solver</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classSUNDIALS_1_1internal_1_1LinearSolverWrapper.html">internal::LinearSolverWrapper</a>&lt;<a class="el" href="classVectorType.html">VectorType</a>&gt; &gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::linear_solver</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01324">1324</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<a id="a7884fd6cdfbd98186e4ca97da177db94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7884fd6cdfbd98186e4ca97da177db94">&#9670;&nbsp;</a></span>mass_solver</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classSUNDIALS_1_1internal_1_1LinearSolverWrapper.html">internal::LinearSolverWrapper</a>&lt;<a class="el" href="classVectorType.html">VectorType</a>&gt; &gt; <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::mass_solver</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="arkode_8h_source.html#l01325">1325</a> of file <a class="el" href="arkode_8h_source.html">arkode.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/sundials/<a class="el" href="arkode_8h_source.html">arkode.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
