<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceSmoothnessEstimator_1_1Fourier.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SmoothnessEstimator::Fourier Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSmoothnessEstimator.html">SmoothnessEstimator</a></li><li class="navelem"><a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html">Fourier</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SmoothnessEstimator::Fourier Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aae63069820e030e1f012e3e84d28e6f8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:aae63069820e030e1f012e3e84d28e6f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html#aae63069820e030e1f012e3e84d28e6f8">coefficient_decay</a> (<a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a>&lt; dim, spacedim &gt; &amp;fe_fourier, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;smoothness_indicators, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a> regression_strategy=<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>, const <a class="el" href="classdouble.html">double</a> smallest_abs_coefficient=1e-10, const bool only_flagged_cells=false)</td></tr>
<tr class="separator:aae63069820e030e1f012e3e84d28e6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8ab53058217f739eec4280e5f52e96"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a6d8ab53058217f739eec4280e5f52e96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html#a6d8ab53058217f739eec4280e5f52e96">coefficient_decay_per_direction</a> (<a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a>&lt; dim, spacedim &gt; &amp;fe_fourier, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;smoothness_indicators, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;coefficients_predicate=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classdouble.html">double</a> smallest_abs_coefficient=1e-10, const bool only_flagged_cells=false)</td></tr>
<tr class="separator:a6d8ab53058217f739eec4280e5f52e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3fa210d75a81b147179f6ac5bfac04"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a6c3fa210d75a81b147179f6ac5bfac04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a>&lt; dim, spacedim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html#a6c3fa210d75a81b147179f6ac5bfac04">default_fe_series</a> (const <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;fe_collection, const unsigned <a class="el" href="classint.html">int</a> component=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a6c3fa210d75a81b147179f6ac5bfac04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Smoothness estimation strategy based on the decay of <a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html">Fourier</a> expansion coefficients.</p>
<p>From the definition, we can write our <a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html">Fourier</a> series expansion \(a_{\bf k}\) of the finite element solution on cell \(K\) with polynomial degree \(p\) as a matrix product </p><p class="formulaDsp">
\begin{eqnarray*} u_h({\bf x}) &amp;=&amp; \sum_j u_j \varphi_j ({\bf x}) \\ u_{h, {\bf k}}({\bf x}) &amp;=&amp; \sum_{{\bf k}, \|{\bf k}\|\le p} a_{\bf k} \phi_{\bf k}({\bf x}), \quad a_{\bf k} = \sum_j {\cal F}_{{\bf k},j} u_j \end{eqnarray*}
</p>
<p> with \(u_j\) the degrees of freedom and \(\varphi_j\) the corresponding shape functions. \(\{\phi_{\bf k}({\bf x}) = \exp(i \, 2 \pi \, {\bf k} \cdot {\bf x}) \}\) are exponential functions on cell \(K\). \(a_{\bf k}\) and \({\cal F}_{{\bf k},j}\) are coefficients and transformation matrices from the <a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html">Fourier</a> expansion of each shape function. For practical reasons, we will perform the calculation of these matrices and coefficients only on the reference cell \(\hat K\). We only have to calculate the transformation matrices once this way. However, results are only applicable if mapping from the reference cell to the actual cell is linear. We use the class <a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a> to determine all coefficients \(a_{\bf k}\).</p>
<p>If the finite element approximation on cell \(K\) is part of the Hilbert space \(H^s(K)\), then the following integral must exist for both the finite element and spectral representation of our solution </p><p class="formulaDsp">
\begin{eqnarray*} \| \nabla^s u_h({\bf x}) \|_{L^2(K)}^2 &amp;=&amp; \int\limits_K \left| \nabla^s u_h({\bf x}) \right|^2 d{\bf x} &lt; \infty \\ \| \nabla^s u_{h, {\bf k}}({\bf x}) \|_{L^2(K)}^2 &amp;=&amp; \int\limits_K \left| \sum\limits_{\bf k} (-i \, 2 \pi {\bf k})^s \, a_{\bf k} \, \phi_{\bf k}({\bf x}) \right|^2 d{\bf x} = (2 \pi)^{2s} \sum\limits_{\bf k} \left| a_{\bf k} \right|^2 \|{\bf k}\|_2^{2s} &lt; \infty \end{eqnarray*}
</p>
<p> The sum is finite only if the summands decay at least with order </p><p class="formulaDsp">
\[ |a_{\bf k}|^2 \|{\bf k}\|_2^{2s} \|{\bf k}\|_2^{d - 1} = {\cal O}\left( \|{\bf k}\|_2^{-1-\epsilon} \right) \]
</p>
<p> for all \(\epsilon &gt; 0\). The additional factor stems from the fact that, since we sum over all multi-indices \({\bf k}\) that are located on a dim-dimensional sphere, we actually have, up to a constant, \(\|{\bf k}\|_2^{d-1}\) modes located in each increment \(\|{\bf k}\|_2 + d\|{\bf k}\|_2\) that need to be taken into account. By a comparison of exponents, we can rewrite this condition as </p><p class="formulaDsp">
\[ |a_{\bf k}| = {\cal O}\left(\|{\bf k}\|_2^ {-\left(s + \frac d2 + \epsilon \right)} \right) \]
</p>
<p>The next step is to estimate how fast these coefficients decay with \(\|{\bf k}\|_2\). Thus, we perform a least-squares fit </p><p class="formulaDsp">
\[ \min_{\alpha,\sigma} \frac 12 \sum_{{\bf k}, \|{\bf k}\|_2 \le p} \left( |a_{\bf k}| - \alpha \|{\bf k}\|_2^{-\sigma}\right)^2 \]
</p>
<p> with regression coefficients \(\alpha\) and \(\sigma\). For simplification, we apply a logarithm on our minimization problem </p><p class="formulaDsp">
\[ \min_{\beta,\sigma} Q(\beta,\sigma) = \frac 12 \sum_{{\bf k}, \|{\bf k}\|_2 \le p} \left( \ln |a_{\bf k}| - \beta + \sigma \ln \|{\bf k}\|_2 \right)^2, \]
</p>
<p> where \(\beta=\ln \alpha\). This is now a problem for which the optimality conditions \(\frac{\partial Q}{\partial\beta}=0, \frac{\partial Q}{\partial\sigma}=0\), are linear in \(\beta,\sigma\). We can write these conditions as follows: </p><p class="formulaDsp">
\[ \left(\begin{array}{cc} \sum_{{\bf k}, \|{\bf k}\|_2 \le p} 1 &amp; \sum_{{\bf k}, \|{\bf k}\|_2 \le p} \ln \|{\bf k}\|_2 \\ \sum_{{\bf k}, \|{\bf k}\|_2 \le p} \ln \|{\bf k}\|_2 &amp; \sum_{{\bf k}, \|{\bf k}\|_2 \le p} (\ln \|{\bf k}\|_2)^2 \end{array}\right) \left(\begin{array}{c} \beta \\ -\sigma \end{array}\right) = \left(\begin{array}{c} \sum_{{\bf k}, \|{\bf k}\|_2\le p} \ln |a_{{\bf k}}| \\ \sum_{{\bf k}, \|{\bf k}\|_2\le p} \ln |a_{{\bf k}}| \ln \|{\bf k}\|_2 \end{array}\right) \]
</p>
<p> Solving for \(\beta\) and \(\sigma\) is just a linear regression fit and to do that we will use <a class="el" href="namespaceFESeries.html#acc4a5771ddd346ce2c47736ba1e47548">FESeries::linear_regression()</a>.</p>
<p>While we are not particularly interested in the actual value of \(\beta\), the formula above gives us a means to calculate the value of the exponent \(\sigma\) that we can then use to determine that \(u(\hat{\bf x})\) is in \(H^s(K)\) with \(s=\sigma-\frac d2\). The decay rates \(\sigma\) will suffice as our smoothness indicators and will be calculated on each cell for any provided solution.</p>
<dl class="section note"><dt>Note</dt><dd>An extensive demonstration of the use of these functions is provided in step-27. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aae63069820e030e1f012e3e84d28e6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae63069820e030e1f012e3e84d28e6f8">&#9670;&nbsp;</a></span>coefficient_decay()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SmoothnessEstimator::Fourier::coefficient_decay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_fourier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>smoothness_indicators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a>&#160;</td>
          <td class="paramname"><em>regression_strategy</em> = <code><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>smallest_abs_coefficient</em> = <code>1e-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_flagged_cells</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In this variant of the estimation strategy for higher dimensions, we will consider all mode vectors \(\bf k\) describing <a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html">Fourier</a> polynomials \(P_{\bf k}\) and perform one least-squares fit over all coefficients at once. If there are multiple coefficients corresponding to the same absolute value of modes \(\|\bf k\|_2\), we take the maximum among those. Thus, the least-squares fit is performed on </p><p class="formulaDsp">
\[ \ln \left( \max\limits_{\|{\bf k}\|_2} |a_{\bf k}| \right) \sim C - \sigma \ln \|{\bf k}\|_2 \]
</p>
<p> for \({\bf k}=(k_1,\ldots,k_d)\) and \(k_i=0,\ldots,p\), with \(p\) the polynomial degree of the finite element. We exclude the \(\|{\bf k}\|_2=0\) modes to avoid the singularity of the logarithm.</p>
<p>The <code>regression_strategy</code> parameter determines which norm will be used on the subset of coefficients \(\bf k\) with the same absolute value \(\|{\bf k}\|_2\). Default is <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a> for a maximum approximation.</p>
<p>For a provided solution vector <code>solution</code> defined on a <a class="el" href="classDoFHandler.html">DoFHandler</a> <code>dof_handler</code>, this function returns a vector <code>smoothness_indicators</code> with as many elements as there are cells where each element contains the estimated regularity \(\sigma\).</p>
<p>A series expansion object <code>fe_fourier</code> has to be supplied, which needs to be constructed with the same FECollection object as the <code>dof_handler</code>.</p>
<p>The parameter <code>smallest_abs_coefficient</code> allows to ignore small (in absolute value) coefficients within the linear regression fit. In case there are less than two nonzero coefficients for a coordinate direction, this direction will be skipped. If all coefficients are zero, the returned value for this cell will be \(\sigma=\infty\).</p>
<p>Smoothness indicators are usually used to decide whether to perform h- or p-adaptation. So in most cases, we only need to calculate those indicators on cells flagged for refinement or coarsening. The parameter <code>only_flagged_cells</code> controls whether this particular subset or all cells will be considered. By default, all cells will be considered. When only flagged cells are supposed to be considered, smoothness indicators will only be set on those vector entries of flagged cells; the others will be set to a signaling NaN. </p>

</div>
</div>
<a id="a6d8ab53058217f739eec4280e5f52e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8ab53058217f739eec4280e5f52e96">&#9670;&nbsp;</a></span>coefficient_decay_per_direction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SmoothnessEstimator::Fourier::coefficient_decay_per_direction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_fourier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>smoothness_indicators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>coefficients_predicate</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>smallest_abs_coefficient</em> = <code>1e-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_flagged_cells</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In this variant of the estimation strategy for higher dimensions, we only consider modes in each coordinate direction, i.e., only mode vectors \(\bf k\) with one nonzero entry. We perform the least-squares fit in each coordinate direction separately and take the lowest decay rate \(\sigma\) among them.</p>
<p>The <code>coefficients_predicate</code> parameter selects <a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html">Fourier</a> coefficients \(a_j\), \(j=0,\ldots,p\) for linear regression in each coordinate direction. The user is responsible for updating the vector of <code>flags</code> provided to this function. Note that its size is \(p+1\), where \(p\) is the polynomial degree of the FE basis on a given element. The default implementation will use all <a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html">Fourier</a> coefficients in each coordinate direction, i.e., set all the elements of the vector to <code>true</code>.</p>
<p>For a provided solution vector <code>solution</code> defined on a <a class="el" href="classDoFHandler.html">DoFHandler</a> <code>dof_handler</code>, this function returns a vector <code>smoothness_indicators</code> with as many elements as there are cells where each element contains the estimated regularity \(\sigma\).</p>
<p>A series expansion object <code>fe_fourier</code> has to be supplied, which needs to be constructed with the same FECollection object as the <code>dof_handler</code>.</p>
<p>The parameter <code>smallest_abs_coefficient</code> allows to ignore small (in absolute value) coefficients within the linear regression fit. In case there are fewer than two nonzero coefficients for a coordinate direction, this direction will be skipped. If all coefficients are zero, the returned value for this cell will be \(\sigma=\infty\).</p>
<p>Smoothness indicators are usually used to decide whether to perform h- or p-adaptation. So in most cases, we only need to calculate those indicators on cells flagged for refinement or coarsening. The parameter <code>only_flagged_cells</code> controls whether this particular subset or all cells will be considered. By default, all cells will be considered. When only flagged cells are supposed to be considered, smoothness indicators will only be set on those vector entries of flagged cells; the others will be set to a signaling NaN. </p>

</div>
</div>
<a id="a6c3fa210d75a81b147179f6ac5bfac04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3fa210d75a81b147179f6ac5bfac04">&#9670;&nbsp;</a></span>default_fe_series()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a>&lt;dim, spacedim&gt; SmoothnessEstimator::Fourier::default_fe_series </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classFESeries_1_1Fourier.html">FESeries::Fourier</a> object for <a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html">Fourier</a> series expansions with the default configuration for smoothness estimation purposes.</p>
<p>For each finite element of the provided <code>fe_collection</code>, we use as many modes as its polynomial degree plus two. Further for each element, we use a 5-point Gaussian quarature iterated in each dimension by the maximal wave number, which is the number of modes decreased by one since we start with \(k = 0\).</p>
<p>As the <a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html">Fourier</a> expansion can only be performed on scalar fields, this class does not operate on vector-valued finite elements and will therefore throw an assertion. However, each component of a finite element field can be treated as a scalar field, respectively, on which <a class="el" href="namespaceSmoothnessEstimator_1_1Fourier.html">Fourier</a> expansions are again possible. For this purpose, the optional parameter <code>component</code> defines which component of each <a class="el" href="classFiniteElement.html">FiniteElement</a> will be used. The default value of <code>component</code> only applies to scalar FEs, in which case it indicates that the sole component is to be decomposed. For vector-valued FEs, a non-default value must be explicitly provided. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
