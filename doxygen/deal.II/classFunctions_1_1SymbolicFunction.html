<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFunctions_1_1SymbolicFunction.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Functions::SymbolicFunction&lt; dim, RangeNumberType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceFunctions.html">Functions</a></li><li class="navelem"><a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFunctions_1_1SymbolicFunction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Functions::SymbolicFunction&lt; dim, RangeNumberType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="symbolic__function_8h_source.html">deal.II/base/symbolic_function.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Functions::SymbolicFunction&lt; dim, RangeNumberType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFunctions_1_1SymbolicFunction__inherit__graph.svg" width="370" height="367"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a385ed76410d75f5f15304ccebaac220d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a> = typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; RangeNumberType &gt;::real_type &gt;::<a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a></td></tr>
<tr class="separator:a385ed76410d75f5f15304ccebaac220d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a17c9b367699488976bff775edf760299"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a17c9b367699488976bff775edf760299">SymbolicFunction</a> (const std::vector&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#ae26cd26bdfb22f8e38e368f3f0715150">function</a>, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#af08c417cc53a4c20c7ef4d79dbd77f52">coordinate_symbols</a>=<a class="el" href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">get_default_coordinate_symbols</a>(), const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#abc3f87cbc1405dd3604863b365bfb1cc">time_symbol</a>=<a class="el" href="namespaceDifferentiation_1_1SD.html#af71e229940cc126030592c5195289113">Differentiation::SD::make_symbol</a>(&quot;t&quot;), const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> &amp;<a class="el" href="classFunctions_1_1SymbolicFunction.html#a648084b629c8192e4c2c0fcee7ca5fd7">user_substitution_map</a>={})</td></tr>
<tr class="separator:a17c9b367699488976bff775edf760299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d679291388c3f241a44018b66367f01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a4d679291388c3f241a44018b66367f01">SymbolicFunction</a> (const std::string &amp;expressions)</td></tr>
<tr class="separator:a4d679291388c3f241a44018b66367f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ed0e06b9e5da65ab6ce09bd27473d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a98ed0e06b9e5da65ab6ce09bd27473d7">update_user_substitution_map</a> (const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> &amp;substitutions)</td></tr>
<tr class="separator:a98ed0e06b9e5da65ab6ce09bd27473d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad742d6b3841d324f6d092ff2b62c41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a7ad742d6b3841d324f6d092ff2b62c41">set_additional_function_arguments</a> (const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> &amp;arguments)</td></tr>
<tr class="separator:a7ad742d6b3841d324f6d092ff2b62c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832f7270359aff87df84713a51ca3c82"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a832f7270359aff87df84713a51ca3c82">get_coordinate_symbols</a> () const</td></tr>
<tr class="separator:a832f7270359aff87df84713a51ca3c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dacfbccafff4a1a3b8995c11c17a659"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a3dacfbccafff4a1a3b8995c11c17a659">get_time_symbol</a> () const</td></tr>
<tr class="separator:a3dacfbccafff4a1a3b8995c11c17a659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b60982e08ae821b8036bc8ddf6fdee"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a25b60982e08ae821b8036bc8ddf6fdee">get_symbolic_function_expressions</a> () const</td></tr>
<tr class="separator:a25b60982e08ae821b8036bc8ddf6fdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836518865a1d95bf9d544dd436b4f8b1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a836518865a1d95bf9d544dd436b4f8b1">get_user_substitution_map</a> () const</td></tr>
<tr class="separator:a836518865a1d95bf9d544dd436b4f8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d90574552874e70a063ad089874d9ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a>&lt; dim, RangeNumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a> () const</td></tr>
<tr class="separator:a4d90574552874e70a063ad089874d9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c14db38b7164318a2be05f3d52b736"><td class="memItemLeft" align="right" valign="top">virtual RangeNumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#ac8c14db38b7164318a2be05f3d52b736">value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const override</td></tr>
<tr class="separator:ac8c14db38b7164318a2be05f3d52b736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18793ed91ba97a1ecf8dfb5ef82a8e25"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, RangeNumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a18793ed91ba97a1ecf8dfb5ef82a8e25">gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const override</td></tr>
<tr class="separator:a18793ed91ba97a1ecf8dfb5ef82a8e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6de7f3694cda9d0baf759db0b1a9f8"><td class="memItemLeft" align="right" valign="top">virtual RangeNumberType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a3c6de7f3694cda9d0baf759db0b1a9f8">laplacian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const override</td></tr>
<tr class="separator:a3c6de7f3694cda9d0baf759db0b1a9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99c28ed9485acf9222de2d79b738cd0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, RangeNumberType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#aa99c28ed9485acf9222de2d79b738cd0">hessian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const override</td></tr>
<tr class="separator:aa99c28ed9485acf9222de2d79b738cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028d1523aac8e490301d025be11f4777"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:a028d1523aac8e490301d025be11f4777"><td class="memTemplItemLeft" align="right" valign="top">StreamType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a028d1523aac8e490301d025be11f4777">print</a> (StreamType &amp;out) const</td></tr>
<tr class="separator:a028d1523aac8e490301d025be11f4777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae316ebc05d21989d573024f8a23c49cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt; &amp;values) const</td></tr>
<tr class="separator:ae316ebc05d21989d573024f8a23c49cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562fc1114e95e702e6696721f71528db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; RangeNumberType &gt; &amp;values, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:a562fc1114e95e702e6696721f71528db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa041dde994d40c068e00661197ac75a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#aa041dde994d40c068e00661197ac75a6">vector_value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:aa041dde994d40c068e00661197ac75a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b4f548be005a1ffeeca7a450b028d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ad1b4f548be005a1ffeeca7a450b028d8">vector_values</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; std::vector&lt; RangeNumberType &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:ad1b4f548be005a1ffeeca7a450b028d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4509a9d71dc1a1ca05cb6205161dc60"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#af4509a9d71dc1a1ca05cb6205161dc60">vector_gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, RangeNumberType &gt;&gt; &amp;gradients) const</td></tr>
<tr class="separator:af4509a9d71dc1a1ca05cb6205161dc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf557f137782b46e85461235d5bd47d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#afcf557f137782b46e85461235d5bd47d">gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, RangeNumberType &gt;&gt; &amp;gradients, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:afcf557f137782b46e85461235d5bd47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddbeb5adda74140a00dfc8db3687b4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a4ddbeb5adda74140a00dfc8db3687b4a">vector_gradients</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, RangeNumberType &gt;&gt;&gt; &amp;gradients) const</td></tr>
<tr class="separator:a4ddbeb5adda74140a00dfc8db3687b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109f7bff0fb455c042086f98bd003ede"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a109f7bff0fb455c042086f98bd003ede">vector_gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, RangeNumberType &gt;&gt;&gt; &amp;gradients) const</td></tr>
<tr class="separator:a109f7bff0fb455c042086f98bd003ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33430fb1069660fb8cfe599181aceefa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a33430fb1069660fb8cfe599181aceefa">vector_laplacian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt; &amp;values) const</td></tr>
<tr class="separator:a33430fb1069660fb8cfe599181aceefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae80353c3a581fa918ea555c3e1c7353"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#aae80353c3a581fa918ea555c3e1c7353">laplacian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; RangeNumberType &gt; &amp;values, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:aae80353c3a581fa918ea555c3e1c7353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6582ff5ce8fddc37866077976df598f9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a6582ff5ce8fddc37866077976df598f9">vector_laplacian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:a6582ff5ce8fddc37866077976df598f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94960fba14557566fa5df8745a721939"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a94960fba14557566fa5df8745a721939">vector_hessian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, RangeNumberType &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:a94960fba14557566fa5df8745a721939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e69625d9daf07615270d65d97dfebde"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a2e69625d9daf07615270d65d97dfebde">hessian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, RangeNumberType &gt;&gt; &amp;values, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:a2e69625d9daf07615270d65d97dfebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1b732264fb498528453312e24d2f49"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#abc1b732264fb498528453312e24d2f49">vector_hessian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, RangeNumberType &gt;&gt;&gt; &amp;values) const</td></tr>
<tr class="separator:abc1b732264fb498528453312e24d2f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e07b63ee34bd7e7ab2492be5213377"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a45e07b63ee34bd7e7ab2492be5213377">memory_consumption</a> () const</td></tr>
<tr class="separator:a45e07b63ee34bd7e7ab2492be5213377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; RangeNumberType &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a> () const</td></tr>
<tr class="separator:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a> (const <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; RangeNumberType &gt;::real_type new_time)</td></tr>
<tr class="separator:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb592482f587dc3f0ee6e2267215a772"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#aeb592482f587dc3f0ee6e2267215a772">advance_time</a> (const <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; RangeNumberType &gt;::real_type delta_t)</td></tr>
<tr class="separator:aeb592482f587dc3f0ee6e2267215a772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2718abd675ea2999ce0687c8cf871d2e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">get_default_coordinate_symbols</a> ()</td></tr>
<tr class="separator:a2718abd675ea2999ce0687c8cf871d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7248c7e11dc434fb7d16cdc5e41e3770"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a></td></tr>
<tr class="separator:a7248c7e11dc434fb7d16cdc5e41e3770"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ad8063ed9dcbe58753504d9173475befe"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ad8063ed9dcbe58753504d9173475befe">dimension</a> = dim</td></tr>
<tr class="separator:ad8063ed9dcbe58753504d9173475befe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae55e876e8b12f682ac61c2813e11b512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#ae55e876e8b12f682ac61c2813e11b512">create_evaluation_substitution_map</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;point) const</td></tr>
<tr class="separator:ae55e876e8b12f682ac61c2813e11b512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250d31b290d25c474d8f6f5fee15d15f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a250d31b290d25c474d8f6f5fee15d15f">update_values</a> () const</td></tr>
<tr class="separator:a250d31b290d25c474d8f6f5fee15d15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48156a0255a46c28018453a45456bd3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a48156a0255a46c28018453a45456bd3f">update_first_derivatives</a> () const</td></tr>
<tr class="separator:a48156a0255a46c28018453a45456bd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd97b22b242e8a5943822f3699143bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#afcd97b22b242e8a5943822f3699143bd">update_second_derivatives</a> () const</td></tr>
<tr class="separator:afcd97b22b242e8a5943822f3699143bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a330683425138c4dd77655cf8e8fe86f2"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a330683425138c4dd77655cf8e8fe86f2">user_function</a></td></tr>
<tr class="separator:a330683425138c4dd77655cf8e8fe86f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648084b629c8192e4c2c0fcee7ca5fd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a648084b629c8192e4c2c0fcee7ca5fd7">user_substitution_map</a></td></tr>
<tr class="separator:a648084b629c8192e4c2c0fcee7ca5fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b2e0ff9e3bf0062a5eb0167c8c46ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a94b2e0ff9e3bf0062a5eb0167c8c46ac">additional_function_arguments</a></td></tr>
<tr class="separator:a94b2e0ff9e3bf0062a5eb0167c8c46ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26cd26bdfb22f8e38e368f3f0715150"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#ae26cd26bdfb22f8e38e368f3f0715150">function</a></td></tr>
<tr class="separator:ae26cd26bdfb22f8e38e368f3f0715150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2e86b7cc7248e73866cfb8d6a0903b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a8b2e86b7cc7248e73866cfb8d6a0903b">function_gradient</a></td></tr>
<tr class="separator:a8b2e86b7cc7248e73866cfb8d6a0903b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1984b346d79b7dbf3584f46e822fccf2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a1984b346d79b7dbf3584f46e822fccf2">function_hessian</a></td></tr>
<tr class="separator:a1984b346d79b7dbf3584f46e822fccf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19426ca9d765f6ac95a708c9efa5be0e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#a19426ca9d765f6ac95a708c9efa5be0e">function_laplacian</a></td></tr>
<tr class="separator:a19426ca9d765f6ac95a708c9efa5be0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08c417cc53a4c20c7ef4d79dbd77f52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#af08c417cc53a4c20c7ef4d79dbd77f52">coordinate_symbols</a></td></tr>
<tr class="separator:af08c417cc53a4c20c7ef4d79dbd77f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3f87cbc1405dd3604863b365bfb1cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1SymbolicFunction.html#abc3f87cbc1405dd3604863b365bfb1cc">time_symbol</a></td></tr>
<tr class="separator:abc3f87cbc1405dd3604863b365bfb1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename RangeNumberType = double&gt;<br />
class Functions::SymbolicFunction&lt; dim, RangeNumberType &gt;</h3>

<p>一个函数类，利用符号微分来计算梯度、拉普拉斯、Hessians和时间导数。 这个类可用于使用 <a class="el" href="namespaceDifferentiation_1_1SD.html">Differentiation::SD</a> 命名空间提供的方法来定义函数。特别是，可以定义一个符号化的评价点（函数的参数），以及一个符号化的表达式。 符号梯度和符号Hessians在构造时计算，当用户使用update_user_substitution_map()方法要求在符号函数中进行替换时，也会计算。 每当一个评估方法被调用时，就会尝试进行替换，用评估点替换坐标符号参数，用get_time()方法返回的当前时间替换符号时间。用户必须确保在求值时，参数替换提供了一个完全求值的表达式（即除了数值之外，函数表达式中不包含其他符号），否则将抛出一个异常。额外的符号可以通过存储在用户提供的替换图中进行部分评估或替换，该替换图可以通过调用update_user_substitution_map（）或set_additional_function_arguments（）方法进行更新。 这个类的最简单的使用情况在下面的例子中给出。 </p><div class="fragment"><div class="line">SymbolicFunction&lt;2&gt; fun(<span class="stringliteral">&quot;x^2+y; t*x*y&quot;</span>);</div><div class="line">fun.set_time(3.0);</div><div class="line"><a class="code" href="classPoint.html">Point&lt;2&gt;</a> p(1.0, 2.0);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> a = fun.value(p, / component / 0); <span class="comment">// a = 3.0</span></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a> = fun.value(p, / component / 1); <span class="comment">// b = 6.0</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> df_dt = fun.time_derivative();</div><div class="line"></div><div class="line"><span class="keyword">auto</span> c = df_dt.value(p, / component / 0); <span class="comment">// c = 0.0</span></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = df_dt.value(p, / component / 1); <span class="comment">// d = 2.0</span></div></div><!-- fragment --><p> 在这个例子中，一个有两个组件的Function是用一个字符串定义的，这个字符串包含了用分号分隔的表达式。 一个更复杂的例子，明确地使用了 <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> 对象，由以下例子给出 </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceDifferentiation_1_1SD.html">Differentiation::SD</a>;</div><div class="line"><span class="comment">// Create a position Tensor&lt;1,2,Differentiation::SD::Expression&gt;</span></div><div class="line"><span class="comment">// with symbols &quot;x&quot; and &quot;y&quot;, and the symbol &quot;t&quot;</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> x = <a class="code" href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">SymbolicFunction&lt;2&gt;::get_default_coordinate_symbols</a>();</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> t = <a class="code" href="namespaceDifferentiation_1_1SD.html#af71e229940cc126030592c5195289113">make_symbol</a>(<span class="stringliteral">&quot;t&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Use directly x[0] (the symbol &quot;x&quot;), x[1] (the symbol &quot;y&quot;), and t</span></div><div class="line"><span class="comment">// (the symbol &quot;t&quot;).</span></div><div class="line"><a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> f = <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(x[0])*<a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(x[1])*<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(t);</div><div class="line"><span class="comment">// Alternatively, you can achieve the same result parsing a string:</span></div><div class="line"><span class="comment">// Expression f(&quot;sin(x)*cos(y)*sin(t)&quot;, true);</span></div><div class="line">SymbolicFunction&lt;2&gt; <span class="keyword">function</span>({f}, x);</div><div class="line"></div><div class="line"><span class="comment">// Evaluate the function, its gradient, and its Laplacian</span></div><div class="line"><a class="code" href="classPoint.html">Point&lt;2&gt;</a> p(1.0, 2.0);</div><div class="line"><span class="keyword">auto</span> fp = <span class="keyword">function</span>.value(p);</div><div class="line"><span class="keyword">auto</span> gradfp = <span class="keyword">function</span>.gradient(p);</div><div class="line"><span class="keyword">auto</span> lapfp = <span class="keyword">function</span>.laplacian(p);</div><div class="line"></div><div class="line"><span class="comment">// Evaluate the time derivative of the function, its gradient, and its</span></div><div class="line"><span class="comment">// Laplacian</span></div><div class="line"><span class="keyword">auto</span> <a class="code" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a> = <span class="keyword">function</span>.time_derivative();</div><div class="line"><span class="keyword">auto</span> dt_fp = <a class="code" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a>.value(p);</div><div class="line"><span class="keyword">auto</span> dt_gradfp = <a class="code" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a>.gradient(p);</div><div class="line"><span class="keyword">auto</span> dt_lapfp = <a class="code" href="classFunctions_1_1SymbolicFunction.html#a4d90574552874e70a063ad089874d9ba">time_derivative</a>.laplacian(p);</div></div><!-- fragment --><p> 部分替换是可能的（也就是说，你可以使用额外的符号来定义函数）。然而，一旦你评估该函数，你必须确保所有无关的符号（即那些没有提到空间 <code>coordinate_symbols</code> 或 <code>time_symbol</code> 变量的符号）已经被数值，或空间或时间参数的表达式所替代，方法是调用update_user_substitution_map()或set_additional_function_arguments()方法。 如果你的函数需要评估额外的参数，你可以通过调用set_additional_function_arguments()方法指定它们。 如果你用相同的参数调用update_user_substitution_map()和set_additional_function_arguments()，对函数评估的影响将是相同的，然而，内部行为和函数导数将不同。update_user_substitution_map()方法执行一次替换（第一次需要替换），然后在内部存储一个结果表达式的副本，以及它的导数（如果需要）。然后在随后的所有评估中使用这些内容。调用set_additional_function_arguments()将在评估时间内，在*所有导数被计算之后，对传递的替换图进行实时评估。 </p><dl class="section note"><dt>Note</dt><dd>这个类和FunctionParser类的区别在于，这个类允许计算一阶和二阶导数（以符号的方式），而FunctionParser类只计算一阶导数，使用有限差分。对于复杂的表达式，这个类可能比FunctionParser类要慢。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="symbolic__function_8h_source.html#l00112">112</a> of file <a class="el" href="symbolic__function_8h_source.html">symbolic_function.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a385ed76410d75f5f15304ccebaac220d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385ed76410d75f5f15304ccebaac220d">&#9670;&nbsp;</a></span>time_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::<a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a> =  typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;RangeNumberType&gt;::real_type&gt;::<a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用于表示时间的标量值实数类型。 </p>

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00139">139</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a17c9b367699488976bff775edf760299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c9b367699488976bff775edf760299">&#9670;&nbsp;</a></span>SymbolicFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::<a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coordinate_symbols</em> = <code><a class="el" href="classFunctions_1_1SymbolicFunction.html#a2718abd675ea2999ce0687c8cf871d2e">get_default_coordinate_symbols</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>time_symbol</em> = <code><a class="el" href="namespaceDifferentiation_1_1SD.html#af71e229940cc126030592c5195289113">Differentiation::SD::make_symbol</a>(&quot;t&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>user_substitution_map</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。 产生的Function对象将有与符号表达式向量 <code>function</code>. 中的条目一样多的组件。向量 <code>function</code> 应包含一个涉及坐标符号参数 <code>coordinate_symbols</code> 和可能的符号时间参数 <code>time_symbol</code>. 的符号表达式的列表，可以用其他符号定义它，只要可选参数 <code>user_substitution_map</code> ] 替换除 <code>coordinate_symbols</code> 和 <code>time_symbol</code>. 以外的所有符号，这在以下情况下很有用：例如，你想用你想用符号命名的材料参数来表达公式，而不是在定义公式时通过它们的数值，或者你想用极坐标而不是笛卡尔坐标来表达你的公式，并且你希望符号引擎能为你计算导数。 你以后可以通过调用update_user_substitution_map()来更新 <code>user_substitution_map</code> 中包含的符号图。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">函数</td><td>类型为 <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>, 的符号表达式的向量，代表此Function的组成部分。 </td></tr>
    <tr><td class="paramname">coordinate_symbols</td><td>代表坐标的符号张量，作为 <code>function</code> 矢量中包含的符号表达式的输入参数。默认的 <code>coordinate_symbols</code> 是一个 <a class="el" href="classTensor.html">Tensor&lt;1,dim,Differentiation::SD::Expression&gt;</a> ，包含符号 "x
"代表<code>dim</code>等于1，"x"、"y "代表<code>dim</code>等于2，而 "x"、"y"、"z
"代表<code>dim</code>等于3。 </td></tr>
    <tr><td class="paramname">time_symbol</td><td>一个代表时间的符号变量。它默认为一个名为 "t
"的符号变量。 </td></tr>
    <tr><td class="paramname">user_substitution_map</td><td>任何可能包含在符号函数中的其他符号都需要在这个映射中指定。该地图可以是空的，函数仍然可以包含未评估的符号，只要你调用update_user_substitution_map()，并在任何评估发生之前提供除 <code>coordinate_symbols</code> 和 <code>time_symbol</code> 外的所有符号的替换。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d679291388c3f241a44018b66367f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d679291388c3f241a44018b66367f01">&#9670;&nbsp;</a></span>SymbolicFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::<a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expressions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数，接收一个描述函数表达式的单一字符串，作为一个分号分隔的表达式列表。 符号表达式可以使用默认的参数和默认的符号时间变量，再加上你可能需要的任何额外的符号，只要你在尝试评估函数或其导数之前，通过调用update_user_substitution_map()更新替换所有符号的用户替换图，并且使用set_additional_function_arguments()方法提供你函数的所有额外函数参数。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a98ed0e06b9e5da65ab6ce09bd27473d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ed0e06b9e5da65ab6ce09bd27473d7">&#9670;&nbsp;</a></span>update_user_substitution_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::update_user_substitution_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitutions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>存储并应用替换映射 <code>substitutions</code> 到这个Function对象的每个符号组件。 注意，这个方法将触发对每个分量的梯度、Hessians和Laplacians的重新计算。 </p>

</div>
</div>
<a id="a7ad742d6b3841d324f6d092ff2b62c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad742d6b3841d324f6d092ff2b62c41">&#9670;&nbsp;</a></span>set_additional_function_arguments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::set_additional_function_arguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置额外的 <code>arguments</code> ，在下一个评估步骤中被替换。 注意， <code>arguments</code> 是在*评估 <code>permanent_user_substitution_map</code>, 和计算完所有导数之后被替换的。如果你传递的额外参数仍然依赖于坐标或时间符号，那么导数的评估将导致部分导数评估。 这种方法提供了一种方法来评估依赖于更多参数而不仅仅是坐标和时间的函数。如果你想对复杂的符号表达式计算总导数，你应该调用update_user_substitution_map()代替。 </p>

</div>
</div>
<a id="a2718abd675ea2999ce0687c8cf871d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2718abd675ea2999ce0687c8cf871d2e">&#9670;&nbsp;</a></span>get_default_coordinate_symbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::get_default_coordinate_symbols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个坐标符号的张量，可以用来定义这个符号函数对象的表达式。 默认参数是一个 <a class="el" href="classTensor.html">Tensor&lt;1,dim,Differentiation::SD::Expression&gt;</a> ，包含符号 "x "代表<code>dim</code>等于1，"x"，"y
"代表<code>dim</code>等于2，"x"，"y"，"z "代表<code>dim</code>等于3。 </p>

</div>
</div>
<a id="a832f7270359aff87df84713a51ca3c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832f7270359aff87df84713a51ca3c82">&#9670;&nbsp;</a></span>get_coordinate_symbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt;&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::get_coordinate_symbols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取符号函数中用于坐标的实际参数。这个对象不包括任何用户定义的参数。 </p>

</div>
</div>
<a id="a3dacfbccafff4a1a3b8995c11c17a659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dacfbccafff4a1a3b8995c11c17a659">&#9670;&nbsp;</a></span>get_time_symbol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::get_time_symbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取该符号函数中实际使用的符号时间。 </p>

</div>
</div>
<a id="a25b60982e08ae821b8036bc8ddf6fdee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b60982e08ae821b8036bc8ddf6fdee">&#9670;&nbsp;</a></span>get_symbolic_function_expressions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt;&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::get_symbolic_function_expressions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取该符号化函数中实际使用的符号化表达式。 </p>

</div>
</div>
<a id="a836518865a1d95bf9d544dd436b4f8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836518865a1d95bf9d544dd436b4f8b1">&#9670;&nbsp;</a></span>get_user_substitution_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a>&amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::get_user_substitution_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取当前存储的 <code>user_substitution_map</code>. 。 </p>

</div>
</div>
<a id="a4d90574552874e70a063ad089874d9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d90574552874e70a063ad089874d9ba">&#9670;&nbsp;</a></span>time_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1SymbolicFunction.html">SymbolicFunction</a>&lt;dim, RangeNumberType&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::time_derivative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个SymbolicFunction对象，表示这个函数的时间导数。空间参数、符号时间和当前存储的用户替换图被转发给新函数。 </p>

</div>
</div>
<a id="ac8c14db38b7164318a2be05f3d52b736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c14db38b7164318a2be05f3d52b736">&#9670;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual RangeNumberType <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回函数在给定点的值。除非只有一个分量（即函数是标量的），否则你应该说明你想要评估的分量；它默认为零，即第一个分量。 </p>

<p>Reimplemented from <a class="el" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function&lt; dim, RangeNumberType &gt;</a>.</p>

</div>
</div>
<a id="a18793ed91ba97a1ecf8dfb5ef82a8e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18793ed91ba97a1ecf8dfb5ef82a8e25">&#9670;&nbsp;</a></span>gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim, RangeNumberType&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回函数的指定分量在给定点的梯度。 </p>

<p>Reimplemented from <a class="el" href="classFunction.html#a4b0aadc89a827b39c20f12889aa88625">Function&lt; dim, RangeNumberType &gt;</a>.</p>

</div>
</div>
<a id="a3c6de7f3694cda9d0baf759db0b1a9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6de7f3694cda9d0baf759db0b1a9f8">&#9670;&nbsp;</a></span>laplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual RangeNumberType <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::laplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算给定分量在点<code>p</code>的拉普拉斯。 </p>

<p>Reimplemented from <a class="el" href="classFunction.html#a763c928e78dc33bbe50873128f06e153">Function&lt; dim, RangeNumberType &gt;</a>.</p>

</div>
</div>
<a id="aa99c28ed9485acf9222de2d79b738cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99c28ed9485acf9222de2d79b738cd0">&#9670;&nbsp;</a></span>hessian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim, RangeNumberType&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::hessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算一个给定分量在点<code>p</code>的Hessian，也就是函数的梯度。 </p>

<p>Reimplemented from <a class="el" href="classFunction.html#a8aa2ec8f2270bdee842413805c4d7442">Function&lt; dim, RangeNumberType &gt;</a>.</p>

</div>
</div>
<a id="a028d1523aac8e490301d025be11f4777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028d1523aac8e490301d025be11f4777">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType &gt; </div>
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">StreamType &amp; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::print </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印存储的参数和函数表达式，因为它将在调用方法value()时被评估。 </p>

<p class="definition">Definition at line <a class="el" href="symbolic__function_8h_source.html#l00369">369</a> of file <a class="el" href="symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="ae55e876e8b12f682ac61c2813e11b512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55e876e8b12f682ac61c2813e11b512">&#9670;&nbsp;</a></span>create_evaluation_substitution_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::create_evaluation_substitution_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个替换图，用 <code>point</code>, 的值替换参数，用this-&gt;<a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time()</a>的值替换符号时间，用 <code>additional_function_arguments</code>. 给出的替换图替换任何其他参数。 </p>

</div>
</div>
<a id="a250d31b290d25c474d8f6f5fee15d15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250d31b290d25c474d8f6f5fee15d15f">&#9670;&nbsp;</a></span>update_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::update_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>重新计算函数的符号值，应用用户的置换图。这可能是一个昂贵的计算，只有在必要时才会调用。 </p>

</div>
</div>
<a id="a48156a0255a46c28018453a45456bd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48156a0255a46c28018453a45456bd3f">&#9670;&nbsp;</a></span>update_first_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::update_first_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>重新计算函数的符号梯度，应用用户置换图。这可能是一个昂贵的计算，只有在必要时才会调用。 </p>

</div>
</div>
<a id="afcd97b22b242e8a5943822f3699143bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd97b22b242e8a5943822f3699143bd">&#9670;&nbsp;</a></span>update_second_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::update_second_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>重新计算函数的符号Hessian和符号Lapalacian。这可能是一个昂贵的计算，只有在必要时才会调用。 </p>

</div>
</div>
<a id="ae316ebc05d21989d573024f8a23c49cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae316ebc05d21989d573024f8a23c49cb">&#9670;&nbsp;</a></span>vector_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::vector_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个向量值函数在某一点的所有分量。 <code>values</code>应事先有正确的大小，即::n_components。 默认实现将为每个分量调用value()。 </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1Monomial.html#a9ec4b9171f0ca2e7366baa9e80f92630">Functions::Monomial&lt; dim, Number &gt;</a>, <a class="el" href="classVectorFunctionFromTensorFunction.html#afb2de9ebbafe45be1de5992f302e50f1">VectorFunctionFromTensorFunction&lt; dim, RangeNumberType &gt;</a>, <a class="el" href="classVectorFunctionFromScalarFunctionObject.html#a790cd173e6b7789ac289b1c5be2e5d99">VectorFunctionFromScalarFunctionObject&lt; dim, RangeNumberType &gt;</a>, <a class="el" href="classComponentSelectFunction.html#a6ae83dd3b85460231dc459103fac5e5a">ComponentSelectFunction&lt; dim, RangeNumberType &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#afeebffa19937e055a7772cf66136a8ca">Functions::ConstantFunction&lt; dim, RangeNumberType &gt;</a>, <a class="el" href="classFunctionParser.html#ac56c50f2d585a27c3a26f2c0d3082263">FunctionParser&lt; dim &gt;</a>, <a class="el" href="classFunctionParser.html#ac56c50f2d585a27c3a26f2c0d3082263">FunctionParser&lt; spacedim &gt;</a>, <a class="el" href="classFunctions_1_1CosineGradFunction.html#ab85e24de3c8adceb7473915d1839ca81">Functions::CosineGradFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ParsedFunction.html#a05574ac64259ada6ab139cdb75d1319e">Functions::ParsedFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FEFieldFunction.html#a3c499a84c22d4aaedb7a5920044861c2">Functions::FEFieldFunction&lt; dim, VectorType, spacedim &gt;</a>, <a class="el" href="classFunctions_1_1IncrementalFunction.html#a76bfd5608612b1d58598b18f7df9447b">Functions::IncrementalFunction&lt; dim, RangeNumberType &gt;</a>, <a class="el" href="classFunctions_1_1FlowFunction.html#adb115c74fb3cb2da8eb0c0760c1e4106">Functions::FlowFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FlowFunction.html#adb115c74fb3cb2da8eb0c0760c1e4106">Functions::FlowFunction&lt; 2 &gt;</a>, <a class="el" href="classFunctionDerivative.html#a4e1099e1b553b1cf3eb6c33bb37b39f9">FunctionDerivative&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1SquareFunction.html#a7ce667ae7e88ffe623225f6f0a5943d8">Functions::SquareFunction&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a562fc1114e95e702e6696721f71528db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562fc1114e95e702e6696721f71528db">&#9670;&nbsp;</a></span>value_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将<code>values</code>设置为函数中指定分量在<code>points</code>的点值。 假设<code>values</code>已经有合适的大小，即与<code>points</code>数组的大小相同。 默认情况下，这个函数为每个点分别重复调用value()，以填充输出数组。 </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1Polynomial.html#a5b5151e5d4af43db47f22508e3e9e2da">Functions::Polynomial&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1Monomial.html#a44ced6e60f2805bfc738a175a17c5ab6">Functions::Monomial&lt; dim, Number &gt;</a>, <a class="el" href="classFunctions_1_1CutOffFunctionCinfty.html#a1f732d99ec3104f62c9f6558fc95e2ef">Functions::CutOffFunctionCinfty&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CutOffFunctionC1.html#a651a2e1ac8f701f11f5aff73c3e4d1b7">Functions::CutOffFunctionC1&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CutOffFunctionW1.html#ac6c1b619bc0cbdef7827a1463232b366">Functions::CutOffFunctionW1&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CutOffFunctionLinfty.html#a35079df32399892031b574316eed93a3">Functions::CutOffFunctionLinfty&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1JumpFunction.html#a54d253b6d583aa25aee52732f829a350">Functions::JumpFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1SlitSingularityFunction.html#a3f0ece56f98717e112cb3c4b0c96aa2d">Functions::SlitSingularityFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">Functions::ConstantFunction&lt; dim, RangeNumberType &gt;</a>, <a class="el" href="classFunctions_1_1ExpFunction.html#a66005ee23a0660a5e54aca0bd694a53b">Functions::ExpFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CosineGradFunction.html#a7d60c31d44bd65265c16edff1d17f1b8">Functions::CosineGradFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CosineFunction.html#ab65c3110ef06c891d440763dc214ae24">Functions::CosineFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FEFieldFunction.html#a00d364da356395defd1b86dc9337a4cc">Functions::FEFieldFunction&lt; dim, VectorType, spacedim &gt;</a>, <a class="el" href="classFunctions_1_1PillowFunction.html#a39f76bfa5a4ed3148506b78915fb5f9c">Functions::PillowFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1Q1WedgeFunction.html#a94605a72f91c3c4725b759bb605ee90e">Functions::Q1WedgeFunction&lt; dim &gt;</a>, <a class="el" href="classFunctionDerivative.html#a07ff98bb6ebea318330b0cb9dc1b2e27">FunctionDerivative&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1SquareFunction.html#a0c70138bad558fc220c39ae9d37adca5">Functions::SquareFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1Bessel1.html#af0a254ac1d1ef48463b7a84b618555b4">Functions::Bessel1&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="aa041dde994d40c068e00661197ac75a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa041dde994d40c068e00661197ac75a6">&#9670;&nbsp;</a></span>vector_value_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::vector_value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将<code>values</code>设为函数在<code>points</code>的点值。 假设<code>values</code>已经有了合适的大小，即与<code>points</code>数组的大小相同，并且所有元素都是与本函数的分量相同的向量。 默认情况下，这个函数对每个点单独重复调用vector_value()，以填充输出数组。 </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1CutOffFunctionCinfty.html#a1dda79292756d0c7f09a6e83b0863110">Functions::CutOffFunctionCinfty&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CutOffFunctionC1.html#a61af4a99b469378a46a997a0595161cd">Functions::CutOffFunctionC1&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CutOffFunctionW1.html#a16ed2d98f36f587761295b2b47818027">Functions::CutOffFunctionW1&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CutOffFunctionLinfty.html#a318b0becb0f5cecd192d7aa4308b8518">Functions::CutOffFunctionLinfty&lt; dim &gt;</a>, <a class="el" href="classVectorFunctionFromTensorFunction.html#a45c0cf7ab1eb829904f690bcd1ff89ce">VectorFunctionFromTensorFunction&lt; dim, RangeNumberType &gt;</a>, <a class="el" href="classComponentSelectFunction.html#a6e99ea47bb310bf252cbf3995ce75b57">ComponentSelectFunction&lt; dim, RangeNumberType &gt;</a>, <a class="el" href="classFunctions_1_1SlitSingularityFunction.html#a5655ffe8f2572ac26e3ad0be3c22f357">Functions::SlitSingularityFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a15fedbebabbe8784862aa1bc435d8aab">Functions::ConstantFunction&lt; dim, RangeNumberType &gt;</a>, <a class="el" href="classFunctions_1_1CosineGradFunction.html#aa49e52415a6782ddc4477cf1b8695e2d">Functions::CosineGradFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CosineFunction.html#a354cd862599cd88a4e620b58525b7df6">Functions::CosineFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FEFieldFunction.html#a8f5951fbc226a1388426fd5f630e239b">Functions::FEFieldFunction&lt; dim, VectorType, spacedim &gt;</a>, <a class="el" href="classFunctions_1_1Q1WedgeFunction.html#ad320f5d29637d534e9ba18846e9f94c3">Functions::Q1WedgeFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FlowFunction.html#a84bc050634158b33755dc7b81251d7db">Functions::FlowFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1FlowFunction.html#a84bc050634158b33755dc7b81251d7db">Functions::FlowFunction&lt; 2 &gt;</a>.</p>

</div>
</div>
<a id="ad1b4f548be005a1ffeeca7a450b028d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b4f548be005a1ffeeca7a450b028d8">&#9670;&nbsp;</a></span>vector_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::vector_values </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于函数的每个分量，填充一个值的向量，每个点一个。 Function中这个函数的默认实现是为每个分量调用value_list()。为了提高性能，可以在派生类中重新实现以加快性能。 </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1StokesCosine.html#a539d0baad1334331d7f183792ba34ea6">Functions::StokesCosine&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1PoisseuilleFlow.html#a3eeb878c2e1a245939d18ed9ddb660ed">Functions::PoisseuilleFlow&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FlowFunction.html#a6ba8c353d5f32375ca5e1a66d0ce891f">Functions::FlowFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1FlowFunction.html#a6ba8c353d5f32375ca5e1a66d0ce891f">Functions::FlowFunction&lt; 2 &gt;</a>.</p>

</div>
</div>
<a id="af4509a9d71dc1a1ca05cb6205161dc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4509a9d71dc1a1ca05cb6205161dc60">&#9670;&nbsp;</a></span>vector_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::vector_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回函数的所有分量在给定点的梯度。 </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a705795e95e1a40e495d4c6021a339d8a">Functions::ConstantFunction&lt; dim, RangeNumberType &gt;</a>, and <a class="el" href="classFunctions_1_1FEFieldFunction.html#a35712b8bb018b10723cc600317526787">Functions::FEFieldFunction&lt; dim, VectorType, spacedim &gt;</a>.</p>

</div>
</div>
<a id="afcf557f137782b46e85461235d5bd47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf557f137782b46e85461235d5bd47d">&#9670;&nbsp;</a></span>gradient_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将<code>gradients</code>设为函数的指定分量在<code>点的梯度</code>。 假设<code>gradients</code>已经有正确的大小，即与<code>points</code>数组的大小相同。 </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a5ffddeee08cfa33154ad3550725277db">Functions::ConstantFunction&lt; dim, RangeNumberType &gt;</a>, and <a class="el" href="classFunctions_1_1FEFieldFunction.html#ae226f81c6b7b686482b638912c82a528">Functions::FEFieldFunction&lt; dim, VectorType, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a4ddbeb5adda74140a00dfc8db3687b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddbeb5adda74140a00dfc8db3687b4a">&#9670;&nbsp;</a></span>vector_gradients()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::vector_gradients </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, RangeNumberType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于函数的每个分量，填充一个梯度值的向量，每个点一个。 Function中这个函数的默认实现是为每个分量调用value_list()。为了提高性能，可以在派生类中重新实现以加快性能。 </p>

</div>
</div>
<a id="a109f7bff0fb455c042086f98bd003ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109f7bff0fb455c042086f98bd003ede">&#9670;&nbsp;</a></span>vector_gradient_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::vector_gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, RangeNumberType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置<code>gradients</code>为函数在<code>points</code>处的梯度，适用于所有组件。假设<code>gradients</code>已经有正确的大小，即与<code>points</code>数组的大小相同。 <code>gradients</code>的外循环是在列表中的点上，内循环是在函数的不同组成部分上。 </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1ConstantFunction.html#a19b7810cbbce455aae32841f00410ecd">Functions::ConstantFunction&lt; dim, RangeNumberType &gt;</a>, and <a class="el" href="classFunctions_1_1FEFieldFunction.html#a17d75aae9b870273bac83b7d85c497d5">Functions::FEFieldFunction&lt; dim, VectorType, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a33430fb1069660fb8cfe599181aceefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33430fb1069660fb8cfe599181aceefa">&#9670;&nbsp;</a></span>vector_laplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::vector_laplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算在<code>p</code>点的所有分量的拉普拉斯，并将它们存储在<code>值</code>中。 </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1FEFieldFunction.html#aea9c62d20827c834fe01af2ec8b3a2e4">Functions::FEFieldFunction&lt; dim, VectorType, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aae80353c3a581fa918ea555c3e1c7353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae80353c3a581fa918ea555c3e1c7353">&#9670;&nbsp;</a></span>laplacian_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::laplacian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; RangeNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算在一组点上的一个分量的拉普拉斯。 </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1JumpFunction.html#a0122a909ecec19d7e375bb97297bac82">Functions::JumpFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1SlitSingularityFunction.html#ab6216f47632cbb11721c47ddc8d12a7a">Functions::SlitSingularityFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ExpFunction.html#a49b01b26ec37ef5adba5a6da5e32f37a">Functions::ExpFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FEFieldFunction.html#a907c24d32524bb506833c46f2ff57636">Functions::FEFieldFunction&lt; dim, VectorType, spacedim &gt;</a>, <a class="el" href="classFunctions_1_1CosineFunction.html#aa6bcb9008b39f85a74d18729bf754975">Functions::CosineFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1PillowFunction.html#ac3dd2dc5d1d56b69bb190ab10ffd9e9e">Functions::PillowFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1Q1WedgeFunction.html#a894f7b0d6de28ab70893a765d6b86a60">Functions::Q1WedgeFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1SquareFunction.html#a41d177957cf47eabfdda94beeff800d9">Functions::SquareFunction&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a6582ff5ce8fddc37866077976df598f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6582ff5ce8fddc37866077976df598f9">&#9670;&nbsp;</a></span>vector_laplacian_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::vector_laplacian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算一组点上的所有分量的拉普拉斯。 </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1FEFieldFunction.html#a5d162944d09780d762abb6e802b0c332">Functions::FEFieldFunction&lt; dim, VectorType, spacedim &gt;</a>, <a class="el" href="classFunctions_1_1FlowFunction.html#aea79a40ce18f8968aa52da9bdb2064c9">Functions::FlowFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1FlowFunction.html#aea79a40ce18f8968aa52da9bdb2064c9">Functions::FlowFunction&lt; 2 &gt;</a>.</p>

</div>
</div>
<a id="a94960fba14557566fa5df8745a721939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94960fba14557566fa5df8745a721939">&#9670;&nbsp;</a></span>vector_hessian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::vector_hessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算点<code>p</code>处所有分量的Hessian，并将其存储在<code>values</code>中。 </p>

</div>
</div>
<a id="a2e69625d9daf07615270d65d97dfebde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e69625d9daf07615270d65d97dfebde">&#9670;&nbsp;</a></span>hessian_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::hessian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, RangeNumberType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算在一组点上的一个分量的Hessian。 </p>

</div>
</div>
<a id="abc1b732264fb498528453312e24d2f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1b732264fb498528453312e24d2f49">&#9670;&nbsp;</a></span>vector_hessian_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::vector_hessian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, RangeNumberType &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算一组点上的所有分量的Hessians。 </p>

</div>
</div>
<a id="a45e07b63ee34bd7e7ab2492be5213377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e07b63ee34bd7e7ab2492be5213377">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个对象的内存消耗估计值，以字节为单位。 这个函数是虚拟的，可以被派生类重载。 </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1Polynomial.html#a2e1af7bafbf4f480c5cf6638ef669d8d">Functions::Polynomial&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html#aeedef0a7c09f521c5e16bbcbd4951289">Functions::InterpolatedUniformGridData&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1InterpolatedTensorProductGridData.html#a996a3f8871bc5a626b78f9933a25efe9">Functions::InterpolatedTensorProductGridData&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1JumpFunction.html#a6b2746bc10c623cdc8a13c1e6b6652eb">Functions::JumpFunction&lt; dim &gt;</a>, <a class="el" href="classComponentSelectFunction.html#a3b9e5888ca567c8503d6d73bcd179b3d">ComponentSelectFunction&lt; dim, RangeNumberType &gt;</a>, <a class="el" href="classFunctions_1_1ConstantFunction.html#a0ac3088e3ac73b2d9d3f585c06497b99">Functions::ConstantFunction&lt; dim, RangeNumberType &gt;</a>, <a class="el" href="classFunctions_1_1FlowFunction.html#ad11ae10ddf295c00ceddbf009605745a">Functions::FlowFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FlowFunction.html#ad11ae10ddf295c00ceddbf009605745a">Functions::FlowFunction&lt; 2 &gt;</a>, <a class="el" href="classFunctions_1_1CSpline.html#a1b1d3c8a4c22b615efcb4e8cc143d13e">Functions::CSpline&lt; dim &gt;</a>, <a class="el" href="classFunctionDerivative.html#a046459a557118c1bb97f457b52b056bb">FunctionDerivative&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1Spherical.html#aa8d6fac9ab77af568c3641c0392c428f">Functions::Spherical&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="ae7d37ddb04314b38cf67c6cba22923f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d37ddb04314b38cf67c6cba22923f6">&#9670;&nbsp;</a></span>get_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; RangeNumberType &gt;::real_type  <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; RangeNumberType &gt;::real_type  &gt;::get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回时间变量的值。 </p>

</div>
</div>
<a id="a3a583fd8f30db3549dbaa43b2592e2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a583fd8f30db3549dbaa43b2592e2bc">&#9670;&nbsp;</a></span>set_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; RangeNumberType &gt;::real_type  &gt;::set_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; RangeNumberType &gt;::real_type&#160;</td>
          <td class="paramname"><em>new_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置时间为<code>new_time</code>，覆盖旧值。 </p>

</div>
</div>
<a id="aeb592482f587dc3f0ee6e2267215a772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb592482f587dc3f0ee6e2267215a772">&#9670;&nbsp;</a></span>advance_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; RangeNumberType &gt;::real_type  &gt;::advance_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; RangeNumberType &gt;::real_type&#160;</td>
          <td class="paramname"><em>delta_t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将时间按给定的时间步长<code>delta_t</code>推进。 </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a330683425138c4dd77655cf8e8fe86f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330683425138c4dd77655cf8e8fe86f2">&#9670;&nbsp;</a></span>user_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::user_function</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个符号函数的组件，在发生任何子结构之前。这是不可改变的，并且在构造时生成。 在任何评估发生之前， <code>user_substitution_map</code> 被应用于这个对象，其结果被存储在内部变量函数中。 在评估过程中， <code>symbolic_coordinate</code>, 、 <code>symbolic_time</code>, 和任何剩余的符号被替换为输入评估点、当前时间和 <code>additional_function_arguments</code>. 的内容。 </p>

<p class="definition">Definition at line <a class="el" href="symbolic__function_8h_source.html#l00292">292</a> of file <a class="el" href="symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="a648084b629c8192e4c2c0fcee7ca5fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648084b629c8192e4c2c0fcee7ca5fd7">&#9670;&nbsp;</a></span>user_substitution_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::user_substitution_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储用于表达式置换的用户置换图。这可以通过调用update_user_substitution_map()来更新。请注意，该函数仍然可以有未解决的符号，只要通过调用set_additional_function_arguments()来解决这些符号。 </p>

<p class="definition">Definition at line <a class="el" href="symbolic__function_8h_source.html#l00298">298</a> of file <a class="el" href="symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="a94b2e0ff9e3bf0062a5eb0167c8c46ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b2e0ff9e3bf0062a5eb0167c8c46ac">&#9670;&nbsp;</a></span>additional_function_arguments</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::additional_function_arguments</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储一个用于额外参数替换的用户替换图。这将通过调用set_additional_function_arguments()来更新。 </p>

<p class="definition">Definition at line <a class="el" href="symbolic__function_8h_source.html#l00304">304</a> of file <a class="el" href="symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="ae26cd26bdfb22f8e38e368f3f0715150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26cd26bdfb22f8e38e368f3f0715150">&#9670;&nbsp;</a></span>function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::function</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个符号函数的实际成分。这是从应用 <code>user_substitution_map</code>. 后的 <code>user_function</code>, 中得到的。 </p>

<p class="definition">Definition at line <a class="el" href="symbolic__function_8h_source.html#l00311">311</a> of file <a class="el" href="symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="a8b2e86b7cc7248e73866cfb8d6a0903b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2e86b7cc7248e73866cfb8d6a0903b">&#9670;&nbsp;</a></span>function_gradient</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt; &gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::function_gradient</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个符号函数的每个分量的梯度。这是通过计算对象 <code>function</code>, 的符号梯度得到的，即应用 <code>user_substitution_map</code> 到 <code>user_function</code>. 之后的梯度。 </p>

<p class="definition">Definition at line <a class="el" href="symbolic__function_8h_source.html#l00320">320</a> of file <a class="el" href="symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="a1984b346d79b7dbf3584f46e822fccf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1984b346d79b7dbf3584f46e822fccf2">&#9670;&nbsp;</a></span>function_hessian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt; &gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::function_hessian</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个符号函数的每个分量的Hessians。这是通过计算对象 <code>function</code>, 的符号Hessian得到的，也就是说，在应用 <code>user_substitution_map</code> 到 <code>user_function</code>. 之后 </p>

<p class="definition">Definition at line <a class="el" href="symbolic__function_8h_source.html#l00329">329</a> of file <a class="el" href="symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="a19426ca9d765f6ac95a708c9efa5be0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19426ca9d765f6ac95a708c9efa5be0e">&#9670;&nbsp;</a></span>function_laplacian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::function_laplacian</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个符号函数的每个分量的拉普拉斯系数。这是通过计算对象 <code>function</code>, 的符号拉普拉斯，即应用 <code>user_substitution_map</code> 到 <code>user_function</code>. 之后得到的。 </p>

<p class="definition">Definition at line <a class="el" href="symbolic__function_8h_source.html#l00337">337</a> of file <a class="el" href="symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="af08c417cc53a4c20c7ef4d79dbd77f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08c417cc53a4c20c7ef4d79dbd77f52">&#9670;&nbsp;</a></span>coordinate_symbols</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>&gt; <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::coordinate_symbols</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>函数的坐标符号参数。 </p>

<p class="definition">Definition at line <a class="el" href="symbolic__function_8h_source.html#l00343">343</a> of file <a class="el" href="symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="abc3f87cbc1405dd3604863b365bfb1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3f87cbc1405dd3604863b365bfb1cc">&#9670;&nbsp;</a></span>time_symbol</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> <a class="el" href="classFunctions_1_1SymbolicFunction.html">Functions::SymbolicFunction</a>&lt; dim, RangeNumberType &gt;::time_symbol</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>该函数的符号时间参数。 </p>

<p class="definition">Definition at line <a class="el" href="symbolic__function_8h_source.html#l00349">349</a> of file <a class="el" href="symbolic__function_8h_source.html">symbolic_function.h</a>.</p>

</div>
</div>
<a id="ad8063ed9dcbe58753504d9173475befe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8063ed9dcbe58753504d9173475befe">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将模板参数的值作为一个静态成员常量导出。 有时对一些表达式模板编程很有用。 </p>

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00126">126</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>

</div>
</div>
<a id="a7248c7e11dc434fb7d16cdc5e41e3770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7248c7e11dc434fb7d16cdc5e41e3770">&#9670;&nbsp;</a></span>n_components</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename RangeNumberType = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFunction.html">Function</a>&lt; dim, RangeNumberType &gt;::n_components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矢量组件的数量。 </p>

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00132">132</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/base/<a class="el" href="symbolic__function_8h_source.html">symbolic_function.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
