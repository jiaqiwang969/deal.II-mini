<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFE__DGVector.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FE_DGVector&lt; PolynomialType, dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFE__DGVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FE_DGVector&lt; PolynomialType, dim, spacedim &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a> &raquo; <a class="el" href="group__febase.html">Base classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fe__dg__vector_8h_source.html">deal.II/fe/fe_dg_vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FE_DGVector&lt; PolynomialType, dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFE__DGVector__inherit__graph.svg" width="1499" height="199"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__DGVector_1_1InternalData.html">InternalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0cd5f34c3ab828fac31004f3b52921a1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a> { <br />
&#160;&#160;<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1afbb5ba93aed087d17dd0224e65a1bddc">unknown</a> = 0x00, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a349c581c3d0e392c33cc41d917eb038c">L2</a> = 0x01, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a0787dd9aa05e57e4e6009dd73cb1d229">Hcurl</a> = 0x02, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a11a375871bcf4978f67ff6d7435f81ee">Hdiv</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a0e986c9c300b61774d25c92ae2a9d054">H1</a> = Hcurl | Hdiv, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a916ecb570449b2ad08281d708b39bae2">H2</a> = 0x0e
<br />
 }</td></tr>
<tr class="separator:a0cd5f34c3ab828fac31004f3b52921a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1351e60ba12ff8474b93306930a99701"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__DGVector.html#a1351e60ba12ff8474b93306930a99701">FE_DGVector</a> (const unsigned <a class="el" href="classint.html">int</a> p, <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> m)</td></tr>
<tr class="separator:a1351e60ba12ff8474b93306930a99701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14525444fb5700986552bae390345880"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__DGVector.html#a14525444fb5700986552bae390345880">get_name</a> () const override</td></tr>
<tr class="separator:a14525444fb5700986552bae390345880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e25f164fd98df828a00b9e488c37cb6"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__DGVector.html#a3e25f164fd98df828a00b9e488c37cb6">clone</a> () const override</td></tr>
<tr class="separator:a3e25f164fd98df828a00b9e488c37cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9f11c1bb7778b0384867a3b1ca4d19"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__DGVector.html#a1c9f11c1bb7778b0384867a3b1ca4d19">has_support_on_face</a> (const unsigned <a class="el" href="classint.html">int</a> shape_index, const unsigned <a class="el" href="classint.html">int</a> face_index) const override</td></tr>
<tr class="separator:a1c9f11c1bb7778b0384867a3b1ca4d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdf31566f4c83b3910e5323f0a40dd9"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__DGVector.html#afcdf31566f4c83b3910e5323f0a40dd9">memory_consumption</a> () const override</td></tr>
<tr class="separator:afcdf31566f4c83b3910e5323f0a40dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0714c652edd917e41ad4f8b7912a2da0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a0714c652edd917e41ad4f8b7912a2da0">requires_update_flags</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags) const override</td></tr>
<tr class="separator:a0714c652edd917e41ad4f8b7912a2da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b08811dba57c3485426c8a4c71631d4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a9b08811dba57c3485426c8a4c71631d4">shape_value</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a9b08811dba57c3485426c8a4c71631d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607518e45ad02f9997ed5486f9c5d8fb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a607518e45ad02f9997ed5486f9c5d8fb">shape_value_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:a607518e45ad02f9997ed5486f9c5d8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cff83feff9e6d7fce635e08a8cdf49c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a7cff83feff9e6d7fce635e08a8cdf49c">shape_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a7cff83feff9e6d7fce635e08a8cdf49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafcfbb9a08f1665c5c35ff2341333e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#acafcfbb9a08f1665c5c35ff2341333e0">shape_grad_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:acafcfbb9a08f1665c5c35ff2341333e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81173894f92fc73d97ab24d428f2ee54"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a81173894f92fc73d97ab24d428f2ee54">shape_grad_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a81173894f92fc73d97ab24d428f2ee54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d39732550551c965be0c3a05a8baf95"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a0d39732550551c965be0c3a05a8baf95">shape_grad_grad_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:a0d39732550551c965be0c3a05a8baf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dec8349bbe812f6fc8a714eaae30364"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a6dec8349bbe812f6fc8a714eaae30364">operator^</a> (const unsigned <a class="el" href="classint.html">int</a> multiplicity) const</td></tr>
<tr class="separator:a6dec8349bbe812f6fc8a714eaae30364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623b0c5a085bc13c826f3d78459a407f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a623b0c5a085bc13c826f3d78459a407f">operator[]</a> (const unsigned <a class="el" href="classint.html">int</a> fe_index) const</td></tr>
<tr class="separator:a623b0c5a085bc13c826f3d78459a407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b5775df3e42a3fcca19aee960d6f4a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a55b5775df3e42a3fcca19aee960d6f4a">operator==</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe) const</td></tr>
<tr class="separator:a55b5775df3e42a3fcca19aee960d6f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439857c3106a765203a354723dfc7cac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a439857c3106a765203a354723dfc7cac">operator==</a> (const <a class="el" href="classFiniteElementData.html">FiniteElementData</a> &amp;) const</td></tr>
<tr class="separator:a439857c3106a765203a354723dfc7cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443a348f7c568cb05b3ec3f18c788f75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a443a348f7c568cb05b3ec3f18c788f75">operator!=</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;) const</td></tr>
<tr class="separator:a443a348f7c568cb05b3ec3f18c788f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga663d09822c597afdf3252fd2ee228484"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga663d09822c597afdf3252fd2ee228484">DeclException1</a> (ExcShapeFunctionNotPrimitive, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The shape function with index &quot;&lt;&lt; arg1&lt;&lt; &quot; is not primitive, i.e. it is vector-valued and &quot;&lt;&lt; &quot;has more than one non-zero vector component. This &quot;&lt;&lt; &quot;function cannot be called for these shape functions. &quot;&lt;&lt; &quot;Maybe you want to use the same function with the &quot;&lt;&lt; &quot;_component suffix?&quot;)</td></tr>
<tr class="separator:ga663d09822c597afdf3252fd2ee228484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec1b9715ae5de8ea67d626df81074e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga6ec1b9715ae5de8ea67d626df81074e1">DeclException0</a> (ExcFENotPrimitive)</td></tr>
<tr class="separator:ga6ec1b9715ae5de8ea67d626df81074e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37396684147b41d9ffe6dfdd4210b1ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga37396684147b41d9ffe6dfdd4210b1ce">DeclException0</a> (ExcInterpolationNotImplemented)</td></tr>
<tr class="separator:ga37396684147b41d9ffe6dfdd4210b1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed68da6b4b3bc08dfbf59630124f2875"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaed68da6b4b3bc08dfbf59630124f2875">DeclExceptionMsg</a> (ExcUnitShapeValuesDoNotExist, &quot;You are trying to access the values or derivatives of shape functions &quot; &quot;on the reference cell of an element that does not define its shape &quot; &quot;functions through mapping from the reference cell. Consequently, &quot; &quot;you cannot ask for shape function values or derivatives on the &quot; &quot;reference cell.&quot;)</td></tr>
<tr class="separator:gaed68da6b4b3bc08dfbf59630124f2875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d7ad6a5f56547799f047a79fb049af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga84d7ad6a5f56547799f047a79fb049af">DeclExceptionMsg</a> (ExcFEHasNoSupportPoints, &quot;You are trying to access the support points of a finite &quot; &quot;element that either has no support points at all, or for &quot; &quot;which the corresponding tables have not been implemented.&quot;)</td></tr>
<tr class="separator:ga84d7ad6a5f56547799f047a79fb049af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d4217c6d67c320694015d7e5e59269f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3d4217c6d67c320694015d7e5e59269f">DeclExceptionMsg</a> (ExcEmbeddingVoid, &quot;You are trying to access the matrices that describe how &quot; &quot;to embed a finite element function on one cell into the &quot; &quot;finite element space on one of its children (i.e., the &quot; &quot;'embedding' or '<a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a>' matrices). However, the &quot; &quot;current finite element can either not define this sort of &quot; &quot;operation, or it has not yet been implemented.&quot;)</td></tr>
<tr class="separator:ga3d4217c6d67c320694015d7e5e59269f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04d11552badfaba74bd005e26054bbaa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga04d11552badfaba74bd005e26054bbaa">DeclExceptionMsg</a> (ExcProjectionVoid, &quot;You are trying to access the matrices that describe how &quot; &quot;to restrict a finite element function from the children &quot; &quot;of one cell to the finite element space defined on their &quot; &quot;parent (i.e., the '<a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">restriction</a>' or 'projection' matrices). &quot; &quot;However, the current finite element can either not define &quot; &quot;this sort of operation, or it has not yet been &quot; &quot;implemented.&quot;)</td></tr>
<tr class="separator:ga04d11552badfaba74bd005e26054bbaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7259b58625401341a88c342ea942ee40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7259b58625401341a88c342ea942ee40">DeclException2</a> (ExcWrongInterfaceMatrixSize, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The interface matrix has a size of &quot;&lt;&lt; arg1&lt;&lt; &quot;x&quot;&lt;&lt; arg2&lt;&lt; &quot;, which is not reasonable for the current element &quot; &quot;in the present dimension.&quot;)</td></tr>
<tr class="separator:ga7259b58625401341a88c342ea942ee40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60aed438915b7d8d37b2a45c902e6bfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classReferenceCell.html">ReferenceCell</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a60aed438915b7d8d37b2a45c902e6bfe">reference_cell</a> () const</td></tr>
<tr class="separator:a60aed438915b7d8d37b2a45c902e6bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfd4619615520b8446ac853826a7d4c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a5cfd4619615520b8446ac853826a7d4c">n_unique_quads</a> () const</td></tr>
<tr class="separator:a5cfd4619615520b8446ac853826a7d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6081492e85d34bbfbd334423e31ce42"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ad6081492e85d34bbfbd334423e31ce42">n_unique_faces</a> () const</td></tr>
<tr class="separator:ad6081492e85d34bbfbd334423e31ce42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1f06778f87a7606cc2e0d5338b41ab"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a0d1f06778f87a7606cc2e0d5338b41ab">n_dofs_per_vertex</a> () const</td></tr>
<tr class="separator:a0d1f06778f87a7606cc2e0d5338b41ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384464e3b59fe91485f603dc32db7dd1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a384464e3b59fe91485f603dc32db7dd1">n_dofs_per_line</a> () const</td></tr>
<tr class="separator:a384464e3b59fe91485f603dc32db7dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8259242b27dc19222cde2016a99dba2"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ad8259242b27dc19222cde2016a99dba2">n_dofs_per_quad</a> (unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:ad8259242b27dc19222cde2016a99dba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32508c87a3850e94e59193f14c52d6f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aa32508c87a3850e94e59193f14c52d6f">max_dofs_per_quad</a> () const</td></tr>
<tr class="separator:aa32508c87a3850e94e59193f14c52d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb7465f62a849481ae0bf5edc78ec7d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aecb7465f62a849481ae0bf5edc78ec7d">n_dofs_per_hex</a> () const</td></tr>
<tr class="separator:aecb7465f62a849481ae0bf5edc78ec7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5f5b1fc401af61dafc61d083f5ae7b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a4a5f5b1fc401af61dafc61d083f5ae7b">n_dofs_per_face</a> (unsigned <a class="el" href="classint.html">int</a> face_no=0, unsigned <a class="el" href="classint.html">int</a> child=0) const</td></tr>
<tr class="separator:a4a5f5b1fc401af61dafc61d083f5ae7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54eef7c23041e6750f0a71c2ca3028bd"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a54eef7c23041e6750f0a71c2ca3028bd">max_dofs_per_face</a> () const</td></tr>
<tr class="separator:a54eef7c23041e6750f0a71c2ca3028bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b522422da89e5c080e7405ad49d7c7"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a> () const</td></tr>
<tr class="separator:a33b522422da89e5c080e7405ad49d7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc6a1e69b9c6594f6f08338d11ceb43"><td class="memTemplParams" colspan="2">template&lt;int structdim&gt; </td></tr>
<tr class="memitem:a6dc6a1e69b9c6594f6f08338d11ceb43"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a6dc6a1e69b9c6594f6f08338d11ceb43">n_dofs_per_object</a> (const unsigned <a class="el" href="classint.html">int</a> i=0) const</td></tr>
<tr class="separator:a6dc6a1e69b9c6594f6f08338d11ceb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a698695065333035e493294ce92820e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">n_components</a> () const</td></tr>
<tr class="separator:a5a698695065333035e493294ce92820e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1c4ca934f26ff463caf35a574e9f14"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a4c1c4ca934f26ff463caf35a574e9f14">n_blocks</a> () const</td></tr>
<tr class="separator:a4c1c4ca934f26ff463caf35a574e9f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b11a9d43bf383bb38953fd50dba34b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ab6b11a9d43bf383bb38953fd50dba34b">block_indices</a> () const</td></tr>
<tr class="separator:ab6b11a9d43bf383bb38953fd50dba34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584a56a1611a86a04c8b9a26d0eb9f27"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a584a56a1611a86a04c8b9a26d0eb9f27">tensor_degree</a> () const</td></tr>
<tr class="separator:a584a56a1611a86a04c8b9a26d0eb9f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e928460be93a004559b841f35ad698"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a18e928460be93a004559b841f35ad698">conforms</a> (const <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a>) const</td></tr>
<tr class="separator:a18e928460be93a004559b841f35ad698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078fb199880f2b29fc72d9c01d317bd0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a078fb199880f2b29fc72d9c01d317bd0">get_first_line_index</a> () const</td></tr>
<tr class="separator:a078fb199880f2b29fc72d9c01d317bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1b484c2e7afda2efaa11e7e31b5bbf"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a3a1b484c2e7afda2efaa11e7e31b5bbf">get_first_quad_index</a> (const unsigned <a class="el" href="classint.html">int</a> quad_no=0) const</td></tr>
<tr class="separator:a3a1b484c2e7afda2efaa11e7e31b5bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4361f6bf7db70f4961e67ddf97ebf8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aff4361f6bf7db70f4961e67ddf97ebf8">get_first_hex_index</a> () const</td></tr>
<tr class="separator:aff4361f6bf7db70f4961e67ddf97ebf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859d429b3a7a847713c6d2528c3f2e97"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a859d429b3a7a847713c6d2528c3f2e97">get_first_face_line_index</a> (const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:a859d429b3a7a847713c6d2528c3f2e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2166738fc6fda9ef70988179d8d569"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a9f2166738fc6fda9ef70988179d8d569">get_first_face_quad_index</a> (const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:a9f2166738fc6fda9ef70988179d8d569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shape function access</div></td></tr>
<tr class="memitem:a8a6d8333e73fa0e5af7d43fe74a06e2c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a8a6d8333e73fa0e5af7d43fe74a06e2c">shape_3rd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:a8a6d8333e73fa0e5af7d43fe74a06e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19e0baf900a7dc723e082acd04cf749"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aa19e0baf900a7dc723e082acd04cf749">shape_3rd_derivative_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:aa19e0baf900a7dc723e082acd04cf749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d05c63d0fbcae9280f49aa6417ead1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a71d05c63d0fbcae9280f49aa6417ead1">shape_4th_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:a71d05c63d0fbcae9280f49aa6417ead1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b04caeb2bb9fe0784db7d4c123604d9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a5b04caeb2bb9fe0784db7d4c123604d9">shape_4th_derivative_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:a5b04caeb2bb9fe0784db7d4c123604d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Transfer and constraint matrices</div></td></tr>
<tr class="memitem:afcd544abd534ae8ce643f8c21b8be7f2"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#afcd544abd534ae8ce643f8c21b8be7f2">get_restriction_matrix</a> (const unsigned <a class="el" href="classint.html">int</a> child, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const</td></tr>
<tr class="separator:afcd544abd534ae8ce643f8c21b8be7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78c7b6503befe61dc6df5eb41c99019"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#af78c7b6503befe61dc6df5eb41c99019">get_prolongation_matrix</a> (const unsigned <a class="el" href="classint.html">int</a> child, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const</td></tr>
<tr class="separator:af78c7b6503befe61dc6df5eb41c99019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ead2dba2770c63493a139bec677ccdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a1ead2dba2770c63493a139bec677ccdb">prolongation_is_implemented</a> () const</td></tr>
<tr class="separator:a1ead2dba2770c63493a139bec677ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0849d6c4188612816934d5468ecf9e6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0849d6c4188612816934d5468ecf9e6b">isotropic_prolongation_is_implemented</a> () const</td></tr>
<tr class="separator:a0849d6c4188612816934d5468ecf9e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8539eac73f0305ba91e612ad5519250"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab8539eac73f0305ba91e612ad5519250">restriction_is_implemented</a> () const</td></tr>
<tr class="separator:ab8539eac73f0305ba91e612ad5519250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645ff401ff38407d67a0785163939f87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a645ff401ff38407d67a0785163939f87">isotropic_restriction_is_implemented</a> () const</td></tr>
<tr class="separator:a645ff401ff38407d67a0785163939f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa81cef78859c726852a1ee1ef37210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a6aa81cef78859c726852a1ee1ef37210">restriction_is_additive</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:a6aa81cef78859c726852a1ee1ef37210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a89da67f07c3b699f3712159c003ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a75a89da67f07c3b699f3712159c003ac">constraints</a> (const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;subface_case=::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt;::case_isotropic) const</td></tr>
<tr class="separator:a75a89da67f07c3b699f3712159c003ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f5b5d1700cf820f8989f35418efbfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a01f5b5d1700cf820f8989f35418efbfc">constraints_are_implemented</a> (const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;subface_case=::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt;::case_isotropic) const</td></tr>
<tr class="separator:a01f5b5d1700cf820f8989f35418efbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92fb4945b3dd83fc513abd3e612f022"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#af92fb4945b3dd83fc513abd3e612f022">hp_constraints_are_implemented</a> () const</td></tr>
<tr class="separator:af92fb4945b3dd83fc513abd3e612f022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0545a749431c39c4048f49e478905e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7f0545a749431c39c4048f49e478905e">get_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix) const</td></tr>
<tr class="separator:a7f0545a749431c39c4048f49e478905e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions to support hp</div></td></tr>
<tr class="memitem:ada551320eb695448249601e69bd46a66"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ada551320eb695448249601e69bd46a66">get_face_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:ada551320eb695448249601e69bd46a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a764505812713f679a5ad64033077d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7a764505812713f679a5ad64033077d6">get_subface_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, const unsigned <a class="el" href="classint.html">int</a> subface, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:a7a764505812713f679a5ad64033077d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions to support hp-</div></td></tr>
<tr class="memitem:a2dd93e3d4f1f81301e6ae5f1b4832b26"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a2dd93e3d4f1f81301e6ae5f1b4832b26">hp_vertex_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const</td></tr>
<tr class="separator:a2dd93e3d4f1f81301e6ae5f1b4832b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace71f6d638de257e5791bfa7cd43e083"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ace71f6d638de257e5791bfa7cd43e083">hp_line_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const</td></tr>
<tr class="separator:ace71f6d638de257e5791bfa7cd43e083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac728e4ad74d39b32883ef76dd5b99b61"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac728e4ad74d39b32883ef76dd5b99b61">hp_quad_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:ac728e4ad74d39b32883ef76dd5b99b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acf7f396d861978209890fa268bdcbe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0acf7f396d861978209890fa268bdcbe">compare_for_domination</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other, const unsigned <a class="el" href="classint.html">int</a> codim=0) const</td></tr>
<tr class="separator:a0acf7f396d861978209890fa268bdcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Index computations</div></td></tr>
<tr class="memitem:a86644fe67824373cd51e9ff7fca94f8c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:a86644fe67824373cd51e9ff7fca94f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ea16b60a6fc644a9bc7097703a53e8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae2ea16b60a6fc644a9bc7097703a53e8">component_to_system_index</a> (const unsigned <a class="el" href="classint.html">int</a> component, const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:ae2ea16b60a6fc644a9bc7097703a53e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb73242a6dca33f8da1bb44a5f00d61"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aecb73242a6dca33f8da1bb44a5f00d61">face_system_to_component_index</a> (const unsigned <a class="el" href="classint.html">int</a> index, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:aecb73242a6dca33f8da1bb44a5f00d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54657bc9ca9484522e7e6e3ca2499bc"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae54657bc9ca9484522e7e6e3ca2499bc">adjust_quad_dof_index_for_face_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> index, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classbool.html">bool</a> face_orientation, const <a class="el" href="classbool.html">bool</a> face_flip, const <a class="el" href="classbool.html">bool</a> face_rotation) const</td></tr>
<tr class="separator:ae54657bc9ca9484522e7e6e3ca2499bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5fb2386a3531ac85e226464294f4d5"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a6c5fb2386a3531ac85e226464294f4d5">face_to_cell_index</a> (const unsigned <a class="el" href="classint.html">int</a> face_dof_index, const unsigned <a class="el" href="classint.html">int</a> face, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false) const</td></tr>
<tr class="separator:a6c5fb2386a3531ac85e226464294f4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5859e4b85feaa0406c4aa571fc4dfa4f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a5859e4b85feaa0406c4aa571fc4dfa4f">adjust_line_dof_index_for_line_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> index, const <a class="el" href="classbool.html">bool</a> line_orientation) const</td></tr>
<tr class="separator:a5859e4b85feaa0406c4aa571fc4dfa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12aa649db6e1460a8d30b067af952fc4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a12aa649db6e1460a8d30b067af952fc4">get_nonzero_components</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a12aa649db6e1460a8d30b067af952fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac228df752c9c2462aabf284e862402d0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac228df752c9c2462aabf284e862402d0">n_nonzero_components</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ac228df752c9c2462aabf284e862402d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626abd282a25193db7f61b4ec53e7385"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a626abd282a25193db7f61b4ec53e7385">is_primitive</a> () const</td></tr>
<tr class="separator:a626abd282a25193db7f61b4ec53e7385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38241991825f67d635d53d25cb5a2fda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a38241991825f67d635d53d25cb5a2fda">is_primitive</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a38241991825f67d635d53d25cb5a2fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12fbcc708737aa60fa272d4d3e22aea"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ad12fbcc708737aa60fa272d4d3e22aea">n_base_elements</a> () const</td></tr>
<tr class="separator:ad12fbcc708737aa60fa272d4d3e22aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705f734e2f56aa34710defb72299e7c8"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a705f734e2f56aa34710defb72299e7c8">base_element</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:a705f734e2f56aa34710defb72299e7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa009769e662e34081f60ff16327db1b1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aa009769e662e34081f60ff16327db1b1">element_multiplicity</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:aa009769e662e34081f60ff16327db1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e31b9a8f1f72dc65e970eca1522d183"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9e31b9a8f1f72dc65e970eca1522d183">get_sub_fe</a> (const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask) const</td></tr>
<tr class="separator:a9e31b9a8f1f72dc65e970eca1522d183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b07708eb577149824c317df6e35f161"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4b07708eb577149824c317df6e35f161">get_sub_fe</a> (const unsigned <a class="el" href="classint.html">int</a> first_component, const unsigned <a class="el" href="classint.html">int</a> n_selected_components) const</td></tr>
<tr class="separator:a4b07708eb577149824c317df6e35f161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ac75dfc5b9f4e01c34d5865b4ca5a2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:a95ac75dfc5b9f4e01c34d5865b4ca5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4647e72a2670c17849701a6357eb87"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9c4647e72a2670c17849701a6357eb87">face_system_to_base_index</a> (const unsigned <a class="el" href="classint.html">int</a> index, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:a9c4647e72a2670c17849701a6357eb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc49f8114f396b20b9a7fe9a3c058568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#afc49f8114f396b20b9a7fe9a3c058568">first_block_of_base</a> (const unsigned <a class="el" href="classint.html">int</a> b) const</td></tr>
<tr class="separator:afc49f8114f396b20b9a7fe9a3c058568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1ca2e63382a8fd20910ae0303f4f6c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a2e1ca2e63382a8fd20910ae0303f4f6c">component_to_base_index</a> (const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:a2e1ca2e63382a8fd20910ae0303f4f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656f95e7c9144846758b804a41405cd3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a656f95e7c9144846758b804a41405cd3">block_to_base_index</a> (const unsigned <a class="el" href="classint.html">int</a> block) const</td></tr>
<tr class="separator:a656f95e7c9144846758b804a41405cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0763dd6212313f0ff69f04c735b2a147"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0763dd6212313f0ff69f04c735b2a147">system_to_block_index</a> (const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:a0763dd6212313f0ff69f04c735b2a147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3dd1574cabab93b67e3fe47a103b6a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7b3dd1574cabab93b67e3fe47a103b6a">component_to_block_index</a> (const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:a7b3dd1574cabab93b67e3fe47a103b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Component and block matrices</div></td></tr>
<tr class="memitem:a4409f54175f279ac24cc982cfcfcbd2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const</td></tr>
<tr class="separator:a4409f54175f279ac24cc982cfcfcbd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d11c23f6db2eca49ba470defb873c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a46d11c23f6db2eca49ba470defb873c0">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const</td></tr>
<tr class="separator:a46d11c23f6db2eca49ba470defb873c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0dcc1e76885ec0ddcaae340dcdcd62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a2c0dcc1e76885ec0ddcaae340dcdcd62">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;sym_tensor) const</td></tr>
<tr class="separator:a2c0dcc1e76885ec0ddcaae340dcdcd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d2a54a95f43f0db77e74b1bfab21d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a24d2a54a95f43f0db77e74b1bfab21d2">component_mask</a> (const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;<a class="el" href="classFiniteElement.html#a7cc5ed75cad6792b8b21a3ac635a8860">block_mask</a>) const</td></tr>
<tr class="separator:a24d2a54a95f43f0db77e74b1bfab21d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc5ed75cad6792b8b21a3ac635a8860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7cc5ed75cad6792b8b21a3ac635a8860">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const</td></tr>
<tr class="separator:a7cc5ed75cad6792b8b21a3ac635a8860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9294bf84eec96ac31f29808a5aa87551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9294bf84eec96ac31f29808a5aa87551">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const</td></tr>
<tr class="separator:a9294bf84eec96ac31f29808a5aa87551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace95b8ef3a342bbb8f82cb17113be612"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ace95b8ef3a342bbb8f82cb17113be612">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;sym_tensor) const</td></tr>
<tr class="separator:ace95b8ef3a342bbb8f82cb17113be612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931d71caa9f14212b8dd89337e155fc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a931d71caa9f14212b8dd89337e155fc1">block_mask</a> (const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>) const</td></tr>
<tr class="separator:a931d71caa9f14212b8dd89337e155fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d75035bee0b250281be6fae5022374"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt;, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a83d75035bee0b250281be6fae5022374">get_constant_modes</a> () const</td></tr>
<tr class="separator:a83d75035bee0b250281be6fae5022374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Support points and interpolation</div></td></tr>
<tr class="memitem:a31950b76dd77043681a605d775b9f885"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a31950b76dd77043681a605d775b9f885">get_unit_support_points</a> () const</td></tr>
<tr class="separator:a31950b76dd77043681a605d775b9f885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f25ecdd4c356032bd44e3e6571d983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a47f25ecdd4c356032bd44e3e6571d983">has_support_points</a> () const</td></tr>
<tr class="separator:a47f25ecdd4c356032bd44e3e6571d983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6847a0da4cf62bca0dc7e27862a853f2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a6847a0da4cf62bca0dc7e27862a853f2">unit_support_point</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:a6847a0da4cf62bca0dc7e27862a853f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78f6cfda334497625e2cef7a16be6f6"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac78f6cfda334497625e2cef7a16be6f6">get_unit_face_support_points</a> (const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:ac78f6cfda334497625e2cef7a16be6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e0ebd1082fd37318aac7c5b69c99ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a40e0ebd1082fd37318aac7c5b69c99ba">has_face_support_points</a> (const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:a40e0ebd1082fd37318aac7c5b69c99ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3c2b0d51bd908a6bd2ae934aab6204"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aab3c2b0d51bd908a6bd2ae934aab6204">unit_face_support_point</a> (const unsigned <a class="el" href="classint.html">int</a> index, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:aab3c2b0d51bd908a6bd2ae934aab6204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b9d0a87e17f83f6a9abe50375b5543"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a14b9d0a87e17f83f6a9abe50375b5543">get_generalized_support_points</a> () const</td></tr>
<tr class="separator:a14b9d0a87e17f83f6a9abe50375b5543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7a3e41b44869ce600ae0b3a98b5b4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4d7a3e41b44869ce600ae0b3a98b5b4e">has_generalized_support_points</a> () const</td></tr>
<tr class="separator:a4d7a3e41b44869ce600ae0b3a98b5b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ea3780c7d2e6140141a9afcbc421f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGeometryPrimitive.html">GeometryPrimitive</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae0ea3780c7d2e6140141a9afcbc421f4">get_associated_geometry_primitive</a> (const unsigned <a class="el" href="classint.html">int</a> cell_dof_index) const</td></tr>
<tr class="separator:ae0ea3780c7d2e6140141a9afcbc421f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfedd72fb0bd1c9daf2701015edac5f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a5dfedd72fb0bd1c9daf2701015edac5f">convert_generalized_support_point_values_to_dof_values</a> (const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;support_point_values, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;nodal_values) const</td></tr>
<tr class="separator:a5dfedd72fb0bd1c9daf2701015edac5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad82fdeb0955b7d59f32d5371adaaadbc"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ad82fdeb0955b7d59f32d5371adaaadbc">dofs_per_vertex</a></td></tr>
<tr class="separator:ad82fdeb0955b7d59f32d5371adaaadbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490e2ded19c0a8cad0846e07e57e3e76"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a490e2ded19c0a8cad0846e07e57e3e76">dofs_per_line</a></td></tr>
<tr class="separator:a490e2ded19c0a8cad0846e07e57e3e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ab27b2dfa5520f2aa56f9bb8223878"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a00ab27b2dfa5520f2aa56f9bb8223878">dofs_per_quad</a></td></tr>
<tr class="separator:a00ab27b2dfa5520f2aa56f9bb8223878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9014d27be7564a42c962848db0d2fd75"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a9014d27be7564a42c962848db0d2fd75">dofs_per_hex</a></td></tr>
<tr class="separator:a9014d27be7564a42c962848db0d2fd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c172e26b87c60b3f7e5e3ebf155b62e"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a8c172e26b87c60b3f7e5e3ebf155b62e">first_line_index</a></td></tr>
<tr class="separator:a8c172e26b87c60b3f7e5e3ebf155b62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9fc2a37fc1aa814ac73e93baca4bea"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aca9fc2a37fc1aa814ac73e93baca4bea">first_quad_index</a></td></tr>
<tr class="separator:aca9fc2a37fc1aa814ac73e93baca4bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649a135f376e3fba63ecf08c2b17cc64"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a649a135f376e3fba63ecf08c2b17cc64">first_hex_index</a></td></tr>
<tr class="separator:a649a135f376e3fba63ecf08c2b17cc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cf27d2dabe49e0c1f57954d7d08500"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a70cf27d2dabe49e0c1f57954d7d08500">first_face_line_index</a></td></tr>
<tr class="separator:a70cf27d2dabe49e0c1f57954d7d08500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f85f3eae2daee423441fce5e87fa2e6"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a0f85f3eae2daee423441fce5e87fa2e6">first_face_quad_index</a></td></tr>
<tr class="separator:a0f85f3eae2daee423441fce5e87fa2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358bffed1fba59ef4df715469473fd36"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></td></tr>
<tr class="separator:a358bffed1fba59ef4df715469473fd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fa3b8d578ba488b4f37061bb0278bb"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a></td></tr>
<tr class="separator:ae2fa3b8d578ba488b4f37061bb0278bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccdb4fd2c40a3e3cd92cb0361cddaf8"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a1ccdb4fd2c40a3e3cd92cb0361cddaf8">components</a></td></tr>
<tr class="separator:a1ccdb4fd2c40a3e3cd92cb0361cddaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbf5ad6b464871261dbd054bced18a8"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a></td></tr>
<tr class="separator:a2cbf5ad6b464871261dbd054bced18a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca702ba3af0ed17eaffcfbbccf82067f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aca702ba3af0ed17eaffcfbbccf82067f">conforming_space</a></td></tr>
<tr class="separator:aca702ba3af0ed17eaffcfbbccf82067f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9346e3aae3032545c8a94b78a365ffcb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a9346e3aae3032545c8a94b78a365ffcb">block_indices_data</a></td></tr>
<tr class="separator:a9346e3aae3032545c8a94b78a365ffcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a577195e2fad97018b5dccb837952dad7"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a577195e2fad97018b5dccb837952dad7">space_dimension</a> = spacedim</td></tr>
<tr class="separator:a577195e2fad97018b5dccb837952dad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40fa679812dc4fcc76496aa9a139050"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#af40fa679812dc4fcc76496aa9a139050">dimension</a> = dim</td></tr>
<tr class="separator:af40fa679812dc4fcc76496aa9a139050"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adbafd47e79bfff9a4d6992cd407b9357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#adbafd47e79bfff9a4d6992cd407b9357">single_mapping_kind</a> () const</td></tr>
<tr class="separator:adbafd47e79bfff9a4d6992cd407b9357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02356fe38fd14f9a169ae99ade355b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#ab02356fe38fd14f9a169ae99ade355b5">adjust_quad_dof_sign_for_face_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> index, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classbool.html">bool</a> face_orientation, const <a class="el" href="classbool.html">bool</a> face_flip, const <a class="el" href="classbool.html">bool</a> face_rotation) const</td></tr>
<tr class="separator:ab02356fe38fd14f9a169ae99ade355b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea9b13e048ed08291ba5a7e948c16a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#acea9b13e048ed08291ba5a7e948c16a8">get_mapping_kind</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:acea9b13e048ed08291ba5a7e948c16a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3120826089c7acfa86648238856fbfe0"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a3120826089c7acfa86648238856fbfe0">get_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a3120826089c7acfa86648238856fbfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb57d4a4352bcc359d06b50e5d46130c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#acb57d4a4352bcc359d06b50e5d46130c">fill_fe_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:acb57d4a4352bcc359d06b50e5d46130c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76218870e645f59e07c7ab650cf31a79"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">fill_fe_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const =0</td></tr>
<tr class="separator:a76218870e645f59e07c7ab650cf31a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4560cde3da4b06fe983caa200f7f83e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#ad4560cde3da4b06fe983caa200f7f83e">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:ad4560cde3da4b06fe983caa200f7f83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5fd937dc322e6028f60c30fc65f185"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7c5fd937dc322e6028f60c30fc65f185">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a7c5fd937dc322e6028f60c30fc65f185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd572e784ad8c26c2c41c9fc3ce86ed6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#abd572e784ad8c26c2c41c9fc3ce86ed6">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:abd572e784ad8c26c2c41c9fc3ce86ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7943632de4e3fe21b1a82e926c6170"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a8d7943632de4e3fe21b1a82e926c6170">fill_fe_subface_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> sub_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a8d7943632de4e3fe21b1a82e926c6170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7af117168f8d0fdb4bbdd516373625"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ace7af117168f8d0fdb4bbdd516373625">fill_fe_subface_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> sub_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const =0</td></tr>
<tr class="separator:ace7af117168f8d0fdb4bbdd516373625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62838f7428ee56e34c4081ca6d03bc26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a62838f7428ee56e34c4081ca6d03bc26">reinit_restriction_and_prolongation_matrices</a> (const <a class="el" href="classbool.html">bool</a> isotropic_restriction_only=false, const <a class="el" href="classbool.html">bool</a> isotropic_prolongation_only=false)</td></tr>
<tr class="separator:a62838f7428ee56e34c4081ca6d03bc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9df544a5b3b010e497c6645e6c734a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableIndices.html">TableIndices</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4c9df544a5b3b010e497c6645e6c734a">interface_constraints_size</a> () const</td></tr>
<tr class="separator:a4c9df544a5b3b010e497c6645e6c734a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7236d243e42448327e719a9ea66a81"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0d7236d243e42448327e719a9ea66a81">get_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a0d7236d243e42448327e719a9ea66a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2f79f305092a89472245fb9ee4cdf7"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7e2f79f305092a89472245fb9ee4cdf7">get_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a7e2f79f305092a89472245fb9ee4cdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450e656fc6a48e7a6f1a9546713fcbf5"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a450e656fc6a48e7a6f1a9546713fcbf5">get_subface_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a450e656fc6a48e7a6f1a9546713fcbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:abe780620df7c633e43ca45aba2e4270f"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#abe780620df7c633e43ca45aba2e4270f">compute_n_nonzero_components</a> (const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; &amp;<a class="el" href="classFiniteElement.html#ae6fe073d1e3ce59791b142067482bd5b">nonzero_components</a>)</td></tr>
<tr class="separator:abe780620df7c633e43ca45aba2e4270f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abeecf4df065ca5f5701ba1190a190631"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#abeecf4df065ca5f5701ba1190a190631">mapping_kind</a></td></tr>
<tr class="separator:abeecf4df065ca5f5701ba1190a190631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20234bd8b6c97e450bb3c0efcd836198"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a20234bd8b6c97e450bb3c0efcd836198">adjust_quad_dof_sign_for_face_orientation_table</a></td></tr>
<tr class="separator:a20234bd8b6c97e450bb3c0efcd836198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45a96809bedb741904aebe616a32ba2"><td class="memItemLeft" align="right" valign="top">const std::unique_ptr&lt; const <a class="el" href="classTensorPolynomialsBase.html">TensorPolynomialsBase</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#ae45a96809bedb741904aebe616a32ba2">poly_space</a></td></tr>
<tr class="separator:ae45a96809bedb741904aebe616a32ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c73bd10d9b2b3c8d11e390c23b1b7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a38c73bd10d9b2b3c8d11e390c23b1b7e">inverse_node_matrix</a></td></tr>
<tr class="separator:a38c73bd10d9b2b3c8d11e390c23b1b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188e364c278533b4b319f702390322fd"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a188e364c278533b4b319f702390322fd">cache_mutex</a></td></tr>
<tr class="separator:a188e364c278533b4b319f702390322fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3728ea2a8d8d8744ebe14bdf6cbb31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a6f3728ea2a8d8d8744ebe14bdf6cbb31">cached_point</a></td></tr>
<tr class="separator:a6f3728ea2a8d8d8744ebe14bdf6cbb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb75d35170b98b1ba99090e566f6c5cd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#adb75d35170b98b1ba99090e566f6c5cd">cached_values</a></td></tr>
<tr class="separator:adb75d35170b98b1ba99090e566f6c5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306eab3ba19d1b62dd82b4126f466d55"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a306eab3ba19d1b62dd82b4126f466d55">cached_grads</a></td></tr>
<tr class="separator:a306eab3ba19d1b62dd82b4126f466d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14cdfca59390a4e648da7a0c7bee0b7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#af14cdfca59390a4e648da7a0c7bee0b7">cached_grad_grads</a></td></tr>
<tr class="separator:af14cdfca59390a4e648da7a0c7bee0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4993707a4ec342560ff74e5d22401794"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">restriction</a></td></tr>
<tr class="separator:a4993707a4ec342560ff74e5d22401794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc42f850096c429fd39cfcbde1b6b56"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a></td></tr>
<tr class="separator:afbc42f850096c429fd39cfcbde1b6b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d4cd5afce6a401892aeb5a40ccfa2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac8d4cd5afce6a401892aeb5a40ccfa2f">interface_constraints</a></td></tr>
<tr class="separator:ac8d4cd5afce6a401892aeb5a40ccfa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f6e0c83686b918fbb92716ead92313"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab4f6e0c83686b918fbb92716ead92313">unit_support_points</a></td></tr>
<tr class="separator:ab4f6e0c83686b918fbb92716ead92313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cab5fe59b82da1fc25e1454b12c4fa9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a1cab5fe59b82da1fc25e1454b12c4fa9">unit_face_support_points</a></td></tr>
<tr class="separator:a1cab5fe59b82da1fc25e1454b12c4fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2531d00b5c9e77e1e64981864c3b8cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae2531d00b5c9e77e1e64981864c3b8cc">generalized_support_points</a></td></tr>
<tr class="separator:ae2531d00b5c9e77e1e64981864c3b8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646b0f9a97e1df8fc14f9305149ed525"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a646b0f9a97e1df8fc14f9305149ed525">generalized_face_support_points</a></td></tr>
<tr class="separator:a646b0f9a97e1df8fc14f9305149ed525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5592f17f6c16d325de2d30f1cc051eeb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a5592f17f6c16d325de2d30f1cc051eeb">adjust_quad_dof_index_for_face_orientation_table</a></td></tr>
<tr class="separator:a5592f17f6c16d325de2d30f1cc051eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6659bb0dccc62e2d680c964e5035daf6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a6659bb0dccc62e2d680c964e5035daf6">adjust_line_dof_index_for_line_orientation_table</a></td></tr>
<tr class="separator:a6659bb0dccc62e2d680c964e5035daf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af218ae93821b61054de7e88e1734aa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9af218ae93821b61054de7e88e1734aa">system_to_component_table</a></td></tr>
<tr class="separator:a9af218ae93821b61054de7e88e1734aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc61022ae105ef061458aa5f2d573055"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#abc61022ae105ef061458aa5f2d573055">face_system_to_component_table</a></td></tr>
<tr class="separator:abc61022ae105ef061458aa5f2d573055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870f688170ad210708077eed94642d73"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a870f688170ad210708077eed94642d73">system_to_base_table</a></td></tr>
<tr class="separator:a870f688170ad210708077eed94642d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e6a76c64f925c81561745fd6bc12c3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab4e6a76c64f925c81561745fd6bc12c3">face_system_to_base_table</a></td></tr>
<tr class="separator:ab4e6a76c64f925c81561745fd6bc12c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f62f39ded99d6525f1c33f4227ee8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a61f62f39ded99d6525f1c33f4227ee8d">base_to_block_indices</a></td></tr>
<tr class="separator:a61f62f39ded99d6525f1c33f4227ee8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2c44f3a207e0e11880820a29ac37a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aaf2c44f3a207e0e11880820a29ac37a8">component_to_base_table</a></td></tr>
<tr class="separator:aaf2c44f3a207e0e11880820a29ac37a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f4833a318127b42d2dc806bffe1c2c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aa8f4833a318127b42d2dc806bffe1c2c">restriction_is_additive_flags</a></td></tr>
<tr class="separator:aa8f4833a318127b42d2dc806bffe1c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fe073d1e3ce59791b142067482bd5b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae6fe073d1e3ce59791b142067482bd5b">nonzero_components</a></td></tr>
<tr class="separator:ae6fe073d1e3ce59791b142067482bd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7cb6ef5342900727931ef983636502"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0b7cb6ef5342900727931ef983636502">n_nonzero_components_table</a></td></tr>
<tr class="separator:a0b7cb6ef5342900727931ef983636502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4124079b6443590608046d8f150574f6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4124079b6443590608046d8f150574f6">cached_primitivity</a></td></tr>
<tr class="separator:a4124079b6443590608046d8f150574f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a364d44d4709e57bd29a4499fdbf031a7"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__DGVector.html#a364d44d4709e57bd29a4499fdbf031a7">get_dpo_vector</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>)</td></tr>
<tr class="separator:a364d44d4709e57bd29a4499fdbf031a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a45f266aa4761c1cdbbff62e65d8f3cc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a>&lt; 3, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__DGVector.html#a45f266aa4761c1cdbbff62e65d8f3cc2">interior_weights</a></td></tr>
<tr class="separator:a45f266aa4761c1cdbbff62e65d8f3cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class PolynomialType, int dim, int spacedim = dim&gt;<br />
class FE_DGVector&lt; PolynomialType, dim, spacedim &gt;</h3>

<p>DG elements based on vector valued polynomials.</p>
<p>These elements use vector valued polynomial spaces as they have been introduced for H<sup>div</sup> and H<sup>curl</sup> conforming finite elements, but do not use the usual continuity of these elements. Thus, they are suitable for DG and hybrid formulations involving these function spaces.</p>
<p>The template argument <code>PolynomialType</code> refers to a vector valued polynomial space like <a class="el" href="classPolynomialsRaviartThomas.html">PolynomialsRaviartThomas</a> or <a class="el" href="classPolynomialsNedelec.html">PolynomialsNedelec</a>. Note that the dimension of the polynomial space and the argument <code>dim</code> must coincide. </p>

<p class="definition">Definition at line <a class="el" href="fe__dg__vector_8h_source.html#l00053">53</a> of file <a class="el" href="fe__dg__vector_8h_source.html">fe_dg_vector.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a0cd5f34c3ab828fac31004f3b52921a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd5f34c3ab828fac31004f3b52921a1">&#9670;&nbsp;</a></span>Conformity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">FiniteElementData::Conformity</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enumerator for the different types of continuity a finite element may have. Continuity is measured by the Sobolev space containing the constructed finite element space and is also called this way.</p>
<p>Note that certain continuities may imply others. For instance, a function in <em>H<sup>1</sup></em> is in <em>H<sup>curl</sup></em> and <em>H<sup>div</sup></em> as well.</p>
<p>If you are interested in continuity in the classical sense, then the following relations hold:</p>
<ol>
<li>
<p class="startli"><em>H<sup>1</sup></em> implies that the function is continuous over cell boundaries.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><em>H<sup>2</sup></em> implies that the function is continuously differentiable over cell boundaries.</p>
<p class="endli"></p>
</li>
<li>
<em>L<sup>2</sup></em> indicates that the element is discontinuous. Since discontinuous elements have no topological couplings between grid cells and code may actually depend on this property, <em>L<sup>2</sup></em> conformity is handled in a special way in the sense that it is <b>not</b> implied by any higher conformity. </li>
</ol>
<p>In order to test if a finite element conforms to a certain space, use <a class="el" href="classFiniteElementData.html#a18e928460be93a004559b841f35ad698">FiniteElementData&lt;dim&gt;::conforms()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0cd5f34c3ab828fac31004f3b52921a1afbb5ba93aed087d17dd0224e65a1bddc"></a>unknown&#160;</td><td class="fielddoc"><p>Indicates incompatible continuities of a system. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0cd5f34c3ab828fac31004f3b52921a1a349c581c3d0e392c33cc41d917eb038c"></a>L2&#160;</td><td class="fielddoc"><p>Discontinuous elements. See above! </p>
</td></tr>
<tr><td class="fieldname"><a id="a0cd5f34c3ab828fac31004f3b52921a1a0787dd9aa05e57e4e6009dd73cb1d229"></a>Hcurl&#160;</td><td class="fielddoc"><p>Conformity with the space <em>H<sup>curl</sup></em> (continuous tangential component of a vector field) </p>
</td></tr>
<tr><td class="fieldname"><a id="a0cd5f34c3ab828fac31004f3b52921a1a11a375871bcf4978f67ff6d7435f81ee"></a>Hdiv&#160;</td><td class="fielddoc"><p>Conformity with the space <em>H<sup>div</sup></em> (continuous normal component of a vector field) </p>
</td></tr>
<tr><td class="fieldname"><a id="a0cd5f34c3ab828fac31004f3b52921a1a0e986c9c300b61774d25c92ae2a9d054"></a>H1&#160;</td><td class="fielddoc"><p>Conformity with the space <em>H<sup>1</sup></em> (continuous) </p>
</td></tr>
<tr><td class="fieldname"><a id="a0cd5f34c3ab828fac31004f3b52921a1a916ecb570449b2ad08281d708b39bae2"></a>H2&#160;</td><td class="fielddoc"><p>Conformity with the space <em>H<sup>2</sup></em> (continuously differentiable) </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00245">245</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1351e60ba12ff8474b93306930a99701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1351e60ba12ff8474b93306930a99701">&#9670;&nbsp;</a></span>FE_DGVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolynomialType, int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFE__DGVector.html">FE_DGVector</a>&lt; PolynomialType, dim, spacedim &gt;::<a class="el" href="classFE__DGVector.html">FE_DGVector</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for the vector element of degree <code>p</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a14525444fb5700986552bae390345880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14525444fb5700986552bae390345880">&#9670;&nbsp;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolynomialType, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classFE__DGVector.html">FE_DGVector</a>&lt; PolynomialType, dim, spacedim &gt;::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a string that uniquely identifies a finite element. This class returns <code>FE_DGVector_</code> plus a piece of the name that is taken from what the polynomial object returns, plus <code>&lt;dim&gt;(degree)</code>, with <code>dim</code> and <code>degree</code> replaced by appropriate values. </p>

<p>Implements <a class="el" href="classFiniteElement.html#a09655d1d2555af8dcd48caebd4039d29">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classFE__DGBDM.html#a16c0ab3da8af0875c5ef04c1228556f5">FE_DGBDM&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGRaviartThomas.html#af3963a717a05edfd1e3c63797e00cde0">FE_DGRaviartThomas&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__DGNedelec.html#acda7f6437d923c2877dbad85fd5c0aaa">FE_DGNedelec&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a3e25f164fd98df828a00b9e488c37cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e25f164fd98df828a00b9e488c37cb6">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolynomialType, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classFE__DGVector.html">FE_DGVector</a>&lt; PolynomialType, dim, spacedim &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A sort of virtual copy constructor, this function returns a copy of the finite element object. Derived classes need to override the function here in this base class and return an object of the same type as the derived class.</p>
<p>Some places in the library, for example the constructors of <a class="el" href="classFESystem.html">FESystem</a> as well as the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> class, need to make copies of finite elements without knowing their exact type. They do so through this function. </p>

<p>Implements <a class="el" href="classFiniteElement.html#a63dfa09878be59ca47a2fc33206a53c6">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a1c9f11c1bb7778b0384867a3b1ca4d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9f11c1bb7778b0384867a3b1ca4d19">&#9670;&nbsp;</a></span>has_support_on_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolynomialType, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classFE__DGVector.html">FE_DGVector</a>&lt; PolynomialType, dim, spacedim &gt;::has_support_on_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>shape_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns <code>true</code>, if the shape function <code>shape_index</code> has non-zero function values somewhere on the face <code>face_index</code>.</p>
<p>For this element, we always return <code>true</code>. </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#a68dc9f085edbcd92f8d0703d3e5fce6f">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="afcdf31566f4c83b3910e5323f0a40dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdf31566f4c83b3910e5323f0a40dd9">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolynomialType, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classFE__DGVector.html">FE_DGVector</a>&lt; PolynomialType, dim, spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object.</p>
<p>This function is made virtual, since finite element objects are usually accessed through pointers to their base class, rather than the class itself. </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#adccc5f8ac313d3e7182599a01e6353a5">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a364d44d4709e57bd29a4499fdbf031a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364d44d4709e57bd29a4499fdbf031a7">&#9670;&nbsp;</a></span>get_dpo_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolynomialType, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFE__DGVector.html">FE_DGVector</a>&lt; PolynomialType, dim, spacedim &gt;::get_dpo_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Only for internal use. Its full name is <code>get_dofs_per_object_vector</code> function and it creates the <code>dofs_per_object</code> vector that is needed within the constructor to be passed to the constructor of <code><a class="el" href="classFiniteElementData.html">FiniteElementData</a></code>. </p>

</div>
</div>
<a id="a0714c652edd917e41ad4f8b7912a2da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0714c652edd917e41ad4f8b7912a2da0">&#9670;&nbsp;</a></span>requires_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::requires_update_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a set of update flags, compute which other quantities <em>also</em> need to be computed in order to satisfy the request by the given flags. Then return the combination of the original set of flags and those just computed.</p>
<p>As an example, if <code>update_flags</code> contains update_gradients a finite element class will typically require the computation of the inverse of the Jacobian matrix in order to rotate the gradient of shape functions on the reference cell to the real cell. It would then return not just update_gradients, but also update_covariant_transformation, the flag that makes the mapping class produce the inverse of the Jacobian matrix.</p>
<p>An extensive discussion of the interaction between this function and <a class="el" href="classFEValues.html">FEValues</a> can be found in the <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and FEValues work together</a> documentation module.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> </dd></dl>

<p>Implements <a class="el" href="classFiniteElement.html#a7ee9f47da3fcdfc8c1ca7c7a0feb1929">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a9b08811dba57c3485426c8a4c71631d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b08811dba57c3485426c8a4c71631d4">&#9670;&nbsp;</a></span>shape_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::shape_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the (scalar) value of shape function <code>i</code> at the given quadrature point <code>p</code>. Since the elements represented by this class are vector valued, there is no such scalar value and the function therefore throws an exception. </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#ada115873f976e6078b3990ac28a70ea1">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a607518e45ad02f9997ed5486f9c5d8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607518e45ad02f9997ed5486f9c5d8fb">&#9670;&nbsp;</a></span>shape_value_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a> <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::shape_value_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just like for <a class="el" href="classFE__PolyTensor.html#a9b08811dba57c3485426c8a4c71631d4">shape_value()</a>, but this function will be called when the shape function has more than one non-zero vector component. In that case, this function should return the value of the <code>component-th</code> vector component of the <code>ith</code> shape function at point <code>p</code>. </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#a7296a43734ce3ba8cb393ff472521bbf">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a7cff83feff9e6d7fce635e08a8cdf49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cff83feff9e6d7fce635e08a8cdf49c">&#9670;&nbsp;</a></span>shape_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim&gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::shape_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the gradient of (scalar) shape function <code>i</code> at the given quadrature point <code>p</code>. Since the elements represented by this class are vector valued, there is no such scalar value and the function therefore throws an exception. </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#acbe2c4ae879fa50f40a04bc586232566">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="acafcfbb9a08f1665c5c35ff2341333e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafcfbb9a08f1665c5c35ff2341333e0">&#9670;&nbsp;</a></span>shape_grad_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim&gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::shape_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just like for <a class="el" href="classFE__PolyTensor.html#a7cff83feff9e6d7fce635e08a8cdf49c">shape_grad()</a>, but this function will be called when the shape function has more than one non-zero vector component. In that case, this function should return the gradient of the <code>component-th</code> vector component of the <code>ith</code> shape function at point <code>p</code>. </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#af60d83969af1e9b5082513fbf1266771">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a81173894f92fc73d97ab24d428f2ee54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81173894f92fc73d97ab24d428f2ee54">&#9670;&nbsp;</a></span>shape_grad_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;2, dim&gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::shape_grad_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of (scalar) shape function <code>i</code> at the given quadrature point <code>p</code>. Since the elements represented by this class are vector valued, there is no such scalar value and the function therefore throws an exception. </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#a1cb1c323ae3ebdeca8c330861e35fcac">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a0d39732550551c965be0c3a05a8baf95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d39732550551c965be0c3a05a8baf95">&#9670;&nbsp;</a></span>shape_grad_grad_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;2, dim&gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::shape_grad_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just like for <a class="el" href="classFE__PolyTensor.html#a81173894f92fc73d97ab24d428f2ee54">shape_grad_grad()</a>, but this function will be called when the shape function has more than one non-zero vector component. In that case, this function should return the gradient of the <code>component-th</code> vector component of the <code>ith</code> shape function at point <code>p</code>. </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#a2e74d93f2e11913b4410c2284069a841">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="adbafd47e79bfff9a4d6992cd407b9357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbafd47e79bfff9a4d6992cd407b9357">&#9670;&nbsp;</a></span>single_mapping_kind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::single_mapping_kind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a boolean that is true when the finite element uses a single mapping and false when the finite element uses multiple mappings. </p>

</div>
</div>
<a id="ab02356fe38fd14f9a169ae99ade355b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02356fe38fd14f9a169ae99ade355b5">&#9670;&nbsp;</a></span>adjust_quad_dof_sign_for_face_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::adjust_quad_dof_sign_for_face_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For faces with non-standard face_orientation in 3D, the dofs on faces (quads) have to be permuted in order to be combined with the correct shape functions and additionally can change the sign. Given a local dof <code>index</code> on a quad, return the sign of the permuted shape function, if the face has non-standard face_orientation, face_flip or face_rotation. In 2D and 1D there is no need for permutation and consequently it does nothing in this case.</p>
<p>The permutation itself is returned by adjust_quad_dof_index_for_face_orientation implemented in the interface class <a class="el" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a>. </p>

</div>
</div>
<a id="acea9b13e048ed08291ba5a7e948c16a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea9b13e048ed08291ba5a7e948c16a8">&#9670;&nbsp;</a></span>get_mapping_kind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::get_mapping_kind </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns MappingKind <code>i</code> for the finite element. </p>

</div>
</div>
<a id="a3120826089c7acfa86648238856fbfe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3120826089c7acfa86648238856fbfe0">&#9670;&nbsp;</a></span>get_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::get_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an internal data object and return a pointer to it of which the caller of this function then assumes ownership. This object will then be passed to the <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> every time the finite element shape functions and their derivatives are evaluated on a concrete cell. The object created here is therefore used by derived classes as a place for scratch objects that are used in evaluating shape functions, as well as to store information that can be pre-computed once and re-used on every cell (e.g., for evaluating the values and gradients of shape functions on the reference cell, for later re-use when transforming these values to a concrete cell).</p>
<p>This function is the first one called in the process of initializing a <a class="el" href="classFEValues.html">FEValues</a> object for a given mapping and finite element object. The returned object will later be passed to <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> for a concrete cell, which will itself place its output into an object of type <a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>. Since there may be data that can already be computed in its <em>final</em> form on the reference cell, this function also receives a reference to the <a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a> object as its last argument. This output argument is guaranteed to always be the same one when used with the InternalDataBase object returned by this function. In other words, the subdivision of scratch data and final data in the returned object and the <code>output_data</code> object is as follows: If data can be pre- computed on the reference cell in the exact form in which it will later be needed on a concrete cell, then this function should already emplace it in the <code>output_data</code> object. An example are the values of shape functions at quadrature points for the usual Lagrange elements which on a concrete cell are identical to the ones on the reference cell. On the other hand, if some data can be pre-computed to make computations on a concrete cell <em>cheaper</em>, then it should be put into the returned object for later re-use in a derive class's implementation of <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a>. An example are the gradients of shape functions on the reference cell for Lagrange elements: to compute the gradients of the shape functions on a concrete cell, one has to multiply the gradients on the reference cell by the inverse of the Jacobian of the mapping; consequently, we cannot already compute the gradients on a concrete cell at the time the current function is called, but we can at least pre-compute the gradients on the reference cell, and store it in the object returned.</p>
<p>An extensive discussion of the interaction between this function and <a class="el" href="classFEValues.html">FEValues</a> can be found in the <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and FEValues work together</a> documentation module. See also the documentation of the InternalDataBase class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">update_flags</td><td>A set of UpdateFlags values that describe what kind of information the <a class="el" href="classFEValues.html">FEValues</a> object requests the finite element to compute. This set of flags may also include information that the finite element can not compute, e.g., flags that pertain to data produced by the mapping. An implementation of this function needs to set up all data fields in the returned object that are necessary to produce the finite- element related data specified by these flags, and may already pre- compute part of this information as discussed above. Elements may want to store these update flags (or a subset of these flags) in <a class="el" href="classFiniteElement_1_1InternalDataBase.html#a99c4ead335ec713b3f9b3cdc8b5a1f40">InternalDataBase::update_each</a> so they know at the time when <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> is called what they are supposed to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>A reference to the mapping used for computing values and derivatives of shape functions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the object that describes where the shape functions should be evaluated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to the object that <a class="el" href="classFEValues.html">FEValues</a> will use in conjunction with the object returned here and where an implementation of <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> will place the requested information. This allows the current function to already pre-compute pieces of information that can be computed on the reference cell, as discussed above. <a class="el" href="classFEValues.html">FEValues</a> guarantees that this output object and the object returned by the current function will always be used together. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an object of a type derived from InternalDataBase and that derived classes can use to store scratch data that can be pre- computed, or for scratch arrays that then only need to be allocated once. The calling site assumes ownership of this object and will delete it when it is no longer necessary. </dd></dl>

<p>Implements <a class="el" href="classFiniteElement.html#a83c2e3851e02752d6b241fd402cc0bcd">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00278">278</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="acb57d4a4352bcc359d06b50e5d46130c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb57d4a4352bcc359d06b50e5d46130c">&#9670;&nbsp;</a></span>fill_fe_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a76218870e645f59e07c7ab650cf31a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76218870e645f59e07c7ab650cf31a79">&#9670;&nbsp;</a></span>fill_fe_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute information about the shape functions on the cell denoted by the first argument. Derived classes will have to implement this function based on the kind of element they represent. It is called by <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a>.</p>
<p>Conceptually, this function evaluates shape functions and their derivatives at the quadrature points represented by the mapped locations of those described by the quadrature argument to this function. In many cases, computing derivatives of shape functions (and in some cases also computing values of shape functions) requires making use of the mapping from the reference to the real cell; this information can either be taken from the <code>mapping_data</code> object that has been filled for the current cell before this function is called, or by calling the member functions of a <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> object with the <code>mapping_internal</code> object that also corresponds to the current cell.</p>
<p>The information computed by this function is used to fill the various member variables of the output argument of this function. Which of the member variables of that structure should be filled is determined by the update flags stored in the <a class="el" href="classFiniteElement_1_1InternalDataBase.html#a99c4ead335ec713b3f9b3cdc8b5a1f40">FiniteElement::InternalDataBase::update_each</a> field of the object passed to this function. These flags are typically set by <a class="el" href="classFiniteElement.html#a83c2e3851e02752d6b241fd402cc0bcd">FiniteElement::get_data()</a>, FiniteElement::get_face_date() and <a class="el" href="classFiniteElement.html#a450e656fc6a48e7a6f1a9546713fcbf5">FiniteElement::get_subface_data()</a> (or, more specifically, implementations of these functions in derived classes).</p>
<p>An extensive discussion of the interaction between this function and <a class="el" href="classFEValues.html">FEValues</a> can be found in the <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and FEValues work together</a> documentation module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The cell of the triangulation for which this function is to compute a mapping from the reference cell to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_similarity</td><td>Whether or not the cell given as first argument is simply a translation, rotation, etc of the cell for which this function was called the most recent time. This information is computed simply by matching the vertices (as stored by the <a class="el" href="classTriangulation.html">Triangulation</a>) between the previous and the current cell. The value passed here may be modified by implementations of this function and should then be returned (see the discussion of the return value of this function). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the quadrature formula in use for the current evaluation. This quadrature object is the same as the one used when creating the <code>internal_data</code> object. The current object is then responsible for evaluating shape functions at the mapped locations of the quadrature points represented by this object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>A reference to the mapping object used to map from the reference cell to the current cell. This object was used to compute the information in the <code>mapping_data</code> object before the current function was called. It is also the mapping object that created the <code>mapping_internal</code> object via <a class="el" href="classMapping.html#a2fdce92a1ba733f9652de666d3475a34">Mapping::get_data()</a>. You will need the reference to this mapping object most often to call <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping::transform()</a> to transform gradients and higher derivatives from the reference to the current cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_internal</td><td>An object specific to the mapping object. What the mapping chooses to store in there is of no relevance to the current function, but you may have to pass a reference to this object to certain functions of the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> class (e.g., <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping::transform()</a>) if you need to call them from the current function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_data</td><td>The output object into which the <a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a> function wrote the mapping information corresponding to the current cell. This includes, for example, Jacobians of the mapping that may be of relevance to the current function, as well as other information that <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> requested from the mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_internal</td><td>A reference to an object previously created by <a class="el" href="classFE__PolyTensor.html#a3120826089c7acfa86648238856fbfe0">get_data()</a> and that may be used to store information the mapping can compute once on the reference cell. See the documentation of the <a class="el" href="classFiniteElement_1_1InternalDataBase.html">FiniteElement::InternalDataBase</a> class for an extensive description of the purpose of these objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to an object whose member variables should be computed. Not all of the members of this argument need to be filled; which ones need to be filled is determined by the update flags stored inside the <code>fe_internal</code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classFEValues.html">FEValues</a> ensures that this function is always called with the same pair of <code>fe_internal</code> and <code>output_data</code> objects. In other words, if an implementation of this function knows that it has written a piece of data into the output argument in a previous call, then there is no need to copy it there again in a later call if the implementation knows that this is the same value. </dd></dl>

</div>
</div>
<a id="ad4560cde3da4b06fe983caa200f7f83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4560cde3da4b06fe983caa200f7f83e">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c5fd937dc322e6028f60c30fc65f185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5fd937dc322e6028f60c30fc65f185">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is the equivalent to <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a>, but for faces of cells. See there for an extensive discussion of its purpose. It is called by <a class="el" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">FEFaceValues::reinit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The cell of the triangulation for which this function is to compute a mapping from the reference cell to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>The number of the face we are currently considering, indexed among the faces of the cell specified by the previous argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the quadrature formula in use for the current evaluation. This quadrature object is the same as the one used when creating the <code>internal_data</code> object. The current object is then responsible for evaluating shape functions at the mapped locations of the quadrature points represented by this object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>A reference to the mapping object used to map from the reference cell to the current cell. This object was used to compute the information in the <code>mapping_data</code> object before the current function was called. It is also the mapping object that created the <code>mapping_internal</code> object via <a class="el" href="classMapping.html#a2fdce92a1ba733f9652de666d3475a34">Mapping::get_data()</a>. You will need the reference to this mapping object most often to call <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping::transform()</a> to transform gradients and higher derivatives from the reference to the current cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_internal</td><td>An object specific to the mapping object. What the mapping chooses to store in there is of no relevance to the current function, but you may have to pass a reference to this object to certain functions of the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> class (e.g., <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping::transform()</a>) if you need to call them from the current function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_data</td><td>The output object into which the <a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a> function wrote the mapping information corresponding to the current cell. This includes, for example, Jacobians of the mapping that may be of relevance to the current function, as well as other information that <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> requested from the mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_internal</td><td>A reference to an object previously created by <a class="el" href="classFE__PolyTensor.html#a3120826089c7acfa86648238856fbfe0">get_data()</a> and that may be used to store information the mapping can compute once on the reference cell. See the documentation of the <a class="el" href="classFiniteElement_1_1InternalDataBase.html">FiniteElement::InternalDataBase</a> class for an extensive description of the purpose of these objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to an object whose member variables should be computed. Not all of the members of this argument need to be filled; which ones need to be filled is determined by the update flags stored inside the <code>fe_internal</code> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd572e784ad8c26c2c41c9fc3ce86ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd572e784ad8c26c2c41c9fc3ce86ed6">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>Use the version taking a <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> argument. </dd></dl>

</div>
</div>
<a id="a8d7943632de4e3fe21b1a82e926c6170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7943632de4e3fe21b1a82e926c6170">&#9670;&nbsp;</a></span>fill_fe_subface_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>sub_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ace7af117168f8d0fdb4bbdd516373625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7af117168f8d0fdb4bbdd516373625">&#9670;&nbsp;</a></span>fill_fe_subface_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>sub_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is the equivalent to <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a>, but for the children of faces of cells. See there for an extensive discussion of its purpose. It is called by <a class="el" href="classFESubfaceValues.html#a341778d1291f936d5192a39f2531472a">FESubfaceValues::reinit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The cell of the triangulation for which this function is to compute a mapping from the reference cell to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>The number of the face we are currently considering, indexed among the faces of the cell specified by the previous argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_no</td><td>The number of the subface, i.e., the number of the child of a face, that we are currently considering, indexed among the children of the face specified by the previous argument. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the quadrature formula in use for the current evaluation. This quadrature object is the same as the one used when creating the <code>internal_data</code> object. The current object is then responsible for evaluating shape functions at the mapped locations of the quadrature points represented by this object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>A reference to the mapping object used to map from the reference cell to the current cell. This object was used to compute the information in the <code>mapping_data</code> object before the current function was called. It is also the mapping object that created the <code>mapping_internal</code> object via <a class="el" href="classMapping.html#a2fdce92a1ba733f9652de666d3475a34">Mapping::get_data()</a>. You will need the reference to this mapping object most often to call <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping::transform()</a> to transform gradients and higher derivatives from the reference to the current cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_internal</td><td>An object specific to the mapping object. What the mapping chooses to store in there is of no relevance to the current function, but you may have to pass a reference to this object to certain functions of the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> class (e.g., <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping::transform()</a>) if you need to call them from the current function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_data</td><td>The output object into which the <a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a> function wrote the mapping information corresponding to the current cell. This includes, for example, Jacobians of the mapping that may be of relevance to the current function, as well as other information that <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> requested from the mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_internal</td><td>A reference to an object previously created by <a class="el" href="classFE__PolyTensor.html#a3120826089c7acfa86648238856fbfe0">get_data()</a> and that may be used to store information the mapping can compute once on the reference cell. See the documentation of the <a class="el" href="classFiniteElement_1_1InternalDataBase.html">FiniteElement::InternalDataBase</a> class for an extensive description of the purpose of these objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to an object whose member variables should be computed. Not all of the members of this argument need to be filled; which ones need to be filled is determined by the update flags stored inside the <code>fe_internal</code> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dec8349bbe812f6fc8a714eaae30364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dec8349bbe812f6fc8a714eaae30364">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::unique_ptr&lt;<a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt; &gt;, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>multiplicity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates information for creating a <a class="el" href="classFESystem.html">FESystem</a> with this class as base element and with multiplicity <code>multiplicity</code>. In particular, the return type of this function can be used in the constructor for a <a class="el" href="classFESystem.html">FESystem</a> object. This function calls <a class="el" href="classFE__DGVector.html#a3e25f164fd98df828a00b9e488c37cb6">clone()</a> and hence creates a copy of the current object. </p>

</div>
</div>
<a id="a623b0c5a085bc13c826f3d78459a407f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623b0c5a085bc13c826f3d78459a407f">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operator returns a reference to the present object if the argument given equals to zero. While this does not seem particularly useful, it is helpful in writing code that works with both <a class="el" href="classDoFHandler.html">DoFHandler</a> and the hp- version <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a>, since one can then write code like this: </p><div class="fragment"><div class="line"><a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a> =</div><div class="line">  dof_handler-&gt;get_fe()[cell-&gt;active_fe_index()].n_dofs_per_cell();</div></div><!-- fragment --><p>This code doesn't work in both situations without the present operator because <a class="el" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">DoFHandler::get_fe()</a> returns a finite element, whereas hp::DoFHandler::get_fe() returns a collection of finite elements that doesn't offer a <code>dofs_per_cell</code> member variable: one first has to select which finite element to work on, which is done using the operator[]. Fortunately, <code>cell-&gt;active_fe_index()</code> also works for non-hp-classes and simply returns zero in that case. The present operator[] accepts this zero argument, by returning the finite element with index zero within its collection (that, of course, consists only of the present finite element anyway).</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>With DoFHandler::get_fe(int) and the deprecation of the <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> class, there is no more use of this operator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03088">3088</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a8a6d8333e73fa0e5af7d43fe74a06e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6d8333e73fa0e5af7d43fe74a06e2c">&#9670;&nbsp;</a></span>shape_3rd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;3, dim&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of third derivatives of the <code>ith</code> shape function at point <code>p</code> on the unit cell. The derivatives are derivatives on the unit cell with respect to unit cell coordinates. If the finite element is vector-valued, then return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non- primitive), then derived classes implementing this function should throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFiniteElement.html#aa19e0baf900a7dc723e082acd04cf749">shape_3rd_derivative_component()</a> function.</p>
<p>Implementations of this function should throw an exception of type ExcUnitShapeValuesDoNotExist if the shape functions of the <a class="el" href="classFiniteElement.html">FiniteElement</a> under consideration depend on the shape of the cell in real space, i.e., if the shape functions are not defined by mapping from the reference cell. Some non-conforming elements are defined this way, as is the <a class="el" href="classFE__DGPNonparametric.html">FE_DGPNonparametric</a> class, to name just one example.</p>
<p>The default implementation of this virtual function does exactly this, i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a7886198e8af5a27191a9118ac85a4135">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#aa59119ad4067e65e27c7889266dd43a6">FE_Poly&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#aa59119ad4067e65e27c7889266dd43a6">FE_Poly&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="aa19e0baf900a7dc723e082acd04cf749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19e0baf900a7dc723e082acd04cf749">&#9670;&nbsp;</a></span>shape_3rd_derivative_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;3, dim&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_3rd_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just like for <a class="el" href="classFiniteElement.html#a8a6d8333e73fa0e5af7d43fe74a06e2c">shape_3rd_derivative()</a>, but this function will be called when the shape function has more than one non-zero vector component. In that case, this function should return the gradient of the <code>component-</code> th vector component of the <code>ith</code> shape function at point <code>p</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a21c88c3fc150b2ca6272dd7619f9e888">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#aa258a0a78360027cf8bddea4ceb3cbd1">FE_Poly&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#aa258a0a78360027cf8bddea4ceb3cbd1">FE_Poly&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a71d05c63d0fbcae9280f49aa6417ead1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d05c63d0fbcae9280f49aa6417ead1">&#9670;&nbsp;</a></span>shape_4th_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;4, dim&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_4th_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of fourth derivatives of the <code>ith</code> shape function at point <code>p</code> on the unit cell. The derivatives are derivatives on the unit cell with respect to unit cell coordinates. If the finite element is vector-valued, then return the value of the only non-zero component of the vector value of this shape function. If the shape function has more than one non-zero component (which we refer to with the term non- primitive), then derived classes implementing this function should throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFiniteElement.html#a5b04caeb2bb9fe0784db7d4c123604d9">shape_4th_derivative_component()</a> function.</p>
<p>Implementations of this function should throw an exception of type ExcUnitShapeValuesDoNotExist if the shape functions of the <a class="el" href="classFiniteElement.html">FiniteElement</a> under consideration depend on the shape of the cell in real space, i.e., if the shape functions are not defined by mapping from the reference cell. Some non-conforming elements are defined this way, as is the <a class="el" href="classFE__DGPNonparametric.html">FE_DGPNonparametric</a> class, to name just one example.</p>
<p>The default implementation of this virtual function does exactly this, i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a0632bcef7a158890590c0983b7b2dc11">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#aa4d2a9a7e2db3544f8f78b6815ab6f63">FE_Poly&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#aa4d2a9a7e2db3544f8f78b6815ab6f63">FE_Poly&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a5b04caeb2bb9fe0784db7d4c123604d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b04caeb2bb9fe0784db7d4c123604d9">&#9670;&nbsp;</a></span>shape_4th_derivative_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;4, dim&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_4th_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Just like for <a class="el" href="classFiniteElement.html#a71d05c63d0fbcae9280f49aa6417ead1">shape_4th_derivative()</a>, but this function will be called when the shape function has more than one non-zero vector component. In that case, this function should return the gradient of the <code>component-</code> th vector component of the <code>ith</code> shape function at point <code>p</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a66880f9471932ba9eca38086f2a2f457">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a00f27b44c9f21097d7549931d4442ec4">FE_Poly&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#a00f27b44c9f21097d7549931d4442ec4">FE_Poly&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="afcd544abd534ae8ce643f8c21b8be7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd544abd534ae8ce643f8c21b8be7f2">&#9670;&nbsp;</a></span>get_restriction_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_restriction_matrix </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix that describes restricting a finite element field from the given <code>child</code> (as obtained by the given <code>refinement_case</code>) to the parent cell. The interpretation of the returned matrix depends on what <a class="el" href="classFiniteElement.html#a6aa81cef78859c726852a1ee1ef37210">restriction_is_additive()</a> returns for each shape function.</p>
<p>Row and column indices are related to coarse grid and fine grid spaces, respectively, consistent with the definition of the associated operator.</p>
<p>If projection matrices are not implemented in the derived finite element class, this function aborts with an exception of type FiniteElement::ExcProjectionVoid. You can check whether this would happen by first calling the <a class="el" href="classFiniteElement.html#ab8539eac73f0305ba91e612ad5519250">restriction_is_implemented()</a> or the <a class="el" href="classFiniteElement.html#a645ff401ff38407d67a0785163939f87">isotropic_restriction_is_implemented()</a> function. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#aa78b3955be5f0a0dd00613863663ad37">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a794830292475f9f7954e3c372f22eb6d">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#abd9de789b3ab33cb1172f8d630fe55c4">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#a063dddc23a35cac2c56ec178a0777c88">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#aa94cf59302343037d59a53120e2e0452">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ab9bd0a6548a9e86cc756d6431b79ad05">FE_Q_Base&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#ad211f057d54c2393d8e8d3bc80bf7ff6">FE_Bernstein&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__SimplexPoly.html#aa21d1da3e0c864a5528c65fabc9814d1">FE_SimplexPoly&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="af78c7b6503befe61dc6df5eb41c99019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78c7b6503befe61dc6df5eb41c99019">&#9670;&nbsp;</a></span>get_prolongation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_prolongation_matrix </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prolongation/embedding matrix between grids.</p>
<p>The identity operator from a coarse grid space into a fine grid space (where both spaces are identified as functions defined on the parent and child cells) is associated with a matrix <code>P</code> that maps the corresponding representations of these functions in terms of their nodal values. The restriction of this matrix <code>P_i</code> to a single child cell is returned here.</p>
<p>The matrix <code>P</code> is the concatenation, not the sum of the cell matrices <code>P_i</code>. That is, if the same non-zero entry <code>j,k</code> exists in two different child matrices <code>P_i</code>, the value should be the same in both matrices and it is copied into the matrix <code>P</code> only once.</p>
<p>Row and column indices are related to fine grid and coarse grid spaces, respectively, consistent with the definition of the associated operator.</p>
<p>These matrices are used by routines assembling the prolongation matrix for multi-level methods. Upon assembling the transfer matrix between cells using this matrix array, zero elements in the prolongation matrix are discarded and will not fill up the transfer matrix.</p>
<p>If prolongation matrices are not implemented in the derived finite element class, this function aborts with an exception of type FiniteElement::ExcEmbeddingVoid. You can check whether this would happen by first calling the <a class="el" href="classFiniteElement.html#a1ead2dba2770c63493a139bec677ccdb">prolongation_is_implemented()</a> or the <a class="el" href="classFiniteElement.html#a0849d6c4188612816934d5468ecf9e6b">isotropic_prolongation_is_implemented()</a> function. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#ae0c24e15d2cc5acc418b0f5871e03e6f">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#a164d31b07ee4fa125ef82a5aeeb4763b">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__Enriched.html#a13b03dd5790179739d24fc4af71e6392">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a6fa2a0b5bf8ef1d01c55428f8f7507fb">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#a8c2801697f341de97036f3af122b6417">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a12bcc0d544cda4d1efd030839bb1424a">FE_Q_Base&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#accb931ea71dc4beb800264ce0c27ee3f">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#aec8ee608cdef3c8ef4d1c145c121ec5f">FE_Bernstein&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__SimplexPoly.html#a2082b76cc4db0c27311f8bbd9a5a0fc0">FE_SimplexPoly&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a1ead2dba2770c63493a139bec677ccdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ead2dba2770c63493a139bec677ccdb">&#9670;&nbsp;</a></span>prolongation_is_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::prolongation_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this element implements its prolongation matrices. The return value also indicates whether a call to the <a class="el" href="classFiniteElement.html#af78c7b6503befe61dc6df5eb41c99019">get_prolongation_matrix()</a> function will generate an error or not.</p>
<p>Note, that this function returns <code>true</code> only if the prolongation matrices of the isotropic and all anisotropic refinement cases are implemented. If you are interested in the prolongation matrices for isotropic refinement only, use the isotropic_prolongation_is_implemented function instead.</p>
<p>This function is mostly here in order to allow us to write more efficient test programs which we run on all kinds of weird elements, and for which we simply need to exclude certain tests in case something is not implemented. It will in general probably not be a great help in applications, since there is not much one can do if one needs these features and they are not implemented. This function could be used to check whether a call to <code><a class="el" href="classFiniteElement.html#af78c7b6503befe61dc6df5eb41c99019">get_prolongation_matrix()</a></code> will succeed; however, one then still needs to cope with the lack of information this just expresses. </p>

</div>
</div>
<a id="a0849d6c4188612816934d5468ecf9e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0849d6c4188612816934d5468ecf9e6b">&#9670;&nbsp;</a></span>isotropic_prolongation_is_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::isotropic_prolongation_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this element implements its prolongation matrices for isotropic children. The return value also indicates whether a call to the <code>get_prolongation_matrix</code> function will generate an error or not.</p>
<p>This function is mostly here in order to allow us to write more efficient test programs which we run on all kinds of weird elements, and for which we simply need to exclude certain tests in case something is not implemented. It will in general probably not be a great help in applications, since there is not much one can do if one needs these features and they are not implemented. This function could be used to check whether a call to <code><a class="el" href="classFiniteElement.html#af78c7b6503befe61dc6df5eb41c99019">get_prolongation_matrix()</a></code> will succeed; however, one then still needs to cope with the lack of information this just expresses. </p>

</div>
</div>
<a id="ab8539eac73f0305ba91e612ad5519250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8539eac73f0305ba91e612ad5519250">&#9670;&nbsp;</a></span>restriction_is_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this element implements its restriction matrices. The return value also indicates whether a call to the <a class="el" href="classFiniteElement.html#afcd544abd534ae8ce643f8c21b8be7f2">get_restriction_matrix()</a> function will generate an error or not.</p>
<p>Note, that this function returns <code>true</code> only if the restriction matrices of the isotropic and all anisotropic refinement cases are implemented. If you are interested in the restriction matrices for isotropic refinement only, use the <a class="el" href="classFiniteElement.html#a645ff401ff38407d67a0785163939f87">isotropic_restriction_is_implemented()</a> function instead.</p>
<p>This function is mostly here in order to allow us to write more efficient test programs which we run on all kinds of weird elements, and for which we simply need to exclude certain tests in case something is not implemented. It will in general probably not be a great help in applications, since there is not much one can do if one needs these features and they are not implemented. This function could be used to check whether a call to <code><a class="el" href="classFiniteElement.html#afcd544abd534ae8ce643f8c21b8be7f2">get_restriction_matrix()</a></code> will succeed; however, one then still needs to cope with the lack of information this just expresses. </p>

</div>
</div>
<a id="a645ff401ff38407d67a0785163939f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645ff401ff38407d67a0785163939f87">&#9670;&nbsp;</a></span>isotropic_restriction_is_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::isotropic_restriction_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this element implements its restriction matrices for isotropic children. The return value also indicates whether a call to the <a class="el" href="classFiniteElement.html#afcd544abd534ae8ce643f8c21b8be7f2">get_restriction_matrix()</a> function will generate an error or not.</p>
<p>This function is mostly here in order to allow us to write more efficient test programs which we run on all kinds of weird elements, and for which we simply need to exclude certain tests in case something is not implemented. It will in general probably not be a great help in applications, since there is not much one can do if one needs these features and they are not implemented. This function could be used to check whether a call to <code><a class="el" href="classFiniteElement.html#afcd544abd534ae8ce643f8c21b8be7f2">get_restriction_matrix()</a></code> will succeed; however, one then still needs to cope with the lack of information this just expresses. </p>

</div>
</div>
<a id="a6aa81cef78859c726852a1ee1ef37210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa81cef78859c726852a1ee1ef37210">&#9670;&nbsp;</a></span>restriction_is_additive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction_is_additive </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the <a class="el" href="classFiniteElement.html#aa8f4833a318127b42d2dc806bffe1c2c">restriction_is_additive_flags</a> field. See the discussion about restriction matrices in the general class documentation for more information.</p>
<p>The index must be between zero and the number of shape functions of this element. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03271">3271</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a75a89da67f07c3b699f3712159c003ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a89da67f07c3b699f3712159c003ac">&#9670;&nbsp;</a></span>constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::constraints </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subface_case</em> = <code>::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt;&#160;dim&#160;&gt;::case_isotropic</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read only reference to the matrix that describes the constraints at the interface between a refined and an unrefined cell.</p>
<p>Some finite elements do not (yet) implement hanging node constraints. If this is the case, then this function will generate an exception, since no useful return value can be generated. If you should have a way to live with this, then you might want to use the <a class="el" href="classFiniteElement.html#a01f5b5d1700cf820f8989f35418efbfc">constraints_are_implemented()</a> function to check up front whether this function will succeed or generate the exception. </p>

</div>
</div>
<a id="a01f5b5d1700cf820f8989f35418efbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f5b5d1700cf820f8989f35418efbfc">&#9670;&nbsp;</a></span>constraints_are_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::constraints_are_implemented </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subface_case</em> = <code>::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt;&#160;dim&#160;&gt;::case_isotropic</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this element implements its hanging node constraints. The return value also indicates whether a call to the <a class="el" href="classFiniteElement.html#a75a89da67f07c3b699f3712159c003ac">constraints()</a> function will generate an error or not.</p>
<p>This function is mostly here in order to allow us to write more efficient test programs which we run on all kinds of weird elements, and for which we simply need to exclude certain tests in case hanging node constraints are not implemented. It will in general probably not be a great help in applications, since there is not much one can do if one needs hanging node constraints and they are not implemented. This function could be used to check whether a call to <code><a class="el" href="classFiniteElement.html#a75a89da67f07c3b699f3712159c003ac">constraints()</a></code> will succeed; however, one then still needs to cope with the lack of information this just expresses. </p>

</div>
</div>
<a id="af92fb4945b3dd83fc513abd3e612f022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92fb4945b3dd83fc513abd3e612f022">&#9670;&nbsp;</a></span>hp_constraints_are_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_constraints_are_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this element implements its hanging node constraints in the new way, which has to be used to make elements "hp-compatible". That means, the element properly implements the get_face_interpolation_matrix and get_subface_interpolation_matrix methods. Therefore the return value also indicates whether a call to the <a class="el" href="classFiniteElement.html#ada551320eb695448249601e69bd46a66">get_face_interpolation_matrix()</a> method and the <a class="el" href="classFiniteElement.html#a7a764505812713f679a5ad64033077d6">get_subface_interpolation_matrix()</a> method will generate an error or not.</p>
<p>Currently the main purpose of this function is to allow the make_hanging_node_constraints method to decide whether the new procedures, which are supposed to work in the hp-framework can be used, or if the old well verified but not hp-capable functions should be used. Once the transition to the new scheme for computing the interface constraints is complete, this function will be superfluous and will probably go away.</p>
<p>Derived classes should implement this function accordingly. The default assumption is that a finite element does not provide hp-capable face interpolation, and the default implementation therefore returns <code>false</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a928be8e2a0821ee9ce6b49d8e6af31e4">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#a01cf16597b416fc16b40a9db86f5b496">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__FaceP.html#a1f14d8a077b9d57b7e612fb510c97eb6">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#af4401a334d75921e0583b3440af1591e">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a549d90fd0662bcf266df60c89617f3f7">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomasNodal.html#a53b70cded478ad4b67b8cd71939f28d8">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFE__DGPMonomial.html#a0496ddcffece15cb1936fc3b460bc3ef">FE_DGPMonomial&lt; dim &gt;</a>, <a class="el" href="classFE__Enriched.html#a00daf2b77ac87926c3f460775f1ebfac">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a73718e36a622f048596353915a7658ca">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a73718e36a622f048596353915a7658ca">FE_Nothing&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#a775a1d1729b81ed51313b9318b73a502">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ_3_011_00_01spacedim_01_4.html#a2f8a4b02a03fa3fac59833c9faf0e784">FE_FaceQ&lt; 1, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a2a82426707f0dc868ba397fbf2fc6427">FE_Q_Base&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a7b68c5032c17efb156d7e0d230a123c5">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__FaceQ.html#a743d5397bff912d1c051c142570ee0b4">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#a50063743e7fb3d5c756ca5094299c37f">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__TraceQ.html#a8568c47b80c0ba7ac6be65fd9268e94c">FE_TraceQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__SimplexPoly.html#a5690b0959afe1c9cba6c5e33e631d02f">FE_SimplexPoly&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a7f0545a749431c39c4048f49e478905e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0545a749431c39c4048f49e478905e">&#9670;&nbsp;</a></span>get_interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from the given finite element to the present one. The size of the matrix is then <a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a> times <code>source.<a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a></code>.</p>
<p>Derived elements will have to implement this function. They may only provide interpolation matrices for certain source finite elements, for example those from the same family. If they don't implement interpolation from a given element, then they must throw an exception of type ExcInterpolationNotImplemented. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a81434b7f789d58de174332cf418fc715">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a06985c4e77ada9e45815721645b93135">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#af54493ced646ce5c80a13b37dec3e5b0">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a89125efa37dcc8d5a5789294d1f39059">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#a83dc0c0a90fa8932bedecef3d7431886">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#a99ab284a1894491fe64c7ec3b3beba1e">FE_Bernstein&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#a3219dca0865bcb1e6a4a2f3de389108f">FE_Q_Base&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ada551320eb695448249601e69bd46a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada551320eb695448249601e69bd46a66">&#9670;&nbsp;</a></span>get_face_interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_face_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from a face of one element to the face of the neighboring element. The size of the matrix is then <code>source.<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code> times <code>this-&gt;<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code>.</p>
<p>Derived elements will have to implement this function. They may only provide interpolation matrices for certain source finite elements, for example those from the same family. If they don't implement interpolation from a given element, then they must throw an exception of type ExcInterpolationNotImplemented. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#acc8da51192aa2016c12acaae3553c5f9">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#a060f705506dcf156e1eb4c315b7ee441">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a74d3ce2b0c87ec29d4acf483db377fd9">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#ac7e85d98cba4e484b947132d0357452c">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a7344705e7ea228a48973290d4b48e97f">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#aff2e07dc06e00c8540340d183a474bdf">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#ac85b2308e702077c87d999f452c207b3">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#ab54f0072af1b3f1cafc4dc9b7570e5aa">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__TraceQ.html#a9593f239a9da3d1f9d7514863a86b0c8">FE_TraceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#aff0668a407a3034b32f6a030165583a9">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexPoly.html#afab3ae394382930183d0323eea98af17">FE_SimplexPoly&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#a8680b615c4e2b9339ab5fcf13bf31138">FE_Q_Base&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a7a764505812713f679a5ad64033077d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a764505812713f679a5ad64033077d6">&#9670;&nbsp;</a></span>get_subface_interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_subface_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the matrix interpolating from a face of one element to the subface of the neighboring element. The size of the matrix is then <code>source.<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code> times <code>this-&gt;<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code>.</p>
<p>Derived elements will have to implement this function. They may only provide interpolation matrices for certain source finite elements, for example those from the same family. If they don't implement interpolation from a given element, then they must throw an exception of type ExcInterpolationNotImplemented. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#ac6cec45533b2bc8ad05563316cdd244d">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#a579ec0e671c8582634db0d84f7279c31">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a59e9c847e310a1e8403fabcb3cf14845">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#af599e3e4939451b866daf11194785be4">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a3a4e4ffab3762d262f9b123246da230a">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a0e1a7021b12809884a7497b8fc3ea6df">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#aff8bcbebe450d850bd001f0c9775d5b7">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#a3abbea307416b20327542603b9444bdb">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__TraceQ.html#a99357283f0a88c6d9bef12f3c54963e5">FE_TraceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#aa528e00a4e528e3df3de83926cab126c">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a8507069b81c5cdacf0bc605a36b95c8b">FE_Q_Base&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__SimplexPoly.html#a45c30c34277f222736405ac1b5e16e46">FE_SimplexPoly&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a2dd93e3d4f1f81301e6ae5f1b4832b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd93e3d4f1f81301e6ae5f1b4832b26">&#9670;&nbsp;</a></span>hp_vertex_dof_identities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_vertex_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If, on a vertex, several finite elements are active, the hp-code first assigns the degrees of freedom of each of these FEs different global indices. It then calls this function to find out which of them should get identical values, and consequently can receive the same global DoF index. This function therefore returns a list of identities between DoFs of the present finite element object with the DoFs of <code>fe_other</code>, which is a reference to a finite element object representing one of the other finite elements active on this particular vertex. The function computes which of the degrees of freedom of the two finite element objects are equivalent, both numbered between zero and the corresponding value of <a class="el" href="classFiniteElementData.html#a0d1f06778f87a7606cc2e0d5338b41ab">n_dofs_per_vertex()</a> of the two finite elements. The first index of each pair denotes one of the vertex dofs of the present element, whereas the second is the corresponding index of the other finite element. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a2743be5a59591e0746df95a660ca868e">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#ab82d20af6d3556ec3f9c06a698489baf">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#aef7e0b6f5ac3238463ca9a4edadf9341">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a80b06d0a5145e342aa13d08ae5496bc1">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a556fb9fe441331dfa939727023a96ab1">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a58d01b9bd0d76666f186c2908349bcbb">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#aa00400957f6cc38e4accba02edb0ad2f">FE_Q_Base&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexDGP.html#a9d0c906b1d2a184d5affb83ddac63b52">FE_SimplexDGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#aa20943d38a1ae639e0794b7495aeb1d4">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexP.html#a4e1d10bafafc25c0c65d58273ecf1c11">FE_SimplexP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#a83c43530d42e470b830ac0a5bb56abfd">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PyramidP.html#a3fe4a9d32e1de1e7ccb33e750eec296e">FE_PyramidP&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__WedgeP.html#ac92df3ca985fc0a0f1ac8ee42832e430">FE_WedgeP&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ace71f6d638de257e5791bfa7cd43e083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace71f6d638de257e5791bfa7cd43e083">&#9670;&nbsp;</a></span>hp_line_dof_identities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_line_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as hp_vertex_dof_indices(), except that the function treats degrees of freedom on lines. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a2376198fb1a52db80d3eb59bdaa19d27">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#aa564fd7b2dc013fdf46ea3708a066256">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#aef4e08256c6fe6a4a7312db3691e8643">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#aa1227ce926d6a9f0754807a30b24784a">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a5a2f524f5f69d7aecf21a3d861665b22">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a8662c262f4fea25489cd0182a7f1535d">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ac5c443be5255eaec0fa5f9d72bf6e708">FE_Q_Base&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexDGP.html#a23410d3fdd7591bf25afdf242253fda1">FE_SimplexDGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#aad37a9421e43944ff14d2b7e9d25dd37">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexP.html#a0c60f57182b849bf3cf64606fdbccf08">FE_SimplexP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#a76fd836c43e2d7c151fdef0820186199">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PyramidP.html#a2f1869c06310fb74867c9bc0d54376f1">FE_PyramidP&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__WedgeP.html#a478c46a4007c7c5fd1f9628adc8bbc88">FE_WedgeP&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ac728e4ad74d39b32883ef76dd5b99b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac728e4ad74d39b32883ef76dd5b99b61">&#9670;&nbsp;</a></span>hp_quad_dof_identities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_quad_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as hp_vertex_dof_indices(), except that the function treats degrees of freedom on quads. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a5bd093ee5bdcbc956d49307f6a905975">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a4cce11b554c0c96c6bf788cfe6c117bd">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a7bb9762296d6954d558db8146ab51164">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#af47a61dec958dae30ed7bbfd6e23adeb">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a994da8a3c93aa7bc092900f8220a5221">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a42a4ca85d7148f7159b4dda514216057">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#ae4025e69f78655106e4d5ba1e103c5c0">FE_Q_Base&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#a7c96292ca65dc684888c11a7abd9e7c7">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#aa3b0fde12d0707fcf8e060241556239e">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PyramidP.html#aaca8b30c90346ebd06d0a01caee338a3">FE_PyramidP&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__WedgeP.html#a2b338c10de93c58f0d50cff2ceeadedb">FE_WedgeP&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a0acf7f396d861978209890fa268bdcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acf7f396d861978209890fa268bdcbe">&#9670;&nbsp;</a></span>compare_for_domination()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::compare_for_domination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this element dominates another one given as argument <code>fe_other</code>, whether it is the other way around, whether neither dominates, or if either could dominate. The <code>codim</code> parameter describes the codimension of the investigated subspace and specifies that it is subject to this comparison. For example, if <code>codim==0</code> then this function compares which element dominates at the cell level. If <code>codim==1</code>, then the elements are compared at faces, i.e., the comparison happens between the function spaces of the two finite elements as restricted to a face. Larger values of <code>codim</code> work correspondingly.</p>
<p>For a definition of domination, see <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a> and in particular the <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a596cd1dbcdad862b8ee5611c961fc1c7">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q.html#abec4c53f61d3d6be0667c02578207c20">FE_Q&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#adb4ce4bf42098869f6e75f2ebe359923">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a95ab8df8e36e10aa467215cff298def6">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#abb520af627df08e163971c92d91a6c8e">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a5a91874184581363adbdd1a592e1691b">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#a5f0a1ffc28d16b59ec3bc3431750b18d">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a7d3eb17cafc09cc7c27d5a3c8db481c4">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#ad11054a3b32e5e73b213f1300987e971">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexDGP.html#a0061240a4a03b33f83528620d9f14ab5">FE_SimplexDGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#a6168cc8dbee54c4e0d5d010d26be1cfa">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#a4d559c18d6e56e2d00a3ed893817b1ae">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#aa63241256f9dd60b8b03e04fcec52379">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__iso__Q1.html#a90926c7e82b1dfdb9761fdb8d1e2515a">FE_Q_iso_Q1&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexP.html#a7782c9d9917e45bd1a7dc94f7e982e8c">FE_SimplexP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__TraceQ.html#a9e8ba4fc02c008cf88773094dbe0ac64">FE_TraceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PyramidP.html#aec8e80a12b0d54d4e346d64b82dddfcd">FE_PyramidP&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__WedgeP.html#ac371eb89e8a6bb7942c25df2b5ce66bd">FE_WedgeP&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a55b5775df3e42a3fcca19aee960d6f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b5775df3e42a3fcca19aee960d6f4a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator.</p>
<p>The implementation in the current class checks for equality of the following pieces of information between the current object and the one given as argument, in this order:</p><ul>
<li>the dynamic type (i.e., the type of the most derived class) of the current object and of the given object,</li>
<li>the name returned by <a class="el" href="classFE__DGVector.html#a14525444fb5700986552bae390345880">get_name()</a>,</li>
<li>as all of the fields in <a class="el" href="classFiniteElementData.html">FiniteElementData</a>,</li>
<li>constraint matrices.</li>
</ul>
<p>This covers most cases where elements can differ, but there are cases of derived elements that are different and for which the current function still returns <code>true</code>. For these cases, derived classes should overload this function.</p>
<dl class="section note"><dt>Note</dt><dd>This operator specifically does not check the following member variables of the current class:<ul>
<li>restriction matrices,</li>
<li>prolongation matrices of this object and the argument. This is because these member variables may be initialized only on demand by derived classes, rather than being available immediately. Consequently, comparing these members would not only be costly because these are generally big arrays, but also because their computation may be expensive. On the other hand, derived classes for which these arrays may differ for two objects even though the above list compares as equal, will probably want to implement their own <a class="el" href="classFiniteElement.html#a55b5775df3e42a3fcca19aee960d6f4a">operator==()</a> anyway. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a439857c3106a765203a354723dfc7cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439857c3106a765203a354723dfc7cac">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator. </p>

</div>
</div>
<a id="a443a348f7c568cb05b3ec3f18c788f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443a348f7c568cb05b3ec3f18c788f75">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Non-equality comparison operator. Defined in terms of the equality comparison operator. </p>

</div>
</div>
<a id="a86644fe67824373cd51e9ff7fca94f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86644fe67824373cd51e9ff7fca94f8c">&#9670;&nbsp;</a></span>system_to_component_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_component_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute vector component and index of this shape function within the shape functions corresponding to this component from the index of a shape function within this finite element.</p>
<p>If the element is scalar, then the component is always zero, and the index within this component is equal to the overall index.</p>
<p>If the shape function referenced has more than one non-zero component, then it cannot be associated with one vector component, and an exception of type ExcShapeFunctionNotPrimitive will be raised.</p>
<p>Note that if the element is composed of other (base) elements, and a base element has more than one component but all its shape functions are primitive (i.e. are non-zero in only one component), then this mapping contains valid information. However, the index of a shape function of this element within one component (i.e. the second number of the respective entry of this array) does not indicate the index of the respective shape function within the base element (since that has more than one vector-component). For this information, refer to the <a class="el" href="classFiniteElement.html#a870f688170ad210708077eed94642d73">system_to_base_table</a> field and the <a class="el" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index()</a> function.</p>
<p>See the class description above for an example of how this function is typically used.</p>
<p>The use of this function is explained extensively in the step-8 and step-20 tutorial programs as well as in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03100">3100</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ae2ea16b60a6fc644a9bc7097703a53e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ea16b60a6fc644a9bc7097703a53e8">&#9670;&nbsp;</a></span>component_to_system_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_system_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the shape function for the given vector component and index.</p>
<p>If the element is scalar, then the component must be zero, and the index within this component is equal to the overall index.</p>
<p>This is the opposite operation from the <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03133">3133</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="aecb73242a6dca33f8da1bb44a5f00d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb73242a6dca33f8da1bb44a5f00d61">&#9670;&nbsp;</a></span>face_system_to_component_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_component_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index()</a>, but do it for shape functions and their indices on a face. The range of allowed indices is therefore 0..<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a>.</p>
<p>You will rarely need this function in application programs, since almost all application codes only need to deal with cell indices, not face indices. The function is mainly there for use inside the library. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03160">3160</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ae54657bc9ca9484522e7e6e3ca2499bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54657bc9ca9484522e7e6e3ca2499bc">&#9670;&nbsp;</a></span>adjust_quad_dof_index_for_face_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_quad_dof_index_for_face_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For faces with non-standard face_orientation in 3D, the dofs on faces (quads) have to be permuted in order to be combined with the correct shape functions. Given a local dof <code>index</code> on a quad, return the local index, if the face has non-standard face_orientation, face_flip or face_rotation. In 2D and 1D there is no need for permutation and consequently an exception is thrown. </p>

</div>
</div>
<a id="a6c5fb2386a3531ac85e226464294f4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5fb2386a3531ac85e226464294f4d5">&#9670;&nbsp;</a></span>face_to_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_to_cell_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given an index in the natural ordering of indices on a face, return the index of the same degree of freedom on the cell.</p>
<p>To explain the concept, consider the case where we would like to know whether a degree of freedom on a face, for example as part of an <a class="el" href="classFESystem.html">FESystem</a> element, is primitive. Unfortunately, the <a class="el" href="classFiniteElement.html#a626abd282a25193db7f61b4ec53e7385">is_primitive()</a> function in the <a class="el" href="classFiniteElement.html">FiniteElement</a> class takes a cell index, so we would need to find the cell index of the shape function that corresponds to the present face index. This function does that.</p>
<p>Code implementing this would then look like this: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a>; ++i)</div><div class="line"> <span class="keywordflow">if</span> (fe.is_primitive(fe.face_to_cell_index(i, some_face_no)))</div><div class="line">  ... <span class="keywordflow">do</span> whatever</div></div><!-- fragment --><p> The function takes additional arguments that account for the fact that actual faces can be in their standard ordering with respect to the cell under consideration, or can be flipped, oriented, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face_dof_index</td><td>The index of the degree of freedom on a face. This index must be between zero and dofs_per_face. </td></tr>
    <tr><td class="paramname">face</td><td>The number of the face this degree of freedom lives on. This number must be between zero and <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">GeometryInfo::faces_per_cell</a>. </td></tr>
    <tr><td class="paramname">face_orientation</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a>. </td></tr>
    <tr><td class="paramname">face_flip</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a>. </td></tr>
    <tr><td class="paramname">face_rotation</td><td>One part of the description of the orientation of the face. See <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of this degree of freedom within the set of degrees of freedom on the entire cell. The returned value will be between zero and dofs_per_cell.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function exists in this class because that is where it was first implemented. However, it can't really work in the most general case without knowing what element we have. The reason is that when a face is flipped or rotated, we also need to know whether we need to swap the degrees of freedom on this face, or whether they are immune from this. For this, consider the situation of a \(Q_3\) element in 2d. If face_flip is true, then we need to consider the two degrees of freedom on the edge in reverse order. On the other hand, if the element were a \(Q_1^2\), then because the two degrees of freedom on this edge belong to different vector components, they should not be considered in reverse order. What all of this shows is that the function can't work if there are more than one degree of freedom per line or quad, and that in these cases the function will throw an exception pointing out that this functionality will need to be provided by a derived class that knows what degrees of freedom actually represent. </dd></dl>

<p>Reimplemented in <a class="el" href="classFESystem.html#a30e79aafafe7cfa71d5527326541e720">FESystem&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#a5f121cf5ab2ac40a2a892f79baa76bd1">FE_Q_Base&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a5859e4b85feaa0406c4aa571fc4dfa4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5859e4b85feaa0406c4aa571fc4dfa4f">&#9670;&nbsp;</a></span>adjust_line_dof_index_for_line_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_line_dof_index_for_line_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>line_orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For lines with non-standard line_orientation in 3D, the dofs on lines have to be permuted in order to be combined with the correct shape functions. Given a local dof <code>index</code> on a line, return the local index, if the line has non-standard line_orientation. In 2D and 1D there is no need for permutation, so the given index is simply returned. </p>

</div>
</div>
<a id="a12aa649db6e1460a8d30b067af952fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12aa649db6e1460a8d30b067af952fc4">&#9670;&nbsp;</a></span>get_nonzero_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return in which of the vector components of this finite element the <code>ith</code> shape function is non-zero. The length of the returned array is equal to the number of vector components of this element.</p>
<p>For most finite element spaces, the result of this function will be a vector with exactly one element being <code>true</code>, since for most spaces the individual vector components are independent. In that case, the component with the single zero is also the first element of what <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index()</a> returns.</p>
<p>Only for those spaces that couple the components, for example to make a shape function divergence free, will there be more than one <code>true</code> entry. Elements for which this is true are called non-primitive (see <a class="el" href="DEALGlossary.html#GlossPrimitive">GlossPrimitive</a>). </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03282">3282</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ac228df752c9c2462aabf284e862402d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac228df752c9c2462aabf284e862402d0">&#9670;&nbsp;</a></span>n_nonzero_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::n_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return in how many vector components the <code>ith</code> shape function is non- zero. This value equals the number of entries equal to <code>true</code> in the result of the <a class="el" href="classFiniteElement.html#a12aa649db6e1460a8d30b067af952fc4">get_nonzero_components()</a> function.</p>
<p>For most finite element spaces, the result will be equal to one. It is not equal to one only for those ansatz spaces for which vector-valued shape functions couple the individual components, for example in order to make them divergence-free. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03292">3292</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a626abd282a25193db7f61b4ec53e7385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626abd282a25193db7f61b4ec53e7385">&#9670;&nbsp;</a></span>is_primitive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::is_primitive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the entire finite element is primitive, in the sense that all its shape functions are primitive. If the finite element is scalar, then this is always the case.</p>
<p>Since this is an extremely common operation, the result is cached and returned by this function. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03302">3302</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a38241991825f67d635d53d25cb5a2fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38241991825f67d635d53d25cb5a2fda">&#9670;&nbsp;</a></span>is_primitive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::is_primitive </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the <code>ith</code> shape function is primitive in the sense that the shape function is non-zero in only one vector component. Non- primitive shape functions would then, for example, be those of divergence free ansatz spaces, in which the individual vector components are coupled.</p>
<p>The result of the function is <code>true</code> if and only if the result of <code>n_nonzero_components(i)</code> is equal to one. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03311">3311</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ad12fbcc708737aa60fa272d4d3e22aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12fbcc708737aa60fa272d4d3e22aea">&#9670;&nbsp;</a></span>n_base_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::n_base_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of base elements in a mixed discretization.</p>
<p>Note that even for vector valued finite elements, the number of components needs not coincide with the number of base elements, since they may be reused. For example, if you create a <a class="el" href="classFESystem.html">FESystem</a> with three identical finite element classes by using the constructor that takes one finite element and a multiplicity, then the number of base elements is still one, although the number of components of the finite element is equal to the multiplicity. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03114">3114</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a705f734e2f56aa34710defb72299e7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705f734e2f56aa34710defb72299e7c8">&#9670;&nbsp;</a></span>base_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::base_element </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to base element objects. If the element is atomic, then <code>base_element(0)</code> is <code>this</code>. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a76d99a0ab9afd229cf814b9d828b44a2">FESystem&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Enriched.html#aca712c58c8767546a2f33754d9a09c74">FE_Enriched&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aa009769e662e34081f60ff16327db1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa009769e662e34081f60ff16327db1b1">&#9670;&nbsp;</a></span>element_multiplicity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::element_multiplicity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This index denotes how often the base element <code>index</code> is used in a composed element. If the element is atomic, then the result is always equal to one. See the documentation for the <a class="el" href="classFiniteElement.html#ad12fbcc708737aa60fa272d4d3e22aea">n_base_elements()</a> function for more details. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03123">3123</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a9e31b9a8f1f72dc65e970eca1522d183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e31b9a8f1f72dc65e970eca1522d183">&#9670;&nbsp;</a></span>get_sub_fe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_sub_fe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to a contained finite element that matches the components selected by the given <a class="el" href="classComponentMask.html">ComponentMask</a> <code>mask</code>.</p>
<p>For an arbitrarily nested <a class="el" href="classFESystem.html">FESystem</a>, this function returns the inner-most <a class="el" href="classFiniteElement.html">FiniteElement</a> that matches the given mask. The method fails if the <code>mask</code> does not exactly match one of the contained finite elements. It is most useful if the current object is an <a class="el" href="classFESystem.html">FESystem</a>, as the return value can only be <code>this</code> in all other cases.</p>
<p>Note that the returned object can be an <a class="el" href="classFESystem.html">FESystem</a> if the mask matches it but not any of the contained objects.</p>
<p>Let us illustrate the function with the an <a class="el" href="classFESystem.html">FESystem</a> <code>fe</code> with 7 components: </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;2&gt;</a> fe_velocity(<a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>(2), 2);</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> fe_pressure(1);</div><div class="line"><a class="code" href="classFE__DGP.html">FE_DGP&lt;2&gt;</a> fe_dg(0);</div><div class="line"><a class="code" href="classFE__BDM.html">FE_BDM&lt;2&gt;</a> fe_nonprim(1);</div><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;2&gt;</a> fe(fe_velocity, 1, fe_pressure, 1, fe_dg, 2, fe_nonprim, 1);</div></div><!-- fragment --><p>The following table lists all possible component masks you can use: </p><table class="doxtable">
<tr>
<th><a class="el" href="classComponentMask.html">ComponentMask</a> </th><th>Result </th><th>Description  </th></tr>
<tr>
<td><code>[true,true,true,true,true,true,true]</code> </td><td><code>FESystem&lt;2&gt;[FESystem&lt;2&gt;[FE_Q&lt;2&gt;(2)^2]-FE_Q&lt;2&gt;(1)-FE_DGP&lt;2&gt;(0)^2-FE_BDM&lt;2&gt;(1)]</code> </td><td><code>fe</code> itself, the whole <code><a class="el" href="classFESystem.html">FESystem</a></code>   </td></tr>
<tr>
<td><code>[true,true,false,false,false,false,false]</code> </td><td><code>FESystem&lt;2&gt;[FE_Q&lt;2&gt;(2)^2]</code> </td><td>just the <code>fe_velocity</code>   </td></tr>
<tr>
<td><code>[true,false,false,false,false,false,false]</code> </td><td><code>FE_Q&lt;2&gt;(2)</code> </td><td>The first component in <code>fe_velocity</code>   </td></tr>
<tr>
<td><code>[false,true,false,false,false,false,false]</code> </td><td><code>FE_Q&lt;2&gt;(2)</code> </td><td>The second component in <code>fe_velocity</code>   </td></tr>
<tr>
<td><code>[false,false,true,false,false,false,false]</code> </td><td><code>FE_Q&lt;2&gt;(1)</code> </td><td><code>fe_pressure</code>   </td></tr>
<tr>
<td><code>[false,false,false,true,false,false,false]</code> </td><td><code>FE_DGP&lt;2&gt;(0)</code> </td><td>first copy of <code>fe_dg</code>   </td></tr>
<tr>
<td><code>[false,false,false,false,true,false,false]</code> </td><td><code>FE_DGP&lt;2&gt;(0)</code> </td><td>second copy of <code>fe_dg</code>   </td></tr>
<tr>
<td><code>[false,false,false,false,false,true,true]</code> </td><td><code>FE_BDM&lt;2&gt;(1)</code> </td><td>both components of <code>fe_nonprim</code>   </td></tr>
</table>

</div>
</div>
<a id="a4b07708eb577149824c317df6e35f161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b07708eb577149824c317df6e35f161">&#9670;&nbsp;</a></span>get_sub_fe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_sub_fe </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_selected_components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to a contained finite element that matches the components <code>n_selected_components</code> components starting at component with index <code>first_component</code>.</p>
<p>See the other <a class="el" href="classFiniteElement.html#a9e31b9a8f1f72dc65e970eca1522d183">get_sub_fe()</a> function above for more details. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a9d0943cddd61aec42370ee37f27ba385">FESystem&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a95ac75dfc5b9f4e01c34d5865b4ca5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ac75dfc5b9f4e01c34d5865b4ca5a2">&#9670;&nbsp;</a></span>system_to_base_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return for shape function <code>index</code> the base element it belongs to, the number of the copy of this base element (which is between zero and the multiplicity of this element), and the index of this shape function within this base element.</p>
<p>If the element is not composed of others, then base and instance are always zero, and the index is equal to the number of the shape function. If the element is composed of single instances of other elements (i.e. all with multiplicity one) all of which are scalar, then base values and dof indices within this element are equal to the <a class="el" href="classFiniteElement.html#a9af218ae93821b61054de7e88e1734aa">system_to_component_table</a>. It differs only in case the element is composed of other elements and at least one of them is vector-valued itself.</p>
<p>See the class documentation above for an example of how this function is typically used.</p>
<p>This function returns valid values also in the case of vector-valued (i.e. non-primitive) shape functions, in contrast to the <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03195">3195</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a9c4647e72a2670c17849701a6357eb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4647e72a2670c17849701a6357eb87">&#9670;&nbsp;</a></span>face_system_to_base_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index()</a>, but for degrees of freedom located on a face. The range of allowed indices is therefore 0..<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a>.</p>
<p>You will rarely need this function in application programs, since almost all application codes only need to deal with cell indices, not face indices. The function is mainly there for use inside the library. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03206">3206</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="afc49f8114f396b20b9a7fe9a3c058568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc49f8114f396b20b9a7fe9a3c058568">&#9670;&nbsp;</a></span>first_block_of_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::first_block_of_base </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a base element number, return the first block of a <a class="el" href="classBlockVector.html">BlockVector</a> it would generate. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03222">3222</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a2e1ca2e63382a8fd20910ae0303f4f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1ca2e63382a8fd20910ae0303f4f6c">&#9670;&nbsp;</a></span>component_to_base_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each vector component, return which base element implements this component and which vector component in this base element this is. This information is only of interest for vector-valued finite elements which are composed of several sub-elements. In that case, one may want to obtain information about the element implementing a certain vector component, which can be done using this function and the <a class="el" href="classFESystem.html#a76d99a0ab9afd229cf814b9d828b44a2">FESystem::base_element()</a> function.</p>
<p>If this is a scalar finite element, then the return value is always equal to a pair of zeros. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03232">3232</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a656f95e7c9144846758b804a41405cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656f95e7c9144846758b804a41405cd3">&#9670;&nbsp;</a></span>block_to_base_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the base element for this block and the number of the copy of the base element. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03244">3244</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a0763dd6212313f0ff69f04c735b2a147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0763dd6212313f0ff69f04c735b2a147">&#9670;&nbsp;</a></span>system_to_block_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_block_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The vector block and the index inside the block for this shape function. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03254">3254</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a7b3dd1574cabab93b67e3fe47a103b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3dd1574cabab93b67e3fe47a103b6a">&#9670;&nbsp;</a></span>component_to_block_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_block_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The vector block for this component. </p>

</div>
</div>
<a id="a4409f54175f279ac24cc982cfcfcbd2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4409f54175f279ac24cc982cfcfcbd2f">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the one component is true that corresponds to the given argument. See <a class="el" href="DEALGlossary.html#GlossComponentMask">the glossary</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>An object that represents a single scalar vector component of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the one that corresponds to the argument. </dd></dl>

</div>
</div>
<a id="a46d11c23f6db2eca49ba470defb873c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d11c23f6db2eca49ba470defb873c0">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim</code> components are true that correspond to the given argument. See <a class="el" href="DEALGlossary.html#GlossComponentMask">the glossary</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>An object that represents dim vector components of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

</div>
</div>
<a id="a2c0dcc1e76885ec0ddcaae340dcdcd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0dcc1e76885ec0ddcaae340dcdcd62">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sym_tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim*(dim+1)/2</code> components are true that correspond to the given argument. See <a class="el" href="DEALGlossary.html#GlossComponentMask">the glossary</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym_tensor</td><td>An object that represents dim*(dim+1)/2 components of this finite element that are jointly to be interpreted as forming a symmetric tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

</div>
</div>
<a id="a24d2a54a95f43f0db77e74b1bfab21d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d2a54a95f43f0db77e74b1bfab21d2">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>block_mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a block mask (see <a class="el" href="DEALGlossary.html#GlossBlockMask">this glossary entry</a>), produce a component mask (see <a class="el" href="DEALGlossary.html#GlossComponentMask">this glossary entry</a>) that represents the components that correspond to the blocks selected in the input argument. This is essentially a conversion operator from <a class="el" href="classBlockMask.html">BlockMask</a> to <a class="el" href="classComponentMask.html">ComponentMask</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_mask</td><td>The mask that selects individual blocks of the finite element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mask that selects those components corresponding to the selected blocks of the input argument. </dd></dl>

</div>
</div>
<a id="a7cc5ed75cad6792b8b21a3ac635a8860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc5ed75cad6792b8b21a3ac635a8860">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a block mask with as many elements as this object has blocks and of which exactly the one component is true that corresponds to the given argument. See <a class="el" href="DEALGlossary.html#GlossBlockMask">the glossary</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>This function will only succeed if the scalar referenced by the argument encompasses a complete block. In other words, if, for example, you pass an extractor for the single \(x\) velocity and this object represents an <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> object, then the single scalar object you selected is part of a larger block and consequently there is no block mask that would represent it. The function will then produce an exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>An object that represents a single scalar vector component of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the one that corresponds to the argument. </dd></dl>

</div>
</div>
<a id="a9294bf84eec96ac31f29808a5aa87551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9294bf84eec96ac31f29808a5aa87551">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim</code> components are true that correspond to the given argument. See <a class="el" href="DEALGlossary.html#GlossBlockMask">the glossary</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The same caveat applies as to the version of the function above: The extractor object passed as argument must be so that it corresponds to full blocks and does not split blocks of this element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>An object that represents dim vector components of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

</div>
</div>
<a id="ace95b8ef3a342bbb8f82cb17113be612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace95b8ef3a342bbb8f82cb17113be612">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sym_tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim*(dim+1)/2</code> components are true that correspond to the given argument. See <a class="el" href="DEALGlossary.html#GlossBlockMask">the glossary</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The same caveat applies as to the version of the function above: The extractor object passed as argument must be so that it corresponds to full blocks and does not split blocks of this element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym_tensor</td><td>An object that represents dim*(dim+1)/2 components of this finite element that are jointly to be interpreted as forming a symmetric tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

</div>
</div>
<a id="a931d71caa9f14212b8dd89337e155fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931d71caa9f14212b8dd89337e155fc1">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a component mask (see <a class="el" href="DEALGlossary.html#GlossComponentMask">this glossary entry</a>), produce a block mask (see <a class="el" href="DEALGlossary.html#GlossBlockMask">this glossary entry</a>) that represents the blocks that correspond to the components selected in the input argument. This is essentially a conversion operator from <a class="el" href="classComponentMask.html">ComponentMask</a> to <a class="el" href="classBlockMask.html">BlockMask</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function will only succeed if the components referenced by the argument encompasses complete blocks. In other words, if, for example, you pass an component mask for the single \(x\) velocity and this object represents an <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> object, then the single component you selected is part of a larger block and consequently there is no block mask that would represent it. The function will then produce an exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component_mask</td><td>The mask that selects individual components of the finite element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mask that selects those blocks corresponding to the selected blocks of the input argument. </dd></dl>

</div>
</div>
<a id="a83d75035bee0b250281be6fae5022374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d75035bee0b250281be6fae5022374">&#9670;&nbsp;</a></span>get_constant_modes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;<a class="el" href="classTable.html">Table</a>&lt;2, <a class="el" href="classbool.html">bool</a>&gt;, std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_constant_modes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a list of constant modes of the element. The number of rows in the resulting table depends on the elements in use. For standard elements, the table has as many rows as there are components in the element and dofs_per_cell columns. To each component of the finite element, the row in the returned table contains a basis representation of the constant function 1 on the element. However, there are some scalar elements where there is more than one constant mode, e.g. the element <a class="el" href="classFE__Q__DG0.html">FE_Q_DG0</a>.</p>
<p>In order to match the constant modes to the actual components in the element, the returned data structure also returns a vector with as many components as there are constant modes on the element that contains the component number. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a6a2f2d3af8769dfcb13ec1ab96d669d1">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#a4f5b778287c6a71a5946f3722ec3aa31">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__FaceP.html#aae7d76a96e78f7619e9c3a32383edea9">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQLegendre.html#a3d0f4eb97ab51e6c32d31a0c5f5d9fd5">FE_DGQLegendre&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#adacd4b68836d131c9f4ff00822a151c6">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ_3_011_00_01spacedim_01_4.html#ae0e39a94de98e36879d18133cf8643fd">FE_FaceQ&lt; 1, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a9869b854d98d3ba43e7b49541e38831c">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#a13bda3b81efac651b12229ddcb90f0e5">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#afae6dff6d5b43cd45aa447ef9c31ddc6">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a06b83d5a576cb6d4cf652522806128f1">FE_Q_Base&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#ac131d8398ddbba96c639a20b2cb34e07">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#a82f7ff8b0b8bd9c27340d5ca0387b817">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__TraceQ.html#ac6b2bc07e5ea4924e97ec12a18f812b2">FE_TraceQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__SimplexPoly.html#af6095c12963b49ea0453b1a79e7b3b7e">FE_SimplexPoly&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a31950b76dd77043681a605d775b9f885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31950b76dd77043681a605d775b9f885">&#9670;&nbsp;</a></span>get_unit_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_unit_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the support points of the trial functions on the unit cell, if the derived finite element defines them. Finite elements that allow some kind of interpolation operation usually have support points. On the other hand, elements that define their degrees of freedom by, for example, moments on faces, or as derivatives, don't have support points. In that case, the returned field is empty.</p>
<p>If the finite element defines support points, then their number equals the number of degrees of freedom of the element. The order of points in the array matches that returned by the <code>cell-&gt;get_dof_indices</code> function.</p>
<p>See the class documentation for details on support points.</p>
<dl class="section note"><dt>Note</dt><dd>Finite elements' implementation of this function returns these points in the same order as shape functions. The order of shape functions is typically documented in the class documentation of the various finite element classes. In particular, shape functions (and consequently the mapped quadrature points discussed in the class documentation of this class) will then traverse first those shape functions located on vertices, then on lines, then on quads, etc.</dd>
<dd>
If this element implements support points, then it will return one such point per shape function. Since multiple shape functions may be defined at the same location, the support points returned here may be duplicated. An example would be an element of the kind <code><a class="el" href="classFESystem.html">FESystem(FE_Q(1),3)</a></code> for which each support point would appear three times in the returned array. </dd></dl>

</div>
</div>
<a id="a47f25ecdd4c356032bd44e3e6571d983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f25ecdd4c356032bd44e3e6571d983">&#9670;&nbsp;</a></span>has_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether a finite element has defined support points. If the result is true, then a call to the <a class="el" href="classFiniteElement.html#a31950b76dd77043681a605d775b9f885">get_unit_support_points()</a> yields a non-empty array.</p>
<p>The result may be false if an element is not defined by interpolating shape functions, for example by P-elements on quadrilaterals. It will usually only be true if the element constructs its shape functions by the requirement that they be one at a certain point and zero at all the points associated with the other shape functions.</p>
<p>In composed elements (i.e. for the <a class="el" href="classFESystem.html">FESystem</a> class), the result will be true if all the base elements have defined support points. <a class="el" href="classFE__Nothing.html">FE_Nothing</a> is a special case in FESystems, because it has 0 support points and <a class="el" href="classFiniteElement.html#a47f25ecdd4c356032bd44e3e6571d983">has_support_points()</a> is false, but an <a class="el" href="classFESystem.html">FESystem</a> containing an <a class="el" href="classFE__Nothing.html">FE_Nothing</a> among other elements will return true. </p>

</div>
</div>
<a id="a6847a0da4cf62bca0dc7e27862a853f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6847a0da4cf62bca0dc7e27862a853f2">&#9670;&nbsp;</a></span>unit_support_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_support_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the position of the support point of the <code>indexth</code> shape function. If it does not exist, raise an exception.</p>
<p>The default implementation simply returns the respective element from the array you get from <a class="el" href="classFiniteElement.html#a31950b76dd77043681a605d775b9f885">get_unit_support_points()</a>, but derived elements may overload this function. In particular, note that the <a class="el" href="classFESystem.html">FESystem</a> class overloads it so that it can return the support points of individual base elements, if not all the base elements define support points. In this way, you can still ask for certain support points, even if <a class="el" href="classFiniteElement.html#a31950b76dd77043681a605d775b9f885">get_unit_support_points()</a> only returns an empty array. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a407cfce59711c10f48ebabc78327e79d">FESystem&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ac78f6cfda334497625e2cef7a16be6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78f6cfda334497625e2cef7a16be6f6">&#9670;&nbsp;</a></span>get_unit_face_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim - 1&gt; &gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_unit_face_support_points </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the support points of the trial functions on the unit face, if the derived finite element defines some. Finite elements that allow some kind of interpolation operation usually have support points. On the other hand, elements that define their degrees of freedom by, for example, moments on faces, or as derivatives, don't have support points. In that case, the returned field is empty</p>
<p>Note that elements that have support points need not necessarily have some on the faces, even if the interpolation points are located physically on a face. For example, the discontinuous elements have interpolation points on the vertices, and for higher degree elements also on the faces, but they are not defined to be on faces since in that case degrees of freedom from both sides of a face (or from all adjacent elements to a vertex) would be identified with each other, which is not what we would like to have). Logically, these degrees of freedom are therefore defined to belong to the cell, rather than the face or vertex. In that case, the returned element would therefore have length zero.</p>
<p>If the finite element defines support points, then their number equals the number of degrees of freedom on the face (<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a>). The order of points in the array matches that returned by the <code>cell-&gt;face(face)-&gt;get_dof_indices</code> function.</p>
<p>See the class documentation for details on support points. </p>

</div>
</div>
<a id="a40e0ebd1082fd37318aac7c5b69c99ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e0ebd1082fd37318aac7c5b69c99ba">&#9670;&nbsp;</a></span>has_face_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_face_support_points </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether a finite element has defined support points on faces. If the result is true, then a call to the <a class="el" href="classFiniteElement.html#ac78f6cfda334497625e2cef7a16be6f6">get_unit_face_support_points()</a> yields a non-empty vector.</p>
<p>For more information, see the documentation for the <a class="el" href="classFiniteElement.html#a47f25ecdd4c356032bd44e3e6571d983">has_support_points()</a> function. </p>

</div>
</div>
<a id="aab3c2b0d51bd908a6bd2ae934aab6204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3c2b0d51bd908a6bd2ae934aab6204">&#9670;&nbsp;</a></span>unit_face_support_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;dim - 1&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_face_support_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function corresponding to the <a class="el" href="classFiniteElement.html#a6847a0da4cf62bca0dc7e27862a853f2">unit_support_point()</a> function, but for faces. See there for more information. </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a0dc5c4bf19afec1c55d13d3a81c03a75">FESystem&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a14b9d0a87e17f83f6a9abe50375b5543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b9d0a87e17f83f6a9abe50375b5543">&#9670;&nbsp;</a></span>get_generalized_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt;&amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_generalized_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector of generalized support points.</p>
<dl class="section note"><dt>Note</dt><dd>The vector returned by this function is always a minimal set of <em>unique</em> support points. This is in contrast to the behavior of <a class="el" href="classFiniteElement.html#a31950b76dd77043681a605d775b9f885">get_unit_support_points()</a> that returns a repeated list of unit support points for an <a class="el" href="classFESystem.html">FESystem</a> of numerous (Lagrangian) base elements.</dd></dl>
<p>See the <a class="el" href="DEALGlossary.html#GlossGeneralizedSupport">glossary entry on generalized support points</a> for more information. </p>

</div>
</div>
<a id="a4d7a3e41b44869ce600ae0b3a98b5b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7a3e41b44869ce600ae0b3a98b5b4e">&#9670;&nbsp;</a></span>has_generalized_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_generalized_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether a finite element has defined generalized support points. If the result is true, then a call to the <a class="el" href="classFiniteElement.html#a14b9d0a87e17f83f6a9abe50375b5543">get_generalized_support_points()</a> yields a non-empty vector.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossGeneralizedSupport">glossary entry on generalized support points</a> for more information. </p>

</div>
</div>
<a id="ae0ea3780c7d2e6140141a9afcbc421f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ea3780c7d2e6140141a9afcbc421f4">&#9670;&nbsp;</a></span>get_associated_geometry_primitive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGeometryPrimitive.html">GeometryPrimitive</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_associated_geometry_primitive </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_dof_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For a given degree of freedom, return whether it is logically associated with a vertex, line, quad or hex.</p>
<p>For instance, for continuous finite elements this coincides with the lowest dimensional object the support point of the degree of freedom lies on. To give an example, for \(Q_1\) elements in 3d, every degree of freedom is defined by a shape function that we get by interpolating using support points that lie on the vertices of the cell. The support of these points of course extends to all edges connected to this vertex, as well as the adjacent faces and the cell interior, but we say that logically the degree of freedom is associated with the vertex as this is the lowest- dimensional object it is associated with. Likewise, for \(Q_2\) elements in 3d, the degrees of freedom with support points at edge midpoints would yield a value of <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2a65afbb3592220b91df58e72e858050f4">GeometryPrimitive::line</a> from this function, whereas those on the centers of faces in 3d would return <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2aeeed229077b068966c4edd2ff537b995">GeometryPrimitive::quad</a>.</p>
<p>To make this more formal, the kind of object returned by this function represents the object so that the support of the shape function corresponding to the degree of freedom, (i.e., that part of the domain where the function "lives") is the union of all of the cells sharing this object. To return to the example above, for \(Q_2\) in 3d, the shape function with support point at an edge midpoint has support on all cells that share the edge and not only the cells that share the adjacent faces, and consequently the function will return <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2a65afbb3592220b91df58e72e858050f4">GeometryPrimitive::line</a>.</p>
<p>On the other hand, for discontinuous elements of type \(DGQ_2\), a degree of freedom associated with an interpolation polynomial that has its support point physically located at a line bounding a cell, but is nonzero only on one cell. Consequently, it is logically associated with the interior of that cell (i.e., with a <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2aeeed229077b068966c4edd2ff537b995">GeometryPrimitive::quad</a> in 2d and a <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2acbbe64bcc53f9747fcf5ff863d59fe14">GeometryPrimitive::hex</a> in 3d).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_dof_index</td><td>The index of a shape function or degree of freedom. This index must be in the range <code>[0,dofs_per_cell)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The integer value of the object returned by this function equals the dimensionality of the object it describes, and can consequently be used in generic programming paradigms. For example, if a degree of freedom is associated with a vertex, then this function returns <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2af5e3dcc6059fdf418fc23763c0224d9f">GeometryPrimitive::vertex</a>, which has a numeric value of zero (the dimensionality of a vertex). </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l03334">3334</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a5dfedd72fb0bd1c9daf2701015edac5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dfedd72fb0bd1c9daf2701015edac5f">&#9670;&nbsp;</a></span>convert_generalized_support_point_values_to_dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::convert_generalized_support_point_values_to_dof_values </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_point_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodal_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the values of a function \(f(\mathbf x)\) at the (generalized) support points of the reference cell, this function then computes what the nodal values of the element are, i.e., \(\Psi_i[f]\), where \(\Psi_i\) are the node functionals of the element (see also <a class="el" href="DEALGlossary.html#GlossNodes">Node values or node functionals</a>). The values \(\Psi_i[f]\) are then the expansion coefficients for the shape functions of the finite element function that <em>interpolates</em> the given function \(f(x)\), i.e., \( f_h(\mathbf x) = \sum_i \Psi_i[f] \varphi_i(\mathbf x) \) is the finite element interpolant of \(f\) with the current element. The operation described here is used, for example, in the <a class="el" href="namespaceFETools.html#a9f31747a809637e571e11c146d9bec0a">FETools::compute_node_matrix()</a> function.</p>
<p>In more detail, let us assume that the generalized support points (see <a class="el" href="DEALGlossary.html#GlossGeneralizedSupport">this glossary entry</a> ) of the current element are \(\hat{\mathbf x}_i\) and that the node functionals associated with the current element are \(\Psi_i[\cdot]\). Then, the fact that the element is based on generalized support points, implies that if we apply \(\Psi_i\) to a (possibly vector-valued) finite element function \(\varphi\), the result must have the form \(\Psi_i[\varphi] = f_i(\varphi(\hat{\mathbf x}_i))\) &ndash; in other words, the value of the node functional \(\Psi_i\) applied to \(\varphi\) <em>only</em> depends on the <em>values of \(\varphi\) at \(\hat{\mathbf x}_i\)</em> and not on values anywhere else, or integrals of \(\varphi\), or any other kind of information.</p>
<p>The exact form of \(f_i\) depends on the element. For example, for scalar <a class="el" href="DEALGlossary.html#GlossLagrange">Lagrange elements</a>, we have that in fact \(\Psi_i[\varphi] = \varphi(\hat{\mathbf x}_i)\). If you combine multiple scalar Lagrange elements via an <a class="el" href="classFESystem.html">FESystem</a> object, then \(\Psi_i[\varphi] = \varphi(\hat{\mathbf x}_i)_{c(i)}\) where \(c(i)\) is the result of the <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">FiniteElement::system_to_component_index()</a> function's return value's first component. In these two cases, \(f_i\) is therefore simply the identity (in the scalar case) or a function that selects a particular vector component of its argument. On the other hand, for Raviart-Thomas elements, one would have that \(f_i(\mathbf y) = \mathbf y \cdot \mathbf n_i\) where \(\mathbf n_i\) is the normal vector of the face at which the shape function is defined.</p>
<p>Given all of this, what this function does is the following: If you input a list of values of a function \(\varphi\) at all generalized support points (where each value is in fact a vector of values with as many components as the element has), then this function returns a vector of values obtained by applying the node functionals to these values. In other words, if you pass in \(\{\varphi(\hat{\mathbf x}_i)\}_{i=0}^{N-1}\) then you will get out a vector \(\{\Psi[\varphi]\}_{i=0}^{N-1}\) where \(N\) equals <code>dofs_per_cell</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">support_point_values</td><td>An array of size <code>dofs_per_cell</code> (which equals the number of points the <a class="el" href="classFiniteElement.html#a14b9d0a87e17f83f6a9abe50375b5543">get_generalized_support_points()</a> function will return) where each element is a vector with as many entries as the element has vector components. This array should contain the values of a function at the generalized support points of the current element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodal_values</td><td>An array of size <code>dofs_per_cell</code> that contains the node functionals of the element applied to the given function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this function for (transformed) values on the real cell only for elements with trivial MappingKind. For all other elements (for example for H(curl), or H(div) conforming elements) vector values have to be transformed to the reference cell first.</dd>
<dd>
Given what the function is supposed to do, the function clearly can only work for elements that actually implement (generalized) support points. Elements that do not have generalized support points &ndash; e.g., elements whose nodal functionals evaluate integrals or moments of functions (such as <a class="el" href="classFE__Q__Hierarchical.html">FE_Q_Hierarchical</a>) &ndash; can in general not make sense of the operation that is required for this function. They consequently may not implement it. </dd></dl>

<p>Reimplemented in <a class="el" href="classFESystem.html#a6b1fe3f9c386185c9e534a773f6bc8bb">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q.html#a2a3d8b92931d75d5b8f0cf31a2d7d2f4">FE_Q&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQArbitraryNodes.html#ac345b45518d1951d9ae56314a0150dba">FE_DGQArbitraryNodes&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomasNodal.html#a2c1118f22d1d20bce8f332321e93726f">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#aa935e2be31cd4fca799cfeb335b219c6">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a1bb891e65c64187ab8eb7bae584894c9">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#abe46675ff9414704b5181dbf9ed4ad8d">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#aa2c660b6899aa0f19d62e67297079b02">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__Q__iso__Q1.html#a4e561c5858ee438802214c0b54d3c438">FE_Q_iso_Q1&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__ABF.html#ae5e42a39251a0e3e2e8b2eb2c6e47063">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#a160665bbb97210cc41707a2c715e33b4">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__BernardiRaugel.html#a90740dc14c0e56a26fd0d210cdf1fbf6">FE_BernardiRaugel&lt; dim &gt;</a>, <a class="el" href="classFE__RT__Bubbles.html#ab56fe2ab18731d921b50bf90d0ab9425">FE_RT_Bubbles&lt; dim &gt;</a>, <a class="el" href="classFE__RannacherTurek.html#aa6078fcf994b628b3e02e38141394903">FE_RannacherTurek&lt; dim &gt;</a>, <a class="el" href="classFE__SimplexP__Bubbles.html#a319c434b1d2d29b600f855dbf6e7c92e">FE_SimplexP_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexPoly.html#a5cc6c1fff56177c160db079c75d8d10b">FE_SimplexPoly&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#ac216856f202d7a1467af7288ecb6e526">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__BDM.html#a0d327040eb2aae1fb32dfbfa4466e3da">FE_BDM&lt; dim &gt;</a>, and <a class="el" href="classFE__TraceQ.html#add9217608d6d1eadff83afc8620748e6">FE_TraceQ&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a62838f7428ee56e34c4081ca6d03bc26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62838f7428ee56e34c4081ca6d03bc26">&#9670;&nbsp;</a></span>reinit_restriction_and_prolongation_matrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::reinit_restriction_and_prolongation_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isotropic_restriction_only</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isotropic_prolongation_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reinit the vectors of restriction and prolongation matrices to the right sizes: For every refinement case, except for <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase::no_refinement</a>, and for every child of that refinement case the space of one restriction and prolongation matrix is allocated, see the documentation of the restriction and prolongation vectors for more detail on the actual vector sizes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isotropic_restriction_only</td><td>only the restriction matrices required for isotropic refinement are reinited to the right size. </td></tr>
    <tr><td class="paramname">isotropic_prolongation_only</td><td>only the prolongation matrices required for isotropic refinement are reinited to the right size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c9df544a5b3b010e497c6645e6c734a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9df544a5b3b010e497c6645e6c734a">&#9670;&nbsp;</a></span>interface_constraints_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableIndices.html">TableIndices</a>&lt;2&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::interface_constraints_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the size of interface constraint matrices. Since this is needed in every derived finite element class when initializing their size, it is placed into this function, to avoid having to recompute the dimension- dependent size of these matrices each time.</p>
<p>Note that some elements do not implement the interface constraints for certain polynomial degrees. In this case, this function still returns the size these matrices should have when implemented, but the actual matrices are empty. </p>

</div>
</div>
<a id="abe780620df7c633e43ca45aba2e4270f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe780620df7c633e43ca45aba2e4270f">&#9670;&nbsp;</a></span>compute_n_nonzero_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::compute_n_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nonzero_components</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the pattern of nonzero components for each shape function, compute for each entry how many components are non-zero for each shape function. This function is used in the constructor of this class. </p>

</div>
</div>
<a id="a0d7236d243e42448327e719a9ea66a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7236d243e42448327e719a9ea66a81">&#9670;&nbsp;</a></span>get_face_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <a class="el" href="classFE__PolyTensor.html#a3120826089c7acfa86648238856fbfe0">get_data()</a>, but return an object that will later be used for evaluating shape function information at quadrature points on faces of cells. The object will then be used in calls to implementations of <a class="el" href="classFiniteElement.html#a7c5fd937dc322e6028f60c30fc65f185">FiniteElement::fill_fe_face_values()</a>. See the documentation of <a class="el" href="classFE__PolyTensor.html#a3120826089c7acfa86648238856fbfe0">get_data()</a> for more information.</p>
<p>The default implementation of this function converts the face quadrature into a cell quadrature with appropriate quadrature point locations, and with that calls the <a class="el" href="classFE__PolyTensor.html#a3120826089c7acfa86648238856fbfe0">get_data()</a> function above that has to be implemented in derived classes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">update_flags</td><td>A set of UpdateFlags values that describe what kind of information the <a class="el" href="classFEValues.html">FEValues</a> object requests the finite element to compute. This set of flags may also include information that the finite element can not compute, e.g., flags that pertain to data produced by the mapping. An implementation of this function needs to set up all data fields in the returned object that are necessary to produce the finite- element related data specified by these flags, and may already pre- compute part of this information as discussed above. Elements may want to store these update flags (or a subset of these flags) in <a class="el" href="classFiniteElement_1_1InternalDataBase.html#a99c4ead335ec713b3f9b3cdc8b5a1f40">InternalDataBase::update_each</a> so they know at the time when <a class="el" href="classFiniteElement.html#a7c5fd937dc322e6028f60c30fc65f185">FiniteElement::fill_fe_face_values()</a> is called what they are supposed to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>A reference to the mapping used for computing values and derivatives of shape functions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the object that describes where the shape functions should be evaluated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to the object that <a class="el" href="classFEValues.html">FEValues</a> will use in conjunction with the object returned here and where an implementation of <a class="el" href="classFiniteElement.html#a7c5fd937dc322e6028f60c30fc65f185">FiniteElement::fill_fe_face_values()</a> will place the requested information. This allows the current function to already pre-compute pieces of information that can be computed on the reference cell, as discussed above. <a class="el" href="classFEValues.html">FEValues</a> guarantees that this output object and the object returned by the current function will always be used together. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an object of a type derived from InternalDataBase and that derived classes can use to store scratch data that can be pre- computed, or for scratch arrays that then only need to be allocated once. The calling site assumes ownership of this object and will delete it when it is no longer necessary. </dd></dl>

<p>Reimplemented in <a class="el" href="classFESystem.html#af822e18d3891e859beaaa0d6d1fde1ce">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#acdd13cb22e73ac00aca340573fa71291">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a1b2ccb51d1367ebc4db1803503eb4c88">FE_PolyFace&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a1b2ccb51d1367ebc4db1803503eb4c88">FE_PolyFace&lt; TensorProductPolynomials&lt; dim - 1 &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__PolyFace.html#a1b2ccb51d1367ebc4db1803503eb4c88">FE_PolyFace&lt; PolynomialSpace&lt; dim - 1 &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a7e2f79f305092a89472245fb9ee4cdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2f79f305092a89472245fb9ee4cdf7">&#9670;&nbsp;</a></span>get_face_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>Use the version taking a <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> argument. </dd></dl>

</div>
</div>
<a id="a450e656fc6a48e7a6f1a9546713fcbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450e656fc6a48e7a6f1a9546713fcbf5">&#9670;&nbsp;</a></span>get_subface_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_subface_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <a class="el" href="classFE__PolyTensor.html#a3120826089c7acfa86648238856fbfe0">get_data()</a>, but return an object that will later be used for evaluating shape function information at quadrature points on children of faces of cells. The object will then be used in calls to implementations of <a class="el" href="classFiniteElement.html#ace7af117168f8d0fdb4bbdd516373625">FiniteElement::fill_fe_subface_values()</a>. See the documentation of <a class="el" href="classFE__PolyTensor.html#a3120826089c7acfa86648238856fbfe0">get_data()</a> for more information.</p>
<p>The default implementation of this function converts the face quadrature into a cell quadrature with appropriate quadrature point locations, and with that calls the <a class="el" href="classFE__PolyTensor.html#a3120826089c7acfa86648238856fbfe0">get_data()</a> function above that has to be implemented in derived classes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">update_flags</td><td>A set of UpdateFlags values that describe what kind of information the <a class="el" href="classFEValues.html">FEValues</a> object requests the finite element to compute. This set of flags may also include information that the finite element can not compute, e.g., flags that pertain to data produced by the mapping. An implementation of this function needs to set up all data fields in the returned object that are necessary to produce the finite- element related data specified by these flags, and may already pre- compute part of this information as discussed above. Elements may want to store these update flags (or a subset of these flags) in <a class="el" href="classFiniteElement_1_1InternalDataBase.html#a99c4ead335ec713b3f9b3cdc8b5a1f40">InternalDataBase::update_each</a> so they know at the time when <a class="el" href="classFiniteElement.html#ace7af117168f8d0fdb4bbdd516373625">FiniteElement::fill_fe_subface_values()</a> is called what they are supposed to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>A reference to the mapping used for computing values and derivatives of shape functions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the object that describes where the shape functions should be evaluated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to the object that <a class="el" href="classFEValues.html">FEValues</a> will use in conjunction with the object returned here and where an implementation of <a class="el" href="classFiniteElement.html#ace7af117168f8d0fdb4bbdd516373625">FiniteElement::fill_fe_subface_values()</a> will place the requested information. This allows the current function to already pre-compute pieces of information that can be computed on the reference cell, as discussed above. <a class="el" href="classFEValues.html">FEValues</a> guarantees that this output object and the object returned by the current function will always be used together. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an object of a type derived from InternalDataBase and that derived classes can use to store scratch data that can be pre- computed, or for scratch arrays that then only need to be allocated once. The calling site assumes ownership of this object and will delete it when it is no longer necessary. </dd></dl>

<p>Reimplemented in <a class="el" href="classFESystem.html#a7be5a18f327f8fc2cc89e53d4f3eb02c">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a508cbbd19fac3a5c168ac99038fce12c">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#afff6983e489d1feb1914dcc687939c86">FE_PolyFace&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#afff6983e489d1feb1914dcc687939c86">FE_PolyFace&lt; TensorProductPolynomials&lt; dim - 1 &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__PolyFace.html#afff6983e489d1feb1914dcc687939c86">FE_PolyFace&lt; PolynomialSpace&lt; dim - 1 &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a60aed438915b7d8d37b2a45c902e6bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60aed438915b7d8d37b2a45c902e6bfe">&#9670;&nbsp;</a></span>reference_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classReferenceCell.html">ReferenceCell</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::reference_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the kind of reference cell this element is defined on: For example, whether the element's reference cell is a square or triangle, or similar choices in higher dimensions. </p>

</div>
</div>
<a id="a5cfd4619615520b8446ac853826a7d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfd4619615520b8446ac853826a7d4c">&#9670;&nbsp;</a></span>n_unique_quads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_unique_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of unique quads. If all quads have the same type, the value is one; else it equals the number of quads. </p>

</div>
</div>
<a id="ad6081492e85d34bbfbd334423e31ce42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6081492e85d34bbfbd334423e31ce42">&#9670;&nbsp;</a></span>n_unique_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_unique_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of unique faces. If all faces have the same type, the value is one; else it equals the number of faces. </p>

</div>
</div>
<a id="a0d1f06778f87a7606cc2e0d5338b41ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1f06778f87a7606cc2e0d5338b41ab">&#9670;&nbsp;</a></span>n_dofs_per_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_dofs_per_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of dofs per vertex. </p>

</div>
</div>
<a id="a384464e3b59fe91485f603dc32db7dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384464e3b59fe91485f603dc32db7dd1">&#9670;&nbsp;</a></span>n_dofs_per_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_dofs_per_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of dofs per line. Not including dofs on lower dimensional objects. </p>

</div>
</div>
<a id="ad8259242b27dc19222cde2016a99dba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8259242b27dc19222cde2016a99dba2">&#9670;&nbsp;</a></span>n_dofs_per_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_dofs_per_quad </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of dofs per quad. Not including dofs on lower dimensional objects. </p>

</div>
</div>
<a id="aa32508c87a3850e94e59193f14c52d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32508c87a3850e94e59193f14c52d6f">&#9670;&nbsp;</a></span>max_dofs_per_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::max_dofs_per_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum number of dofs per quad. Not including dofs on lower dimensional objects. </p>

</div>
</div>
<a id="aecb7465f62a849481ae0bf5edc78ec7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb7465f62a849481ae0bf5edc78ec7d">&#9670;&nbsp;</a></span>n_dofs_per_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_dofs_per_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of dofs per hex. Not including dofs on lower dimensional objects. </p>

</div>
</div>
<a id="a4a5f5b1fc401af61dafc61d083f5ae7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5f5b1fc401af61dafc61d083f5ae7b">&#9670;&nbsp;</a></span>n_dofs_per_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_dofs_per_face </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of dofs per face, accumulating degrees of freedom of all lower dimensional objects. </p>

</div>
</div>
<a id="a54eef7c23041e6750f0a71c2ca3028bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54eef7c23041e6750f0a71c2ca3028bd">&#9670;&nbsp;</a></span>max_dofs_per_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::max_dofs_per_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum number of dofs per face, accumulating degrees of freedom of all lower dimensional objects. </p>

</div>
</div>
<a id="a33b522422da89e5c080e7405ad49d7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b522422da89e5c080e7405ad49d7c7">&#9670;&nbsp;</a></span>n_dofs_per_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_dofs_per_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of dofs per cell, accumulating degrees of freedom of all lower dimensional objects. </p>

</div>
</div>
<a id="a6dc6a1e69b9c6594f6f08338d11ceb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc6a1e69b9c6594f6f08338d11ceb43">&#9670;&nbsp;</a></span>n_dofs_per_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int structdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_dofs_per_object </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of degrees per structdim-dimensional object. For structdim==0, the function therefore returns dofs_per_vertex, for structdim==1 dofs_per_line, etc. This function is mostly used to allow some template trickery for functions that should work on all sorts of objects without wanting to use the different names (vertex, line, ...) associated with these objects. </p>

</div>
</div>
<a id="a5a698695065333035e493294ce92820e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a698695065333035e493294ce92820e">&#9670;&nbsp;</a></span>n_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of components. See <a class="el" href="DEALGlossary.html#GlossComponent">the glossary</a> for more information. </p>

</div>
</div>
<a id="a4c1c4ca934f26ff463caf35a574e9f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1c4ca934f26ff463caf35a574e9f14">&#9670;&nbsp;</a></span>n_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of blocks. See <a class="el" href="DEALGlossary.html#GlossBlock">the glossary</a> for more information. </p>

</div>
</div>
<a id="ab6b11a9d43bf383bb38953fd50dba34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b11a9d43bf383bb38953fd50dba34b">&#9670;&nbsp;</a></span>block_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&amp; <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::block_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Detailed information on block sizes. </p>

</div>
</div>
<a id="a584a56a1611a86a04c8b9a26d0eb9f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584a56a1611a86a04c8b9a26d0eb9f27">&#9670;&nbsp;</a></span>tensor_degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::tensor_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximal polynomial degree of a shape function in a single coordinate direction.</p>
<p>This function can be used to determine the optimal quadrature rule. </p>

</div>
</div>
<a id="a18e928460be93a004559b841f35ad698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e928460be93a004559b841f35ad698">&#9670;&nbsp;</a></span>conforms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::conforms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether a finite element space conforms to a certain Sobolev space.</p>
<dl class="section note"><dt>Note</dt><dd>This function will return a true value even if the finite element space has higher regularity than asked for. </dd></dl>

</div>
</div>
<a id="a078fb199880f2b29fc72d9c01d317bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078fb199880f2b29fc72d9c01d317bd0">&#9670;&nbsp;</a></span>get_first_line_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::get_first_line_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return first index of dof on a line. </p>

</div>
</div>
<a id="a3a1b484c2e7afda2efaa11e7e31b5bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1b484c2e7afda2efaa11e7e31b5bbf">&#9670;&nbsp;</a></span>get_first_quad_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::get_first_quad_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_no</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return first index of dof on a quad. </p>

</div>
</div>
<a id="aff4361f6bf7db70f4961e67ddf97ebf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4361f6bf7db70f4961e67ddf97ebf8">&#9670;&nbsp;</a></span>get_first_hex_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::get_first_hex_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return first index of dof on a hexahedron. </p>

</div>
</div>
<a id="a859d429b3a7a847713c6d2528c3f2e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859d429b3a7a847713c6d2528c3f2e97">&#9670;&nbsp;</a></span>get_first_face_line_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::get_first_face_line_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return first index of dof on a line for face data. </p>

</div>
</div>
<a id="a9f2166738fc6fda9ef70988179d8d569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2166738fc6fda9ef70988179d8d569">&#9670;&nbsp;</a></span>get_first_face_quad_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::get_first_face_quad_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return first index of dof on a quad for face data. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a45f266aa4761c1cdbbff62e65d8f3cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f266aa4761c1cdbbff62e65d8f3cc2">&#9670;&nbsp;</a></span>interior_weights</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolynomialType, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt;3, <a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classFE__DGVector.html">FE_DGVector</a>&lt; PolynomialType, dim, spacedim &gt;::interior_weights</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fe__dg__vector_8h_source.html#l00129">129</a> of file <a class="el" href="fe__dg__vector_8h_source.html">fe_dg_vector.h</a>.</p>

</div>
</div>
<a id="abeecf4df065ca5f5701ba1190a190631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeecf4df065ca5f5701ba1190a190631">&#9670;&nbsp;</a></span>mapping_kind</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::mapping_kind</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The mapping type to be used to map shape functions from the reference cell to the mesh cell. If this vector is length one, the same mapping will be applied to all shape functions. If the vector size is equal to the finite element dofs per cell, then each shape function will be mapped according to the corresponding entry in the vector. </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00218">218</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="a20234bd8b6c97e450bb3c0efcd836198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20234bd8b6c97e450bb3c0efcd836198">&#9670;&nbsp;</a></span>adjust_quad_dof_sign_for_face_orientation_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTable.html">Table</a>&lt;2, <a class="el" href="classbool.html">bool</a>&gt; &gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::adjust_quad_dof_sign_for_face_orientation_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For faces with non-standard face_orientation in 3D, the dofs on faces (quads) need not only to be permuted in order to be combined with the correct shape functions. Additionally they may change their sign.</p>
<p>The constructor of this class fills this table with 'false' values, i.e., no sign change at all. Derived finite element classes have to fill this <a class="el" href="classTable.html">Table</a> with the correct values, see the documentation in GeometryInfo&lt;dim&gt; and this <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary entry on face orientation</a>.</p>
<p>The table must be filled in finite element classes derived from <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a> in a meaningful way since the permutation pattern and the pattern of sign changes depends on how the finite element distributes the local dofs on the faces. An example is the function <code>initialize_quad_dof_index_permutation_and_sign_change()</code> in the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> class that fills this table. </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00265">265</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="ae45a96809bedb741904aebe616a32ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45a96809bedb741904aebe616a32ba2">&#9670;&nbsp;</a></span>poly_space</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unique_ptr&lt;const <a class="el" href="classTensorPolynomialsBase.html">TensorPolynomialsBase</a>&lt;dim&gt; &gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::poly_space</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A copy of the object passed to the constructor that describes the polynomial space. </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00519">519</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="a38c73bd10d9b2b3c8d11e390c23b1b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c73bd10d9b2b3c8d11e390c23b1b7e">&#9670;&nbsp;</a></span>inverse_node_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::inverse_node_matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The inverse of the matrix <em>a<sub>ij</sub></em> of node values <em>N<sub>i</sub></em> applied to polynomial <em>p<sub>j</sub></em>. This matrix is used to convert polynomials in the "raw" basis provided in <a class="el" href="classFE__PolyTensor.html#ae45a96809bedb741904aebe616a32ba2">poly_space</a> to the basis dual to the node functionals on the reference cell.</p>
<p>This object is not filled by <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>, but is a chance for a derived class to allow for reorganization of the basis functions. If it is left empty, the basis in <a class="el" href="classFE__PolyTensor.html#ae45a96809bedb741904aebe616a32ba2">poly_space</a> is used. </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00532">532</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="a188e364c278533b4b319f702390322fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188e364c278533b4b319f702390322fd">&#9670;&nbsp;</a></span>cache_mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::cache_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A mutex to be used to guard access to the variables below. </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00537">537</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="a6f3728ea2a8d8d8744ebe14bdf6cbb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3728ea2a8d8d8744ebe14bdf6cbb31">&#9670;&nbsp;</a></span>cached_point</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;dim&gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::cached_point</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If a shape function is computed at a single point, we must compute all of them to apply <a class="el" href="classFE__PolyTensor.html#a38c73bd10d9b2b3c8d11e390c23b1b7e">inverse_node_matrix</a>. In order to avoid too much overhead, we cache the point and the function values for the next evaluation. </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00544">544</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="adb75d35170b98b1ba99090e566f6c5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb75d35170b98b1ba99090e566f6c5cd">&#9670;&nbsp;</a></span>cached_values</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;1, dim&gt; &gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::cached_values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cached shape function values after call to <a class="el" href="classFE__PolyTensor.html#a607518e45ad02f9997ed5486f9c5d8fb">shape_value_component()</a>. </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00549">549</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="a306eab3ba19d1b62dd82b4126f466d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306eab3ba19d1b62dd82b4126f466d55">&#9670;&nbsp;</a></span>cached_grads</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;2, dim&gt; &gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::cached_grads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cached shape function gradients after call to <a class="el" href="classFE__PolyTensor.html#acafcfbb9a08f1665c5c35ff2341333e0">shape_grad_component()</a>. </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00554">554</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="af14cdfca59390a4e648da7a0c7bee0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14cdfca59390a4e648da7a0c7bee0b7">&#9670;&nbsp;</a></span>cached_grad_grads</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;3, dim&gt; &gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::cached_grad_grads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cached second derivatives of shape functions after call to <a class="el" href="classFE__PolyTensor.html#a0d39732550551c965be0c3a05a8baf95">shape_grad_grad_component()</a>. </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00560">560</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="a577195e2fad97018b5dccb837952dad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577195e2fad97018b5dccb837952dad7">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dimension of the image space, corresponding to <a class="el" href="classTriangulation.html">Triangulation</a>. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l00651">651</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a4993707a4ec342560ff74e5d22401794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4993707a4ec342560ff74e5d22401794">&#9670;&nbsp;</a></span>restriction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classVector.html">Vector</a> of projection matrices. See <a class="el" href="classFiniteElement.html#afcd544abd534ae8ce643f8c21b8be7f2">get_restriction_matrix()</a> above. The constructor initializes these matrices to zero dimensions, which can be changed by derived classes implementing them.</p>
<p>Note, that <code>restriction[refinement_case-1][child]</code> includes the restriction matrix of child <code>child</code> for the <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code>. Here, we use <code>refinement_case-1</code> instead of <code>refinement_case</code> as for <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase::no_refinement</a>(=0) there are no restriction matrices available. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02404">2404</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="afbc42f850096c429fd39cfcbde1b6b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc42f850096c429fd39cfcbde1b6b56">&#9670;&nbsp;</a></span>prolongation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::prolongation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classVector.html">Vector</a> of embedding matrices. See <code><a class="el" href="classFiniteElement.html#af78c7b6503befe61dc6df5eb41c99019">get_prolongation_matrix()</a></code> above. The constructor initializes these matrices to zero dimensions, which can be changed by derived classes implementing them.</p>
<p>Note, that <code>prolongation[refinement_case-1][child]</code> includes the prolongation matrix of child <code>child</code> for the <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code>. Here, we use <code>refinement_case-1</code> instead of <code>refinement_case</code> as for <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase::no_refinement</a>(=0) there are no prolongation matrices available. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02418">2418</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ac8d4cd5afce6a401892aeb5a40ccfa2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d4cd5afce6a401892aeb5a40ccfa2f">&#9670;&nbsp;</a></span>interface_constraints</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::interface_constraints</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specify the constraints which the dofs on the two sides of a cell interface underlie if the line connects two cells of which one is refined once.</p>
<p>For further details see the general description of the derived class.</p>
<p>This field is obviously useless in one dimension and has there a zero size. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02430">2430</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ab4f6e0c83686b918fbb92716ead92313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f6e0c83686b918fbb92716ead92313">&#9670;&nbsp;</a></span>unit_support_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of support points on the unit cell, in case the finite element has any. The constructor leaves this field empty, derived classes may write in some contents.</p>
<p>Finite elements that allow some kind of interpolation operation usually have support points. On the other hand, elements that define their degrees of freedom by, for example, moments on faces, or as derivatives, don't have support points. In that case, this field remains empty. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02442">2442</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a1cab5fe59b82da1fc25e1454b12c4fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cab5fe59b82da1fc25e1454b12c4fa9">&#9670;&nbsp;</a></span>unit_face_support_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim - 1&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_face_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same for the faces. See the description of the <a class="el" href="classFiniteElement.html#ac78f6cfda334497625e2cef7a16be6f6">get_unit_face_support_points()</a> function for a discussion of what contributes a face support point. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02449">2449</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ae2531d00b5c9e77e1e64981864c3b8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2531d00b5c9e77e1e64981864c3b8cc">&#9670;&nbsp;</a></span>generalized_support_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::generalized_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Support points used for interpolation functions of non-Lagrangian elements. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02455">2455</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a646b0f9a97e1df8fc14f9305149ed525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646b0f9a97e1df8fc14f9305149ed525">&#9670;&nbsp;</a></span>generalized_face_support_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim - 1&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::generalized_face_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Face support points used for interpolation functions of non-Lagrangian elements. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02461">2461</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a5592f17f6c16d325de2d30f1cc051eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5592f17f6c16d325de2d30f1cc051eeb">&#9670;&nbsp;</a></span>adjust_quad_dof_index_for_face_orientation_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTable.html">Table</a>&lt;2, <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_quad_dof_index_for_face_orientation_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For faces with non-standard face_orientation in 3D, the dofs on faces (quads) have to be permuted in order to be combined with the correct shape functions. Given a local dof <code>index</code> on a quad, return the shift in the local index, if the face has non-standard face_orientation, i.e. <code>old_index + shift = new_index</code>. In 2D and 1D there is no need for permutation so the vector is empty. In 3D it has the size of <code> <a class="el" href="classFiniteElementData.html#a00ab27b2dfa5520f2aa56f9bb8223878">dofs_per_quad</a> * 8 </code>, where 8 is the number of orientations, a face can be in (all combinations of the three bool flags face_orientation, face_flip and face_rotation).</p>
<p>The constructor of this class fills this table with zeros, i.e., no permutation at all. Derived finite element classes have to fill this <a class="el" href="classTable.html">Table</a> with the correct values. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02478">2478</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a6659bb0dccc62e2d680c964e5035daf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6659bb0dccc62e2d680c964e5035daf6">&#9670;&nbsp;</a></span>adjust_line_dof_index_for_line_orientation_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_line_dof_index_for_line_orientation_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For lines with non-standard line_orientation in 3D, the dofs on lines have to be permuted in order to be combined with the correct shape functions. Given a local dof <code>index</code> on a line, return the shift in the local index, if the line has non-standard line_orientation, i.e. <code>old_index + shift = new_index</code>. In 2D and 1D there is no need for permutation so the vector is empty. In 3D it has the size of <a class="el" href="classFiniteElementData.html#a490e2ded19c0a8cad0846e07e57e3e76">dofs_per_line</a>.</p>
<p>The constructor of this class fills this table with zeros, i.e., no permutation at all. Derived finite element classes have to fill this vector with the correct values. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02493">2493</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a9af218ae93821b61054de7e88e1734aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af218ae93821b61054de7e88e1734aa">&#9670;&nbsp;</a></span>system_to_component_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_component_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store what <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index()</a> will return. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02498">2498</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="abc61022ae105ef061458aa5f2d573055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc61022ae105ef061458aa5f2d573055">&#9670;&nbsp;</a></span>face_system_to_component_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_component_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map between linear dofs and component dofs on face. This is filled with default values in the constructor, but derived classes will have to overwrite the information if necessary.</p>
<p>By component, we mean the vector component, not the base element. The information thus makes only sense if a shape function is non-zero in only one component. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02510">2510</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a870f688170ad210708077eed94642d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870f688170ad210708077eed94642d73">&#9670;&nbsp;</a></span>system_to_base_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_base_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each shape function, store to which base element and which instance of this base element (in case its multiplicity is greater than one) it belongs, and its index within this base element. If the element is not composed of others, then base and instance are always zero, and the index is equal to the number of the shape function. If the element is composed of single instances of other elements (i.e. all with multiplicity one) all of which are scalar, then base values and dof indices within this element are equal to the <a class="el" href="classFiniteElement.html#a9af218ae93821b61054de7e88e1734aa">system_to_component_table</a>. It differs only in case the element is composed of other elements and at least one of them is vector-valued itself.</p>
<p>This array has valid values also in the case of vector-valued (i.e. non- primitive) shape functions, in contrast to the <a class="el" href="classFiniteElement.html#a9af218ae93821b61054de7e88e1734aa">system_to_component_table</a>. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02529">2529</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ab4e6a76c64f925c81561745fd6bc12c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e6a76c64f925c81561745fd6bc12c3">&#9670;&nbsp;</a></span>face_system_to_base_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt;std::pair&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_base_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Likewise for the indices on faces. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02536">2536</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a61f62f39ded99d6525f1c33f4227ee8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f62f39ded99d6525f1c33f4227ee8d">&#9670;&nbsp;</a></span>base_to_block_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockIndices.html">BlockIndices</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::base_to_block_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each base element, store the number of blocks generated by the base and the first block in a block vector it will generate. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02542">2542</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="aaf2c44f3a207e0e11880820a29ac37a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2c44f3a207e0e11880820a29ac37a8">&#9670;&nbsp;</a></span>component_to_base_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_base_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The base element establishing a component.</p>
<p>For each component number <code>c</code>, the entries have the following meaning: </p><dl>
<dt><code>table[c].first.first</code> </dt>
<dd>Number of the base element for <code>c</code>. This is the index you can pass to <a class="el" href="classFiniteElement.html#a705f734e2f56aa34710defb72299e7c8">base_element()</a>. </dd>
<dt><code>table[c].first.second</code> </dt>
<dd>Component within the base element for <code>c</code>. This value is between 0 and the <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">n_components()</a> of this base element. </dd>
<dt><code>table[c].second</code> </dt>
<dd>Index of the multiple of the base element that contains <code>c</code>. This value is between 0 and the <a class="el" href="classFiniteElement.html#aa009769e662e34081f60ff16327db1b1">element_multiplicity()</a> of this base element. </dd>
</dl>
<p>This variable is set to the correct size by the constructor of this class, but needs to be initialized by derived classes, unless its size is one and the only entry is a zero, which is the case for scalar elements. In that case, the initialization by the base class is sufficient.</p>
<dl class="section note"><dt>Note</dt><dd>This table is filled by <a class="el" href="namespaceFETools_1_1Compositing.html#abd957d101116d4a8b4c17c0ee16ad202">FETools::Compositing::build_cell_tables()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02565">2565</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="aa8f4833a318127b42d2dc806bffe1c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f4833a318127b42d2dc806bffe1c2c">&#9670;&nbsp;</a></span>restriction_is_additive_flags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction_is_additive_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A flag determining whether restriction matrices are to be concatenated or summed up. See the discussion about restriction matrices in the general class documentation for more information. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02572">2572</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ae6fe073d1e3ce59791b142067482bd5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6fe073d1e3ce59791b142067482bd5b">&#9670;&nbsp;</a></span>nonzero_components</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classComponentMask.html">ComponentMask</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::nonzero_components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each shape function, give a vector of bools (with size equal to the number of vector components which this finite element has) indicating in which component each of these shape functions is non-zero.</p>
<p>For primitive elements, there is only one non-zero component. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02581">2581</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a0b7cb6ef5342900727931ef983636502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7cb6ef5342900727931ef983636502">&#9670;&nbsp;</a></span>n_nonzero_components_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::n_nonzero_components_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This array holds how many values in the respective entry of the <a class="el" href="classFiniteElement.html#ae6fe073d1e3ce59791b142067482bd5b">nonzero_components</a> element are non-zero. The array is thus a short-cut to allow faster access to this information than if we had to count the non-zero entries upon each request for this information. The field is initialized in the constructor of this class. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02590">2590</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a4124079b6443590608046d8f150574f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4124079b6443590608046d8f150574f6">&#9670;&nbsp;</a></span>cached_primitivity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::cached_primitivity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store whether all shape functions are primitive. Since finding this out is a very common operation, we cache the result, i.e. compute the value in the constructor for simpler access. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02597">2597</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="af40fa679812dc4fcc76496aa9a139050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40fa679812dc4fcc76496aa9a139050">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dimension of the finite element, which is the template parameter <code>dim</code> </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00285">285</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="ad82fdeb0955b7d59f32d5371adaaadbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82fdeb0955b7d59f32d5371adaaadbc">&#9670;&nbsp;</a></span>dofs_per_vertex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::dofs_per_vertex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of degrees of freedom on a vertex. </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00309">309</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a490e2ded19c0a8cad0846e07e57e3e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490e2ded19c0a8cad0846e07e57e3e76">&#9670;&nbsp;</a></span>dofs_per_line</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::dofs_per_line</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of degrees of freedom in a line; not including the degrees of freedom on the vertices of the line. </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00315">315</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a00ab27b2dfa5520f2aa56f9bb8223878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ab27b2dfa5520f2aa56f9bb8223878">&#9670;&nbsp;</a></span>dofs_per_quad</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::dofs_per_quad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of degrees of freedom in a quadrilateral; not including the degrees of freedom on the lines and vertices of the quadrilateral. </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00329">329</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a9014d27be7564a42c962848db0d2fd75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9014d27be7564a42c962848db0d2fd75">&#9670;&nbsp;</a></span>dofs_per_hex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::dofs_per_hex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of degrees of freedom in a hexahedron; not including the degrees of freedom on the quadrilaterals, lines and vertices of the hexahedron. </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00342">342</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a8c172e26b87c60b3f7e5e3ebf155b62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c172e26b87c60b3f7e5e3ebf155b62e">&#9670;&nbsp;</a></span>first_line_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::first_line_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>First index of dof on a line. </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00347">347</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="aca9fc2a37fc1aa814ac73e93baca4bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9fc2a37fc1aa814ac73e93baca4bea">&#9670;&nbsp;</a></span>first_quad_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::first_quad_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>First index of dof on a quad. </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00361">361</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a649a135f376e3fba63ecf08c2b17cc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649a135f376e3fba63ecf08c2b17cc64">&#9670;&nbsp;</a></span>first_hex_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::first_hex_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>First index of dof on a hexahedron. </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00366">366</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a70cf27d2dabe49e0c1f57954d7d08500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cf27d2dabe49e0c1f57954d7d08500">&#9670;&nbsp;</a></span>first_face_line_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::first_face_line_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>First index of dof on a line for face data. </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00378">378</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a0f85f3eae2daee423441fce5e87fa2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f85f3eae2daee423441fce5e87fa2e6">&#9670;&nbsp;</a></span>first_face_quad_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::first_face_quad_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>First index of dof on a quad for face data. </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00390">390</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a358bffed1fba59ef4df715469473fd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358bffed1fba59ef4df715469473fd36">&#9670;&nbsp;</a></span>dofs_per_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::dofs_per_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of degrees of freedom on a face. This is the accumulated number of degrees of freedom on all the objects of dimension up to <code>dim-1</code> constituting a face. </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00405">405</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="ae2fa3b8d578ba488b4f37061bb0278bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fa3b8d578ba488b4f37061bb0278bb">&#9670;&nbsp;</a></span>dofs_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::dofs_per_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of degrees of freedom on a cell. This is the accumulated number of degrees of freedom on all the objects of dimension up to <code>dim</code> constituting a cell. </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00419">419</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a1ccdb4fd2c40a3e3cd92cb0361cddaf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccdb4fd2c40a3e3cd92cb0361cddaf8">&#9670;&nbsp;</a></span>components</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of vector components of this finite element, and dimension of the image space. For vector-valued finite elements (i.e. when this number is greater than one), the number of vector components is in many cases equal to the number of base elements glued together with the help of the <a class="el" href="classFESystem.html">FESystem</a> class. However, for elements like the Nedelec element, the number is greater than one even though we only have one base element. </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00429">429</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a2cbf5ad6b464871261dbd054bced18a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbf5ad6b464871261dbd054bced18a8">&#9670;&nbsp;</a></span>degree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::degree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximal polynomial degree of a shape function in a single coordinate direction. </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00435">435</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="aca702ba3af0ed17eaffcfbbccf82067f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca702ba3af0ed17eaffcfbbccf82067f">&#9670;&nbsp;</a></span>conforming_space</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::conforming_space</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate the space this element conforms to. </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00440">440</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a9346e3aae3032545c8a94b78a365ffcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9346e3aae3032545c8a94b78a365ffcb">&#9670;&nbsp;</a></span>block_indices_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockIndices.html">BlockIndices</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::block_indices_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Storage for an object describing the sizes of each block of a compound element. For an element which is not an <a class="el" href="classFESystem.html">FESystem</a>, this contains only a single block with length <a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>. </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00447">447</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/fe/<a class="el" href="fe__dg__vector_8h_source.html">fe_dg_vector.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
