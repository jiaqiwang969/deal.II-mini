<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/structGeometryInfo.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: GeometryInfo&lt; dim &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structGeometryInfo-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GeometryInfo&lt; dim &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grids and Triangulations</a> &#124; <a class="el" href="group__geomprimitives.html">Geometric and other primitives</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="geometry__info_8h_source.html">deal.II/base/geometry_info.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a253fd1bcb288e88bdecccf727b7b907a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a253fd1bcb288e88bdecccf727b7b907a">face_indices</a> ()</td></tr>
<tr class="separator:a253fd1bcb288e88bdecccf727b7b907a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a76e2c08f49817f09bcab9bbb7e373c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a3a76e2c08f49817f09bcab9bbb7e373c">vertex_indices</a> ()</td></tr>
<tr class="separator:a3a76e2c08f49817f09bcab9bbb7e373c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad022815fd2a5c25fc0cddaca93f3cca5"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#ad022815fd2a5c25fc0cddaca93f3cca5">n_children</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case)</td></tr>
<tr class="separator:ad022815fd2a5c25fc0cddaca93f3cca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe25e8c0a5a67e3618fa17dadf58b944"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#afe25e8c0a5a67e3618fa17dadf58b944">n_subfaces</a> (const <a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;subface_case)</td></tr>
<tr class="separator:afe25e8c0a5a67e3618fa17dadf58b944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca2ea6ad9db59ae8d34662599e14fc2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a6ca2ea6ad9db59ae8d34662599e14fc2">subface_ratio</a> (const <a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;subface_case, const unsigned <a class="el" href="classint.html">int</a> subface_no)</td></tr>
<tr class="separator:a6ca2ea6ad9db59ae8d34662599e14fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b91a076a13a5a6594f132b09c824c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#af6b91a076a13a5a6594f132b09c824c3">face_refinement_case</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;cell_refinement_case, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:af6b91a076a13a5a6594f132b09c824c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff1bd9fab7ea7b2ab9265c53c8e34a4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a0ff1bd9fab7ea7b2ab9265c53c8e34a4">min_cell_refinement_case_for_face_refinement</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt; &amp;<a class="el" href="structGeometryInfo.html#af6b91a076a13a5a6594f132b09c824c3">face_refinement_case</a>, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:a0ff1bd9fab7ea7b2ab9265c53c8e34a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5efb5e5ca92dfead4105ff194dbe94"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a3f5efb5e5ca92dfead4105ff194dbe94">line_refinement_case</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;cell_refinement_case, const unsigned <a class="el" href="classint.html">int</a> line_no)</td></tr>
<tr class="separator:a3f5efb5e5ca92dfead4105ff194dbe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b46dc2ac462eeeeab76b04e22928b8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a46b46dc2ac462eeeeab76b04e22928b8">min_cell_refinement_case_for_line_refinement</a> (const unsigned <a class="el" href="classint.html">int</a> line_no)</td></tr>
<tr class="separator:a46b46dc2ac462eeeeab76b04e22928b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1263120c3a820d6b17b4055e6e0ef9f1"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a1263120c3a820d6b17b4055e6e0ef9f1">child_cell_on_face</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;ref_case, const unsigned <a class="el" href="classint.html">int</a> face, const unsigned <a class="el" href="classint.html">int</a> subface, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt; &amp;<a class="el" href="structGeometryInfo.html#af6b91a076a13a5a6594f132b09c824c3">face_refinement_case</a>=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt;::isotropic_refinement)</td></tr>
<tr class="separator:a1263120c3a820d6b17b4055e6e0ef9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd66dc231589a519786719dbde492c9a"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#abd66dc231589a519786719dbde492c9a">line_to_cell_vertices</a> (const unsigned <a class="el" href="classint.html">int</a> line, const unsigned <a class="el" href="classint.html">int</a> vertex)</td></tr>
<tr class="separator:abd66dc231589a519786719dbde492c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adac0f129f0bdaa1600b14a543bdaa4"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a2adac0f129f0bdaa1600b14a543bdaa4">face_to_cell_vertices</a> (const unsigned <a class="el" href="classint.html">int</a> face, const unsigned <a class="el" href="classint.html">int</a> vertex, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:a2adac0f129f0bdaa1600b14a543bdaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd80ab9c6099f69d8d980b9f6fa070b"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#addd80ab9c6099f69d8d980b9f6fa070b">face_to_cell_lines</a> (const unsigned <a class="el" href="classint.html">int</a> face, const unsigned <a class="el" href="classint.html">int</a> line, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:addd80ab9c6099f69d8d980b9f6fa070b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b2e56d13ff47bf46c4dbdaef49508c"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a24b2e56d13ff47bf46c4dbdaef49508c">standard_to_real_face_vertex</a> (const unsigned <a class="el" href="classint.html">int</a> vertex, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:a24b2e56d13ff47bf46c4dbdaef49508c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad032159a72b9a4e71ab25912d9d4737d"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#ad032159a72b9a4e71ab25912d9d4737d">real_to_standard_face_vertex</a> (const unsigned <a class="el" href="classint.html">int</a> vertex, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:ad032159a72b9a4e71ab25912d9d4737d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6b330c8a3699c3e70b833cf164a77b"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a5f6b330c8a3699c3e70b833cf164a77b">standard_to_real_face_line</a> (const unsigned <a class="el" href="classint.html">int</a> line, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:a5f6b330c8a3699c3e70b833cf164a77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0250ad9b85b95081a95c280457ec76ba"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a0250ad9b85b95081a95c280457ec76ba">standard_to_real_line_vertex</a> (const unsigned <a class="el" href="classint.html">int</a> vertex, const <a class="el" href="classbool.html">bool</a> line_orientation=true)</td></tr>
<tr class="separator:a0250ad9b85b95081a95c280457ec76ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e986d54f7ba4754b976437eecb139c"><td class="memItemLeft" align="right" valign="top">static std::array&lt; unsigned <a class="el" href="classint.html">int</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#ae0e986d54f7ba4754b976437eecb139c">standard_quad_vertex_to_line_vertex_index</a> (const unsigned <a class="el" href="classint.html">int</a> vertex)</td></tr>
<tr class="separator:ae0e986d54f7ba4754b976437eecb139c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa8dcf848b7c7ce048d4161206c52ef"><td class="memItemLeft" align="right" valign="top">static std::array&lt; unsigned <a class="el" href="classint.html">int</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#affa8dcf848b7c7ce048d4161206c52ef">standard_hex_vertex_to_quad_vertex_index</a> (const unsigned <a class="el" href="classint.html">int</a> vertex)</td></tr>
<tr class="separator:affa8dcf848b7c7ce048d4161206c52ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed8aecb4e67dfeb06ace9d8af349d0d"><td class="memItemLeft" align="right" valign="top">static std::array&lt; unsigned <a class="el" href="classint.html">int</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a2ed8aecb4e67dfeb06ace9d8af349d0d">standard_hex_line_to_quad_line_index</a> (const unsigned <a class="el" href="classint.html">int</a> line)</td></tr>
<tr class="separator:a2ed8aecb4e67dfeb06ace9d8af349d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6d27bc23671e82a8a69a938fca4166"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#aaf6d27bc23671e82a8a69a938fca4166">real_to_standard_face_line</a> (const unsigned <a class="el" href="classint.html">int</a> line, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:aaf6d27bc23671e82a8a69a938fca4166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328671c4ef755bea25625d068eaa8d31"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a328671c4ef755bea25625d068eaa8d31">unit_cell_vertex</a> (const unsigned <a class="el" href="classint.html">int</a> vertex)</td></tr>
<tr class="separator:a328671c4ef755bea25625d068eaa8d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0102b28ec69c4bc6b2b0337715c09bc8"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a0102b28ec69c4bc6b2b0337715c09bc8">child_cell_from_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p)</td></tr>
<tr class="separator:a0102b28ec69c4bc6b2b0337715c09bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d17e49dab89d46ada2fff521cc5337"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a90d17e49dab89d46ada2fff521cc5337">cell_to_child_coordinates</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> child_index, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; refine_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement)</td></tr>
<tr class="separator:a90d17e49dab89d46ada2fff521cc5337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e860ab6e9daead69bab4553c1b7921a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a6e860ab6e9daead69bab4553c1b7921a">child_to_cell_coordinates</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> child_index, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; refine_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement)</td></tr>
<tr class="separator:a6e860ab6e9daead69bab4553c1b7921a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2d235da3d7459096d535d360bcf3d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#ace2d235da3d7459096d535d360bcf3d3">is_inside_unit_cell</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p)</td></tr>
<tr class="separator:ace2d235da3d7459096d535d360bcf3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1e5a9fe7531316d23bbc8df02833f2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a0f1e5a9fe7531316d23bbc8df02833f2">is_inside_unit_cell</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const <a class="el" href="classdouble.html">double</a> eps)</td></tr>
<tr class="separator:a0f1e5a9fe7531316d23bbc8df02833f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae0fe397acba1d1079cbfa917b7046c"><td class="memTemplParams" colspan="2">template&lt;typename Number  = double&gt; </td></tr>
<tr class="memitem:aaae0fe397acba1d1079cbfa917b7046c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classPoint.html">Point</a>&lt; dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#aaae0fe397acba1d1079cbfa917b7046c">project_to_unit_cell</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim, Number &gt; &amp;p)</td></tr>
<tr class="separator:aaae0fe397acba1d1079cbfa917b7046c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106c0b4889baa0f60e5754a2b43c420d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a106c0b4889baa0f60e5754a2b43c420d">distance_to_unit_cell</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p)</td></tr>
<tr class="separator:a106c0b4889baa0f60e5754a2b43c420d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1d6d09377959718f18d1443757895c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a9e1d6d09377959718f18d1443757895c">d_linear_shape_function</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;xi, const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:a9e1d6d09377959718f18d1443757895c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad48513b4c435ca22f2a026f1918ac44"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#aad48513b4c435ca22f2a026f1918ac44">d_linear_shape_function_gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;xi, const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:aad48513b4c435ca22f2a026f1918ac44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af047ab1fe45077a53df9cd8212fc790c"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:af047ab1fe45077a53df9cd8212fc790c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#af047ab1fe45077a53df9cd8212fc790c">alternating_form_at_vertices</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;(&amp;<a class="el" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>)[<a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a>], <a class="el" href="classTensor.html">Tensor</a>&lt; spacedim - dim, spacedim &gt;(&amp;forms)[<a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a>])</td></tr>
<tr class="separator:af047ab1fe45077a53df9cd8212fc790c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6c0be4a8cd812fd4fa7266e75e3b93"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3e6c0be4a8cd812fd4fa7266e75e3b93">ExcInvalidCoordinate</a> (<a class="el" href="classdouble.html">double</a> arg1)</td></tr>
<tr class="separator:ga3e6c0be4a8cd812fd4fa7266e75e3b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65a897bfa399fb45d5a49f56fe372011"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga65a897bfa399fb45d5a49f56fe372011">ExcInvalidSubface</a> (<a class="el" href="classint.html">int</a> arg1, <a class="el" href="classint.html">int</a> arg2, <a class="el" href="classint.html">int</a> arg3)</td></tr>
<tr class="separator:ga65a897bfa399fb45d5a49f56fe372011"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:afd3320089fb8cbd675963e56fb37d01f"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#afd3320089fb8cbd675963e56fb37d01f">max_children_per_cell</a> = 1 &lt;&lt; dim</td></tr>
<tr class="separator:afd3320089fb8cbd675963e56fb37d01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3e48d5e97a217c149a33c0b42a51c2"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> = 2 * dim</td></tr>
<tr class="separator:a5d3e48d5e97a217c149a33c0b42a51c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fc1bee407ade48090ce592473dc327"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a29fc1bee407ade48090ce592473dc327">max_children_per_face</a></td></tr>
<tr class="separator:a29fc1bee407ade48090ce592473dc327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb3a95a842d98b8b3bf9a64735d0eee"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a> = 1 &lt;&lt; dim</td></tr>
<tr class="separator:a2bb3a95a842d98b8b3bf9a64735d0eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8410f6471e4ac443b51f6c20809bfb"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#aad8410f6471e4ac443b51f6c20809bfb">vertices_per_face</a></td></tr>
<tr class="separator:aad8410f6471e4ac443b51f6c20809bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef86260668d5b98a7bb73db8986d027"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#afef86260668d5b98a7bb73db8986d027">lines_per_face</a></td></tr>
<tr class="separator:afef86260668d5b98a7bb73db8986d027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166d28164dfd718a9211ae788e057b56"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a166d28164dfd718a9211ae788e057b56">quads_per_face</a></td></tr>
<tr class="separator:a166d28164dfd718a9211ae788e057b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de02b6910b68785cc8acd9488599092"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a3de02b6910b68785cc8acd9488599092">lines_per_cell</a></td></tr>
<tr class="separator:a3de02b6910b68785cc8acd9488599092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa91c1fd95bc59a8c34a4af6443c2f85"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#afa91c1fd95bc59a8c34a4af6443c2f85">quads_per_cell</a></td></tr>
<tr class="separator:afa91c1fd95bc59a8c34a4af6443c2f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3c139c94b4d9e54371400514a102f4"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a6e3c139c94b4d9e54371400514a102f4">hexes_per_cell</a></td></tr>
<tr class="separator:a6e3c139c94b4d9e54371400514a102f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a95dd40f1faa1a1bad8210dcb66f1f"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a09a95dd40f1faa1a1bad8210dcb66f1f">ucd_to_deal</a></td></tr>
<tr class="separator:a09a95dd40f1faa1a1bad8210dcb66f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c82eb40866a5d8685d23604b76300f"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a33c82eb40866a5d8685d23604b76300f">dx_to_deal</a></td></tr>
<tr class="separator:a33c82eb40866a5d8685d23604b76300f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea298d2f0914e2810d9b96081e809f6a"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="ndarray_8h.html#a82399009710c9549884b9d8c506ad695">ndarray</a>&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a>, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#aea298d2f0914e2810d9b96081e809f6a">vertex_to_face</a></td></tr>
<tr class="separator:aea298d2f0914e2810d9b96081e809f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41eabdf96722189263e5ede8ab8d566a"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a41eabdf96722189263e5ede8ab8d566a">unit_normal_direction</a></td></tr>
<tr class="separator:a41eabdf96722189263e5ede8ab8d566a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b79386bf8ca6410c906c3b8c4e8c40"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#af9b79386bf8ca6410c906c3b8c4e8c40">unit_normal_orientation</a></td></tr>
<tr class="separator:af9b79386bf8ca6410c906c3b8c4e8c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b67e58ad8e792e55efc3cbfb274ef7"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;, <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#aa9b67e58ad8e792e55efc3cbfb274ef7">unit_normal_vector</a></td></tr>
<tr class="separator:aa9b67e58ad8e792e55efc3cbfb274ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba9791aca6cde3acf3f79bbb63e8247"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="ndarray_8h.html#a82399009710c9549884b9d8c506ad695">ndarray</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;, <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a>, dim - 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a0ba9791aca6cde3acf3f79bbb63e8247">unit_tangential_vectors</a></td></tr>
<tr class="separator:a0ba9791aca6cde3acf3f79bbb63e8247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29821832e1cd4777e3e377c022e09073"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a29821832e1cd4777e3e377c022e09073">opposite_face</a></td></tr>
<tr class="separator:a29821832e1cd4777e3e377c022e09073"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim&gt;<br />
struct GeometryInfo&lt; dim &gt;</h3>

<p>该类为构成单元的所有拓扑结构提供独立的维度信息，或 <a class="el" href="DEALGlossary.html#GlossReferenceCell">参考单元</a> 。这个类已经被ReferenceCell类所取代。</p>
<ul>
<li>更多信息见那里。</li>
</ul>
<p>它是库中的一个中心点，关于参考单元的顶点、线或面的编号的信息被收集起来。因此，这个类的信息被广泛用于Triangulation对象的几何描述，以及代码的其他各个部分。特别是，它也是以独立于维度的方式编写代码的重点；例如，在2D中不写顶点0&lt;=v&lt;4的循环，而是写成 0&lt;=v&lt;<a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">GeometryInfo&lt;dim&gt;::vertices_per_cell</a>, ，从而使代码在3D中也能工作，而无需改变。 该类中最常用的部分是它的静态成员，如vertices_per_cell、faces_per_cell等。然而，该类也提供了关于更抽象的问题的信息，如面的方向等。下面的文档给出了许多这些概念的文字描述。</p>
<h3>Implementation conventions for two spatial dimensions</h3>
<p>从5.2版本开始，deal.II基于一个编号方案，尽可能使用lexicographic排序（x跑得最快），因此试图采用一种'经典'排序。 2d中顶点和面（线）的排序定义为</p>
<ul>
<li>顶点的编号是按词法排序的</li>
<li>面（2d中的线）：首先是在x方向和y方向上有法线的两个面。对于每两个面：首先是法线为负坐标方向的面，然后是法线为正坐标方向的面，也就是说，面的排序是根据它们的法线指向</li>
<li>, x,</li>
<li>, y方向的法线排序。</li>
<li>线条的方向由点0对点1的方向表示，并且总是在其中一个坐标方向上</li>
<li>3d中的面线是有序的，这样诱导的2D局部坐标系（x,y）意味着（右手规则）面线法线方向的法线，见N2/。 由此产生的2d中顶点和面（线）的编号，以及线的方向，如下所示。</li>
</ul>
<pre class="fragment">*     3
*  2--&gt;--3
*  |     |
* 0^     ^1
*  |     |
*  0--&gt;--1
*      2
* </pre><p>请注意，在构建网格时，线的方向必须是正确的；但是，在细化时，它将自动被保留。 此外，我们定义子线的方向与父线相同，即<code>line-&gt;child(0)-&gt;vertex(0)==line-&gt;vertex(0)</code>，<code>line-&gt;child(1)-&gt;vertex(1)==line-&gt;vertex(1)</code>。这也意味着，第一条子线（<code>line-&gt;child(0)</code>）是位于旧线的顶点(0)的那条。 同样地，我们定义，一个四边形的四个子线与旧四边形的顶点相邻，并具有相同的编号。 请注意，关于这些约定的几个信息可以在运行或编译时从本类的成员函数和变量中提取出来。</p>
<h4>Coordinate systems</h4>
<p>当单元格中的点需要明确的坐标时（例如用于正交公式或试用函数的定义点），我们为单元格定义以下坐标系统。</p>
<pre class="fragment">* y^   2-----3
* |   |     |
* |   |     |
* |   |     |
* |   0-----1
*
*
*
*
*
*
*
*
*
* ------------&gt;x
* </pre><p>这里，顶点0是坐标系的原点，顶点1的坐标是&lt;tt&gt;(1,0)，顶点2在&lt;tt&gt;(0,1)，顶点3在&lt;tt&gt;(1,1)。 <a class="el" href="structGeometryInfo.html#a328671c4ef755bea25625d068eaa8d31">GeometryInfo&lt;dim&gt;::unit_cell_vertex()</a> 函数可以用来在运行时查询这些信息。</p>
<h3>Implementation conventions for three spatial dimensions</h3>
<p>按照惯例，我们将对三空间维度的六面体的顶点、线和面使用以下编号惯例。在给出这些约定之前，我们声明以下草图是绘制六面体的三维图片的标准方式。</p>
<pre class="fragment">*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* -------*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* -------*
*                    /|       |       /       /|
*                   / |       |      /       / |
* z                 /  |       |     /       /  |
* ^                  |       |
*
*
*
*
*
*
*
*
*
* -------*   |
* |   ^y           |
*
*
*
*
*
* -------*    |       |
* |  /             |  /       /     |       |  /
* | /              | /       /      |       | /
* |/               |/       /       |       |/
*
*
*
*
*
* ------&gt;x
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* -------*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* -------*
* </pre><p> 图片的左边部分显示的是立方体的左面、底部和背面，而右边的应是顶部、右侧和正面。你可以通过将这两部分移到一起恢复整个立方体。 请再次注意，以下几个约定的信息可以在运行或编译时从本类的成员函数和变量中提取。 </p><h4>Vertices</h4>
<p>3d中顶点的排序是由与2D情况相同的规则定义的。特别是，以下情况仍然是真实的。</p>
<ul>
<li>顶点的编号是按词法排序的。 因此，顶点的编号方式如下</li>
</ul>
<pre class="fragment">*     6-------7        6-------7
*    /|       |       /       /|
*   / |       |      /       / |
*  /  |       |     /       /  |
* 4   |       |    4-------5   |
* |   2-------3    |       |   3
* |  /       /     |       |  /
* | /       /      |       | /
* |/       /       |       |/
* 0-------1        0-------1
* </pre><p>我们注意到，首先，底面的顶点（z=0）的编号方式与四边形的顶点完全相同。然后将底面的顶点(z=1)移到顶面，进行类似的编号。同样， <a class="el" href="structGeometryInfo.html#a328671c4ef755bea25625d068eaa8d31">GeometryInfo&lt;dim&gt;::unit_cell_vertex()</a> 函数可以用来在运行时查询这些信息。</p>
<h4>Lines</h4>
<p>这里，与顶点的情况相同。</p>
<ul>
<li>3d中的线序。 <ul>
<li>
首先是面(z=0)的线，按2D线排序， </li>
<li>
然后是面(z=1)的线，按2D线排序， </li>
<li>
最后是Z方向的线，按lexicographic排序 </li>
</ul>
。 <pre class="fragment">*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---7---*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---7---*
*    /|       |       /       /|
*   4 |       11     4       5 11
*  /  10      |     /       /  |
*   |       |
*
*
*
*
*
*
*
*
*
* ---6---*   |
* |
*
*
*
*
*
* ---3---*    |       |
* |  /       /     |       9  /
* 8 0       1      8       | 1
* |/       /       |       |/
*
*
*
*
*
*
*
*
*
* ---2---*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---2---*
* </pre> 如同在2d中，线是以坐标方向指向的。</li>
</ul>
<pre class="fragment">*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---&gt;---*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---&gt;---*
*    /|       |       /       /|
*   ^ |       ^      ^       ^ ^
*  /  ^       |     /       /  |
*   |       |
*
*
*
*
*
*
*
*
*
* ---&gt;---*   |
* |
*
*
*
*
*
* ---&gt;---*    |       |
* |  /       /     |       ^  /
* ^ ^       ^      ^       | ^
* |/       /       |       |/
*
*
*
*
*
*
*
*
*
* ---&gt;---*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---&gt;---*
* </pre><p>边缘（就像顶点和面）是以其自身的权利存储的实体，而不是在每次需要时从单元格中构造出来，这一事实意味着相邻的单元格实际上有指向边缘的指针，因此它们之间是共享的。这意味着平行边的集合具有平行方向的约定不仅仅是一个局部条件。在单元格列表被传递给Triangulation类的对象以创建三角形之前，你必须确保单元格的方向是兼容的，这样边的方向才是全局的，符合上述惯例。然而，GridReordering类可以为你做到这一点，它可以对输入单元的任意列表中的单元和边进行重新定向，这些单元不需要已经被排序。 </p><h4>Faces</h4>
<p>3D中面的编号是由一个类似2D的规则来定义的。</p>
<ul>
<li>面（3d中的四边形）：首先是在x-方向有法线的两个面，然后是y-和z-方向。对于每两个面：首先是法线在负坐标方向的面，然后是法线在正方向的面，也就是说，面的顺序是根据它们的法线指向</li>
<li>, x,</li>
<li>, y,</li>
<li>，Z方向。 因此，面的编号顺序为：左、右、前、后、底、顶面。 <pre class="fragment">*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* -------*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* -------*
*    /|       |       /       /|
*   / |   3   |      /   5   / |
*  /  |       |     /       /  |
*   |       |
*
*
*
*
*
*
*
*
*
* -------*   |
* | 0-------*    |       | 1
* |  /       /     |       |  /
* | /   4   /      |   2   | /
* |/       /       |       |/
*
*
*
*
*
*
*
*
*
* -------*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* -------*
* </pre></li>
</ul>
<p>面的 <em> 标准 </em> 方向是这样的，即诱导的2d局部坐标系（x,y）意味着（右手规则）面法线方向的法线，见N2a）。 在下文中，我们展示了局部坐标系和面线的编号。 </p><ul>
<li>
面的0和1。 <pre class="fragment">*        Face 0           Face 1
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* -------*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* -------*
*     /|       |       /       /|
*    3 1       |      /       3 1
*  y/  |       |     /      y/  |
*    |x      |
*
*
*
*
*
*
*
*
*
* -------*   |x
*  |
*
*
*
*
*
* -------*    |       |
*  0  /       /     |       0  /
*  | 2       /      |       | 2
*  |/       /       |       |/
*
*
*
*
*
*
*
*
*
*
*
*
*
* -------*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* -------*
* </pre> </li>
<li>
<p class="startli">脸部2和3。 </p><pre class="fragment">*      x Face 3           Face 2
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---1---*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* -------*
*     /|       |       /       /|
*    / |       3      /       / |
*   /  2       |    x/       /  |
*    |       |
*
*
*
*
*
*
*
*
*
* ---1---*   |
*  |
*
*
*
*
*
* ---0---*y   |       |
*  |  /       /     |       3  /
*  | /       /      2       | /
*  |/       /       |       |/
*
*
*
*
*
*
*
*
*
*
*
*
*
* -------*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---0---*y
* </pre><p class="endli"></p>
</li>
<li>
脸部4和5。 <pre class="fragment">*        Face 4         y Face 5
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* -------*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---3---*
*     /|       |       /       /|
*    / |       |      0       1 |
*   /  |       |     /       /  |
*    |y      |
*
*
*
*
*
*
*
*
*
* ---2---* x |
*  |
*
*
*
*
*
* ---3---*    |       |
*  |  /       /     |       |  /
*  | 0       1      |       | /
*  |/       /       |       |/
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---2---* x
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* -------*
* </pre> </li>
</ul>
<p>面的行号（0,1,2,3）对应于以下细胞行号。 </p><ul>
<li>
面0：第8、10、0、4行； </li>
<li>
面1：第9、11、1、5行； </li>
<li>
面2：第2、6、8、9行； </li>
<li>
] 面部3：第3、7、10、11行； </li>
<li>
面部4：第0、1、2、3行； </li>
<li>
面部5：第4、5、6、7行； </li>
</ul>
<p>你可以用 <a class="el" href="structGeometryInfo.html#addd80ab9c6099f69d8d980b9f6fa070b">GeometryInfo&lt;3&gt;::face_to_cell_lines()</a> 函数得到这些数字。 脸部法线可以通过应用右手规则（x,y</p>
<p>-&gt; 法线）。) 我们注意到，在2D的标准方向上，面0和面2的法线指向单元格内，面1和面3的法线指向外。在3D中，面0、2和4的法线指向单元格内，而面1、3和5的法线指向外面。这些信息同样可以从 <a class="el" href="structGeometryInfo.html#af9b79386bf8ca6410c906c3b8c4e8c40">GeometryInfo&lt;dim&gt;::unit_normal_orientation</a>. 中查询到。 然而，事实证明，大量的三维网格不能满足这个约定。这是由于一个单元的面的约定已经暗示了相邻单元的东西，因为它们共享一个共同的面，对第一个单元的固定也固定了两个单元的相对面的法向量。很容易构建单元格循环的案例，对于这些案例，我们无法为所有面找到与该约定一致的方向。 由于这个原因，上述惯例只是我们所说的 <em> 标准方向 </em> ......II实际上允许3d中的面要么有标准方向，要么有其相反的方向，在这种情况下，构成单元格的线会有还原的顺序，上述线的等价关系就不再成立了。你可以通过调用<code>cell-&gt;face_orientation(face_no)</code>来询问一个单元格的某个面是否有标准方向：如果结果是 <code>true</code>, ，那么这个面就有标准方向，否则它的法向量就指向另一个方向。在应用程序中，你需要这些信息的地方其实并不多，但库中有几个地方用到了这个信息。注意，在2d中，结果总是 <code>true</code>. 关于这个主题的更多信息可以在这个 <a class="el" href="DEALGlossary.html#GlossFaceOrientation">词汇表 </a> 文章中找到。 为了允许3D中的各种网格，包括 <em> Moebius </em> -loops，一个面甚至可能从一个单元看是旋转的，而从共享该特定面的邻近单元看则是按照标准。为了解决这个问题，有两个标志<code>face_flip</code>和<code>face_rotation</code>，分别代表180度和90度的旋转。设置这两个标志相当于270度的旋转（都是逆时针）。你可以像询问<code>面的方向</code>一样询问单元格的这些标志。为了启用旋转的面，甚至线条也可以偏离它们在3D中的标准方向。这个信息可以作为<code>line_orientation</code>标志提供给三维中的单元和面。同样，这应该是库内部的东西，应用程序可能永远都不需要去管它。更多的信息请参见 <a class="el" href="DEALGlossary.html#GlossFaceOrientation">这个词汇表条目</a> 。</p>
<h4>Children</h4>
<p>一个各向同性的细化单元的八个子单元是根据它们相邻的顶点来编号的。</p>
<pre class="fragment">*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----*
*    /| 6  |  7 |       / 6  /  7 /|
*  6|    |    |
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----*7|
*  /|----*----*     / 4  /  5 /|
* |/|    |    |
*
*
*
*
*
*
*
*
*
* ----*----* |/|
* |4* | 2  |  3 |    | 4  |  5 |5*3|
* |/|2*----*----*    |    |    |/|
* |/ 2  /  3 /
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----* |/
* |0*----*----*      |    |    |1*
* |/0   /  1 /       | 0  |  1 |/
*
*
*
*
*
*
*
*
*
* ----*----*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----*
* </pre><p> 考虑到面的方向，下列子节点与各自的面相邻。 </p><ul>
<li>
面0：子0、2、4、6； </li>
<li>
面1：子1、3、5、7； </li>
<li>
面2：子0、4、1、5； </li>
<li>
面3：子2、6、3、7； </li>
<li>
面4：子0、1、2、3； </li>
<li>
面5：子4、5、6、7。 </li>
</ul>
<p>你可以用 <a class="el" href="structGeometryInfo.html#a1263120c3a820d6b17b4055e6e0ef9f1">GeometryInfo&lt;3&gt;::child_cell_on_face()</a> 函数得到这些数字。由于每个孩子都与具有相同数字的顶点相邻，这些数字也可以通过 <a class="el" href="structGeometryInfo.html#a2adac0f129f0bdaa1600b14a543bdaa4">GeometryInfo&lt;3&gt;::face_to_cell_vertices()</a> 函数得到。 请注意，上述列表只适用于标准方向的面。如果一个面不在标准方向上，那么在位置1和2（从0到3算起）的孩子会被交换。事实上，这就是GeometryInfo&lt;3&gt;的child_cell_on_face和face_to_cell_vertices函数在调用<code>face_orientation=false</code>参数时的作用。 哪个子单元在哪个面的哪个位置的信息，在计算有悬挂节点的面之间的跳跃项时，最常使用的是FESubfaceValues类型的对象。坐在一个单元格上，你会看一个面，然后算出邻居的哪个子单元是坐在现在和邻居单元之间的一个给定的子表面上。为了避免在这种情况下每次都要查询两个单元格面的标准方向，你应该使用类似<code>cell-&gt;neighbor_child_on_subface(face_no,subface_no)</code>的函数调用，它在2D（面的方向不重要）和3D（需要使用面的方向作为 <code><a class="el" href="structGeometryInfo.html#a1263120c3a820d6b17b4055e6e0ef9f1">GeometryInfo&lt;3&gt;::child_cell_on_face</a></code>). 的附加参数）中都能返回正确的结果。 对于各向异性的细化，子单元不能根据相邻的顶点进行编号，因此使用了以下惯例。</p>
<pre class="fragment">*          RefinementCase&lt;3&gt;::cut_x
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----*
*    /|    |    |       /    /    /|
*   / |    |    |      / 0  /  1 / |
*  /  | 0  |  1 |     /    /    /  |
*   |    |    |
*
*
*
*
*
*
*
*
*
* ----*----*   |
* | 0 |    |    |    |    |    | 1 |
* |
*
*
*
*
*
* ----*----*    |    |    |
* |  /    /    /     | 0  | 1  |  /
* | / 0  /  1 /      |    |    | /
* |/    /    /       |    |    |/
*
*
*
*
*
*
*
*
*
* ----*----*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----*
* </pre><pre class="fragment">*          RefinementCase&lt;3&gt;::cut_y
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---------*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---------*
*    /|         |       /    1    /|
*   |         |
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---------* |
*  /| |    1    |     /    0    /| |
* |1|         |
*
*
*
*
*
*
*
*
*
* ---------* |1|
* | | |         |    |         | | |
* |0|---------*    |         |0|
* | |/    1    /     |    0    | |/
* |---------*      |         |
* |/    0    /       |         |/
*
*
*
*
*
*
*
*
*
* ---------*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---------*
* </pre><pre class="fragment">*          RefinementCase&lt;3&gt;::cut_z
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---------*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---------*
*    /|    1    |       /         /|
*   / |         |      /    1    / |
*  /
*
* ---------*     /         /
* 1/|         |
*
*
*
*
*
*
*
*
*
* ---------* 1/|
* | / |    0    |    |    1    | / |
* |/
*
* ---------*    |         |/
* 0/         /
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---------* 0/
* | /    0    /      |         | /
* |/         /       |    0    |/
*
*
*
*
*
*
*
*
*
* ---------*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---------*
* </pre> <pre class="fragment">*          RefinementCase&lt;3&gt;::cut_xy
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----*
*    /|    |    |       / 2  /  3 /|
*   |    |    |
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----* |
*  /| | 2  |  3 |     / 0  /  1 /| |
* |2|    |    |
*
*
*
*
*
*
*
*
*
* ----*----* |3|
* | | |    |    |    |    |    | | |
* |0|----*----*    |    |    |1|
* | |/ 2  /  3 /     | 0  |  1 | |/
* |----*----*      |    |    |
* |/ 0  /  1 /       |    |    |/
*
*
*
*
*
*
*
*
*
* ----*----*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----*
* </pre><pre class="fragment">*          RefinementCase&lt;3&gt;::cut_xz
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----*
*    /| 1  |  3 |       /    /    /|
*   / |    |    |      / 1  /  3 / |
*  /
*
* ----*----*     /    /    /
* 1/|    |    |
*
*
*
*
*
*
*
*
*
* ----*----* 3/|
* | / | 0  |  2 |    | 1  |  3 | / |
* |/
*
* ----*----*    |    |    |/
* 0/    /    /
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----* 2/
* | / 0  /  2 /      |    |    | /
* |/    /    /       | 0  |  2 |/
*
*
*
*
*
*
*
*
*
* ----*----*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ----*----*
* </pre> <pre class="fragment">*          RefinementCase&lt;3&gt;::cut_yz
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---------*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---------*
*    /|    3    |       /    3    /|
*   |         |
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---------* |
*  /|3*---------*     /    2    /|3*
* |/|         |
*
*
*
*
*
*
*
*
*
* ---------* |/|
* |2* |    1    |    |    2    |2* |
* |/|1*---------*    |         |/|1*
* |/    1    /
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---------* |/
* |0*---------*      |         |0*
* |/    0    /       |    0    |/
*
*
*
*
*
*
*
*
*
* ---------*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* ---------*
* </pre><p>这一信息也可以通过 <code><a class="el" href="structGeometryInfo.html#a1263120c3a820d6b17b4055e6e0ef9f1">GeometryInfo&lt;3&gt;::child_cell_on_face</a></code> 函数获得。 </p><h4>Coordinate systems</h4>
<p>我们为单元格顶点的显性坐标定义了以下坐标系。</p>
<pre class="fragment">*                     6-------7        6-------7
*                    /|       |       /       /|
*                   / |       |      /       / |
* z                 /  |       |     /       /  |
* ^                4   |       |    4-------5   |
* |   ^y           |   2-------3    |       |   3
* |  /             |  /       /     |       |  /
* | /              | /       /      |       | /
* |/               |/       /       |       |/
*
*
*
*
*
* ------&gt;x        0-------1        0-------1
* </pre><p>根据上面的惯例，顶点的坐标如下（排位法，x跑得最快）。 </p><ul>
<li>
顶点0：&lt;tt&gt;(0,0,0); </li>
<li>
顶点1：&lt;tt&gt;(1,0,0); </li>
<li>
顶点2：<code>（0,1,0）</code>; </li>
<li>
顶点3：<code>（1,1,0）</code>; </li>
<li>
顶点4。&lt;tt&gt;(0,0,1); </li>
<li>
顶点5：&lt;tt&gt;(1,0,1); </li>
<li>
顶点6。&lt;tt&gt;(0,1,1); </li>
<li>
顶点7：&lt;tt&gt;(1,1,1)。 </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>这个模板的实例是为维度1,2,3,4提供的，还有一个针对dim=0的特殊化（见手册中的 <a class="el" href="Instantiations.html">Template instantiations</a> 部分）。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l01515">1515</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a253fd1bcb288e88bdecccf727b7b907a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253fd1bcb288e88bdecccf727b7b907a">&#9670;&nbsp;</a></span>face_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::face_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对象，它可以被认为是一个包含从零到<code>面孔_per_cell</code>所有索引的数组。这允许使用基于范围的for循环来编写以下类型的代码。 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> face_index : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;face(face_index)-&gt;at_boundary())</div><div class="line">      ... <span class="keywordflow">do</span> something ...</div></div><!-- fragment --><p> 这里，我们正在循环所有单元格的所有面，<code>face_index</code>接收所有有效的面的索引（1d中的0和1，2D中的0到3，以及3D中的0到5）。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CPP11.html">deal.II and the C++11 standard</a> </dd></dl>

</div>
</div>
<a id="a3a76e2c08f49817f09bcab9bbb7e373c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a76e2c08f49817f09bcab9bbb7e373c">&#9670;&nbsp;</a></span>vertex_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertex_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对象，它可以被认为是一个包含从零到`顶点_per_cell'所有索引的数组。这样就可以使用基于范围的for循环来编写以下类型的代码。 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vertex_index : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::vertex_indices</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;vertex(vertex_index) satisfies some condition)</div><div class="line">      ... <span class="keywordflow">do</span> something ...</div></div><!-- fragment --><p> 这里，我们在所有单元格的所有顶点上循环，<code>vertex_index</code>使用所有有效的索引。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CPP11.html">deal.II and the C++11 standard</a> </dd></dl>

</div>
</div>
<a id="ad022815fd2a5c25fc0cddaca93f3cca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad022815fd2a5c25fc0cddaca93f3cca5">&#9670;&nbsp;</a></span>n_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::n_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回用<code>ref_case</code>提炼的单元格（或面）的子节点数量。 </p>

</div>
</div>
<a id="afe25e8c0a5a67e3618fa17dadf58b944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe25e8c0a5a67e3618fa17dadf58b944">&#9670;&nbsp;</a></span>n_subfaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::n_subfaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subface_case</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回根据 <a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a> <code>face_ref_case</code>. 精炼的一个面的子面的数量。 </p>

</div>
</div>
<a id="a6ca2ea6ad9db59ae8d34662599e14fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca2ea6ad9db59ae8d34662599e14fc2">&#9670;&nbsp;</a></span>subface_ratio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdouble.html">double</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::subface_ratio </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subface_case</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定参考元素上的一个具有 <code><a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt;dim&gt;</code> <code>face_refinement_case</code> 的面，该函数返回 <code>subface_no</code> 第1个子面的面积与该面的面积（=1）之间的比率。 例如，对于 internal::SubfaceCase::cut_xy ，每个子面的比例是1/4。 </p>

</div>
</div>
<a id="af6b91a076a13a5a6594f132b09c824c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b91a076a13a5a6594f132b09c824c3">&#9670;&nbsp;</a></span>face_refinement_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim - 1&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::face_refinement_case </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_refinement_case</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定一个用 <code><a class="el" href="classRefinementCase.html">RefinementCase</a></code> <code>cell_refinement_case精炼的单元格，返回</code> <code>face_no</code> th面的 <code>SubfaceCase</code> 。 </p>

</div>
</div>
<a id="a0ff1bd9fab7ea7b2ab9265c53c8e34a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff1bd9fab7ea7b2ab9265c53c8e34a4">&#9670;&nbsp;</a></span>min_cell_refinement_case_for_face_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::min_cell_refinement_case_for_face_refinement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_refinement_case</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给出第 <code>face_no</code> 个面的SubfaceCase <code>face_refinement_case</code> ，返回最小的单元格的RefinementCase，它对应于该面的细化。 </p>

</div>
</div>
<a id="a3f5efb5e5ca92dfead4105ff194dbe94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5efb5e5ca92dfead4105ff194dbe94">&#9670;&nbsp;</a></span>line_refinement_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;1&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::line_refinement_case </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_refinement_case</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定一个用RefinementCase <code>cell_refinement_case</code> 精炼的单元格，返回第 <code>line_no</code> 个面的RefinementCase。 </p>

</div>
</div>
<a id="a46b46dc2ac462eeeeab76b04e22928b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b46dc2ac462eeeeab76b04e22928b8">&#9670;&nbsp;</a></span>min_cell_refinement_case_for_line_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::min_cell_refinement_case_for_line_refinement </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回单元格的最小/最小的RefinementCase，确保细化线 <code>line_no</code>. 。 </p>

</div>
</div>
<a id="a1263120c3a820d6b17b4055e6e0ef9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1263120c3a820d6b17b4055e6e0ef9f1">&#9670;&nbsp;</a></span>child_cell_on_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::child_cell_on_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_case</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个字段存储了哪些子单元与母单元的某个面相邻。 例如，在2D中，一个单元格的布局如下。 </p><pre class="fragment">* .      3
* .   2--&gt;--3
* .   |     |
* . 0 ^     ^ 1
* .   |     |
* .   0--&gt;--1
* .      2
* </pre><p> 顶点和面用它们的数字表示，面也用它们的方向表示。 现在，在细化时，布局是这样的。 </p><pre class="fragment">*
*
*
*
*
*
*
*
*
* --*--*
* | 2|3 |
*
*
*
*
*
*
*
*
*
* --*--*
* | 0|1 |
*
*
*
*
*
*
*
*
*
* --*--*
* </pre><p> 因此，面0上的子单元是（按面的方向排序）0和2，面3上是2和3，等等。 对于三个空间维度，子单元的确切顺序在这个类的一般文件中规定了。 通过<code>face_orientation</code>, <code>face_flip</code> 和 <code>face_rotation</code> 参数，这个函数可以处理以标准和非标准方向的面。<code>face_orientation</code>默认为<code>true</code>，<code>face_flip</code>和<code>face_rotation</code>默认为<code>false</code>（标准方向），在2d中没有影响。 面部方向的概念在这个 <a class="el" href="DEALGlossary.html#GlossFaceOrientation">词汇表 </a> 条目中得到了解释。 在各向异性细化单元和面的情况下，面的 <code>RefinementCase，<code>face_ref_case</code>，可能对哪个子面在哪个给定子面后面有影响，因此这是一个附加参数，默认为面的各向同性细化。</code> </p>

</div>
</div>
<a id="abd66dc231589a519786719dbde492c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd66dc231589a519786719dbde492c9a">&#9670;&nbsp;</a></span>line_to_cell_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::line_to_cell_vertices </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将线的顶点编号映射到单元格顶点编号，即给出<code>线</code>的第1个顶点的单元格顶点编号，例如： <code>GeometryInfo&lt;2&gt;::line_to_cell_vertices(3,0)=2</code>. 线的顺序，以及它们的方向（这又决定了哪一个是线上的第一个顶点，哪一个是第二个顶点）是deal.II中的典范，如该类的一般文档中所述。 对于<code>dim=2</code>，这个调用被简单地传递给face_to_cell_vertices()函数。 </p>

</div>
</div>
<a id="a2adac0f129f0bdaa1600b14a543bdaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2adac0f129f0bdaa1600b14a543bdaa4">&#9670;&nbsp;</a></span>face_to_cell_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::face_to_cell_vertices </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将面的顶点编号映射到单元格的顶点编号，即给出面的<code>顶点</code>第1个顶点的单元格顶点编号，例如， <code>GeometryInfo&lt;2&gt;::face_to_cell_vertices(3,0)=2</code>, 见本类文档2d部分N4点下的图片。 通过<code>face_orientation</code>, <code>face_flip</code>和<code>face_rotation</code>参数，这个函数可以处理以标准和非标准方向的面。<code>face_orientation</code>默认为<code>true</code>，<code>face_flip</code>和<code>face_rotation</code>默认为<code>false</code>（标准方向）。在2d中，只有<code>face_flip</code>被考虑。更多信息请参见这篇 <a class="el" href="DEALGlossary.html#GlossFaceOrientation">词汇表 </a> 文章。 由于单元格的子节点是根据单元格的顶点排序的，这个调用被传递给child_cell_on_face()函数。 因此，这个函数只是child_cell_on_face()的一个包装器，给它起了一个暗示性的名字。 </p>

</div>
</div>
<a id="addd80ab9c6099f69d8d980b9f6fa070b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd80ab9c6099f69d8d980b9f6fa070b">&#9670;&nbsp;</a></span>face_to_cell_lines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::face_to_cell_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将面的行数映射到单元格行数，即给出面的<code>行</code>第1行的单元格行数，例如： <code>GeometryInfo&lt;3&gt;::face_to_cell_lines(5,0)=4</code>. 通过<code>face_orientation</code>, <code>face_flip</code>和<code>face_rotation</code>参数，这个函数处理以标准和非标准方向为导向的面。<code>face_orientation</code>默认为<code>true</code>，<code>face_flip</code>和<code>face_rotation</code>默认为<code>false</code>（标准方向），在2d中没有影响。 </p>

</div>
</div>
<a id="a24b2e56d13ff47bf46c4dbdaef49508c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b2e56d13ff47bf46c4dbdaef49508c">&#9670;&nbsp;</a></span>standard_to_real_face_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::standard_to_real_face_vertex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将标准方向的面的顶点索引 <code>vertex</code> 映射到具有任意 <code>face_orientation</code>, <code>face_flip</code> 和 <code>面旋转的面。这三个标志的值分别默认为<code>true</code></code>, <code>false</code>和<code>false</code>。这个组合描述了一个标准方向的面。 这个函数只在三维中实现。 </p>

</div>
</div>
<a id="ad032159a72b9a4e71ab25912d9d4737d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad032159a72b9a4e71ab25912d9d4737d">&#9670;&nbsp;</a></span>real_to_standard_face_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::real_to_standard_face_vertex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将具有任意 <code>face_orientation、</code> <code>face_flip</code> 和 <code>face_rotation</code> 的面的顶点索引 <code>vertex</code> 映射到一个标准方向的面。这三个标志的值分别默认为<code>true</code>, <code>false</code>和<code>false</code>。这个组合描述了一个标准方向的面。 这个函数只在三维中实现。 </p>

</div>
</div>
<a id="a5f6b330c8a3699c3e70b833cf164a77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6b330c8a3699c3e70b833cf164a77b">&#9670;&nbsp;</a></span>standard_to_real_face_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::standard_to_real_face_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个标准方向的面的线条索引 <code>line</code> 映射到一个具有任意 <code>face_orientation</code>, <code>face_flip</code> 和 <code>face_rotation的面。这三个标志的值默认分别为<code>true</code></code>, <code>false</code>和<code>false</code>。这个组合描述了一个标准方向的面。 这个函数只在三维中实现。 </p>

</div>
</div>
<a id="a0250ad9b85b95081a95c280457ec76ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0250ad9b85b95081a95c280457ec76ba">&#9670;&nbsp;</a></span>standard_to_real_line_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::standard_to_real_line_vertex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>line_orientation</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将标准方向的线的顶点索引 <code>vertex</code> 映射到一个任意 <code>line_orientation</code>. 的面的顶点索引，这个标志的值默认为<code>true</code>。 </p>

</div>
</div>
<a id="ae0e986d54f7ba4754b976437eecb139c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e986d54f7ba4754b976437eecb139c">&#9670;&nbsp;</a></span>standard_quad_vertex_to_line_vertex_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::array&lt;unsigned <a class="el" href="classint.html">int</a>, 2&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::standard_quad_vertex_to_line_vertex_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将四边形中的顶点索引分解为一对线的索引和该线中的顶点索引。 </p><dl class="section note"><dt>Note</dt><dd>哪条线被选中并不重要（也不是故意暴露）。 </dd></dl>

</div>
</div>
<a id="affa8dcf848b7c7ce048d4161206c52ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa8dcf848b7c7ce048d4161206c52ef">&#9670;&nbsp;</a></span>standard_hex_vertex_to_quad_vertex_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::array&lt;unsigned <a class="el" href="classint.html">int</a>, 2&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::standard_hex_vertex_to_quad_vertex_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个六边形中的顶点索引分解为一对四边形索引和这个四边形中的顶点索引。 </p><dl class="section note"><dt>Note</dt><dd>选择哪个象限并不重要（也不是故意暴露的）。 </dd></dl>

</div>
</div>
<a id="a2ed8aecb4e67dfeb06ace9d8af349d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed8aecb4e67dfeb06ace9d8af349d0d">&#9670;&nbsp;</a></span>standard_hex_line_to_quad_line_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::array&lt;unsigned <a class="el" href="classint.html">int</a>, 2&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::standard_hex_line_to_quad_line_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将六边形中的线索引分解成一对四边形索引和该四边形中的线索引。 </p><dl class="section note"><dt>Note</dt><dd>选择哪个象限并不重要（也不是故意暴露的）。 </dd></dl>

</div>
</div>
<a id="aaf6d27bc23671e82a8a69a938fca4166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6d27bc23671e82a8a69a938fca4166">&#9670;&nbsp;</a></span>real_to_standard_face_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::real_to_standard_face_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将具有任意 <code>face_orientation</code>, <code>face_flip</code> 和 <code>face_rotation</code> 的面的线指数 <code>line</code> 映射到一个标准方向的面。这三个标志的值默认分别为<code>true</code>, <code>false</code>和<code>false</code>。这个组合描述了一个标准方向的面。 这个函数只在三维中实现。 </p>

</div>
</div>
<a id="a328671c4ef755bea25625d068eaa8d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328671c4ef755bea25625d068eaa8d31">&#9670;&nbsp;</a></span>unit_cell_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::unit_cell_vertex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回单元格上 <code>ith</code> 顶点的位置。顶点的顺序是deal.II中的典范顺序，如该类的一般文档中所述。 </p>

</div>
</div>
<a id="a0102b28ec69c4bc6b2b0337715c09bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0102b28ec69c4bc6b2b0337715c09bc8">&#9670;&nbsp;</a></span>child_cell_from_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::child_cell_from_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给出一个单位坐标的点 <code>p</code> ，返回它所在的子单元的编号。如果该点位于两个子单元的界面上，则返回它们中的任何一个指数。结果总是小于 <a class="el" href="structGeometryInfo.html#afd3320089fb8cbd675963e56fb37d01f">GeometryInfo&lt;dimension&gt;::max_children_per_cell</a>. ，子单元的顺序在该类的一般文档中描述。 </p>

</div>
</div>
<a id="a90d17e49dab89d46ada2fff521cc5337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d17e49dab89d46ada2fff521cc5337">&#9670;&nbsp;</a></span>cell_to_child_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::cell_to_child_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td>
          <td class="paramname"><em>refine_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给出单元格上的坐标 <code>p</code> ，返回该点在给定子单元格的坐标系中的坐标值。 原始坐标和返回的坐标实际上都不需要在单元格内，我们只是简单地进行了一个缩放和移位操作，移位的程度取决于子单元的数量。 </p>

</div>
</div>
<a id="a6e860ab6e9daead69bab4553c1b7921a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e860ab6e9daead69bab4553c1b7921a">&#9670;&nbsp;</a></span>child_to_cell_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::child_to_cell_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td>
          <td class="paramname"><em>refine_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与上面的函数相反：在子单元的坐标系中取一个点，并将其转换为母单元的坐标系。 </p>

</div>
</div>
<a id="ace2d235da3d7459096d535d360bcf3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2d235da3d7459096d535d360bcf3d3">&#9670;&nbsp;</a></span>is_inside_unit_cell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::is_inside_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果给定的点在当前空间维度的单元格内，则返回真。 </p>

</div>
</div>
<a id="a0f1e5a9fe7531316d23bbc8df02833f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1e5a9fe7531316d23bbc8df02833f2">&#9670;&nbsp;</a></span>is_inside_unit_cell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::is_inside_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果给定的点在当前空间维度的单元格内，则返回真。这个函数接受一个额外的参数，指定点的位置实际上可能在真正的单元格之外的程度。这是很有用的，因为在实践中，我们往往不能准确地计算出参考坐标中的点的坐标，而只能是数字上的舍入。 容差参数可以小于零，表示该点应该安全地在单元格内。 </p>

</div>
</div>
<a id="aaae0fe397acba1d1079cbfa917b7046c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae0fe397acba1d1079cbfa917b7046c">&#9670;&nbsp;</a></span>project_to_unit_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classPoint.html">Point</a>&lt;dim, Number&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::project_to_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个给定的点投射到单元格上，也就是说，[0...1]以外的每个坐标被修改为位于该区间内。 </p>

</div>
</div>
<a id="a106c0b4889baa0f60e5754a2b43c420d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106c0b4889baa0f60e5754a2b43c420d">&#9670;&nbsp;</a></span>distance_to_unit_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdouble.html">double</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::distance_to_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回单元格外的给定点 <code>p</code> 到最近的单元格边界之间的向量的无穷大规范。对于单元格内的点，这被定义为零。 </p>

</div>
</div>
<a id="a9e1d6d09377959718f18d1443757895c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1d6d09377959718f18d1443757895c">&#9670;&nbsp;</a></span>d_linear_shape_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdouble.html">double</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::d_linear_shape_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算 \(i\) -第 \(d\) -线性（即（双，三）线性）形状函数在位置 \(\xi\) 的值。 </p>

</div>
</div>
<a id="aad48513b4c435ca22f2a026f1918ac44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad48513b4c435ca22f2a026f1918ac44">&#9670;&nbsp;</a></span>d_linear_shape_function_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::d_linear_shape_function_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算 \(i\) -第 \(d\) -线性（即（双，三）线性）形状函数在位置 \(\xi\) 的梯度。 </p>

</div>
</div>
<a id="af047ab1fe45077a53df9cd8212fc790c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af047ab1fe45077a53df9cd8212fc790c">&#9670;&nbsp;</a></span>alternating_form_at_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::alternating_form_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>vertices</em>[vertices_per_cell], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTensor.html">Tensor</a>&lt; spacedim - dim, spacedim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>forms</em>[vertices_per_cell]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于从参考单元、面或边到由给定顶点指定的物体的（双、三）线性映射，计算转换后的单位向量顶点的交替形式。对于维数为 <code>dim</code>, 的物体，有 <code>dim</code> 个矢量，每个矢量有 <code>spacedim</code> 个分量，交替形式是等级为spacedim-dim的张量，对应于 <code>dim</code> 个单位矢量的楔形积，它对应于从参考元素到顶点描述的元素映射的体积和法向量。 例如，如果dim==spacedim==2，那么交替形式是一个标量（因为spacedim-dim=0），其值等于 \(\mathbf v_1\wedge \mathbf v_2=\mathbf v_1^\perp \cdot\mathbf v_2\) ，其中 \(\mathbf v_1^\perp\) 是一个从 \(\mathbf v_1\) 向右旋转90度的矢量。如果dim==spacedim==3，那么结果又是一个标量，其值为 \(\mathbf v_1\wedge \mathbf v_2 \wedge \mathbf v_3 = (\mathbf v_1\times \mathbf v_2)\cdot \mathbf v_3\) ，其中 \(\mathbf v_1, \mathbf v_2, \mathbf v_3\) 是单位dim维单元的一个顶点的单位向量在转化为spacedim维空间的dim维单元时的图像。在这两种情况下，即对于dim==2或3，其结果恰好等于实空间中从参考单元到单元的映射的Jacobian的行列式。请注意，这是实际的行列式，而不是它的绝对值，因为它经常用于将积分从一个坐标系转换到另一个坐标系。特别是，如果顶点指定的对象是一个平行四边形（即参考单元的线性变换），那么计算值在所有顶点都是相同的，并且等于该单元的（有符号的）面积；同样，对于平行四边形，它是该单元的体积。 同样，如果我们有dim==spacedim-1（例如，我们有一个三维空间的四边形，或者一条二维空间的线），那么交替乘积表示每个顶点的物体的法向量（即一个秩-1张量，因为spacedim-dim=1），其中法向量的大小表示从参考物体到顶点所给物体的转换的面积元素。特别是，如果从参考物体到这里考虑的物体的映射是线性的（不是双线或三线），那么返回的向量都是平行的，垂直于顶点描述的映射物体，并且其大小等于映射物体的面积/体积。如果dim=1，spacedim=2，那么返回值为 \(\mathbf v_1^\perp\) ，其中 \(\mathbf v_1\) 是映射到顶点给出的2D中的直线的唯一单位向量的图像；如果dim=2，spacedim=3，那么返回值为 \(\mathbf v_1 \wedge \mathbf v_2=\mathbf v_1 \times \mathbf v_2\) ，其中 \(\mathbf v_1,\mathbf v_2\) 是与映射到三维空间的四边形相切的两个三维向量。 这个函数用于确定一个单元的扭曲程度（见术语表中 <a class="el" href="DEALGlossary.html#GlossDistorted">扭曲的单元 </a> 条目）。 </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afd3320089fb8cbd675963e56fb37d01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3320089fb8cbd675963e56fb37d01f">&#9670;&nbsp;</a></span>max_children_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::max_children_per_cell = 1 &lt;&lt; dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>精炼单元的最大子女数，即各向同性精炼单元的子女数。 如果一个单元被各向异性地精炼，实际的子女数可能少于这里给出的值。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l03707">3707</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a5d3e48d5e97a217c149a33c0b42a51c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3e48d5e97a217c149a33c0b42a51c2">&#9670;&nbsp;</a></span>faces_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::faces_per_cell = 2 * dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个单元的面的数量。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l03713">3713</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a29fc1bee407ade48090ce592473dc327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29fc1bee407ade48090ce592473dc327">&#9670;&nbsp;</a></span>max_children_per_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::max_children_per_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#afd3320089fb8cbd675963e56fb37d01f">::max_children_per_cell</a></div></div><!-- fragment --><p>一个精炼面的最大子女数，即一个各向同性的精炼面的子女数。 如果一个单元被各向异性地细化，实际的子女数可能少于这里给出的值。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l03735">3735</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a2bb3a95a842d98b8b3bf9a64735d0eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb3a95a842d98b8b3bf9a64735d0eee">&#9670;&nbsp;</a></span>vertices_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_cell = 1 &lt;&lt; dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个单元格的顶点数。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l03742">3742</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="aad8410f6471e4ac443b51f6c20809bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8410f6471e4ac443b51f6c20809bfb">&#9670;&nbsp;</a></span>vertices_per_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">::vertices_per_cell</a></div></div><!-- fragment --><p>每个面上的顶点数量。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l03763">3763</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="afef86260668d5b98a7bb73db8986d027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef86260668d5b98a7bb73db8986d027">&#9670;&nbsp;</a></span>lines_per_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::lines_per_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#a3de02b6910b68785cc8acd9488599092">::lines_per_cell</a></div></div><!-- fragment --><p>每个面的线数。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l03770">3770</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a166d28164dfd718a9211ae788e057b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166d28164dfd718a9211ae788e057b56">&#9670;&nbsp;</a></span>quads_per_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::quads_per_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#afa91c1fd95bc59a8c34a4af6443c2f85">::quads_per_cell</a></div></div><!-- fragment --><p>每个面上的四边形数目。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l03777">3777</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a3de02b6910b68785cc8acd9488599092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de02b6910b68785cc8acd9488599092">&#9670;&nbsp;</a></span>lines_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::lines_per_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    (2 * <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#a3de02b6910b68785cc8acd9488599092">::lines_per_cell</a> +</div><div class="line">     <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">::vertices_per_cell</a>)</div></div><!-- fragment --><p>一个单元格的行数。 计算公式利用了这样一个事实：当从一个维度到下一个维度时，低维度的对象被复制一次（因此是旧的线数的两倍），然后在旧对象的每个顶点和副本中的相应顶点之间插入一条新线。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l03785">3785</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="afa91c1fd95bc59a8c34a4af6443c2f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa91c1fd95bc59a8c34a4af6443c2f85">&#9670;&nbsp;</a></span>quads_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::quads_per_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    (2 * <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#afa91c1fd95bc59a8c34a4af6443c2f85">::quads_per_cell</a> +</div><div class="line">     <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#a3de02b6910b68785cc8acd9488599092">::lines_per_cell</a>)</div></div><!-- fragment --><p>一个单元格的四边形的数量。 这个数字与前一个数字一样是递归计算的，不同的是，新的四边形是由连接原始线和它的副本产生的。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l03794">3794</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a6e3c139c94b4d9e54371400514a102f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3c139c94b4d9e54371400514a102f4">&#9670;&nbsp;</a></span>hexes_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::hexes_per_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    (2 * <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#a6e3c139c94b4d9e54371400514a102f4">::hexes_per_cell</a> +</div><div class="line">     <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#afa91c1fd95bc59a8c34a4af6443c2f85">::quads_per_cell</a>)</div></div><!-- fragment --><p>一个单元格的六面体的数量。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l03802">3802</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a09a95dd40f1faa1a1bad8210dcb66f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a95dd40f1faa1a1bad8210dcb66f1f">&#9670;&nbsp;</a></span>ucd_to_deal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a> &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::ucd_to_deal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    internal::GeometryInfoHelper::Initializers&lt;dim&gt;::ucd_to_deal()</div></div><!-- fragment --><p>为UCD输出重新排列顶点。 对于正在以UCD格式写入的单元格，该字段的每个条目包含<code>deal.II</code>中与该位置的UCD编号相对应的一个顶点的编号。 典型的例子：写一个单元并安排顶点，这样UCD就能理解它们。 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt; n_vertices; ++i)</div><div class="line">out &lt;&lt; cell-&gt;vertex(<a class="code" href="structGeometryInfo.html#a09a95dd40f1faa1a1bad8210dcb66f1f">ucd_to_deal</a>[i]);</div></div><!-- fragment --><p> 由于deal.II版本&lt;=5.1中的顶点编号恰好与UCD的编号一致，这个字段也可以像old_to_lexicographic映射一样使用。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l03817">3817</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a33c82eb40866a5d8685d23604b76300f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c82eb40866a5d8685d23604b76300f">&#9670;&nbsp;</a></span>dx_to_deal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a> &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::dx_to_deal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    internal::GeometryInfoHelper::Initializers&lt;dim&gt;::dx_to_deal()</div></div><!-- fragment --><p>为OpenDX输出重新排列顶点。 对于一个被写成OpenDX格式的单元格，这个字段的每个条目都包含<code>deal.II</code>中的一个顶点的编号，它与这个位置的DX编号相对应。 典型的例子：写一个单元并安排顶点，这样OpenDX就能理解它们。 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt; n_vertices; ++i)</div><div class="line">out &lt;&lt; cell-&gt;vertex(<a class="code" href="structGeometryInfo.html#a33c82eb40866a5d8685d23604b76300f">dx_to_deal</a>[i]);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l03831">3831</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="aea298d2f0914e2810d9b96081e809f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea298d2f0914e2810d9b96081e809f6a">&#9670;&nbsp;</a></span>vertex_to_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="ndarray_8h.html#a82399009710c9549884b9d8c506ad695">ndarray</a>&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a>, dim &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertex_to_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">      internal::GeometryInfoHelper::Initializers&lt;dim&gt;::vertex_to_face()</div></div><!-- fragment --><p>这个字段为每个顶点存储它所属的面。在任何给定的维度中，面的数量都等于维度。这个二维数组的第一个索引是所有顶点的，第二个索引是顶点所属的 <code>dim</code> 面。 每个顶点的面的顺序是这样的：第一个列出的面在<em>x</em>方向上包围参考单元，第二个在<em>y</em>方向上，以此类推。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l03841">3841</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a41eabdf96722189263e5ede8ab8d566a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41eabdf96722189263e5ede8ab8d566a">&#9670;&nbsp;</a></span>unit_normal_direction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::unit_normal_direction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">      internal::GeometryInfoHelper::Initializers&lt;dim&gt;::unit_normal_direction()</div></div><!-- fragment --><p>对于参考单元的每个面，这个字段存储其法向量指向的坐标方向。在<code>dim</code>维度中，这些是<code>2*dim</code>的第一个条目<code>{0,0,1,1,2,2,3,3}</code>。 请注意，这只是坐标数。法向量的实际方向是通过将这个方向的单位向量与::unit_normal_orientation相乘而得到的。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l04235">4235</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="af9b79386bf8ca6410c906c3b8c4e8c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b79386bf8ca6410c906c3b8c4e8c40">&#9670;&nbsp;</a></span>unit_normal_orientation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::unit_normal_orientation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    internal::GeometryInfoHelper::Initializers&lt;dim&gt;::unit_normal_orientation()</div></div><!-- fragment --><p>参考单元的一个面的单位法向量的方向。在<code>dim</code>维度中，这些是<code>2*dim</code><code>{-1,1,-1,1,-1,-1,1}</code>的第一个条目。 每个值都是<code>1</code>或<code>-1</code>，分别对应于指向正坐标或负坐标方向的法向量。 注意，这只是面的 <em> 标准方向 </em> 。至少在3D中，三角形中单元格的实际面也可以有相反的方向，这取决于人们可以从它所属的单元格中查询到的一个标志。欲了解更多信息，请参见 <a class="el" href="DEALGlossary.html#GlossFaceOrientation">词汇表 </a> 中关于面的方向的条目。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l04243">4243</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="aa9b67e58ad8e792e55efc3cbfb274ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b67e58ad8e792e55efc3cbfb274ef7">&#9670;&nbsp;</a></span>unit_normal_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::unit_normal_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">      internal::GeometryInfoHelper::Initializers&lt;dim&gt;::unit_normal_vector()</div></div><!-- fragment --><p>参考单元的一个面的单位法向量（Point&lt;dim&gt;）。 注意，这只是面的 <em> 标准方向 </em> 。至少在3D中，三角形中单元格的实际面也可以有相反的方向，这取决于一个可以从它所属的单元格中查询的标志。欲了解更多信息，请参见 <a class="el" href="DEALGlossary.html#GlossFaceOrientation">词汇表 </a> 中关于面的方向的条目。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l04252">4252</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a0ba9791aca6cde3acf3f79bbb63e8247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba9791aca6cde3acf3f79bbb63e8247">&#9670;&nbsp;</a></span>unit_tangential_vectors</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="ndarray_8h.html#a82399009710c9549884b9d8c506ad695">ndarray</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a>, dim - 1 &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::unit_tangential_vectors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= internal::GeometryInfoHelper::Initializers&lt;</div><div class="line">      dim&gt;<a class="code" href="structGeometryInfo.html#a0ba9791aca6cde3acf3f79bbb63e8247">::unit_tangential_vectors</a>()</div></div><!-- fragment --><p>参考单元面的单位切向矢量（Point&lt;dim&gt;的<code>dim-1</code>元素数组），排列在右手坐标系中，使两个矢量之间的交积返回单位法向量。 注意，这只是面的 <em> 标准方向 </em> 。至少在3D中，三角形中单元格的实际面也可以有相反的方向，这取决于一个可以从它所属的单元格中查询的标志。欲了解更多信息，请参见 <a class="el" href="DEALGlossary.html#GlossFaceOrientation">词汇表 </a> 中关于面的方向的条目。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l04261">4261</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a29821832e1cd4777e3e377c022e09073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29821832e1cd4777e3e377c022e09073">&#9670;&nbsp;</a></span>opposite_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::opposite_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    internal::GeometryInfoHelper::Initializers&lt;dim&gt;::opposite_face()</div></div><!-- fragment --><p>数字列表，表示哪个面与给定的面相对。它的条目是<code>{ 1, 0, 3, 2, 5, 4, 7, 6}</code>的第一个<code>2*dim</code>条目。 </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l04269">4269</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="geometry__info_8h_source.html">geometry_info.h</a></li>
<li>source/base/<a class="el" href="geometry__info_8cc_source.html">geometry_info.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
