<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/structGeometryInfo.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: GeometryInfo&lt; dim &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structGeometryInfo-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GeometryInfo&lt; dim &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a> &#124; <a class="el" href="group__geomprimitives.html">Geometric and other primitives</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="geometry__info_8h_source.html">deal.II/base/geometry_info.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a253fd1bcb288e88bdecccf727b7b907a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a253fd1bcb288e88bdecccf727b7b907a">face_indices</a> ()</td></tr>
<tr class="separator:a253fd1bcb288e88bdecccf727b7b907a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a76e2c08f49817f09bcab9bbb7e373c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a3a76e2c08f49817f09bcab9bbb7e373c">vertex_indices</a> ()</td></tr>
<tr class="separator:a3a76e2c08f49817f09bcab9bbb7e373c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad022815fd2a5c25fc0cddaca93f3cca5"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#ad022815fd2a5c25fc0cddaca93f3cca5">n_children</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case)</td></tr>
<tr class="separator:ad022815fd2a5c25fc0cddaca93f3cca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe25e8c0a5a67e3618fa17dadf58b944"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#afe25e8c0a5a67e3618fa17dadf58b944">n_subfaces</a> (const <a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;subface_case)</td></tr>
<tr class="separator:afe25e8c0a5a67e3618fa17dadf58b944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca2ea6ad9db59ae8d34662599e14fc2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a6ca2ea6ad9db59ae8d34662599e14fc2">subface_ratio</a> (const <a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;subface_case, const unsigned <a class="el" href="classint.html">int</a> subface_no)</td></tr>
<tr class="separator:a6ca2ea6ad9db59ae8d34662599e14fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b91a076a13a5a6594f132b09c824c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#af6b91a076a13a5a6594f132b09c824c3">face_refinement_case</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;cell_refinement_case, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:af6b91a076a13a5a6594f132b09c824c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff1bd9fab7ea7b2ab9265c53c8e34a4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a0ff1bd9fab7ea7b2ab9265c53c8e34a4">min_cell_refinement_case_for_face_refinement</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt; &amp;<a class="el" href="structGeometryInfo.html#af6b91a076a13a5a6594f132b09c824c3">face_refinement_case</a>, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:a0ff1bd9fab7ea7b2ab9265c53c8e34a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5efb5e5ca92dfead4105ff194dbe94"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a3f5efb5e5ca92dfead4105ff194dbe94">line_refinement_case</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;cell_refinement_case, const unsigned <a class="el" href="classint.html">int</a> line_no)</td></tr>
<tr class="separator:a3f5efb5e5ca92dfead4105ff194dbe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b46dc2ac462eeeeab76b04e22928b8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a46b46dc2ac462eeeeab76b04e22928b8">min_cell_refinement_case_for_line_refinement</a> (const unsigned <a class="el" href="classint.html">int</a> line_no)</td></tr>
<tr class="separator:a46b46dc2ac462eeeeab76b04e22928b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1263120c3a820d6b17b4055e6e0ef9f1"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a1263120c3a820d6b17b4055e6e0ef9f1">child_cell_on_face</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;ref_case, const unsigned <a class="el" href="classint.html">int</a> face, const unsigned <a class="el" href="classint.html">int</a> subface, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt; &amp;<a class="el" href="structGeometryInfo.html#af6b91a076a13a5a6594f132b09c824c3">face_refinement_case</a>=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt;::isotropic_refinement)</td></tr>
<tr class="separator:a1263120c3a820d6b17b4055e6e0ef9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd66dc231589a519786719dbde492c9a"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#abd66dc231589a519786719dbde492c9a">line_to_cell_vertices</a> (const unsigned <a class="el" href="classint.html">int</a> line, const unsigned <a class="el" href="classint.html">int</a> vertex)</td></tr>
<tr class="separator:abd66dc231589a519786719dbde492c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adac0f129f0bdaa1600b14a543bdaa4"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a2adac0f129f0bdaa1600b14a543bdaa4">face_to_cell_vertices</a> (const unsigned <a class="el" href="classint.html">int</a> face, const unsigned <a class="el" href="classint.html">int</a> vertex, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:a2adac0f129f0bdaa1600b14a543bdaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd80ab9c6099f69d8d980b9f6fa070b"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#addd80ab9c6099f69d8d980b9f6fa070b">face_to_cell_lines</a> (const unsigned <a class="el" href="classint.html">int</a> face, const unsigned <a class="el" href="classint.html">int</a> line, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:addd80ab9c6099f69d8d980b9f6fa070b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b2e56d13ff47bf46c4dbdaef49508c"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a24b2e56d13ff47bf46c4dbdaef49508c">standard_to_real_face_vertex</a> (const unsigned <a class="el" href="classint.html">int</a> vertex, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:a24b2e56d13ff47bf46c4dbdaef49508c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad032159a72b9a4e71ab25912d9d4737d"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#ad032159a72b9a4e71ab25912d9d4737d">real_to_standard_face_vertex</a> (const unsigned <a class="el" href="classint.html">int</a> vertex, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:ad032159a72b9a4e71ab25912d9d4737d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6b330c8a3699c3e70b833cf164a77b"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a5f6b330c8a3699c3e70b833cf164a77b">standard_to_real_face_line</a> (const unsigned <a class="el" href="classint.html">int</a> line, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:a5f6b330c8a3699c3e70b833cf164a77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0250ad9b85b95081a95c280457ec76ba"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a0250ad9b85b95081a95c280457ec76ba">standard_to_real_line_vertex</a> (const unsigned <a class="el" href="classint.html">int</a> vertex, const <a class="el" href="classbool.html">bool</a> line_orientation=true)</td></tr>
<tr class="separator:a0250ad9b85b95081a95c280457ec76ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e986d54f7ba4754b976437eecb139c"><td class="memItemLeft" align="right" valign="top">static std::array&lt; unsigned <a class="el" href="classint.html">int</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#ae0e986d54f7ba4754b976437eecb139c">standard_quad_vertex_to_line_vertex_index</a> (const unsigned <a class="el" href="classint.html">int</a> vertex)</td></tr>
<tr class="separator:ae0e986d54f7ba4754b976437eecb139c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa8dcf848b7c7ce048d4161206c52ef"><td class="memItemLeft" align="right" valign="top">static std::array&lt; unsigned <a class="el" href="classint.html">int</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#affa8dcf848b7c7ce048d4161206c52ef">standard_hex_vertex_to_quad_vertex_index</a> (const unsigned <a class="el" href="classint.html">int</a> vertex)</td></tr>
<tr class="separator:affa8dcf848b7c7ce048d4161206c52ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed8aecb4e67dfeb06ace9d8af349d0d"><td class="memItemLeft" align="right" valign="top">static std::array&lt; unsigned <a class="el" href="classint.html">int</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a2ed8aecb4e67dfeb06ace9d8af349d0d">standard_hex_line_to_quad_line_index</a> (const unsigned <a class="el" href="classint.html">int</a> line)</td></tr>
<tr class="separator:a2ed8aecb4e67dfeb06ace9d8af349d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6d27bc23671e82a8a69a938fca4166"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#aaf6d27bc23671e82a8a69a938fca4166">real_to_standard_face_line</a> (const unsigned <a class="el" href="classint.html">int</a> line, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false)</td></tr>
<tr class="separator:aaf6d27bc23671e82a8a69a938fca4166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328671c4ef755bea25625d068eaa8d31"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a328671c4ef755bea25625d068eaa8d31">unit_cell_vertex</a> (const unsigned <a class="el" href="classint.html">int</a> vertex)</td></tr>
<tr class="separator:a328671c4ef755bea25625d068eaa8d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0102b28ec69c4bc6b2b0337715c09bc8"><td class="memItemLeft" align="right" valign="top">static unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a0102b28ec69c4bc6b2b0337715c09bc8">child_cell_from_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p)</td></tr>
<tr class="separator:a0102b28ec69c4bc6b2b0337715c09bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d17e49dab89d46ada2fff521cc5337"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a90d17e49dab89d46ada2fff521cc5337">cell_to_child_coordinates</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> child_index, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; refine_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement)</td></tr>
<tr class="separator:a90d17e49dab89d46ada2fff521cc5337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e860ab6e9daead69bab4553c1b7921a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a6e860ab6e9daead69bab4553c1b7921a">child_to_cell_coordinates</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> child_index, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; refine_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement)</td></tr>
<tr class="separator:a6e860ab6e9daead69bab4553c1b7921a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2d235da3d7459096d535d360bcf3d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#ace2d235da3d7459096d535d360bcf3d3">is_inside_unit_cell</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p)</td></tr>
<tr class="separator:ace2d235da3d7459096d535d360bcf3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1e5a9fe7531316d23bbc8df02833f2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a0f1e5a9fe7531316d23bbc8df02833f2">is_inside_unit_cell</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const <a class="el" href="classdouble.html">double</a> eps)</td></tr>
<tr class="separator:a0f1e5a9fe7531316d23bbc8df02833f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae0fe397acba1d1079cbfa917b7046c"><td class="memTemplParams" colspan="2">template&lt;typename Number  = double&gt; </td></tr>
<tr class="memitem:aaae0fe397acba1d1079cbfa917b7046c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classPoint.html">Point</a>&lt; dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#aaae0fe397acba1d1079cbfa917b7046c">project_to_unit_cell</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim, Number &gt; &amp;p)</td></tr>
<tr class="separator:aaae0fe397acba1d1079cbfa917b7046c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106c0b4889baa0f60e5754a2b43c420d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a106c0b4889baa0f60e5754a2b43c420d">distance_to_unit_cell</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p)</td></tr>
<tr class="separator:a106c0b4889baa0f60e5754a2b43c420d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1d6d09377959718f18d1443757895c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a9e1d6d09377959718f18d1443757895c">d_linear_shape_function</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;xi, const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:a9e1d6d09377959718f18d1443757895c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad48513b4c435ca22f2a026f1918ac44"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#aad48513b4c435ca22f2a026f1918ac44">d_linear_shape_function_gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;xi, const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:aad48513b4c435ca22f2a026f1918ac44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af047ab1fe45077a53df9cd8212fc790c"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:af047ab1fe45077a53df9cd8212fc790c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#af047ab1fe45077a53df9cd8212fc790c">alternating_form_at_vertices</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;(&amp;<a class="el" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>)[<a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a>], <a class="el" href="classTensor.html">Tensor</a>&lt; spacedim - dim, spacedim &gt;(&amp;forms)[<a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a>])</td></tr>
<tr class="separator:af047ab1fe45077a53df9cd8212fc790c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6c0be4a8cd812fd4fa7266e75e3b93"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3e6c0be4a8cd812fd4fa7266e75e3b93">ExcInvalidCoordinate</a> (<a class="el" href="classdouble.html">double</a> arg1)</td></tr>
<tr class="separator:ga3e6c0be4a8cd812fd4fa7266e75e3b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65a897bfa399fb45d5a49f56fe372011"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga65a897bfa399fb45d5a49f56fe372011">ExcInvalidSubface</a> (<a class="el" href="classint.html">int</a> arg1, <a class="el" href="classint.html">int</a> arg2, <a class="el" href="classint.html">int</a> arg3)</td></tr>
<tr class="separator:ga65a897bfa399fb45d5a49f56fe372011"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:afd3320089fb8cbd675963e56fb37d01f"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#afd3320089fb8cbd675963e56fb37d01f">max_children_per_cell</a> = 1 &lt;&lt; dim</td></tr>
<tr class="separator:afd3320089fb8cbd675963e56fb37d01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3e48d5e97a217c149a33c0b42a51c2"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> = 2 * dim</td></tr>
<tr class="separator:a5d3e48d5e97a217c149a33c0b42a51c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fc1bee407ade48090ce592473dc327"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a29fc1bee407ade48090ce592473dc327">max_children_per_face</a></td></tr>
<tr class="separator:a29fc1bee407ade48090ce592473dc327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb3a95a842d98b8b3bf9a64735d0eee"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a> = 1 &lt;&lt; dim</td></tr>
<tr class="separator:a2bb3a95a842d98b8b3bf9a64735d0eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8410f6471e4ac443b51f6c20809bfb"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#aad8410f6471e4ac443b51f6c20809bfb">vertices_per_face</a></td></tr>
<tr class="separator:aad8410f6471e4ac443b51f6c20809bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef86260668d5b98a7bb73db8986d027"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#afef86260668d5b98a7bb73db8986d027">lines_per_face</a></td></tr>
<tr class="separator:afef86260668d5b98a7bb73db8986d027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166d28164dfd718a9211ae788e057b56"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a166d28164dfd718a9211ae788e057b56">quads_per_face</a></td></tr>
<tr class="separator:a166d28164dfd718a9211ae788e057b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de02b6910b68785cc8acd9488599092"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a3de02b6910b68785cc8acd9488599092">lines_per_cell</a></td></tr>
<tr class="separator:a3de02b6910b68785cc8acd9488599092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa91c1fd95bc59a8c34a4af6443c2f85"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#afa91c1fd95bc59a8c34a4af6443c2f85">quads_per_cell</a></td></tr>
<tr class="separator:afa91c1fd95bc59a8c34a4af6443c2f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3c139c94b4d9e54371400514a102f4"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a6e3c139c94b4d9e54371400514a102f4">hexes_per_cell</a></td></tr>
<tr class="separator:a6e3c139c94b4d9e54371400514a102f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a95dd40f1faa1a1bad8210dcb66f1f"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a09a95dd40f1faa1a1bad8210dcb66f1f">ucd_to_deal</a></td></tr>
<tr class="separator:a09a95dd40f1faa1a1bad8210dcb66f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c82eb40866a5d8685d23604b76300f"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a33c82eb40866a5d8685d23604b76300f">dx_to_deal</a></td></tr>
<tr class="separator:a33c82eb40866a5d8685d23604b76300f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea298d2f0914e2810d9b96081e809f6a"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="ndarray_8h.html#a82399009710c9549884b9d8c506ad695">ndarray</a>&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a>, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#aea298d2f0914e2810d9b96081e809f6a">vertex_to_face</a></td></tr>
<tr class="separator:aea298d2f0914e2810d9b96081e809f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41eabdf96722189263e5ede8ab8d566a"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a41eabdf96722189263e5ede8ab8d566a">unit_normal_direction</a></td></tr>
<tr class="separator:a41eabdf96722189263e5ede8ab8d566a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b79386bf8ca6410c906c3b8c4e8c40"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#af9b79386bf8ca6410c906c3b8c4e8c40">unit_normal_orientation</a></td></tr>
<tr class="separator:af9b79386bf8ca6410c906c3b8c4e8c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b67e58ad8e792e55efc3cbfb274ef7"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;, <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#aa9b67e58ad8e792e55efc3cbfb274ef7">unit_normal_vector</a></td></tr>
<tr class="separator:aa9b67e58ad8e792e55efc3cbfb274ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba9791aca6cde3acf3f79bbb63e8247"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="ndarray_8h.html#a82399009710c9549884b9d8c506ad695">ndarray</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;, <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a>, dim - 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a0ba9791aca6cde3acf3f79bbb63e8247">unit_tangential_vectors</a></td></tr>
<tr class="separator:a0ba9791aca6cde3acf3f79bbb63e8247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29821832e1cd4777e3e377c022e09073"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometryInfo.html#a29821832e1cd4777e3e377c022e09073">opposite_face</a></td></tr>
<tr class="separator:a29821832e1cd4777e3e377c022e09073"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim&gt;<br />
struct GeometryInfo&lt; dim &gt;</h3>

<p>This class provides dimension independent information to all topological structures that make up the unit, or <a class="el" href="DEALGlossary.html#GlossReferenceCell">reference cell</a>. This class has been superseded by the <a class="el" href="classReferenceCell.html">ReferenceCell</a> class &ndash; see there for more information.</p>
<p>It is the one central point in the library where information about the numbering of vertices, lines, or faces of the reference cell is collected. Consequently, the information of this class is used extensively in the geometric description of <a class="el" href="classTriangulation.html">Triangulation</a> objects, as well as in various other parts of the code. In particular, it also serves as the focus of writing code in a dimension independent way; for example, instead of writing a loop over vertices 0&lt;=v&lt;4 in 2d, one would write it as 0&lt;=v&lt;<a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">GeometryInfo&lt;dim&gt;::vertices_per_cell</a>, thus allowing the code to work in 3d as well without changes.</p>
<p>The most frequently used parts of the class are its static members like vertices_per_cell, faces_per_cell, etc. However, the class also offers information about more abstract questions like the orientation of faces, etc. The following documentation gives a textual description of many of these concepts.</p>
<h3>Implementation conventions for two spatial dimensions</h3>
<p>From version 5.2 onwards deal.II is based on a numbering scheme that uses a lexicographic ordering (with x running fastest) wherever possible, hence trying to adopt a kind of 'canonical' ordering.</p>
<p>The ordering of vertices and faces (lines) in 2d is defined by</p>
<ul>
<li>Vertices are numbered in lexicographic ordering</li>
<li>Faces (lines in 2d): first the two faces with normals in x- and then y-direction. For each two faces: first the face with normal in negative coordinate direction, then the one with normal in positive direction, i.e. the faces are ordered according to their normals pointing in -x, x, -y, y direction.</li>
<li>The direction of a line is represented by the direction of point 0 towards point 1 and is always in one of the coordinate directions</li>
<li>Face lines in 3d are ordered, such that the induced 2d local coordinate system (x,y) implies (right hand rule) a normal in face normal direction, see N2/.</li>
</ul>
<p>The resulting numbering of vertices and faces (lines) in 2d as well as the directions of lines is shown in the following. </p><pre class="fragment">*       3
*    2--&gt;--3
*    |     |
*   0^     ^1
*    |     |
*    0--&gt;--1
*        2
* </pre><p>Note that the orientation of lines has to be correct upon construction of a grid; however, it is automatically preserved upon refinement.</p>
<p>Further we define that child lines have the same direction as their parent, i.e. that <code>line-&gt;child(0)-&gt;vertex(0)==line-&gt;vertex(0)</code> and <code>line-&gt;child(1)-&gt;vertex(1)==line-&gt;vertex(1)</code>. This also implies, that the first sub-line (<code>line-&gt;child(0)</code>) is the one at vertex(0) of the old line.</p>
<p>Similarly we define, that the four children of a quad are adjacent to the vertex with the same number of the old quad.</p>
<p>Note that information about several of these conventions can be extracted at run- or compile-time from the member functions and variables of the present class.</p>
<h4>Coordinate systems</h4>
<p>When explicit coordinates are required for points in a cell (e.g for quadrature formulae or the point of definition of trial functions), we define the following coordinate system for the unit cell: </p><pre class="fragment">*  y^   2-----3
*   |   |     |
*   |   |     |
*   |   |     |
*   |   0-----1
*   *------------&gt;x
* </pre><p>Here, vertex 0 is the origin of the coordinate system, vertex 1 has coordinates <code>(1,0)</code>, vertex 2 at <code>(0,1)</code> and vertex 3 at <code>(1,1)</code>. The <a class="el" href="structGeometryInfo.html#a328671c4ef755bea25625d068eaa8d31">GeometryInfo&lt;dim&gt;::unit_cell_vertex()</a> function can be used to query this information at run-time.</p>
<h3>Implementation conventions for three spatial dimensions</h3>
<p>By convention, we will use the following numbering conventions for vertices, lines and faces of hexahedra in three space dimensions. Before giving these conventions we declare the following sketch to be the standard way of drawing 3d pictures of hexahedra: </p><pre class="fragment">*                       *-------*        *-------*
*                      /|       |       /       /|
*                     / |       |      /       / |
*  z                 /  |       |     /       /  |
*  ^                *   |       |    *-------*   |
*  |   ^y           |   *-------*    |       |   *
*  |  /             |  /       /     |       |  /
*  | /              | /       /      |       | /
*  |/               |/       /       |       |/
*  *------&gt;x        *-------*        *-------*
* </pre><p> The left part of the picture shows the left, bottom and back face of the cube, while the right one shall be the top, right and front face. You may recover the whole cube by moving the two parts together into one.</p>
<p>Note again that information about several of the following conventions can be extracted at run- or compile-time from the member functions and variables of the present class.</p>
<h4>Vertices</h4>
<p>The ordering of vertices in 3d is defined by the same rules as in the 2d case. In particular, the following is still true:</p>
<ul>
<li>Vertices are numbered in lexicographic ordering.</li>
</ul>
<p>Hence, the vertices are numbered as follows </p><pre class="fragment">*       6-------7        6-------7
*      /|       |       /       /|
*     / |       |      /       / |
*    /  |       |     /       /  |
*   4   |       |    4-------5   |
*   |   2-------3    |       |   3
*   |  /       /     |       |  /
*   | /       /      |       | /
*   |/       /       |       |/
*   0-------1        0-------1
* </pre><p>We note, that first the vertices on the bottom face (z=0) are numbered exactly the same way as are the vertices on a quadrilateral. Then the vertices on the top face (z=1) are numbered similarly by moving the bottom face to the top. Again, the <a class="el" href="structGeometryInfo.html#a328671c4ef755bea25625d068eaa8d31">GeometryInfo&lt;dim&gt;::unit_cell_vertex()</a> function can be used to query this information at run-time.</p>
<h4>Lines</h4>
<p>Here, the same holds as for the vertices:</p>
<ul>
<li>Line ordering in 3d: <ul>
<li>
first the lines of face (z=0) in 2d line ordering, </li>
<li>
then the lines of face (z=1) in 2d line ordering, </li>
<li>
finally the lines in z direction in lexicographic ordering </li>
</ul>
<pre class="fragment">*       *---7---*        *---7---*
*      /|       |       /       /|
*     4 |       11     4       5 11
*    /  10      |     /       /  |
*   *   |       |    *---6---*   |
*   |   *---3---*    |       |   *
*   |  /       /     |       9  /
*   8 0       1      8       | 1
*   |/       /       |       |/
*   *---2---*        *---2---*
* </pre> As in 2d lines are directed in coordinate directions. <pre class="fragment">*       *---&gt;---*        *---&gt;---*
*      /|       |       /       /|
*     ^ |       ^      ^       ^ ^
*    /  ^       |     /       /  |
*   *   |       |    *---&gt;---*   |
*   |   *---&gt;---*    |       |   *
*   |  /       /     |       ^  /
*   ^ ^       ^      ^       | ^
*   |/       /       |       |/
*   *---&gt;---*        *---&gt;---*
* </pre></li>
</ul>
<p>The fact that edges (just as vertices and faces) are entities that are stored in their own right rather than constructed from cells each time they are needed, means that adjacent cells actually have pointers to edges that are thus shared between them. This implies that the convention that sets of parallel edges have parallel directions is not only a local condition. Before a list of cells is passed to an object of the <a class="el" href="classTriangulation.html">Triangulation</a> class for creation of a triangulation, you therefore have to make sure that cells are oriented in a compatible fashion, so that edge directions are globally according to above convention. However, the <a class="el" href="classGridReordering.html">GridReordering</a> class can do this for you, by reorienting cells and edges of an arbitrary list of input cells that need not be already sorted.</p>
<h4>Faces</h4>
<p>The numbering of faces in 3d is defined by a rule analogous to 2d:</p>
<ul>
<li>Faces (quads in 3d): first the two faces with normals in x-, then y- and z-direction. For each two faces: first the face with normal in negative coordinate direction, then the one with normal in positive direction, i.e. the faces are ordered according to their normals pointing in -x, x, -y, y, -z, z direction.</li>
</ul>
<p>Therefore, the faces are numbered in the ordering: left, right, front, back, bottom and top face: </p><pre class="fragment">*       *-------*        *-------*
*      /|       |       /       /|
*     / |   3   |      /   5   / |
*    /  |       |     /       /  |
*   *   |       |    *-------*   |
*   | 0 *-------*    |       | 1 *
*   |  /       /     |       |  /
*   | /   4   /      |   2   | /
*   |/       /       |       |/
*   *-------*        *-------*
* </pre><p>The <em>standard</em> direction of the faces is such, that the induced 2d local coordinate system (x,y) implies (right hand rule) a normal in face normal direction, see N2a). In the following we show the local coordinate system and the numbering of face lines: </p><ul>
<li>
<p class="startli">Faces 0 and 1: </p><pre class="fragment">*          Face 0           Face 1
*        *-------*        *-------*
*       /|       |       /       /|
*      3 1       |      /       3 1
*    y/  |       |     /      y/  |
*    *   |x      |    *-------*   |x
*    |   *-------*    |       |   *
*    0  /       /     |       0  /
*    | 2       /      |       | 2
*    |/       /       |       |/
*    *-------*        *-------*
*  </pre><p class="endli"></p>
</li>
<li>
<p class="startli">Faces 2 and 3: </p><pre class="fragment">*        x Face 3           Face 2
*        *---1---*        *-------*
*       /|       |       /       /|
*      / |       3      /       / |
*     /  2       |    x/       /  |
*    *   |       |    *---1---*   |
*    |   *---0---*y   |       |   *
*    |  /       /     |       3  /
*    | /       /      2       | /
*    |/       /       |       |/
*    *-------*        *---0---*y
*  </pre><p class="endli"></p>
</li>
<li>
Faces 4 and 5: <pre class="fragment">*          Face 4         y Face 5
*        *-------*        *---3---*
*       /|       |       /       /|
*      / |       |      0       1 |
*     /  |       |     /       /  |
*    *   |y      |    *---2---* x |
*    |   *---3---*    |       |   *
*    |  /       /     |       |  /
*    | 0       1      |       | /
*    |/       /       |       |/
*    *---2---* x      *-------*
*  </pre> </li>
</ul>
<p>The face line numbers (0,1,2,3) correspond to following cell line numbers. </p><ul>
<li>
Face 0: lines 8, 10, 0, 4; </li>
<li>
Face 1: lines 9, 11, 1, 5; </li>
<li>
Face 2: lines 2, 6, 8, 9; </li>
<li>
Face 3: lines 3, 7, 10, 11; </li>
<li>
Face 4: lines 0, 1, 2, 3; </li>
<li>
Face 5: lines 4, 5, 6, 7; </li>
</ul>
<p>You can get these numbers using the <a class="el" href="structGeometryInfo.html#addd80ab9c6099f69d8d980b9f6fa070b">GeometryInfo&lt;3&gt;::face_to_cell_lines()</a> function.</p>
<p>The face normals can be deduced from the face orientation by applying the right hand side rule (x,y -&gt; normal). We note, that in the standard orientation of faces in 2d, faces 0 and 2 have normals that point into the cell, and faces 1 and 3 have normals pointing outward. In 3d, faces 0, 2, and 4 have normals that point into the cell, while the normals of faces 1, 3, and 5 point outward. This information, again, can be queried from <a class="el" href="structGeometryInfo.html#af9b79386bf8ca6410c906c3b8c4e8c40">GeometryInfo&lt;dim&gt;::unit_normal_orientation</a>.</p>
<p>However, it turns out that a significant number of 3d meshes cannot satisfy this convention. This is due to the fact that the face convention for one cell already implies something for the neighbor, since they share a common face and fixing it for the first cell also fixes the normal vectors of the opposite faces of both cells. It is easy to construct cases of loops of cells for which this leads to cases where we cannot find orientations for all faces that are consistent with this convention.</p>
<p>For this reason, above convention is only what we call the <em>standard orientation</em>. deal.II actually allows faces in 3d to have either the standard direction, or its opposite, in which case the lines that make up a cell would have reverted orders, and the above line equivalences would not hold any more. You can ask a cell whether a given face has standard orientation by calling <code>cell-&gt;face_orientation(face_no)</code>: if the result is <code>true</code>, then the face has standard orientation, otherwise its normal vector is pointing the other direction. There are not very many places in application programs where you need this information actually, but a few places in the library make use of this. Note that in 2d, the result is always <code>true</code>. More information on the topic can be found in this <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary</a> article.</p>
<p>In order to allow all kinds of meshes in 3d, including <em>Moebius</em>-loops, a face might even be rotated looking from one cell, whereas it is according to the standard looking at it from the neighboring cell sharing that particular face. In order to cope with this, two flags <code>face_flip</code> and <code>face_rotation</code> are available, to represent rotations by 180 and 90 degree, respectively. Setting both flags amounts to a rotation of 270 degrees (all counterclockwise). You can ask the cell for these flags like for the <code>face_orientation</code>. In order to enable rotated faces, even lines can deviate from their standard direction in 3d. This information is available as the <code>line_orientation</code> flag for cells and faces in 3d. Again, this is something that should be internal to the library and application program will probably never have to bother about it. For more information on this see also <a class="el" href="DEALGlossary.html#GlossFaceOrientation">this glossary entry</a>.</p>
<h4>Children</h4>
<p>The eight children of an isotropically refined cell are numbered according to the vertices they are adjacent to: </p><pre class="fragment">*       *----*----*        *----*----*
*      /| 6  |  7 |       / 6  /  7 /|
*     *6|    |    |      *----*----*7|
*    /| *----*----*     / 4  /  5 /| *
*   * |/|    |    |    *----*----* |/|
*   |4* | 2  |  3 |    | 4  |  5 |5*3|
*   |/|2*----*----*    |    |    |/| *
*   * |/ 2  /  3 /     *----*----* |/
*   |0*----*----*      |    |    |1*
*   |/0   /  1 /       | 0  |  1 |/
*   *----*----*        *----*----*
* </pre><p>Taking into account the orientation of the faces, the following children are adjacent to the respective faces: </p><ul>
<li>
Face 0: children 0, 2, 4, 6; </li>
<li>
Face 1: children 1, 3, 5, 7; </li>
<li>
Face 2: children 0, 4, 1, 5; </li>
<li>
Face 3: children 2, 6, 3, 7; </li>
<li>
Face 4: children 0, 1, 2, 3; </li>
<li>
Face 5: children 4, 5, 6, 7. </li>
</ul>
<p>You can get these numbers using the <a class="el" href="structGeometryInfo.html#a1263120c3a820d6b17b4055e6e0ef9f1">GeometryInfo&lt;3&gt;::child_cell_on_face()</a> function. As each child is adjacent to the vertex with the same number these numbers are also given by the <a class="el" href="structGeometryInfo.html#a2adac0f129f0bdaa1600b14a543bdaa4">GeometryInfo&lt;3&gt;::face_to_cell_vertices()</a> function.</p>
<p>Note that, again, the above list only holds for faces in their standard orientation. If a face is not in standard orientation, then the children at positions 1 and 2 (counting from 0 to 3) would be swapped. In fact, this is what the child_cell_on_face and the face_to_cell_vertices functions of GeometryInfo&lt;3&gt; do, when invoked with a <code>face_orientation=false</code> argument.</p>
<p>The information which child cell is at which position of which face is most often used when computing jump terms across faces with hanging nodes, using objects of type <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a>. Sitting on one cell, you would look at a face and figure out which child of the neighbor is sitting on a given subface between the present and the neighboring cell. To avoid having to query the standard orientation of the faces of the two cells every time in such cases, you should use a function call like <code>cell-&gt;neighbor_child_on_subface(face_no,subface_no)</code>, which returns the correct result both in 2d (where face orientations are immaterial) and 3d (where it is necessary to use the face orientation as additional argument to <code><a class="el" href="structGeometryInfo.html#a1263120c3a820d6b17b4055e6e0ef9f1">GeometryInfo&lt;3&gt;::child_cell_on_face</a></code>).</p>
<p>For anisotropic refinement, the child cells can not be numbered according to adjacent vertices, thus the following conventions are used: </p><pre class="fragment">*            RefinementCase&lt;3&gt;::cut_x
*
*       *----*----*        *----*----*
*      /|    |    |       /    /    /|
*     / |    |    |      / 0  /  1 / |
*    /  | 0  |  1 |     /    /    /  |
*   *   |    |    |    *----*----*   |
*   | 0 |    |    |    |    |    | 1 |
*   |   *----*----*    |    |    |   *
*   |  /    /    /     | 0  | 1  |  /
*   | / 0  /  1 /      |    |    | /
*   |/    /    /       |    |    |/
*   *----*----*        *----*----*
* </pre><pre class="fragment">*            RefinementCase&lt;3&gt;::cut_y
*
*       *---------*        *---------*
*      /|         |       /    1    /|
*     * |         |      *---------* |
*    /| |    1    |     /    0    /| |
*   * |1|         |    *---------* |1|
*   | | |         |    |         | | |
*   |0| *---------*    |         |0| *
*   | |/    1    /     |    0    | |/
*   | *---------*      |         | *
*   |/    0    /       |         |/
*   *---------*        *---------*
* </pre><pre class="fragment">*            RefinementCase&lt;3&gt;::cut_z
*
*       *---------*        *---------*
*      /|    1    |       /         /|
*     / |         |      /    1    / |
*    /  *---------*     /         /  *
*   * 1/|         |    *---------* 1/|
*   | / |    0    |    |    1    | / |
*   |/  *---------*    |         |/  *
*   * 0/         /     *---------* 0/
*   | /    0    /      |         | /
*   |/         /       |    0    |/
*   *---------*        *---------*
* </pre><pre class="fragment">*            RefinementCase&lt;3&gt;::cut_xy
*
*       *----*----*        *----*----*
*      /|    |    |       / 2  /  3 /|
*     * |    |    |      *----*----* |
*    /| | 2  |  3 |     / 0  /  1 /| |
*   * |2|    |    |    *----*----* |3|
*   | | |    |    |    |    |    | | |
*   |0| *----*----*    |    |    |1| *
*   | |/ 2  /  3 /     | 0  |  1 | |/
*   | *----*----*      |    |    | *
*   |/ 0  /  1 /       |    |    |/
*   *----*----*        *----*----*
* </pre><pre class="fragment">*            RefinementCase&lt;3&gt;::cut_xz
*
*       *----*----*        *----*----*
*      /| 1  |  3 |       /    /    /|
*     / |    |    |      / 1  /  3 / |
*    /  *----*----*     /    /    /  *
*   * 1/|    |    |    *----*----* 3/|
*   | / | 0  |  2 |    | 1  |  3 | / |
*   |/  *----*----*    |    |    |/  *
*   * 0/    /    /     *----*----* 2/
*   | / 0  /  2 /      |    |    | /
*   |/    /    /       | 0  |  2 |/
*   *----*----*        *----*----*
* </pre><pre class="fragment">*            RefinementCase&lt;3&gt;::cut_yz
*
*       *---------*        *---------*
*      /|    3    |       /    3    /|
*     * |         |      *---------* |
*    /|3*---------*     /    2    /|3*
*   * |/|         |    *---------* |/|
*   |2* |    1    |    |    2    |2* |
*   |/|1*---------*    |         |/|1*
*   * |/    1    /     *---------* |/
*   |0*---------*      |         |0*
*   |/    0    /       |    0    |/
*   *---------*        *---------*
* </pre><p>This information can also be obtained by the <code><a class="el" href="structGeometryInfo.html#a1263120c3a820d6b17b4055e6e0ef9f1">GeometryInfo&lt;3&gt;::child_cell_on_face</a></code> function.</p>
<h4>Coordinate systems</h4>
<p>We define the following coordinate system for the explicit coordinates of the vertices of the unit cell: </p><pre class="fragment">*                       6-------7        6-------7
*                      /|       |       /       /|
*                     / |       |      /       / |
*  z                 /  |       |     /       /  |
*  ^                4   |       |    4-------5   |
*  |   ^y           |   2-------3    |       |   3
*  |  /             |  /       /     |       |  /
*  | /              | /       /      |       | /
*  |/               |/       /       |       |/
*  *------&gt;x        0-------1        0-------1
* </pre><p>By the convention laid down as above, the vertices have the following coordinates (lexicographic, with x running fastest): </p><ul>
<li>
Vertex 0: <code>(0,0,0)</code>; </li>
<li>
Vertex 1: <code>(1,0,0)</code>; </li>
<li>
Vertex 2: <code>(0,1,0)</code>; </li>
<li>
Vertex 3: <code>(1,1,0)</code>; </li>
<li>
Vertex 4: <code>(0,0,1)</code>; </li>
<li>
Vertex 5: <code>(1,0,1)</code>; </li>
<li>
Vertex 6: <code>(0,1,1)</code>; </li>
<li>
Vertex 7: <code>(1,1,1)</code>. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for dimensions 1,2,3,4, and there is a specialization for dim=0 (see the section on <a class="el" href="Instantiations.html">Template instantiations</a> in the manual). </dd></dl>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l01213">1213</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a253fd1bcb288e88bdecccf727b7b907a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253fd1bcb288e88bdecccf727b7b907a">&#9670;&nbsp;</a></span>face_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::face_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero to <code>faces_per_cell</code>. This allows to write code using range-based for loops of the following kind: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.active_cell_iterators())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> face_index : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::face_indices</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;face(face_index)-&gt;at_boundary())</div><div class="line">      ... <span class="keywordflow">do</span> something ...</div></div><!-- fragment --><p> Here, we are looping over all faces of all cells, with <code>face_index</code> taking on all valid indices for faces (zero and one in 1d, zero through three in 2d, and zero through 5 in 3d).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CPP11.html">deal.II and the C++11 standard</a> </dd></dl>

</div>
</div>
<a id="a3a76e2c08f49817f09bcab9bbb7e373c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a76e2c08f49817f09bcab9bbb7e373c">&#9670;&nbsp;</a></span>vertex_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertex_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero to <code>vertices_per_cell</code>. This allows to write code using range-based for loops of the following kind: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.active_cell_iterators())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vertex_index : <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;dim&gt;::vertex_indices</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;vertex(vertex_index) satisfies some condition)</div><div class="line">      ... <span class="keywordflow">do</span> something ...</div></div><!-- fragment --><p> Here, we are looping over all vertices of all cells, with <code>vertex_index</code> taking on all valid indices.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CPP11.html">deal.II and the C++11 standard</a> </dd></dl>

</div>
</div>
<a id="ad022815fd2a5c25fc0cddaca93f3cca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad022815fd2a5c25fc0cddaca93f3cca5">&#9670;&nbsp;</a></span>n_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::n_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of children of a cell (or face) refined with <code>ref_case</code>. </p>

</div>
</div>
<a id="afe25e8c0a5a67e3618fa17dadf58b944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe25e8c0a5a67e3618fa17dadf58b944">&#9670;&nbsp;</a></span>n_subfaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::n_subfaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subface_case</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of subfaces of a face refined according to <a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a> <code>face_ref_case</code>. </p>

</div>
</div>
<a id="a6ca2ea6ad9db59ae8d34662599e14fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca2ea6ad9db59ae8d34662599e14fc2">&#9670;&nbsp;</a></span>subface_ratio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdouble.html">double</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::subface_ratio </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subface_case</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a face on the reference element with a <code><a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt;dim&gt;</code> <code>face_refinement_case</code> this function returns the ratio between the area of the <code>subface_no</code> th subface and the area(=1) of the face.</p>
<p>E.g. for internal::SubfaceCase::cut_xy the ratio is 1/4 for each of the subfaces. </p>

</div>
</div>
<a id="af6b91a076a13a5a6594f132b09c824c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b91a076a13a5a6594f132b09c824c3">&#9670;&nbsp;</a></span>face_refinement_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim - 1&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::face_refinement_case </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_refinement_case</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a cell refined with the <code><a class="el" href="classRefinementCase.html">RefinementCase</a></code> <code>cell_refinement_case</code> return the <code>SubfaceCase</code> of the <code>face_no</code> th face. </p>

</div>
</div>
<a id="a0ff1bd9fab7ea7b2ab9265c53c8e34a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff1bd9fab7ea7b2ab9265c53c8e34a4">&#9670;&nbsp;</a></span>min_cell_refinement_case_for_face_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::min_cell_refinement_case_for_face_refinement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_refinement_case</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the SubfaceCase <code>face_refinement_case</code> of the <code>face_no</code> th face, return the smallest <a class="el" href="classRefinementCase.html">RefinementCase</a> of the cell, which corresponds to that refinement of the face. </p>

</div>
</div>
<a id="a3f5efb5e5ca92dfead4105ff194dbe94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5efb5e5ca92dfead4105ff194dbe94">&#9670;&nbsp;</a></span>line_refinement_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;1&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::line_refinement_case </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_refinement_case</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a cell refined with the <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>cell_refinement_case</code> return the <a class="el" href="classRefinementCase.html">RefinementCase</a> of the <code>line_no</code> th face. </p>

</div>
</div>
<a id="a46b46dc2ac462eeeeab76b04e22928b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b46dc2ac462eeeeab76b04e22928b8">&#9670;&nbsp;</a></span>min_cell_refinement_case_for_line_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::min_cell_refinement_case_for_line_refinement </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the minimal / smallest <a class="el" href="classRefinementCase.html">RefinementCase</a> of the cell, which ensures refinement of line <code>line_no</code>. </p>

</div>
</div>
<a id="a1263120c3a820d6b17b4055e6e0ef9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1263120c3a820d6b17b4055e6e0ef9f1">&#9670;&nbsp;</a></span>child_cell_on_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::child_cell_on_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_case</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This field stores which child cells are adjacent to a certain face of the mother cell.</p>
<p>For example, in 2D the layout of a cell is as follows: </p><pre class="fragment">* .      3
* .   2--&gt;--3
* .   |     |
* . 0 ^     ^ 1
* .   |     |
* .   0--&gt;--1
* .      2
* </pre><p> Vertices and faces are indicated with their numbers, faces also with their directions.</p>
<p>Now, when refined, the layout is like this: </p><pre class="fragment">* *--*--*
* | 2|3 |
* *--*--*
* | 0|1 |
* *--*--*
* </pre><p>Thus, the child cells on face 0 are (ordered in the direction of the face) 0 and 2, on face 3 they are 2 and 3, etc.</p>
<p>For three spatial dimensions, the exact order of the children is laid down in the general documentation of this class.</p>
<p>Through the <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> arguments this function handles faces oriented in the standard and non-standard orientation. <code>face_orientation</code> defaults to <code>true</code>, <code>face_flip</code> and <code>face_rotation</code> default to <code>false</code> (standard orientation) and has no effect in 2d. The concept of face orientations is explained in this <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary</a> entry.</p>
<p>In the case of anisotropically refined cells and faces, the <code><a class="el" href="classRefinementCase.html">RefinementCase</a></code> of the face, <code>face_ref_case</code>, might have an influence on which child is behind which given subface, thus this is an additional argument, defaulting to isotropic refinement of the face. </p>

</div>
</div>
<a id="abd66dc231589a519786719dbde492c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd66dc231589a519786719dbde492c9a">&#9670;&nbsp;</a></span>line_to_cell_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::line_to_cell_vertices </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map line vertex number to cell vertex number, i.e. give the cell vertex number of the <code>vertex</code>th vertex of line <code>line</code>, e.g. <code>GeometryInfo&lt;2&gt;::line_to_cell_vertices(3,0)=2</code>.</p>
<p>The order of the lines, as well as their direction (which in turn determines which is the first and which the second vertex on a line) is the canonical one in deal.II, as described in the general documentation of this class.</p>
<p>For <code>dim=2</code> this call is simply passed down to the <a class="el" href="structGeometryInfo.html#a2adac0f129f0bdaa1600b14a543bdaa4">face_to_cell_vertices()</a> function. </p>

</div>
</div>
<a id="a2adac0f129f0bdaa1600b14a543bdaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2adac0f129f0bdaa1600b14a543bdaa4">&#9670;&nbsp;</a></span>face_to_cell_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::face_to_cell_vertices </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map face vertex number to cell vertex number, i.e. give the cell vertex number of the <code>vertex</code>th vertex of face <code>face</code>, e.g. <code>GeometryInfo&lt;2&gt;::face_to_cell_vertices(3,0)=2</code>, see the image under point N4 in the 2d section of this class's documentation.</p>
<p>Through the <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> arguments this function handles faces oriented in the standard and non-standard orientation. <code>face_orientation</code> defaults to <code>true</code>, <code>face_flip</code> and <code>face_rotation</code> default to <code>false</code> (standard orientation). In 2d only <code>face_flip</code> is considered. See this <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary</a> article for more information.</p>
<p>As the children of a cell are ordered according to the vertices of the cell, this call is passed down to the <a class="el" href="structGeometryInfo.html#a1263120c3a820d6b17b4055e6e0ef9f1">child_cell_on_face()</a> function. Hence this function is simply a wrapper of <a class="el" href="structGeometryInfo.html#a1263120c3a820d6b17b4055e6e0ef9f1">child_cell_on_face()</a> giving it a suggestive name. </p>

</div>
</div>
<a id="addd80ab9c6099f69d8d980b9f6fa070b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd80ab9c6099f69d8d980b9f6fa070b">&#9670;&nbsp;</a></span>face_to_cell_lines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::face_to_cell_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map face line number to cell line number, i.e. give the cell line number of the <code>line</code>th line of face <code>face</code>, e.g. <code>GeometryInfo&lt;3&gt;::face_to_cell_lines(5,0)=4</code>.</p>
<p>Through the <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> arguments this function handles faces oriented in the standard and non-standard orientation. <code>face_orientation</code> defaults to <code>true</code>, <code>face_flip</code> and <code>face_rotation</code> default to <code>false</code> (standard orientation) and has no effect in 2d. </p>

</div>
</div>
<a id="a24b2e56d13ff47bf46c4dbdaef49508c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b2e56d13ff47bf46c4dbdaef49508c">&#9670;&nbsp;</a></span>standard_to_real_face_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::standard_to_real_face_vertex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map the vertex index <code>vertex</code> of a face in standard orientation to one of a face with arbitrary <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code>. The values of these three flags default to <code>true</code>, <code>false</code> and <code>false</code>, respectively. this combination describes a face in standard orientation.</p>
<p>This function is only implemented in 3D. </p>

</div>
</div>
<a id="ad032159a72b9a4e71ab25912d9d4737d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad032159a72b9a4e71ab25912d9d4737d">&#9670;&nbsp;</a></span>real_to_standard_face_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::real_to_standard_face_vertex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map the vertex index <code>vertex</code> of a face with arbitrary <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> to a face in standard orientation. The values of these three flags default to <code>true</code>, <code>false</code> and <code>false</code>, respectively. this combination describes a face in standard orientation.</p>
<p>This function is only implemented in 3D. </p>

</div>
</div>
<a id="a5f6b330c8a3699c3e70b833cf164a77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6b330c8a3699c3e70b833cf164a77b">&#9670;&nbsp;</a></span>standard_to_real_face_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::standard_to_real_face_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map the line index <code>line</code> of a face in standard orientation to one of a face with arbitrary <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code>. The values of these three flags default to <code>true</code>, <code>false</code> and <code>false</code>, respectively. this combination describes a face in standard orientation.</p>
<p>This function is only implemented in 3D. </p>

</div>
</div>
<a id="a0250ad9b85b95081a95c280457ec76ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0250ad9b85b95081a95c280457ec76ba">&#9670;&nbsp;</a></span>standard_to_real_line_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::standard_to_real_line_vertex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>line_orientation</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map the vertex index <code>vertex</code> of a line in standard orientation to one of a face with arbitrary <code>line_orientation</code>. The value of this flag default to <code>true</code>. </p>

</div>
</div>
<a id="ae0e986d54f7ba4754b976437eecb139c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e986d54f7ba4754b976437eecb139c">&#9670;&nbsp;</a></span>standard_quad_vertex_to_line_vertex_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::array&lt;unsigned <a class="el" href="classint.html">int</a>, 2&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::standard_quad_vertex_to_line_vertex_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decompose the vertex index in a quad into a pair of a line index and a vertex index within this line.</p>
<dl class="section note"><dt>Note</dt><dd>Which line is selected is not of importance (and not exposed on purpose). </dd></dl>

</div>
</div>
<a id="affa8dcf848b7c7ce048d4161206c52ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa8dcf848b7c7ce048d4161206c52ef">&#9670;&nbsp;</a></span>standard_hex_vertex_to_quad_vertex_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::array&lt;unsigned <a class="el" href="classint.html">int</a>, 2&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::standard_hex_vertex_to_quad_vertex_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decompose the vertex index in a hex into a pair of a quad index and a vertex index within this quad.</p>
<dl class="section note"><dt>Note</dt><dd>Which quad is selected is not of importance (and not exposed on purpose). </dd></dl>

</div>
</div>
<a id="a2ed8aecb4e67dfeb06ace9d8af349d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed8aecb4e67dfeb06ace9d8af349d0d">&#9670;&nbsp;</a></span>standard_hex_line_to_quad_line_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::array&lt;unsigned <a class="el" href="classint.html">int</a>, 2&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::standard_hex_line_to_quad_line_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decompose the line index in a hex into a pair of a quad index and a line index within this quad.</p>
<dl class="section note"><dt>Note</dt><dd>Which quad is selected is not of importance (and not exposed on purpose). </dd></dl>

</div>
</div>
<a id="aaf6d27bc23671e82a8a69a938fca4166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6d27bc23671e82a8a69a938fca4166">&#9670;&nbsp;</a></span>real_to_standard_face_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::real_to_standard_face_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map the line index <code>line</code> of a face with arbitrary <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> to a face in standard orientation. The values of these three flags default to <code>true</code>, <code>false</code> and <code>false</code>, respectively. this combination describes a face in standard orientation.</p>
<p>This function is only implemented in 3D. </p>

</div>
</div>
<a id="a328671c4ef755bea25625d068eaa8d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328671c4ef755bea25625d068eaa8d31">&#9670;&nbsp;</a></span>unit_cell_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::unit_cell_vertex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the position of the <code>ith</code> vertex on the unit cell. The order of vertices is the canonical one in deal.II, as described in the general documentation of this class. </p>

</div>
</div>
<a id="a0102b28ec69c4bc6b2b0337715c09bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0102b28ec69c4bc6b2b0337715c09bc8">&#9670;&nbsp;</a></span>child_cell_from_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::child_cell_from_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a point <code>p</code> in unit coordinates, return the number of the child cell in which it would lie in. If the point lies on the interface of two children, return any one of their indices. The result is always less than <a class="el" href="structGeometryInfo.html#afd3320089fb8cbd675963e56fb37d01f">GeometryInfo&lt;dimension&gt;::max_children_per_cell</a>.</p>
<p>The order of child cells is described the general documentation of this class. </p>

</div>
</div>
<a id="a90d17e49dab89d46ada2fff521cc5337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d17e49dab89d46ada2fff521cc5337">&#9670;&nbsp;</a></span>cell_to_child_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::cell_to_child_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td>
          <td class="paramname"><em>refine_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given coordinates <code>p</code> on the unit cell, return the values of the coordinates of this point in the coordinate system of the given child. Neither original nor returned coordinates need actually be inside the cell, we simply perform a scale-and-shift operation with a shift that depends on the number of the child. </p>

</div>
</div>
<a id="a6e860ab6e9daead69bab4553c1b7921a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e860ab6e9daead69bab4553c1b7921a">&#9670;&nbsp;</a></span>child_to_cell_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::child_to_cell_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td>
          <td class="paramname"><em>refine_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The reverse function to the one above: take a point in the coordinate system of the child, and transform it to the coordinate system of the mother cell. </p>

</div>
</div>
<a id="ace2d235da3d7459096d535d360bcf3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2d235da3d7459096d535d360bcf3d3">&#9670;&nbsp;</a></span>is_inside_unit_cell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::is_inside_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the given point is inside the unit cell of the present space dimension. </p>

</div>
</div>
<a id="a0f1e5a9fe7531316d23bbc8df02833f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1e5a9fe7531316d23bbc8df02833f2">&#9670;&nbsp;</a></span>is_inside_unit_cell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::is_inside_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the given point is inside the unit cell of the present space dimension. This function accepts an additional parameter which specifies how much the point position may actually be outside the true unit cell. This is useful because in practice we may often not be able to compute the coordinates of a point in reference coordinates exactly, but only up to numerical roundoff.</p>
<p>The tolerance parameter may be less than zero, indicating that the point should be safely inside the cell. </p>

</div>
</div>
<a id="aaae0fe397acba1d1079cbfa917b7046c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae0fe397acba1d1079cbfa917b7046c">&#9670;&nbsp;</a></span>project_to_unit_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classPoint.html">Point</a>&lt;dim, Number&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::project_to_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Projects a given point onto the unit cell, i.e. each coordinate outside [0..1] is modified to lie within that interval. </p>

</div>
</div>
<a id="a106c0b4889baa0f60e5754a2b43c420d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106c0b4889baa0f60e5754a2b43c420d">&#9670;&nbsp;</a></span>distance_to_unit_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdouble.html">double</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::distance_to_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the infinity norm of the vector between a given point <code>p</code> outside the unit cell to the closest unit cell boundary. For points inside the cell, this is defined as zero. </p>

</div>
</div>
<a id="a9e1d6d09377959718f18d1443757895c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1d6d09377959718f18d1443757895c">&#9670;&nbsp;</a></span>d_linear_shape_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdouble.html">double</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::d_linear_shape_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the value of the \(i\)-th \(d\)-linear (i.e. (bi-,tri-)linear) shape function at location \(\xi\). </p>

</div>
</div>
<a id="aad48513b4c435ca22f2a026f1918ac44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad48513b4c435ca22f2a026f1918ac44">&#9670;&nbsp;</a></span>d_linear_shape_function_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim&gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::d_linear_shape_function_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the gradient of the \(i\)-th \(d\)-linear (i.e. (bi-,tri-)linear) shape function at location \(\xi\). </p>

</div>
</div>
<a id="af047ab1fe45077a53df9cd8212fc790c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af047ab1fe45077a53df9cd8212fc790c">&#9670;&nbsp;</a></span>alternating_form_at_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::alternating_form_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>vertices</em>[vertices_per_cell], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTensor.html">Tensor</a>&lt; spacedim - dim, spacedim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>forms</em>[vertices_per_cell]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For a (bi-, tri-)linear mapping from the reference cell, face, or edge to the object specified by the given vertices, compute the alternating form of the transformed unit vectors vertices. For an object of dimensionality <code>dim</code>, there are <code>dim</code> vectors with <code>spacedim</code> components each, and the alternating form is a tensor of rank spacedim-dim that corresponds to the wedge product of the <code>dim</code> unit vectors, and it corresponds to the volume and normal vectors of the mapping from reference element to the element described by the vertices.</p>
<p>For example, if dim==spacedim==2, then the alternating form is a scalar (because spacedim-dim=0) and its value equals \(\mathbf v_1\wedge \mathbf v_2=\mathbf v_1^\perp \cdot\mathbf v_2\), where \(\mathbf v_1^\perp\) is a vector that is rotated to the right by 90 degrees from \(\mathbf v_1\). If dim==spacedim==3, then the result is again a scalar with value \(\mathbf v_1\wedge \mathbf v_2 \wedge \mathbf v_3 = (\mathbf v_1\times \mathbf v_2)\cdot \mathbf v_3\), where \(\mathbf v_1, \mathbf v_2, \mathbf v_3\) are the images of the unit vectors at a vertex of the unit dim-dimensional cell under transformation to the dim-dimensional cell in spacedim- dimensional space. In both cases, i.e. for dim==2 or 3, the result happens to equal the determinant of the Jacobian of the mapping from reference cell to cell in real space. Note that it is the actual determinant, not its absolute value as often used in transforming integrals from one coordinate system to another. In particular, if the object specified by the vertices is a parallelogram (i.e. a linear transformation of the reference cell) then the computed values are the same at all vertices and equal the (signed) area of the cell; similarly, for parallel-epipeds, it is the volume of the cell.</p>
<p>Likewise, if we have dim==spacedim-1 (e.g. we have a quad in 3d space, or a line in 2d), then the alternating product denotes the normal vector (i.e. a rank-1 tensor, since spacedim-dim=1) to the object at each vertex, where the normal vector's magnitude denotes the area element of the transformation from the reference object to the object given by the vertices. In particular, if again the mapping from reference object to the object under consideration here is linear (not bi- or trilinear), then the returned vectors are all parallel, perpendicular to the mapped object described by the vertices, and have a magnitude equal to the area/volume of the mapped object. If dim=1, spacedim=2, then the returned value is \(\mathbf v_1^\perp\), where \(\mathbf v_1\) is the image of the sole unit vector of a line mapped to the line in 2d given by the vertices; if dim=2, spacedim=3, then the returned values are \(\mathbf v_1 \wedge \mathbf v_2=\mathbf v_1 \times \mathbf v_2\) where \(\mathbf v_1,\mathbf v_2\) are the two three-dimensional vectors that are tangential to the quad mapped into three-dimensional space.</p>
<p>This function is used in order to determine how distorted a cell is (see the entry on <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a> in the glossary). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afd3320089fb8cbd675963e56fb37d01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3320089fb8cbd675963e56fb37d01f">&#9670;&nbsp;</a></span>max_children_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::max_children_per_cell = 1 &lt;&lt; dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum number of children of a refined cell, i.e. the number of children of an isotropically refined cell.</p>
<p>If a cell is refined anisotropically, the actual number of children may be less than the value given here. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l01972">1972</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a5d3e48d5e97a217c149a33c0b42a51c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3e48d5e97a217c149a33c0b42a51c2">&#9670;&nbsp;</a></span>faces_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::faces_per_cell = 2 * dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of faces of a cell. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l01977">1977</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a29fc1bee407ade48090ce592473dc327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29fc1bee407ade48090ce592473dc327">&#9670;&nbsp;</a></span>max_children_per_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::max_children_per_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#afd3320089fb8cbd675963e56fb37d01f">::max_children_per_cell</a></div></div><!-- fragment --><p>Maximum number of children of a refined face, i.e. the number of children of an isotropically refined face.</p>
<p>If a cell is refined anisotropically, the actual number of children may be less than the value given here. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02005">2005</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a2bb3a95a842d98b8b3bf9a64735d0eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb3a95a842d98b8b3bf9a64735d0eee">&#9670;&nbsp;</a></span>vertices_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_cell = 1 &lt;&lt; dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of vertices of a cell. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02011">2011</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="aad8410f6471e4ac443b51f6c20809bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8410f6471e4ac443b51f6c20809bfb">&#9670;&nbsp;</a></span>vertices_per_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">::vertices_per_cell</a></div></div><!-- fragment --><p>Number of vertices on each face. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02034">2034</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="afef86260668d5b98a7bb73db8986d027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef86260668d5b98a7bb73db8986d027">&#9670;&nbsp;</a></span>lines_per_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::lines_per_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#a3de02b6910b68785cc8acd9488599092">::lines_per_cell</a></div></div><!-- fragment --><p>Number of lines on each face. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02040">2040</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a166d28164dfd718a9211ae788e057b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166d28164dfd718a9211ae788e057b56">&#9670;&nbsp;</a></span>quads_per_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::quads_per_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#afa91c1fd95bc59a8c34a4af6443c2f85">::quads_per_cell</a></div></div><!-- fragment --><p>Number of quads on each face. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02046">2046</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a3de02b6910b68785cc8acd9488599092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de02b6910b68785cc8acd9488599092">&#9670;&nbsp;</a></span>lines_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::lines_per_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    (2 * <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#a3de02b6910b68785cc8acd9488599092">::lines_per_cell</a> +</div><div class="line">     <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">::vertices_per_cell</a>)</div></div><!-- fragment --><p>Number of lines of a cell.</p>
<p>The formula to compute this makes use of the fact that when going from one dimension to the next, the object of the lower dimension is copied once (thus twice the old number of lines) and then a new line is inserted between each vertex of the old object and the corresponding one in the copy. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02058">2058</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="afa91c1fd95bc59a8c34a4af6443c2f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa91c1fd95bc59a8c34a4af6443c2f85">&#9670;&nbsp;</a></span>quads_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::quads_per_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    (2 * <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#afa91c1fd95bc59a8c34a4af6443c2f85">::quads_per_cell</a> +</div><div class="line">     <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#a3de02b6910b68785cc8acd9488599092">::lines_per_cell</a>)</div></div><!-- fragment --><p>Number of quadrilaterals of a cell.</p>
<p>This number is computed recursively just as the previous one, with the exception that new quads result from connecting an original line and its copy. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02069">2069</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a6e3c139c94b4d9e54371400514a102f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3c139c94b4d9e54371400514a102f4">&#9670;&nbsp;</a></span>hexes_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::hexes_per_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    (2 * <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#a6e3c139c94b4d9e54371400514a102f4">::hexes_per_cell</a> +</div><div class="line">     <a class="code" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim - 1&gt;<a class="code" href="structGeometryInfo.html#afa91c1fd95bc59a8c34a4af6443c2f85">::quads_per_cell</a>)</div></div><!-- fragment --><p>Number of hexahedra of a cell. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02076">2076</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a09a95dd40f1faa1a1bad8210dcb66f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a95dd40f1faa1a1bad8210dcb66f1f">&#9670;&nbsp;</a></span>ucd_to_deal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a> &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::ucd_to_deal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    internal::GeometryInfoHelper::Initializers&lt;dim&gt;::ucd_to_deal()</div></div><!-- fragment --><p>Rearrange vertices for UCD output. For a cell being written in UCD format, each entry in this field contains the number of a vertex in <code>deal.II</code> that corresponds to the UCD numbering at this location.</p>
<p>Typical example: write a cell and arrange the vertices, such that UCD understands them.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt; n_vertices; ++i)</div><div class="line">  out &lt;&lt; cell-&gt;vertex(<a class="code" href="structGeometryInfo.html#a09a95dd40f1faa1a1bad8210dcb66f1f">ucd_to_deal</a>[i]);</div></div><!-- fragment --><p>As the vertex numbering in deal.II versions &lt;= 5.1 happened to coincide with the UCD numbering, this field can also be used like a old_to_lexicographic mapping. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02097">2097</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a33c82eb40866a5d8685d23604b76300f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c82eb40866a5d8685d23604b76300f">&#9670;&nbsp;</a></span>dx_to_deal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a> &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::dx_to_deal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    internal::GeometryInfoHelper::Initializers&lt;dim&gt;::dx_to_deal()</div></div><!-- fragment --><p>Rearrange vertices for OpenDX output. For a cell being written in OpenDX format, each entry in this field contains the number of a vertex in <code>deal.II</code> that corresponds to the DX numbering at this location.</p>
<p>Typical example: write a cell and arrange the vertices, such that OpenDX understands them.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt; n_vertices; ++i)</div><div class="line">  out &lt;&lt; cell-&gt;vertex(<a class="code" href="structGeometryInfo.html#a33c82eb40866a5d8685d23604b76300f">dx_to_deal</a>[i]);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02113">2113</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="aea298d2f0914e2810d9b96081e809f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea298d2f0914e2810d9b96081e809f6a">&#9670;&nbsp;</a></span>vertex_to_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="ndarray_8h.html#a82399009710c9549884b9d8c506ad695">ndarray</a>&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">vertices_per_cell</a>, dim &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertex_to_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">      internal::GeometryInfoHelper::Initializers&lt;dim&gt;::vertex_to_face()</div></div><!-- fragment --><p>This field stores for each vertex to which faces it belongs. In any given dimension, the number of faces is equal to the dimension. The first index in this 2D-array runs over all vertices, the second index over <code>dim</code> faces to which the vertex belongs.</p>
<p>The order of the faces for each vertex is such that the first listed face bounds the reference cell in <em>x</em> direction, the second in <em>y</em> direction, and so on. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02127">2127</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a41eabdf96722189263e5ede8ab8d566a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41eabdf96722189263e5ede8ab8d566a">&#9670;&nbsp;</a></span>unit_normal_direction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::unit_normal_direction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">      internal::GeometryInfoHelper::Initializers&lt;dim&gt;::unit_normal_direction()</div></div><!-- fragment --><p>For each face of the reference cell, this field stores the coordinate direction in which its normal vector points. In <code>dim</code> dimension these are the <code>2*dim</code> first entries of <code>{0,0,1,1,2,2,3,3}</code>.</p>
<p>Note that this is only the coordinate number. The actual direction of the normal vector is obtained by multiplying the unit vector in this direction with <a class="el" href="structGeometryInfo.html#af9b79386bf8ca6410c906c3b8c4e8c40">unit_normal_orientation</a>. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02579">2579</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="af9b79386bf8ca6410c906c3b8c4e8c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b79386bf8ca6410c906c3b8c4e8c40">&#9670;&nbsp;</a></span>unit_normal_orientation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::unit_normal_orientation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    internal::GeometryInfoHelper::Initializers&lt;dim&gt;::unit_normal_orientation()</div></div><!-- fragment --><p>Orientation of the unit normal vector of a face of the reference cell. In <code>dim</code> dimension these are the <code>2*dim</code> first entries of <code>{-1,1,-1,1,-1,1,-1,1}</code>.</p>
<p>Each value is either <code>1</code> or <code>-1</code>, corresponding to a normal vector pointing in the positive or negative coordinate direction, respectively.</p>
<p>Note that this is only the <em>standard orientation</em> of faces. At least in 3d, actual faces of cells in a triangulation can also have the opposite orientation, depending on a flag that one can query from the cell it belongs to. For more information, see the <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary</a> entry on face orientation. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02598">2598</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="aa9b67e58ad8e792e55efc3cbfb274ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b67e58ad8e792e55efc3cbfb274ef7">&#9670;&nbsp;</a></span>unit_normal_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::unit_normal_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">      internal::GeometryInfoHelper::Initializers&lt;dim&gt;::unit_normal_vector()</div></div><!-- fragment --><p>Unit normal vector (<a class="el" href="classPoint.html">Point&lt;dim&gt;</a>) of a face of the reference cell.</p>
<p>Note that this is only the <em>standard orientation</em> of faces. At least in 3d, actual faces of cells in a triangulation can also have the opposite orientation, depending on a flag that one can query from the cell it belongs to. For more information, see the <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary</a> entry on face orientation. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02612">2612</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a0ba9791aca6cde3acf3f79bbb63e8247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba9791aca6cde3acf3f79bbb63e8247">&#9670;&nbsp;</a></span>unit_tangential_vectors</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="ndarray_8h.html#a82399009710c9549884b9d8c506ad695">ndarray</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a>, dim - 1 &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::unit_tangential_vectors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= internal::GeometryInfoHelper::Initializers&lt;</div><div class="line">      dim&gt;<a class="code" href="structGeometryInfo.html#a0ba9791aca6cde3acf3f79bbb63e8247">::unit_tangential_vectors</a>()</div></div><!-- fragment --><p>Unit tangential vectors (array of <code>dim-1</code> elements of <a class="el" href="classPoint.html">Point&lt;dim&gt;</a>) of a face of the reference cell, arranged in a right-hand coordinate system such that the cross product between the two vectors return the unit normal vector.</p>
<p>Note that this is only the <em>standard orientation</em> of faces. At least in 3d, actual faces of cells in a triangulation can also have the opposite orientation, depending on a flag that one can query from the cell it belongs to. For more information, see the <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary</a> entry on face orientation. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02629">2629</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<a id="a29821832e1cd4777e3e377c022e09073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29821832e1cd4777e3e377c022e09073">&#9670;&nbsp;</a></span>opposite_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::<a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">faces_per_cell</a> &gt; <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::opposite_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    internal::GeometryInfoHelper::Initializers&lt;dim&gt;::opposite_face()</div></div><!-- fragment --><p>List of numbers which denotes which face is opposite to a given face. Its entries are the first <code>2*dim</code> entries of <code>{ 1, 0, 3, 2, 5, 4, 7, 6}</code>. </p>

<p class="definition">Definition at line <a class="el" href="geometry__info_8h_source.html#l02637">2637</a> of file <a class="el" href="geometry__info_8h_source.html">geometry_info.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="geometry__info_8h_source.html">geometry_info.h</a></li>
<li>source/base/<a class="el" href="geometry__info_8cc_source.html">geometry_info.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
