<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classparallel_1_1distributed_1_1Triangulation.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: parallel::distributed::Triangulation&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceparallel.html">parallel</a></li><li class="navelem"><a class="el" href="namespaceparallel_1_1distributed.html">distributed</a></li><li class="navelem"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classparallel_1_1distributed_1_1Triangulation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">parallel::distributed::Triangulation&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Parallel.html">Parallel computing</a> &raquo; <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="distributed_2tria_8h_source.html">deal.II/distributed/tria.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for parallel::distributed::Triangulation&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classparallel_1_1distributed_1_1Triangulation__inherit__graph.svg" width="219" height="519"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0f5f69b2f422595604c9317ea7f15c13"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13">Settings</a> { <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13a80dd6bc33282bb4ee59e282098beeebe">default_setting</a> = 0x0, 
<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13a92fad5ef4e0f7f69d008cb54123b1a9d">mesh_reconstruction_after_repartitioning</a> = 0x1, 
<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13a1cd821e9678703d6d5d907fa0c7a0fe0">construct_multigrid_hierarchy</a> = 0x2, 
<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13a1bcfd814692ed67b8c57e84b042158ad">no_automatic_repartitioning</a> = 0x4
 }</td></tr>
<tr class="separator:a0f5f69b2f422595604c9317ea7f15c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48cef91f67c38d6ec17912922de00f90"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a> = typename ::<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a></td></tr>
<tr class="separator:ga48cef91f67c38d6ec17912922de00f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80b689a21d72f777095aa12bbe01afa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gaa80b689a21d72f777095aa12bbe01afa">active_cell_iterator</a> = typename ::<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="group__Iterators.html#gaa80b689a21d72f777095aa12bbe01afa">active_cell_iterator</a></td></tr>
<tr class="separator:gaa80b689a21d72f777095aa12bbe01afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0facea3dfcde4d6f57b727a3963e89f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0facea3dfcde4d6f57b727a3963e89f4">CellStatus</a> = typename ::<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a></td></tr>
<tr class="separator:a0facea3dfcde4d6f57b727a3963e89f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0633dd17e535a59162b79f338c6ff5ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> { <br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9828da1d84133b33b112afd4a0ac15ec">none</a> = 0x0, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">limit_level_difference_at_vertices</a> = 0x1, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a> = 0x2, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea37c283b96070dc09dde81f51d3ce1812">patch_level_1</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae94a75f4383724ef8f58639aef2eb6c0">coarsest_level_1</a> = 0x8, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa44d17458e16327fb4b674745b883910">allow_anisotropic_smoothing</a> = 0x10, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a> = 0x100, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58">eliminate_refined_boundary_islands</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea75171630dec90d241c811d2732410303">do_not_produce_unrefined_islands</a> = 0x400, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea3fb6b9153821aefc45661f67f22e232a">smoothing_on_refinement</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea8d8dbaaa62136a7e51c7bf5c02d6e1e7">smoothing_on_coarsening</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf64b535fd0fad99b6032412d2cccac36">maximum_smoothing</a> = 0xffff ^ allow_anisotropic_smoothing
<br />
 }</td></tr>
<tr class="separator:a0633dd17e535a59162b79f338c6ff5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12cedb5139eeea73fb2a3eec16636f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad12cedb5139eeea73fb2a3eec16636f8">level_cell_iterator</a> = <a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a></td></tr>
<tr class="separator:ad12cedb5139eeea73fb2a3eec16636f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4015f9d1dc9115fbdf74d74960bec074"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga4015f9d1dc9115fbdf74d74960bec074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad77aace3a5c6c96b985cbf22a28c83f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:gad77aace3a5c6c96b985cbf22a28c83f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23052ad0b446137324ccf9ea0fd386e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:gac23052ad0b446137324ccf9ea0fd386e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8738294ebb9d165e6b431589b0bbc7f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga8738294ebb9d165e6b431589b0bbc7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga863d37379dceb11324e72a44039ac495"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> = typename IteratorSelector::line_iterator</td></tr>
<tr class="separator:ga863d37379dceb11324e72a44039ac495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfba44e3df01252843f37ee1f8e6df58"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a> = typename IteratorSelector::active_line_iterator</td></tr>
<tr class="separator:gabfba44e3df01252843f37ee1f8e6df58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga672c99b1c8da16227cae6f0cf66cc109"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> = typename IteratorSelector::quad_iterator</td></tr>
<tr class="separator:ga672c99b1c8da16227cae6f0cf66cc109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b331baff3d6bfb841950b10845fc5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a> = typename IteratorSelector::active_quad_iterator</td></tr>
<tr class="separator:ga31b331baff3d6bfb841950b10845fc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0500bbdefc5ea6a1306892b933896875"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> = typename IteratorSelector::hex_iterator</td></tr>
<tr class="separator:ga0500bbdefc5ea6a1306892b933896875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fed0f1753adab5eb220b1bec03ae571"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a> = typename IteratorSelector::active_hex_iterator</td></tr>
<tr class="separator:ga4fed0f1753adab5eb220b1bec03ae571"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4da51da139d7789e6fa6d104252b5416"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a4da51da139d7789e6fa6d104252b5416">Triangulation</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classparallel_1_1TriangulationBase.html#a55959d63f6a4e18cae86f005df8605ec">mpi_communicator</a>, const typename ::<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> <a class="el" href="group__Exceptions.html#gac9474a14d0e8429412c82450013bde67">smooth_grid</a>=(::<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9828da1d84133b33b112afd4a0ac15ec">none</a>), const <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13">Settings</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ab24d740e69f0f8817b6c0abd7c46bb45">settings</a>=<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13a80dd6bc33282bb4ee59e282098beeebe">default_setting</a>)</td></tr>
<tr class="separator:a4da51da139d7789e6fa6d104252b5416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dce975e1b3377222ad0a4a14492cc7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a98dce975e1b3377222ad0a4a14492cc7">~Triangulation</a> () override</td></tr>
<tr class="separator:a98dce975e1b3377222ad0a4a14492cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19cebc16207fc60f8b0ab1eb1c4540f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">clear</a> () override</td></tr>
<tr class="separator:af19cebc16207fc60f8b0ab1eb1c4540f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66be05fbab855a4960fbcfd20c8488f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a66be05fbab855a4960fbcfd20c8488f9">is_multilevel_hierarchy_constructed</a> () const override</td></tr>
<tr class="separator:a66be05fbab855a4960fbcfd20c8488f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c96607beadb34c293b8f1037eb62057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5c96607beadb34c293b8f1037eb62057">execute_transfer</a> (const typename ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt; dim &gt;::forest *<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#afa33ee8b97c37ea611c10fb105b43a18">parallel_forest</a>, const typename ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt; dim &gt;::gloidx *previous_global_first_quadrant)</td></tr>
<tr class="separator:a5c96607beadb34c293b8f1037eb62057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d18fdfd9cb49b5fb87a1a78e10c86ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d18fdfd9cb49b5fb87a1a78e10c86ca">copy_triangulation</a> (const ::<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;other_tria) override</td></tr>
<tr class="separator:a8d18fdfd9cb49b5fb87a1a78e10c86ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f8516b5fe9b8fc6e8784c987f9263f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a85f8516b5fe9b8fc6e8784c987f9263f">create_triangulation</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="classTriangulation.html#a51469854babb27752dc9f26ed9d5ee30">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata) override</td></tr>
<tr class="separator:a85f8516b5fe9b8fc6e8784c987f9263f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80369486f903cb4477e46b3e63ce18df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a80369486f903cb4477e46b3e63ce18df">create_triangulation</a> (const <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>&lt; dim, spacedim &gt; &amp;construction_data) override</td></tr>
<tr class="separator:a80369486f903cb4477e46b3e63ce18df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dba428552f512e0859a9b6a06ad3b7e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">execute_coarsening_and_refinement</a> () override</td></tr>
<tr class="separator:a9dba428552f512e0859a9b6a06ad3b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad472f89b0dde244ecc13989806e78d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">prepare_coarsening_and_refinement</a> () override</td></tr>
<tr class="separator:a0ad472f89b0dde244ecc13989806e78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cc5327a81ae46b8a6d9a3eb4bd9893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a12cc5327a81ae46b8a6d9a3eb4bd9893">repartition</a> ()</td></tr>
<tr class="separator:a12cc5327a81ae46b8a6d9a3eb4bd9893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569306c9c8e694e3006f8fafa035f0ce"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a569306c9c8e694e3006f8fafa035f0ce">has_hanging_nodes</a> () const override</td></tr>
<tr class="separator:a569306c9c8e694e3006f8fafa035f0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0357cc88e13176507540d7f2524123"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#afa0357cc88e13176507540d7f2524123">memory_consumption</a> () const override</td></tr>
<tr class="separator:afa0357cc88e13176507540d7f2524123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7661a73ff6a5c955c40dbb31bba4128f"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a7661a73ff6a5c955c40dbb31bba4128f">memory_consumption_p4est</a> () const</td></tr>
<tr class="separator:a7661a73ff6a5c955c40dbb31bba4128f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bb82f9331c5cb192cfda724be59f37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a96bb82f9331c5cb192cfda724be59f37">write_mesh_vtk</a> (const std::string &amp;file_basename) const</td></tr>
<tr class="separator:a96bb82f9331c5cb192cfda724be59f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b5ad193b7a41b9c95a924dde2fb90e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a74b5ad193b7a41b9c95a924dde2fb90e">get_checksum</a> () const</td></tr>
<tr class="separator:a74b5ad193b7a41b9c95a924dde2fb90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd3a35ff1a0b49c26b3d735af5d62b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">save</a> (const std::string &amp;filename) const override</td></tr>
<tr class="separator:a5cd3a35ff1a0b49c26b3d735af5d62b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8d56c4155e1ab11e9f16799c71d3a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">load</a> (const std::string &amp;filename, const <a class="el" href="classbool.html">bool</a> autopartition=true) override</td></tr>
<tr class="separator:a8d8d56c4155e1ab11e9f16799c71d3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8c3dda81bb89d601c6db5b9717b34b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9e8c3dda81bb89d601c6db5b9717b34b">load</a> (const typename ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt; dim &gt;::forest *forest)</td></tr>
<tr class="separator:a9e8c3dda81bb89d601c6db5b9717b34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90dc28ab95be39095cecfdf3496eac04"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a90dc28ab95be39095cecfdf3496eac04">get_p4est_tree_to_coarse_cell_permutation</a> () const</td></tr>
<tr class="separator:a90dc28ab95be39095cecfdf3496eac04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0502ebf9878fc3c675115ed81cd5181f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0502ebf9878fc3c675115ed81cd5181f">get_coarse_cell_to_p4est_tree_permutation</a> () const</td></tr>
<tr class="separator:a0502ebf9878fc3c675115ed81cd5181f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c88267bebc11d2814888a5878a96d68"><td class="memItemLeft" align="right" valign="top">const ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt; dim &gt;::forest *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a2c88267bebc11d2814888a5878a96d68">get_p4est</a> () const</td></tr>
<tr class="separator:a2c88267bebc11d2814888a5878a96d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba7cf46ec43269f5ba430e91996d065"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ba7cf46ec43269f5ba430e91996d065">add_periodicity</a> (const std::vector&lt;::<a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a> &gt;&gt; &amp;) override</td></tr>
<tr class="separator:a5ba7cf46ec43269f5ba430e91996d065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1a95528832932bf2fad380f8098367"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach</a> (const std::function&lt; std::vector&lt; char &gt;(const <a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>)&gt; &amp;pack_callback, const <a class="el" href="classbool.html">bool</a> returns_variable_size_data)</td></tr>
<tr class="separator:acb1a95528832932bf2fad380f8098367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbdf11dcfacd414a8936e6d26fecb76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack</a> (const unsigned <a class="el" href="classint.html">int</a> handle, const std::function&lt; void(const <a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>, const boost::iterator_range&lt; std::vector&lt; char &gt;::const_iterator &gt; &amp;)&gt; &amp;unpack_callback)</td></tr>
<tr class="separator:a6fbdf11dcfacd414a8936e6d26fecb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b606a3f26f71603f7759dc16d33db9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a77b606a3f26f71603f7759dc16d33db9">get_communicator</a> () const override</td></tr>
<tr class="separator:a77b606a3f26f71603f7759dc16d33db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba82cc28f325167d0950150e23cf037"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a7ba82cc28f325167d0950150e23cf037">copy_triangulation</a> (const ::<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;old_tria) override</td></tr>
<tr class="separator:a7ba82cc28f325167d0950150e23cf037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bca327fa47f88b58086dacc20028064"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1bca327fa47f88b58086dacc20028064">copy_triangulation</a> (const <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;other_tria)</td></tr>
<tr class="separator:a1bca327fa47f88b58086dacc20028064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e904416671ca175093274144e49439"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a74e904416671ca175093274144e49439">n_locally_owned_active_cells</a> () const</td></tr>
<tr class="separator:a74e904416671ca175093274144e49439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46548d5ed479030dbc75d8fbb2b68d11"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a46548d5ed479030dbc75d8fbb2b68d11">n_global_active_cells</a> () const override</td></tr>
<tr class="separator:a46548d5ed479030dbc75d8fbb2b68d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94c22b8116e1b5f4284ae01b221a2e2"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ab94c22b8116e1b5f4284ae01b221a2e2">n_global_levels</a> () const override</td></tr>
<tr class="separator:ab94c22b8116e1b5f4284ae01b221a2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b129156d89f37482d2095de5751d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a41b129156d89f37482d2095de5751d9c">locally_owned_subdomain</a> () const override</td></tr>
<tr class="separator:a41b129156d89f37482d2095de5751d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e24708aa6563bf529cd8a10ca0cbe12"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a5e24708aa6563bf529cd8a10ca0cbe12">ghost_owners</a> () const</td></tr>
<tr class="separator:a5e24708aa6563bf529cd8a10ca0cbe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff00f28a17583c0316af55b04b139e3"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#abff00f28a17583c0316af55b04b139e3">level_ghost_owners</a> () const</td></tr>
<tr class="separator:abff00f28a17583c0316af55b04b139e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640568c9b7f4b50cf45b5c52a8420b05"><td class="memItemLeft" align="right" valign="top">const std::weak_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a640568c9b7f4b50cf45b5c52a8420b05">global_active_cell_index_partitioner</a> () const</td></tr>
<tr class="separator:a640568c9b7f4b50cf45b5c52a8420b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8513533c19e088ed8303ea50198b9920"><td class="memItemLeft" align="right" valign="top">const std::weak_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a8513533c19e088ed8303ea50198b9920">global_level_cell_index_partitioner</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a8513533c19e088ed8303ea50198b9920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1acf0c97fceec538c4552ee300213c"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a1e1acf0c97fceec538c4552ee300213c">get_boundary_ids</a> () const override</td></tr>
<tr class="separator:a1e1acf0c97fceec538c4552ee300213c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f63aebdfa85dc769c1503c00670a7e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a51f63aebdfa85dc769c1503c00670a7e">get_manifold_ids</a> () const override</td></tr>
<tr class="separator:a51f63aebdfa85dc769c1503c00670a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63df2c11257f1e6fb482e4f9ea4589f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ad63df2c11257f1e6fb482e4f9ea4589f">communicate_locally_moved_vertices</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;vertex_locally_moved)</td></tr>
<tr class="separator:ad63df2c11257f1e6fb482e4f9ea4589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d830897853a1098344e718dd878147"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ae5d830897853a1098344e718dd878147">n_global_coarse_cells</a> () const override</td></tr>
<tr class="separator:ae5d830897853a1098344e718dd878147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a302f66ccc9bd281cf850fdc4f76e50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4a302f66ccc9bd281cf850fdc4f76e50">set_mesh_smoothing</a> (const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> mesh_smoothing)</td></tr>
<tr class="separator:a4a302f66ccc9bd281cf850fdc4f76e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df95bfd43216e389a132786f87474f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a06df95bfd43216e389a132786f87474f">get_mesh_smoothing</a> () const</td></tr>
<tr class="separator:a06df95bfd43216e389a132786f87474f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number, const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;manifold_object)</td></tr>
<tr class="separator:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644a2152b8f5a6902afdc503d163d950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga644a2152b8f5a6902afdc503d163d950">reset_manifold</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> manifold_number)</td></tr>
<tr class="separator:ga644a2152b8f5a6902afdc503d163d950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a> ()</td></tr>
<tr class="separator:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2acfbef517fd03855c4b371f3e182f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number)</td></tr>
<tr class="separator:gae2acfbef517fd03855c4b371f3e182f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number)</td></tr>
<tr class="separator:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa4e0af28512cb5f9cc8cb3b95a38c669">set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id, const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number)</td></tr>
<tr class="separator:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d4bed3d2ac6148e969a331bde49f63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa5d4bed3d2ac6148e969a331bde49f63">get_manifold</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number) const</td></tr>
<tr class="separator:gaa5d4bed3d2ac6148e969a331bde49f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbee6e665998c3e4a745cd7836df364"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abbbee6e665998c3e4a745cd7836df364">create_triangulation_compatibility</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="classTriangulation.html#a51469854babb27752dc9f26ed9d5ee30">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:abbbee6e665998c3e4a745cd7836df364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc34248a9ba0c38fd0020256a8def5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afdc34248a9ba0c38fd0020256a8def5c">flip_all_direction_flags</a> ()</td></tr>
<tr class="separator:afdc34248a9ba0c38fd0020256a8def5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Internal information about the number of objects</div></td></tr>
<tr class="memitem:a2f0c10f7a8cd32d961e9367173685047"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a2f0c10f7a8cd32d961e9367173685047"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2f0c10f7a8cd32d961e9367173685047">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:a2f0c10f7a8cd32d961e9367173685047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae2f72d5fbb277ec65dbe0382ae72a929">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a466c6b1755b353d43ce8827b1518e3"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4a466c6b1755b353d43ce8827b1518e3">n_raw_lines</a> () const</td></tr>
<tr class="separator:a4a466c6b1755b353d43ce8827b1518e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615e8e8877a420fede76cea831f6ca52"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a615e8e8877a420fede76cea831f6ca52">n_raw_lines</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a615e8e8877a420fede76cea831f6ca52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcdcdaea38195ba043370ddc6202224"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abbcdcdaea38195ba043370ddc6202224">n_raw_quads</a> () const</td></tr>
<tr class="separator:abbcdcdaea38195ba043370ddc6202224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f590c6799cf3bb79c3c810f972a117e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9f590c6799cf3bb79c3c810f972a117e">n_raw_quads</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a9f590c6799cf3bb79c3c810f972a117e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5a359c972a4679b5ff1be96b68efc1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aed5a359c972a4679b5ff1be96b68efc1">n_raw_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:aed5a359c972a4679b5ff1be96b68efc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c26f9d04c1b4a4fb190334ebd1542"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a947c26f9d04c1b4a4fb190334ebd1542">n_raw_cells</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a947c26f9d04c1b4a4fb190334ebd1542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7926c72a24cc478de8217c1f6988e0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5a7926c72a24cc478de8217c1f6988e0">n_raw_faces</a> () const</td></tr>
<tr class="separator:a5a7926c72a24cc478de8217c1f6988e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7117ea716b516ef11a205a5d0020fe40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7117ea716b516ef11a205a5d0020fe40">add_periodicity</a> (const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a> &gt;&gt; &amp;)</td></tr>
<tr class="separator:a7117ea716b516ef11a205a5d0020fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34318b9fb11fa49f10ba7c5155960c6"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::pair&lt; <a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::pair&lt; std::pair&lt; <a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::bitset&lt; 3 &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac34318b9fb11fa49f10ba7c5155960c6">get_periodic_face_map</a> () const</td></tr>
<tr class="separator:ac34318b9fb11fa49f10ba7c5155960c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f08d0df83f6455dbdac86c1a0736b8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classReferenceCell.html">ReferenceCell</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af4f08d0df83f6455dbdac86c1a0736b8">get_reference_cells</a> () const</td></tr>
<tr class="separator:af4f08d0df83f6455dbdac86c1a0736b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c84e9fa932ccd35820fe68abfe1348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a24c84e9fa932ccd35820fe68abfe1348">all_reference_cells_are_hyper_cube</a> () const</td></tr>
<tr class="separator:a24c84e9fa932ccd35820fe68abfe1348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70afc9a4f52455c18183ab31dd6789f"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ac70afc9a4f52455c18183ab31dd6789f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac70afc9a4f52455c18183ab31dd6789f">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ac70afc9a4f52455c18183ab31dd6789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mesh refinement</div></td></tr>
<tr class="memitem:aed8e461d4b2b23a0e1730afdef36e694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aed8e461d4b2b23a0e1730afdef36e694">set_all_refine_flags</a> ()</td></tr>
<tr class="separator:aed8e461d4b2b23a0e1730afdef36e694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad0b3fb24aae17f4668427a433dea19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (const unsigned <a class="el" href="classint.html">int</a> times=1)</td></tr>
<tr class="separator:a6ad0b3fb24aae17f4668427a433dea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6552fa04ee753657bd9f92571d76cf09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6552fa04ee753657bd9f92571d76cf09">coarsen_global</a> (const unsigned <a class="el" href="classint.html">int</a> times=1)</td></tr>
<tr class="separator:a6552fa04ee753657bd9f92571d76cf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">History of a triangulation</div></td></tr>
<tr class="memitem:aca5cfa9068a5d3ad32dfca87e2901a87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aca5cfa9068a5d3ad32dfca87e2901a87">save_refine_flags</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:aca5cfa9068a5d3ad32dfca87e2901a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affce5fca29acccbb2dc1294ebe404a03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#affce5fca29acccbb2dc1294ebe404a03">save_refine_flags</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:affce5fca29acccbb2dc1294ebe404a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fc07c3f9e1f02658ca556f41087c85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a43fc07c3f9e1f02658ca556f41087c85">load_refine_flags</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a43fc07c3f9e1f02658ca556f41087c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac924a05e66d5e76458ad088a2b7b5583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac924a05e66d5e76458ad088a2b7b5583">load_refine_flags</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:ac924a05e66d5e76458ad088a2b7b5583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64b6155fd89f8f29d4c02795c1a10d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af64b6155fd89f8f29d4c02795c1a10d9">save_coarsen_flags</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:af64b6155fd89f8f29d4c02795c1a10d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaecbe89311fdaa8a9b999209ff9155"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abaaecbe89311fdaa8a9b999209ff9155">save_coarsen_flags</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:abaaecbe89311fdaa8a9b999209ff9155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4029122ffe741f843f2f3a7deeceea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa4029122ffe741f843f2f3a7deeceea9">load_coarsen_flags</a> (std::istream &amp;out)</td></tr>
<tr class="separator:aa4029122ffe741f843f2f3a7deeceea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a9463dcf9aeb3a69831e5e1a321053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a48a9463dcf9aeb3a69831e5e1a321053">load_coarsen_flags</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a48a9463dcf9aeb3a69831e5e1a321053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178e9ce017916f190ddf7a734ef15902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a178e9ce017916f190ddf7a734ef15902">get_anisotropic_refinement_flag</a> () const</td></tr>
<tr class="separator:a178e9ce017916f190ddf7a734ef15902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">User data</div></td></tr>
<tr class="memitem:aaa726b33b52f694cfca48fae8e761661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaa726b33b52f694cfca48fae8e761661">clear_user_flags</a> ()</td></tr>
<tr class="separator:aaa726b33b52f694cfca48fae8e761661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9971ee882f15fe521afc4e079383b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6a9971ee882f15fe521afc4e079383b5">save_user_flags</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a6a9971ee882f15fe521afc4e079383b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad25280beb6c2607418a0d3e903819a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aad25280beb6c2607418a0d3e903819a3">save_user_flags</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:aad25280beb6c2607418a0d3e903819a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3612ed3c7f7f9cccd3003d85b6f7350"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af3612ed3c7f7f9cccd3003d85b6f7350">load_user_flags</a> (std::istream &amp;in)</td></tr>
<tr class="separator:af3612ed3c7f7f9cccd3003d85b6f7350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17946286639b12a03804ebc400eab51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac17946286639b12a03804ebc400eab51">load_user_flags</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:ac17946286639b12a03804ebc400eab51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8896f8e838dd34ed5b7c1aa351f76f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af8896f8e838dd34ed5b7c1aa351f76f5">clear_user_flags_line</a> ()</td></tr>
<tr class="separator:af8896f8e838dd34ed5b7c1aa351f76f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7d8e059d6f8f903879eea858215fb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2b7d8e059d6f8f903879eea858215fb8">save_user_flags_line</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a2b7d8e059d6f8f903879eea858215fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02adea7b298cd5047ee5a5755f87ae36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a02adea7b298cd5047ee5a5755f87ae36">save_user_flags_line</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a02adea7b298cd5047ee5a5755f87ae36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25190c31d16cde2a01fa0f2318aa0b74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a25190c31d16cde2a01fa0f2318aa0b74">load_user_flags_line</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a25190c31d16cde2a01fa0f2318aa0b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87294511c2f203a57531aaaf2bd2ce39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a87294511c2f203a57531aaaf2bd2ce39">load_user_flags_line</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a87294511c2f203a57531aaaf2bd2ce39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd263157214206ceb637c402552f0eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1dd263157214206ceb637c402552f0eb">clear_user_flags_quad</a> ()</td></tr>
<tr class="separator:a1dd263157214206ceb637c402552f0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4a2db0492d38971366bfcd159cbbc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#acf4a2db0492d38971366bfcd159cbbc1">save_user_flags_quad</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:acf4a2db0492d38971366bfcd159cbbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431026974872f49e59f6a799ee0a19d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a431026974872f49e59f6a799ee0a19d6">save_user_flags_quad</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a431026974872f49e59f6a799ee0a19d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e868cde85c04bcc8cec82ba09f24e7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5e868cde85c04bcc8cec82ba09f24e7b">load_user_flags_quad</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a5e868cde85c04bcc8cec82ba09f24e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8651e0def48d61e3f8f0aa8051ae5985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8651e0def48d61e3f8f0aa8051ae5985">load_user_flags_quad</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a8651e0def48d61e3f8f0aa8051ae5985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbe198bb49c3135378bb680582afd46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7cbe198bb49c3135378bb680582afd46">clear_user_flags_hex</a> ()</td></tr>
<tr class="separator:a7cbe198bb49c3135378bb680582afd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5512376f914359303ce7d4666d550b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1d5512376f914359303ce7d4666d550b">save_user_flags_hex</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a1d5512376f914359303ce7d4666d550b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57c92493d66995cf29bef79f0e8e09b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae57c92493d66995cf29bef79f0e8e09b">save_user_flags_hex</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:ae57c92493d66995cf29bef79f0e8e09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e15f4d848adbe6c8bf1af374e467a31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6e15f4d848adbe6c8bf1af374e467a31">load_user_flags_hex</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a6e15f4d848adbe6c8bf1af374e467a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e827086d26927d08129c8489fdcd45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a77e827086d26927d08129c8489fdcd45">load_user_flags_hex</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a77e827086d26927d08129c8489fdcd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26562806fd764afdffb973dce92554e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">clear_user_data</a> ()</td></tr>
<tr class="separator:a26562806fd764afdffb973dce92554e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3794cd2d7f80bd81f69fcb828535412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae3794cd2d7f80bd81f69fcb828535412">save_user_indices</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const</td></tr>
<tr class="separator:ae3794cd2d7f80bd81f69fcb828535412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a2359968a027a8b14ae381c8886d30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12a2359968a027a8b14ae381c8886d30">load_user_indices</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:a12a2359968a027a8b14ae381c8886d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a41f6c10b5db7d540a9df15742ebf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a03a41f6c10b5db7d540a9df15742ebf0">save_user_pointers</a> (std::vector&lt; void *&gt; &amp;v) const</td></tr>
<tr class="separator:a03a41f6c10b5db7d540a9df15742ebf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8891e8277a047b9dd4fe86943d1321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2f8891e8277a047b9dd4fe86943d1321">load_user_pointers</a> (const std::vector&lt; void *&gt; &amp;v)</td></tr>
<tr class="separator:a2f8891e8277a047b9dd4fe86943d1321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451b2af8e62783f4780552088fd9ad88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a451b2af8e62783f4780552088fd9ad88">save_user_indices_line</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a451b2af8e62783f4780552088fd9ad88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2160dd04545294d138ca00deb4af42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7b2160dd04545294d138ca00deb4af42">load_user_indices_line</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:a7b2160dd04545294d138ca00deb4af42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d65cc99c33ea13361700a58ff9d6686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8d65cc99c33ea13361700a58ff9d6686">save_user_indices_quad</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a8d65cc99c33ea13361700a58ff9d6686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1020c09b32fbb78156b00b833271e21d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1020c09b32fbb78156b00b833271e21d">load_user_indices_quad</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:a1020c09b32fbb78156b00b833271e21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a18d1c25ca9c0b7cef07c6e92fdd28f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8a18d1c25ca9c0b7cef07c6e92fdd28f">save_user_indices_hex</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a8a18d1c25ca9c0b7cef07c6e92fdd28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad8869b9c8234d6c81c24c69dd97d39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abad8869b9c8234d6c81c24c69dd97d39">load_user_indices_hex</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:abad8869b9c8234d6c81c24c69dd97d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699d7c1b73eccc41bc53009003ab3d28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a699d7c1b73eccc41bc53009003ab3d28">save_user_pointers_line</a> (std::vector&lt; void *&gt; &amp;v) const</td></tr>
<tr class="separator:a699d7c1b73eccc41bc53009003ab3d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879d77427982a2d69d2dd9512d4ba6c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a879d77427982a2d69d2dd9512d4ba6c9">load_user_pointers_line</a> (const std::vector&lt; void *&gt; &amp;v)</td></tr>
<tr class="separator:a879d77427982a2d69d2dd9512d4ba6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d27b23e1d873b38817d08b7bb6884f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7d27b23e1d873b38817d08b7bb6884f8">save_user_pointers_quad</a> (std::vector&lt; void *&gt; &amp;v) const</td></tr>
<tr class="separator:a7d27b23e1d873b38817d08b7bb6884f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f771811ec221a4ca0c49f3a09164fec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4f771811ec221a4ca0c49f3a09164fec">load_user_pointers_quad</a> (const std::vector&lt; void *&gt; &amp;v)</td></tr>
<tr class="separator:a4f771811ec221a4ca0c49f3a09164fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42ad416119dff0589b8b67dd3de02e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac42ad416119dff0589b8b67dd3de02e8">save_user_pointers_hex</a> (std::vector&lt; void *&gt; &amp;v) const</td></tr>
<tr class="separator:ac42ad416119dff0589b8b67dd3de02e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dad0c49d2423e8c4410efcc773ad82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a03dad0c49d2423e8c4410efcc773ad82">load_user_pointers_hex</a> (const std::vector&lt; void *&gt; &amp;v)</td></tr>
<tr class="separator:a03dad0c49d2423e8c4410efcc773ad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell iterator functions</div></td></tr>
<tr class="memitem:a36fb6b15f119483143c433dd10df9b26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a36fb6b15f119483143c433dd10df9b26">begin</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:a36fb6b15f119483143c433dd10df9b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6c58805fe436a94b141c1585606c7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gaa80b689a21d72f777095aa12bbe01afa">active_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afe6c58805fe436a94b141c1585606c7f">begin_active</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:afe6c58805fe436a94b141c1585606c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c41c89a9cf1e020050985822196dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end</a> () const</td></tr>
<tr class="separator:a92c41c89a9cf1e020050985822196dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9597b118c84fce0addf7f4db3b067659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9597b118c84fce0addf7f4db3b067659">end</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a9597b118c84fce0addf7f4db3b067659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0967cc6653ea9a08e94fe9da4d11793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gaa80b689a21d72f777095aa12bbe01afa">active_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab0967cc6653ea9a08e94fe9da4d11793">end_active</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:ab0967cc6653ea9a08e94fe9da4d11793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51f6fbd9bcd9e41757039a7b4954d2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab51f6fbd9bcd9e41757039a7b4954d2a">last</a> () const</td></tr>
<tr class="separator:ab51f6fbd9bcd9e41757039a7b4954d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb00096abe5ef91413440e1e1b66c00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gaa80b689a21d72f777095aa12bbe01afa">active_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2eb00096abe5ef91413440e1e1b66c00">last_active</a> () const</td></tr>
<tr class="separator:a2eb00096abe5ef91413440e1e1b66c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367c0bd718b0ae9316f3b6f52d0ff4c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a367c0bd718b0ae9316f3b6f52d0ff4c6">create_cell_iterator</a> (const <a class="el" href="classCellId.html">CellId</a> &amp;cell_id) const</td></tr>
<tr class="separator:a367c0bd718b0ae9316f3b6f52d0ff4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell iterator functions returning ranges of iterators</div></td></tr>
<tr class="memitem:gae2dc0cda6c74461c0bbc22a41b5525c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gae2dc0cda6c74461c0bbc22a41b5525c4">cell_iterators</a> () const</td></tr>
<tr class="separator:gae2dc0cda6c74461c0bbc22a41b5525c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23e860c5192f6501650dda8bb3e2b497"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#gaa80b689a21d72f777095aa12bbe01afa">active_cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga23e860c5192f6501650dda8bb3e2b497">active_cell_iterators</a> () const</td></tr>
<tr class="separator:ga23e860c5192f6501650dda8bb3e2b497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae69f18aa4845bfe513fd51a39755b9d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gae69f18aa4845bfe513fd51a39755b9d6">cell_iterators_on_level</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:gae69f18aa4845bfe513fd51a39755b9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad45356a49aeb1130d244abb313afdc24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#gaa80b689a21d72f777095aa12bbe01afa">active_cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gad45356a49aeb1130d244abb313afdc24">active_cell_iterators_on_level</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:gad45356a49aeb1130d244abb313afdc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Face iterator functions</div></td></tr>
<tr class="memitem:abd8e77917e8512bd1e70bf180929f407"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abd8e77917e8512bd1e70bf180929f407">begin_face</a> () const</td></tr>
<tr class="separator:abd8e77917e8512bd1e70bf180929f407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e8d4115aad4a2a5c97a7f7c06d34d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af7e8d4115aad4a2a5c97a7f7c06d34d5">begin_active_face</a> () const</td></tr>
<tr class="separator:af7e8d4115aad4a2a5c97a7f7c06d34d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359dfdc82f2269b68b1d30c8a2286c6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a359dfdc82f2269b68b1d30c8a2286c6f">end_face</a> () const</td></tr>
<tr class="separator:a359dfdc82f2269b68b1d30c8a2286c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c4ae1d1e8d3e7d179fdd6bcbbae7d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga95c4ae1d1e8d3e7d179fdd6bcbbae7d6">active_face_iterators</a> () const</td></tr>
<tr class="separator:ga95c4ae1d1e8d3e7d179fdd6bcbbae7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vertex iterator functions</div></td></tr>
<tr class="memitem:aa76498325599ace7304627cb64e5fcd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa76498325599ace7304627cb64e5fcd2">begin_vertex</a> () const</td></tr>
<tr class="separator:aa76498325599ace7304627cb64e5fcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8705fe160c08af9a2372c605525ef0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0e8705fe160c08af9a2372c605525ef0">begin_active_vertex</a> () const</td></tr>
<tr class="separator:a0e8705fe160c08af9a2372c605525ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad93f466afba9b3f003d09a685a615f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaad93f466afba9b3f003d09a685a615f">end_vertex</a> () const</td></tr>
<tr class="separator:aaad93f466afba9b3f003d09a685a615f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information about the triangulation</div></td></tr>
<tr class="memitem:a46edbe1027405ca9545e3c2289eb3938"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines</a> () const</td></tr>
<tr class="separator:a46edbe1027405ca9545e3c2289eb3938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5ba9d51dfdd307da590e31c9262c28"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aee5ba9d51dfdd307da590e31c9262c28">n_lines</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:aee5ba9d51dfdd307da590e31c9262c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c9d6f7b2068f5afa429020086b6b8c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines</a> () const</td></tr>
<tr class="separator:a76c9d6f7b2068f5afa429020086b6b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d30203bdeaa3b9e2b416f24b7e9d6d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a21d30203bdeaa3b9e2b416f24b7e9d6d">n_active_lines</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a21d30203bdeaa3b9e2b416f24b7e9d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105d0305d8c801076bea2404087f29a7"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a105d0305d8c801076bea2404087f29a7">n_quads</a> () const</td></tr>
<tr class="separator:a105d0305d8c801076bea2404087f29a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0817fceed7429359f89928eec87d381"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af0817fceed7429359f89928eec87d381">n_quads</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:af0817fceed7429359f89928eec87d381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a0837c6dabdda21930bf3d49e9852d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab7a0837c6dabdda21930bf3d49e9852d">n_active_quads</a> () const</td></tr>
<tr class="separator:ab7a0837c6dabdda21930bf3d49e9852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf97ad6187b553b2980043dd1c8d75db"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abf97ad6187b553b2980043dd1c8d75db">n_active_quads</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:abf97ad6187b553b2980043dd1c8d75db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa75fe811e9d1707ce798f874aa2e117"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaa75fe811e9d1707ce798f874aa2e117">n_hexs</a> () const</td></tr>
<tr class="separator:aaa75fe811e9d1707ce798f874aa2e117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015bc7a2fecb2cba52050a8f2bfbafe1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a015bc7a2fecb2cba52050a8f2bfbafe1">n_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a015bc7a2fecb2cba52050a8f2bfbafe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee621a8e59e259c252ccc64f19e37301"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aee621a8e59e259c252ccc64f19e37301">n_active_hexs</a> () const</td></tr>
<tr class="separator:aee621a8e59e259c252ccc64f19e37301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8bbb4c8ffd9f8adb683b39a82a9b1e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ade8bbb4c8ffd9f8adb683b39a82a9b1e">n_active_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:ade8bbb4c8ffd9f8adb683b39a82a9b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea687f123f3f5a8b09d7485cf03be72"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a> () const</td></tr>
<tr class="separator:abea687f123f3f5a8b09d7485cf03be72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c5623c62d2e43aa63f1eb4904eeec8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a40c5623c62d2e43aa63f1eb4904eeec8">n_cells</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a40c5623c62d2e43aa63f1eb4904eeec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea5c9957dbb566a562bbe2c0f3971e9"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a> () const</td></tr>
<tr class="separator:a5ea5c9957dbb566a562bbe2c0f3971e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d106ed8c9a29d6bb7d2bfb636f8df62"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3d106ed8c9a29d6bb7d2bfb636f8df62">n_active_cells</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a3d106ed8c9a29d6bb7d2bfb636f8df62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e297d311818e3a79bcede5804f51065"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1e297d311818e3a79bcede5804f51065">n_faces</a> () const</td></tr>
<tr class="separator:a1e297d311818e3a79bcede5804f51065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae907d55b3b12c5c75e58174c1781ff"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5ae907d55b3b12c5c75e58174c1781ff">n_active_faces</a> () const</td></tr>
<tr class="separator:a5ae907d55b3b12c5c75e58174c1781ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777f035a17e91a4d822971516ca11db5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a> () const</td></tr>
<tr class="separator:a777f035a17e91a4d822971516ca11db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aadc2300ef9a6f2368fe7bc5926fe8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a> () const</td></tr>
<tr class="separator:ae1aadc2300ef9a6f2368fe7bc5926fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3059d54432e0d739534e5330bb7b3a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">get_vertices</a> () const</td></tr>
<tr class="separator:afb3059d54432e0d739534e5330bb7b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76937acd9dfc3ade1fb885c7ab1ae776"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">n_used_vertices</a> () const</td></tr>
<tr class="separator:a76937acd9dfc3ade1fb885c7ab1ae776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2295fdb4bfc8ab41f51cdbc34de449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aab2295fdb4bfc8ab41f51cdbc34de449">vertex_used</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:aab2295fdb4bfc8ab41f51cdbc34de449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07690a619d2817f4c8ef3bb74c43b80a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a07690a619d2817f4c8ef3bb74c43b80a">get_used_vertices</a> () const</td></tr>
<tr class="separator:a07690a619d2817f4c8ef3bb74c43b80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6313a19a8cc20e07249978218b5ca6a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa6313a19a8cc20e07249978218b5ca6a">max_adjacent_cells</a> () const</td></tr>
<tr class="separator:aa6313a19a8cc20e07249978218b5ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcac8668993d582f192d3c85b642dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#acbcac8668993d582f192d3c85b642dd3">get_triangulation</a> ()</td></tr>
<tr class="separator:acbcac8668993d582f192d3c85b642dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae427477f592d34c1bf3367e408f90c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aae427477f592d34c1bf3367e408f90c3">get_triangulation</a> () const</td></tr>
<tr class="separator:aae427477f592d34c1bf3367e408f90c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Keeping up with what happens to a triangulation</div></td></tr>
<tr class="memitem:ad136f601f63a6d1bd8e205edd93cbae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTriangulation_1_1Signals.html">Signals</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad136f601f63a6d1bd8e205edd93cbae3">signals</a></td></tr>
<tr class="separator:ad136f601f63a6d1bd8e205edd93cbae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aefd8ddbf96799abebb6c05dced569329"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aefd8ddbf96799abebb6c05dced569329">dimension</a> = dim</td></tr>
<tr class="separator:aefd8ddbf96799abebb6c05dced569329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3414a986e63a95d54e961b9b35d756fb"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3414a986e63a95d54e961b9b35d756fb">space_dimension</a> = spacedim</td></tr>
<tr class="separator:a3414a986e63a95d54e961b9b35d756fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ae36be1617767da4972eb996d9325902f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a> = typename std::pair&lt; <a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a>, <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a> &gt;</td></tr>
<tr class="separator:ae36be1617767da4972eb996d9325902f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a53caa007ddc9229fa461a0fd925482ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a53caa007ddc9229fa461a0fd925482ae">save_attached_data</a> (const unsigned <a class="el" href="classint.html">int</a> global_first_cell, const unsigned <a class="el" href="classint.html">int</a> global_num_cells, const std::string &amp;filename) const</td></tr>
<tr class="separator:a53caa007ddc9229fa461a0fd925482ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef794a63c63ff09e2c1c231998083f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#aeef794a63c63ff09e2c1c231998083f2">load_attached_data</a> (const unsigned <a class="el" href="classint.html">int</a> global_first_cell, const unsigned <a class="el" href="classint.html">int</a> global_num_cells, const unsigned <a class="el" href="classint.html">int</a> local_num_cells, const std::string &amp;filename, const unsigned <a class="el" href="classint.html">int</a> n_attached_deserialize_fixed, const unsigned <a class="el" href="classint.html">int</a> n_attached_deserialize_variable)</td></tr>
<tr class="separator:aeef794a63c63ff09e2c1c231998083f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5164a6fb30048f0ce5e81f67b60285f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#ab5164a6fb30048f0ce5e81f67b60285f">update_number_cache</a> ()</td></tr>
<tr class="separator:ab5164a6fb30048f0ce5e81f67b60285f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cf6c4bfa4a3d00d8c76792d1b9872a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a10cf6c4bfa4a3d00d8c76792d1b9872a">update_reference_cells</a> () override</td></tr>
<tr class="separator:a10cf6c4bfa4a3d00d8c76792d1b9872a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac35d252ab3fcbcdc675d6ac526b24c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#adac35d252ab3fcbcdc675d6ac526b24c">reset_global_cell_indices</a> ()</td></tr>
<tr class="separator:adac35d252ab3fcbcdc675d6ac526b24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a891e1057149129681a27bab8ffc10d19"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a891e1057149129681a27bab8ffc10d19">local_cell_relations</a></td></tr>
<tr class="separator:a891e1057149129681a27bab8ffc10d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5979f543c847e88743216cb5986f7107"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structparallel_1_1DistributedTriangulationBase_1_1CellAttachedData.html">CellAttachedData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a5979f543c847e88743216cb5986f7107">cell_attached_data</a></td></tr>
<tr class="separator:a5979f543c847e88743216cb5986f7107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd423107278fb82665a4a64f0a6da6d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallel_1_1DistributedTriangulationBase_1_1DataTransfer.html">DataTransfer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html#afd423107278fb82665a4a64f0a6da6d2">data_transfer</a></td></tr>
<tr class="separator:afd423107278fb82665a4a64f0a6da6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55959d63f6a4e18cae86f005df8605ec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a55959d63f6a4e18cae86f005df8605ec">mpi_communicator</a></td></tr>
<tr class="separator:a55959d63f6a4e18cae86f005df8605ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf7a809217fa1eb11b8c06c49b1b2cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#addf7a809217fa1eb11b8c06c49b1b2cb">my_subdomain</a></td></tr>
<tr class="separator:addf7a809217fa1eb11b8c06c49b1b2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25846dd7a465319119e91f44d77ae0b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#a25846dd7a465319119e91f44d77ae0b1">n_subdomains</a></td></tr>
<tr class="separator:a25846dd7a465319119e91f44d77ae0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad29d4b50a16239861deb2bb07bc6089"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structparallel_1_1TriangulationBase_1_1NumberCache.html">NumberCache</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html#aad29d4b50a16239861deb2bb07bc6089">number_cache</a></td></tr>
<tr class="separator:aad29d4b50a16239861deb2bb07bc6089"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa76bd5ba9c0072f52360805b5139cb61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">update_cell_relations</a> () override</td></tr>
<tr class="separator:aa76bd5ba9c0072f52360805b5139cb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232e33c7dbc34de152ec06348e08582c"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt; dim &gt;::tree *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a232e33c7dbc34de152ec06348e08582c">init_tree</a> (const <a class="el" href="classint.html">int</a> dealii_coarse_cell_index) const</td></tr>
<tr class="separator:a232e33c7dbc34de152ec06348e08582c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff58f98f967850202c11ac70103a83ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aff58f98f967850202c11ac70103a83ff">setup_coarse_cell_to_p4est_tree_permutation</a> ()</td></tr>
<tr class="separator:aff58f98f967850202c11ac70103a83ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34f8cf1b84fd708c2e2a01d68016c63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac34f8cf1b84fd708c2e2a01d68016c63">copy_new_triangulation_to_p4est</a> (std::integral_constant&lt; <a class="el" href="classint.html">int</a>, 2 &gt;)</td></tr>
<tr class="separator:ac34f8cf1b84fd708c2e2a01d68016c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c270d4283241cb67c13e3f47cdb15e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a7c270d4283241cb67c13e3f47cdb15e0">copy_new_triangulation_to_p4est</a> (std::integral_constant&lt; <a class="el" href="classint.html">int</a>, 3 &gt;)</td></tr>
<tr class="separator:a7c270d4283241cb67c13e3f47cdb15e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a0e407bc3a785f18ab3c64563caf03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a93a0e407bc3a785f18ab3c64563caf03">copy_local_forest_to_triangulation</a> ()</td></tr>
<tr class="separator:a93a0e407bc3a785f18ab3c64563caf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3311500b4531f0b801f9c3dbdeeafea3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a3311500b4531f0b801f9c3dbdeeafea3">get_cell_weights</a> () const</td></tr>
<tr class="separator:a3311500b4531f0b801f9c3dbdeeafea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8631e7836b12461acc21d119f8fabf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#afe8631e7836b12461acc21d119f8fabf">mark_locally_active_vertices_on_level</a> (const <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:afe8631e7836b12461acc21d119f8fabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6af7d3e309cef138d916aa6e0b3494"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">coarse_cell_id_to_coarse_cell_index</a> (const <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a> coarse_cell_id) const override</td></tr>
<tr class="separator:acc6af7d3e309cef138d916aa6e0b3494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee4a0a9c73acef08adae3cdfabf60f2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">coarse_cell_index_to_coarse_cell_id</a> (const unsigned <a class="el" href="classint.html">int</a> coarse_cell_index) const override</td></tr>
<tr class="separator:a5ee4a0a9c73acef08adae3cdfabf60f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab24d740e69f0f8817b6c0abd7c46bb45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13">Settings</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ab24d740e69f0f8817b6c0abd7c46bb45">settings</a></td></tr>
<tr class="separator:ab24d740e69f0f8817b6c0abd7c46bb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20283ec6daa76bcfafe7540fa5b4c3ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a20283ec6daa76bcfafe7540fa5b4c3ab">triangulation_has_content</a></td></tr>
<tr class="separator:a20283ec6daa76bcfafe7540fa5b4c3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d77880dff14f4e373bfc85b0372cbd"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt; dim &gt;::connectivity *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ae5d77880dff14f4e373bfc85b0372cbd">connectivity</a></td></tr>
<tr class="separator:ae5d77880dff14f4e373bfc85b0372cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa33ee8b97c37ea611c10fb105b43a18"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt; dim &gt;::forest *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#afa33ee8b97c37ea611c10fb105b43a18">parallel_forest</a></td></tr>
<tr class="separator:afa33ee8b97c37ea611c10fb105b43a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ad171a487b4a1ace0c747c7ba9a650"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt; dim &gt;::ghost *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a44ad171a487b4a1ace0c747c7ba9a650">parallel_ghost</a></td></tr>
<tr class="separator:a44ad171a487b4a1ace0c747c7ba9a650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d48b3a3c96e351aad2b550bd1baa4f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ae7d48b3a3c96e351aad2b550bd1baa4f">coarse_cell_to_p4est_tree_permutation</a></td></tr>
<tr class="separator:ae7d48b3a3c96e351aad2b550bd1baa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb403db4f9fb3d529ce133378ef1b48"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cb403db4f9fb3d529ce133378ef1b48">p4est_tree_to_coarse_cell_permutation</a></td></tr>
<tr class="separator:a5cb403db4f9fb3d529ce133378ef1b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a50c4100869e8b9e63a082320a59e7d92"><td class="memTemplParams" colspan="2">template&lt;int , int , class &gt; </td></tr>
<tr class="memitem:a50c4100869e8b9e63a082320a59e7d92"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a50c4100869e8b9e63a082320a59e7d92">::FETools::internal::ExtrapolateImplementation</a></td></tr>
<tr class="separator:a50c4100869e8b9e63a082320a59e7d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e9b1ae1a0d06897814df4e5481ac4e"><td class="memTemplParams" colspan="2">template&lt;int , int &gt; </td></tr>
<tr class="memitem:a30e9b1ae1a0d06897814df4e5481ac4e"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a30e9b1ae1a0d06897814df4e5481ac4e">TemporarilyMatchRefineFlags</a></td></tr>
<tr class="separator:a30e9b1ae1a0d06897814df4e5481ac4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Exceptions</h2></td></tr>
<tr class="memitem:gafc78a1322a1040b8601290e52f2cc532"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gafc78a1322a1040b8601290e52f2cc532">DeclException2</a> (ExcInvalidLevel, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are requesting information from refinement level &quot;&lt;&lt; arg1&lt;&lt; &quot; of a triangulation, but this triangulation only has &quot;&lt;&lt; arg2&lt;&lt; &quot; refinement levels. The given level &quot;&lt;&lt; arg1&lt;&lt; &quot; must be *less* than &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:gafc78a1322a1040b8601290e52f2cc532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c118c9eb467d05ebe068651b74002ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8c118c9eb467d05ebe068651b74002ab">DeclException2</a> (ExcTriangulationNotEmpty, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are trying to perform an operation on a triangulation &quot;&lt;&lt; &quot;that is only allowed if the triangulation is currently empty. &quot;&lt;&lt; &quot;However, it currently stores &quot;&lt;&lt; arg1&lt;&lt; &quot; vertices and has &quot;&lt;&lt; &quot;cells on &quot;&lt;&lt; arg2&lt;&lt; &quot; levels.&quot;)</td></tr>
<tr class="separator:ga8c118c9eb467d05ebe068651b74002ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966384346b2c7308b814ab09065d0470"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga966384346b2c7308b814ab09065d0470">DeclException0</a> (ExcGridReadError)</td></tr>
<tr class="separator:ga966384346b2c7308b814ab09065d0470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa031bdac9392e3cdaa7ecf87171335"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaafa031bdac9392e3cdaa7ecf87171335">DeclException0</a> (ExcFacesHaveNoLevel)</td></tr>
<tr class="separator:gaafa031bdac9392e3cdaa7ecf87171335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7cec3f85f90fe0e3d9e9ec626a0dbfc3">DeclException0</a> (ExcNonOrientableTriangulation)</td></tr>
<tr class="separator:ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391a9a406c14d6830d2ccbf0c59b429b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga391a9a406c14d6830d2ccbf0c59b429b">DeclException1</a> (ExcEmptyLevel, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You tried to do something on level &quot;&lt;&lt; arg1&lt;&lt; &quot;, but this level is empty.&quot;)</td></tr>
<tr class="separator:ga391a9a406c14d6830d2ccbf0c59b429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9880263a1f12cd1dfecf45ac55c75c8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9880263a1f12cd1dfecf45ac55c75c8b">DeclException1</a> (ExcBoundaryIdNotFound, <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>,&lt;&lt; &quot;The given boundary_id &quot;&lt;&lt; arg1&lt;&lt; &quot; is not defined in this Triangulation!&quot;)</td></tr>
<tr class="separator:ga9880263a1f12cd1dfecf45ac55c75c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95a456ec8242cdf9109491510534f13d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga95a456ec8242cdf9109491510534f13d">DeclExceptionMsg</a> (ExcInconsistentCoarseningFlags, &quot;A cell is flagged for coarsening, but either not all of its siblings &quot; &quot;are active or flagged for coarsening as well. Please clean up all &quot; &quot;coarsen flags on your triangulation via &quot; &quot;<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">Triangulation::prepare_coarsening_and_refinement</a>() beforehand!&quot;)</td></tr>
<tr class="separator:ga95a456ec8242cdf9109491510534f13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9474a14d0e8429412c82450013bde67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac9474a14d0e8429412c82450013bde67">smooth_grid</a></td></tr>
<tr class="separator:gac9474a14d0e8429412c82450013bde67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f47aa64420502db8ebeffd531572779"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classReferenceCell.html">ReferenceCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f47aa64420502db8ebeffd531572779">reference_cells</a></td></tr>
<tr class="separator:ga5f47aa64420502db8ebeffd531572779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609fee9e79ae50f4c348a39838c7eb0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga609fee9e79ae50f4c348a39838c7eb0c">update_periodic_face_map</a> ()</td></tr>
<tr class="separator:ga609fee9e79ae50f4c348a39838c7eb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9e3e5c077024f40355432c771ccf541"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9e3e5c077024f40355432c771ccf541">write_bool_vector</a> (const unsigned <a class="el" href="classint.html">int</a> magic_number1, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned <a class="el" href="classint.html">int</a> magic_number2, std::ostream &amp;out)</td></tr>
<tr class="separator:gaf9e3e5c077024f40355432c771ccf541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20c92032e652bdafdfd7624a55aa2866"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga20c92032e652bdafdfd7624a55aa2866">read_bool_vector</a> (const unsigned <a class="el" href="classint.html">int</a> magic_number1, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned <a class="el" href="classint.html">int</a> magic_number2, std::istream &amp;in)</td></tr>
<tr class="separator:ga20c92032e652bdafdfd7624a55aa2866"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class parallel::distributed::Triangulation&lt; dim, spacedim &gt;</h3>

<p>This class acts like the <a class="el" href="classTriangulation.html">Triangulation</a> class, but it distributes the mesh across a number of different processors when using MPI. The class's interface does not add a lot to the <a class="el" href="classTriangulation.html">Triangulation</a> class but there are a number of difficult algorithms under the hood that ensure we always have a load-balanced, fully distributed mesh. Use of this class is explained in step-40, step-32, the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> documentation module, as well as the <a class="el" href="DEALGlossary.html#distributed_paper">distributed_paper</a>. See there for more information. This class satisfies the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This class does not support anisotropic refinement, because it relies on the p4est library that does not support this. Attempts to refine cells anisotropically will result in errors.</dd>
<dd>
There is currently no support for distributing 1d triangulations.</dd></dl>
<h3>Interaction with boundary description </h3>
<p>Refining and coarsening a distributed triangulation is a complicated process because cells may have to be migrated from one processor to another. On a single processor, materializing that part of the global mesh that we want to store here from what we have stored before therefore may involve several cycles of refining and coarsening the locally stored set of cells until we have finally gotten from the previous to the next triangulation. This process is described in more detail in the <a class="el" href="DEALGlossary.html#distributed_paper">distributed_paper</a>. Unfortunately, in this process, some information can get lost relating to flags that are set by user code and that are inherited from mother to child cell but that are not moved along with a cell if that cell is migrated from one processor to another.</p>
<p>An example are boundary indicators. Assume, for example, that you start with a single cell that is refined once globally, yielding four children. If you have four processors, each one owns one cell. Assume now that processor 1 sets the boundary indicators of the external boundaries of the cell it owns to 42. Since processor 0 does not own this cell, it doesn't set the boundary indicators of its ghost cell copy of this cell. Now, assume we do several mesh refinement cycles and end up with a configuration where this processor suddenly finds itself as the owner of this cell. If boundary indicator 42 means that we need to integrate Neumann boundary conditions along this boundary, then processor 0 will forget to do so because it has never set the boundary indicator along this cell's boundary to 42.</p>
<p>The way to avoid this dilemma is to make sure that things like setting boundary indicators or material ids is done immediately every time a parallel triangulation is refined. This is not necessary for sequential triangulations because, there, these flags are inherited from mother to child cell and remain with a cell even if it is refined and the children are later coarsened again, but this does not hold for distributed triangulations. It is made even more difficult by the fact that in the process of refining a parallel distributed triangulation, the triangulation may call <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement</a> multiple times and this function needs to know about boundaries. In other words, it is <em>not</em> enough to just set boundary indicators on newly created faces only <em>after</em> calling <code>distributed::parallel::TriangulationBase::execute_coarsening_and_refinement</code>: it actually has to happen while that function is still running.</p>
<p>The way to do this is by writing a function that sets boundary indicators and that will be called by the <a class="el" href="classTriangulation.html">Triangulation</a> class. The triangulation does not provide a pointer to itself to the function being called, nor any other information, so the trick is to get this information into the function. C++ provides a nice mechanism for this that is best explained using an example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> set_boundary_ids (</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  ... <span class="keyword">set</span> boundary indicators on the triangulation <span class="keywordtype">object</span> ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">MyClass&lt;dim&gt;::create_coarse_mesh (</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> &amp;coarse_grid)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  ... create the coarse mesh ...</div><div class="line"></div><div class="line">  coarse_grid.<a class="code" href="classTriangulation.html#ad136f601f63a6d1bd8e205edd93cbae3">signals</a>.<a class="code" href="structTriangulation_1_1Signals.html#aa65bc4587a433d690b9f29732f7a9466">post_refinement</a>.connect(</div><div class="line">    [&amp;coarse_grid](){</div><div class="line">      set_boundary_ids&lt;dim&gt;(coarse_grid);</div><div class="line">    });</div><div class="line">}</div></div><!-- fragment --><p>The object passed as argument to <code>connect</code> is an object that can be called like a function with no arguments. It does so by wrapping a function that does, in fact, take an argument but this one argument is stored as a reference to the coarse grid triangulation when the lambda function is created. After each refinement step, the triangulation will then call the object so created which will in turn call <code>set_boundary_ids&lt;dim&gt;</code> with the reference to the coarse grid as argument.</p>
<p>This approach can be generalized. In the example above, we have used a global function that will be called. However, sometimes it is necessary that this function is in fact a member function of the class that generates the mesh, for example because it needs to access run-time parameters. This can be achieved as follows: assuming the <code>set_boundary_ids()</code> function has been declared as a (non- static, but possibly private) member function of the <code>MyClass</code> class, then the following will work: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">MyClass&lt;dim&gt;::set_boundary_ids (</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> &amp;triangulation)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  ... <span class="keyword">set</span> boundary indicators on the triangulation <span class="keywordtype">object</span> ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">MyClass&lt;dim&gt;::create_coarse_mesh (</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> &amp;coarse_grid)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  ... create the coarse mesh ...</div><div class="line"></div><div class="line">  coarse_grid.<a class="code" href="classTriangulation.html#ad136f601f63a6d1bd8e205edd93cbae3">signals</a>.<a class="code" href="structTriangulation_1_1Signals.html#aa65bc4587a433d690b9f29732f7a9466">post_refinement</a>.connect(</div><div class="line">    [<span class="keyword">this</span>, &amp;coarse_grid]()</div><div class="line">    {</div><div class="line">      this-&gt;set_boundary_ids(coarse_grid);</div><div class="line">    });</div><div class="line">}</div></div><!-- fragment --><p> The lambda function above again is an object that can be called like a global function with no arguments, and this object in turn calls the current object's member function <code>set_boundary_ids</code> with a reference to the triangulation to work on. Note that because the <code>create_coarse_mesh</code> function is declared as <code>const</code>, it is necessary that the <code>set_boundary_ids</code> function is also declared <code>const</code>.</p>
<p><b>Note:</b>For reasons that have to do with the way the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> is implemented, functions that have been attached to the post-refinement signal of the triangulation are called more than once, sometimes several times, every time the triangulation is actually refined. </p>

<p class="definition">Definition at line <a class="el" href="distributed_2tria_8h_source.html#l00249">249</a> of file <a class="el" href="distributed_2tria_8h_source.html">tria.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0facea3dfcde4d6f57b727a3963e89f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0facea3dfcde4d6f57b727a3963e89f4">&#9670;&nbsp;</a></span>CellStatus</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a> =  typename ::<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="distributed_2tria_8h_source.html#l00295">295</a> of file <a class="el" href="distributed_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ae36be1617767da4972eb996d9325902f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36be1617767da4972eb996d9325902f">&#9670;&nbsp;</a></span>cell_relation_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a> =  typename std::pair&lt;<a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a>, <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Auxiliary data structure for assigning a CellStatus to a deal.II cell iterator. For an extensive description of the former, see the documentation for the member function <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00701">701</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="ad12cedb5139eeea73fb2a3eec16636f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12cedb5139eeea73fb2a3eec16636f8">&#9670;&nbsp;</a></span>level_cell_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ad12cedb5139eeea73fb2a3eec16636f8">level_cell_iterator</a> =  <a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as above to allow the usage of the "MeshType concept" also on the refinement levels. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01361">1361</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a0f5f69b2f422595604c9317ea7f15c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5f69b2f422595604c9317ea7f15c13">&#9670;&nbsp;</a></span>Settings</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13">parallel::distributed::Triangulation::Settings</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configuration flags for distributed Triangulations to be set in the constructor. Settings can be combined using bitwise OR. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0f5f69b2f422595604c9317ea7f15c13a80dd6bc33282bb4ee59e282098beeebe"></a>default_setting&#160;</td><td class="fielddoc"><p>Default settings, other options are disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0f5f69b2f422595604c9317ea7f15c13a92fad5ef4e0f7f69d008cb54123b1a9d"></a>mesh_reconstruction_after_repartitioning&#160;</td><td class="fielddoc"><p>If set, the deal.II mesh will be reconstructed from the coarse mesh every time a repartitioning in p4est happens. This can be a bit more expensive, but guarantees the same memory layout and therefore cell ordering in the deal.II mesh. As assembly is done in the deal.II cell ordering, this flag is required to get reproducible behavior after snapshot/resume. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0f5f69b2f422595604c9317ea7f15c13a1cd821e9678703d6d5d907fa0c7a0fe0"></a>construct_multigrid_hierarchy&#160;</td><td class="fielddoc"><p>This flags needs to be set to use the geometric multigrid functionality. This option requires additional computation and communication. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0f5f69b2f422595604c9317ea7f15c13a1bcfd814692ed67b8c57e84b042158ad"></a>no_automatic_repartitioning&#160;</td><td class="fielddoc"><p>Setting this flag will disable automatic repartitioning of the cells after a refinement cycle. It can be executed manually by calling <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a12cc5327a81ae46b8a6d9a3eb4bd9893">repartition()</a>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="distributed_2tria_8h_source.html#l00301">301</a> of file <a class="el" href="distributed_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a0633dd17e535a59162b79f338c6ff5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0633dd17e535a59162b79f338c6ff5ae">&#9670;&nbsp;</a></span>MeshSmoothing</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare some symbolic names for mesh smoothing algorithms. The meaning of these flags is documented in the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a> class. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea9828da1d84133b33b112afd4a0ac15ec"></a>none&#160;</td><td class="fielddoc"><p>No mesh smoothing at all, except that meshes have to remain one- irregular. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc"></a>limit_level_difference_at_vertices&#160;</td><td class="fielddoc"><p>It can be shown, that degradation of approximation occurs if the triangulation contains vertices which are member of cells with levels differing by more than one. One such example is the following:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt="limit_level_difference_at_vertices.png"/>
</div>
<p> It would seem that in two space dimensions, the maximum jump in levels between cells sharing a common vertex is two (as in the example above). However, this is not true if more than four cells meet at a vertex. It is not uncommon that a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse (initial) mesh</a> contains vertices at which six or even eight cells meet, when small features of the domain have to be resolved even on the coarsest mesh. In that case, the maximum difference in levels is three or four, respectively. The problem gets even worse in three space dimensions.</p>
<p>Looking at an interpolation of the second derivative of the finite element solution (assuming bilinear finite elements), one sees that the numerical solution is almost totally wrong, compared with the true second derivative. Indeed, on regular meshes, there exist sharp estimations that the H<sup>2</sup>-error is only of order one, so we should not be surprised; however, the numerical solution may show a value for the second derivative which may be a factor of ten away from the true value. These problems are located on the small cell adjacent to the center vertex, where cells of non-subsequent levels meet, as well as on the upper and right neighbor of this cell (but with a less degree of deviation from the true value).</p>
<p>If the smoothing indicator given to the constructor contains the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">limit_level_difference_at_vertices</a>, situations as the above one are eliminated by also marking the upper right cell for refinement.</p>
<p>In case of anisotropic refinement, the level of a cell is not linked to the refinement of a cell as directly as in case of isotropic refinement. Furthermore, a cell can be strongly refined in one direction and not or at least much less refined in another. Therefore, it is very difficult to decide, which cases should be excluded from the refinement process. As a consequence, when using anisotropic refinement, the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">limit_level_difference_at_vertices</a> flag must not be set. On the other hand, the implementation of multigrid methods in deal.II requires that this bit be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f"></a>eliminate_unrefined_islands&#160;</td><td class="fielddoc"><p>Single cells which are not refined and are surrounded by cells which are refined usually also lead to a sharp decline in approximation properties locally. The reason is that the nodes on the faces between unrefined and refined cells are not real degrees of freedom but carry constraints. The patch without additional degrees of freedom is thus significantly larger then the unrefined cell itself. If in the parameter passed to the constructor the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a> is set, all cells which are not flagged for refinement but which are surrounded by more refined cells than unrefined cells are flagged for refinement. Cells which are not yet refined but flagged for that are accounted for the number of refined neighbors. Cells on the boundary are not accounted for at all. An unrefined island is, by this definition also a cell which (in 2D) is surrounded by three refined cells and one unrefined one, or one surrounded by two refined cells, one unrefined one and is at the boundary on one side. It is thus not a true island, as the name of the flag may indicate. However, no better name came to mind to the author by now. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea37c283b96070dc09dde81f51d3ce1812"></a>patch_level_1&#160;</td><td class="fielddoc"><p>A triangulation of patch level 1 consists of patches, i.e. of cells that are refined once. This flag ensures that a mesh of patch level 1 is still of patch level 1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh is of patch level 1 before calling <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a> the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that if at least one of the children of a cell is or will be refined than all children need to be refined. If the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea37c283b96070dc09dde81f51d3ce1812">patch_level_1</a> flag is set, than the flags <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a>, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58">eliminate_refined_boundary_islands</a> will be ignored as they will be fulfilled automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeae94a75f4383724ef8f58639aef2eb6c0"></a>coarsest_level_1&#160;</td><td class="fielddoc"><p>Each <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse grid</a> cell is refined at least once, i.e., the triangulation might have active cells on level 1 but not on level 0. This flag ensures that a mesh which has coarsest_level_1 has still coarsest_level_1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh has coarsest_level_1 before calling execute_coarsening_and_refinement the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that active cells on level 1 may not be coarsened.</p>
<p>The main use of this flag is to ensure that each cell has at least one neighbor in each coordinate direction (i.e. each cell has at least a left or right, and at least an upper or lower neighbor in 2d). This is a necessary precondition for some algorithms that compute finite differences between cells. The <a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a> class is one of these algorithms that require that a triangulation is coarsest_level_1 unless all cells already have at least one neighbor in each coordinate direction on the coarsest level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaa44d17458e16327fb4b674745b883910"></a>allow_anisotropic_smoothing&#160;</td><td class="fielddoc"><p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined.</p>
<p>However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements.</p>
<p>The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to step-30. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e"></a>eliminate_refined_inner_islands&#160;</td><td class="fielddoc"><p>This algorithm seeks for isolated cells which are refined or flagged for refinement. This definition is unlike that for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a>, which would mean that an island is defined as a cell which is refined but more of its neighbors are not refined than are refined. For example, in 2D, a cell's refinement would be reverted if at most one of its neighbors is also refined (or refined but flagged for coarsening).</p>
<p>The reason for the change in definition of an island is, that this option would be a bit dangerous, since if you consider a chain of refined cells (e.g. along a kink in the solution), the cells at the two ends would be coarsened, after which the next outermost cells would need to be coarsened. Therefore, only one loop of flagging cells like this could be done to avoid eating up the whole chain of refined cells (`chain reaction'...).</p>
<p>This algorithm also takes into account cells which are not actually refined but are flagged for refinement. If necessary, it takes away the refinement flag.</p>
<p>Actually there are two versions of this flag, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58">eliminate_refined_boundary_islands</a>. The first eliminates islands defined by the definition above which are in the interior of the domain, while the second eliminates only those islands if the cell is at the boundary. The reason for this split of flags is that one often wants to eliminate such islands in the interior while those at the boundary may well be wanted, for example if one refines the mesh according to a criterion associated with a boundary integral or if one has rough boundary data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58"></a>eliminate_refined_boundary_islands&#160;</td><td class="fielddoc"><p>The result of this flag is very similar to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a>. See the documentation there. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea75171630dec90d241c811d2732410303"></a>do_not_produce_unrefined_islands&#160;</td><td class="fielddoc"><p>This flag prevents the occurrence of unrefined islands. In more detail: It prohibits the coarsening of a cell if 'most of the neighbors' will be refined after the step. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea3fb6b9153821aefc45661f67f22e232a"></a>smoothing_on_refinement&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon refinement by flagging some more cells for refinement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea8d8dbaaa62136a7e51c7bf5c02d6e1e7"></a>smoothing_on_coarsening&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon coarsening by flagging some more cells for coarsening. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaf64b535fd0fad99b6032412d2cccac36"></a>maximum_smoothing&#160;</td><td class="fielddoc"><p>This flag includes all the above ones (therefore combines all smoothing algorithms implemented), with the exception of anisotropic smoothing. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01136">1136</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4da51da139d7789e6fa6d104252b5416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da51da139d7789e6fa6d104252b5416">&#9670;&nbsp;</a></span>Triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ::<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td>
          <td class="paramname"><em>smooth_grid</em> = <code>(::<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;::<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9828da1d84133b33b112afd4a0ac15ec">none</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13">Settings</a>&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13a80dd6bc33282bb4ee59e282098beeebe">default_setting</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_communicator</td><td>The MPI communicator to be used for the triangulation.</td></tr>
    <tr><td class="paramname">smooth_grid</td><td>Degree and kind of mesh smoothing to be applied to the mesh. See the <a class="el" href="classTriangulation.html">Triangulation</a> class for a description of the kinds of smoothing operations that can be applied.</td></tr>
    <tr><td class="paramname">settings</td><td>See the description of the Settings enumerator. Providing <code>construct_multigrid_hierarchy</code> enforces <code><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">Triangulation::limit_level_difference_at_vertices</a></code> for smooth_grid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This class does not currently support the <code>check_for_distorted_cells</code> argument provided by the base class.</dd>
<dd>
While it is possible to pass all of the mesh smoothing flags listed in the base class to objects of this type, it is not always possible to honor all of these smoothing options if they would require knowledge of refinement/coarsening flags on cells not locally owned by this processor. As a consequence, for some of these flags, the ultimate number of cells of the parallel triangulation may depend on the number of processors into which it is partitioned. On the other hand, if no smoothing flags are passed, if you always mark the same cells of the mesh, you will always get the exact same refined mesh independent of the number of processors into which the triangulation is partitioned. </dd></dl>

</div>
</div>
<a id="a98dce975e1b3377222ad0a4a14492cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98dce975e1b3377222ad0a4a14492cc7">&#9670;&nbsp;</a></span>~Triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::~<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#ad9931013dff6e9094c5b525359b6e1c5">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af19cebc16207fc60f8b0ab1eb1c4540f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19cebc16207fc60f8b0ab1eb1c4540f">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset this triangulation into a virgin state by deleting all data.</p>
<p>Note that this operation is only allowed if no subscriptions to this object exist any more, such as <a class="el" href="classDoFHandler.html">DoFHandler</a> objects using it. </p>

<p>Reimplemented from <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#af8b346b087dd89464415ecb7d2775a61">parallel::DistributedTriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a66be05fbab855a4960fbcfd20c8488f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66be05fbab855a4960fbcfd20c8488f9">&#9670;&nbsp;</a></span>is_multilevel_hierarchy_constructed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::is_multilevel_hierarchy_constructed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return if multilevel hierarchy is supported and has been constructed. </p>

<p>Implements <a class="el" href="classparallel_1_1TriangulationBase.html#a8f9bfda5524458e6fb8ebe54e9c491fc">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a5c96607beadb34c293b8f1037eb62057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c96607beadb34c293b8f1037eb62057">&#9670;&nbsp;</a></span>execute_transfer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::execute_transfer </td>
          <td>(</td>
          <td class="paramtype">const typename ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt; dim &gt;::forest *&#160;</td>
          <td class="paramname"><em>parallel_forest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt; dim &gt;::gloidx *&#160;</td>
          <td class="paramname"><em>previous_global_first_quadrant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfer data across forests.</p>
<p>Besides the actual <code>parallel_forest</code>, which has been already refined and repartitioned, this function also needs information about its previous state, i.e. the locally owned intervals in p4est's sc_array of each processor. This information needs to be memcopyied out of the old p4est object and has to be provided via the parameter <code>previous_global_first_quadrant</code>.</p>
<p>Data has to be previously packed with <a class="el" href="classparallel_1_1DistributedTriangulationBase_1_1DataTransfer.html#a0620c6cfe0a96c0ae34ae416bf727bdc">DistributedTriangulationBase::DataTransfer::pack_data()</a>. </p>

</div>
</div>
<a id="a8d18fdfd9cb49b5fb87a1a78e10c86ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d18fdfd9cb49b5fb87a1a78e10c86ca">&#9670;&nbsp;</a></span>copy_triangulation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::copy_triangulation </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other_tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the same function as in the base class.</p>
<dl class="section note"><dt>Note</dt><dd>This function can be used to copy a serial <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a> to a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> but only if the serial <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a> has never been refined. </dd></dl>

</div>
</div>
<a id="a85f8516b5fe9b8fc6e8784c987f9263f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f8516b5fe9b8fc6e8784c987f9263f">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a triangulation as documented in the base class.</p>
<p>This function also sets up the various data structures necessary to distribute a mesh across a number of processors. This will be necessary once the mesh is being refined, though we will always keep the entire coarse mesh that is generated by this function on all processors. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a80369486f903cb4477e46b3e63ce18df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80369486f903cb4477e46b3e63ce18df">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>construction_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Create a triangulation as documented in the base class.</p>
<p>This function also sets up the various data structures necessary to distribute a mesh across a number of processors. This will be necessary once the mesh is being refined, though we will always keep the entire coarse mesh that is generated by this function on all processors.</p>
<dl class="section note"><dt>Note</dt><dd>Not implemented yet. </dd></dl>

<p>Reimplemented from <a class="el" href="classTriangulation.html#aa80c37d5d647831736e40e4ffb0e0ee2">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a9dba428552f512e0859a9b6a06ad3b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dba428552f512e0859a9b6a06ad3b7e">&#9670;&nbsp;</a></span>execute_coarsening_and_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::execute_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen and refine the mesh according to refinement and coarsening flags set.</p>
<p>Since the current processor only has control over those cells it owns (i.e. the ones for which <code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a> == this-&gt;<a class="el" href="classparallel_1_1TriangulationBase.html#a41b129156d89f37482d2095de5751d9c">locally_owned_subdomain()</a></code>), refinement and coarsening flags are only respected for those locally owned cells. Flags may be set on other cells as well (and may often, in fact, if you call <a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement()</a>) but will be largely ignored: the decision to refine the global mesh will only be affected by flags set on locally owned cells.</p>
<dl class="section note"><dt>Note</dt><dd>This function by default partitions the mesh in such a way that the number of cells on all processors is roughly equal. If you want to set weights for partitioning, e.g. because some cells are more expensive to compute than others, you can use the signal cell_weight as documented in the <a class="el" href="classTriangulation.html">Triangulation</a> class. This function will check whether a function is connected to the signal and if so use it. If you prefer to repartition the mesh yourself at user-defined intervals only, you can create your triangulation object by passing the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13a1bcfd814692ed67b8c57e84b042158ad">parallel::distributed::Triangulation::no_automatic_repartitioning</a> flag to the constructor, which ensures that calling the current function only refines and coarsens the triangulation, but doesn't partition it. You can then call the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a12cc5327a81ae46b8a6d9a3eb4bd9893">repartition()</a> function manually. The usage of the cell_weights signal is identical in both cases, if a function is connected to the signal it will be used to balance the calculated weights, otherwise the number of cells is balanced. </dd></dl>

<p>Reimplemented from <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a0ad472f89b0dde244ecc13989806e78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad472f89b0dde244ecc13989806e78d">&#9670;&nbsp;</a></span>prepare_coarsening_and_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::prepare_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Override the implementation of prepare_coarsening_and_refinement from the base class. This is necessary if periodic boundaries are enabled and the level difference over vertices over the periodic boundary must not be more than 2:1. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a12cc5327a81ae46b8a6d9a3eb4bd9893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12cc5327a81ae46b8a6d9a3eb4bd9893">&#9670;&nbsp;</a></span>repartition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::repartition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Manually repartition the active cells between processors. Normally this repartitioning will happen automatically when calling <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">execute_coarsening_and_refinement()</a> (or <a class="el" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global()</a>) unless the <code>no_automatic_repartitioning</code> is set in the constructor. Setting the flag and then calling <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a12cc5327a81ae46b8a6d9a3eb4bd9893">repartition()</a> gives the same result.</p>
<p>If you want to transfer data (using <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">SolutionTransfer</a> or manually with <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a> and <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>), you need to set it up twice: once when calling <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">execute_coarsening_and_refinement()</a>, which will handle coarsening and refinement but obviously won't ship any data between processors, and a second time when calling <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a12cc5327a81ae46b8a6d9a3eb4bd9893">repartition()</a>. Here, no coarsening and refinement will be done but information will be packed and shipped to different processors. In other words, you probably want to treat a call to <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a12cc5327a81ae46b8a6d9a3eb4bd9893">repartition()</a> in the same way as <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">execute_coarsening_and_refinement()</a> with respect to dealing with data movement (<a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">SolutionTransfer</a>, etc.).</p>
<dl class="section note"><dt>Note</dt><dd>If no function is connected to the cell_weight signal described in the <a class="el" href="classTriangulation.html">Triangulation</a> class, this function will balance the number of cells on each processor. If one or more functions are connected, it will calculate the sum of the weights and balance the weights across processors. The only requirement on the weights is that every cell's weight is positive and that the sum over all weights on all processors can be formed using a 64-bit integer. Beyond that, it is your choice how you want to interpret the weights. A common approach is to consider the weights proportional to the cost of doing computations on a cell, e.g., by summing the time for assembly and solving. In practice, determining this cost is of course not trivial since we don't solve on isolated cells, but on the entire mesh. In such cases, one could, for example, choose the weight equal to the number of unknowns per cell (in the context of hp-finite element methods), or using a heuristic that estimates the cost on each cell depending on whether, for example, one has to run some expensive algorithm on some cells but not others (such as forming boundary integrals during the assembly only on cells that are actually at the boundary, or computing expensive nonlinear terms only on some cells but not others, e.g., in the elasto-plastic problem in step-42). </dd></dl>

</div>
</div>
<a id="a569306c9c8e694e3006f8fafa035f0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569306c9c8e694e3006f8fafa035f0ce">&#9670;&nbsp;</a></span>has_hanging_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::has_hanging_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the triangulation has hanging nodes.</p>
<p>In the context of parallel distributed triangulations, every processor stores only that part of the triangulation it locally owns. However, it also stores the entire coarse mesh, and to guarantee the 2:1 relationship between cells, this may mean that there are hanging nodes between cells that are not locally owned or ghost cells (i.e., between ghost cells and artificial cells, or between artificial and artificial cells; see <a class="el" href="DEALGlossary.html#GlossArtificialCell">the glossary</a>). One is not typically interested in this case, so the function returns whether there are hanging nodes between any two cells of the "global" mesh, i.e., the union of locally owned cells on all processors. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a935cc3b953d71fe4081fa8f88820f034">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="afa0357cc88e13176507540d7f2524123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0357cc88e13176507540d7f2524123">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the local memory consumption in bytes. </p>

<p>Reimplemented from <a class="el" href="classparallel_1_1TriangulationBase.html#ad8baa2e614b9868460a7a0f3cbc6d3de">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a7661a73ff6a5c955c40dbb31bba4128f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7661a73ff6a5c955c40dbb31bba4128f">&#9670;&nbsp;</a></span>memory_consumption_p4est()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::memory_consumption_p4est </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the local memory consumption contained in the p4est data structures alone. This is already contained in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#afa0357cc88e13176507540d7f2524123">memory_consumption()</a> but made available separately for debugging purposes. </p>

</div>
</div>
<a id="a96bb82f9331c5cb192cfda724be59f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bb82f9331c5cb192cfda724be59f37">&#9670;&nbsp;</a></span>write_mesh_vtk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::write_mesh_vtk </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_basename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A collective operation that produces a sequence of output files with the given file base name that contain the mesh in VTK format.</p>
<p>More than anything else, this function is useful for debugging the interface between deal.II and p4est. </p>

</div>
</div>
<a id="a74b5ad193b7a41b9c95a924dde2fb90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b5ad193b7a41b9c95a924dde2fb90e">&#9670;&nbsp;</a></span>get_checksum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::get_checksum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a check sum of the triangulation. This is a collective operation and is mostly useful for debugging purposes. </p>

</div>
</div>
<a id="a5cd3a35ff1a0b49c26b3d735af5d62b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd3a35ff1a0b49c26b3d735af5d62b3">&#9670;&nbsp;</a></span>save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the refinement information from the coarse mesh into the given file. This file needs to be reachable from all nodes in the computation on a shared network file system. See the <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">SolutionTransfer</a> class on how to store solution vectors into this file. Additional cell-based data can be saved using DistributedTriangulationBase::DataTransfer::register_data_attach(). </p>

<p>Implements <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ac958319402a5301d2dde94f1c6e8c78a">parallel::DistributedTriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a8d8d56c4155e1ab11e9f16799c71d3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8d56c4155e1ab11e9f16799c71d3a3">&#9670;&nbsp;</a></span>load() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>autopartition</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the refinement information saved with <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">save()</a> back in. The mesh must contain the same coarse mesh that was used in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">save()</a> before calling this function.</p>
<p>You do not need to load with the same number of MPI processes that you saved with. Rather, if a mesh is loaded with a different number of MPI processes than used at the time of saving, the mesh is repartitioned appropriately. Cell-based data that was saved with DistributedTriangulationBase::DataTransfer::register_data_attach() can be read in with DistributedTriangulationBase::DataTransfer::notify_ready_to_unpack() after calling <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">load()</a>.</p>
<p>If you use p4est version &gt; 0.3.4.2 the <code>autopartition</code> flag tells p4est to ignore the partitioning that the triangulation had when it was saved and make it uniform upon loading. If <code>autopartition</code> is set to false, the triangulation is only repartitioned if needed (i.e. if a different number of MPI processes is encountered). </p>

<p>Implements <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ad5a7ad9fd72720414a8c983acee58142">parallel::DistributedTriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a9e8c3dda81bb89d601c6db5b9717b34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8c3dda81bb89d601c6db5b9717b34b">&#9670;&nbsp;</a></span>load() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const typename ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt; dim &gt;::forest *&#160;</td>
          <td class="paramname"><em>forest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the refinement information from a given parallel forest. This forest might be obtained from the function call to <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a2c88267bebc11d2814888a5878a96d68">parallel::distributed::Triangulation::get_p4est()</a>. </p>

</div>
</div>
<a id="a90dc28ab95be39095cecfdf3496eac04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90dc28ab95be39095cecfdf3496eac04">&#9670;&nbsp;</a></span>get_p4est_tree_to_coarse_cell_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&gt;&amp; <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::get_p4est_tree_to_coarse_cell_permutation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a permutation vector for the order the coarse cells are handed off to p4est. For example the value of the \(i\)th element in this vector is the index of the deal.II coarse cell (counting from begin(0)) that corresponds to the \(i\)th tree managed by p4est. </p>

</div>
</div>
<a id="a0502ebf9878fc3c675115ed81cd5181f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0502ebf9878fc3c675115ed81cd5181f">&#9670;&nbsp;</a></span>get_coarse_cell_to_p4est_tree_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&gt;&amp; <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::get_coarse_cell_to_p4est_tree_permutation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a permutation vector for the mapping from the coarse deal cells to the p4est trees. This is the inverse of get_p4est_tree_to_coarse_cell_permutation. </p>

</div>
</div>
<a id="a2c88267bebc11d2814888a5878a96d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c88267bebc11d2814888a5878a96d68">&#9670;&nbsp;</a></span>get_p4est()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt;dim&gt;::forest* <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::get_p4est </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns a pointer to the internally stored p4est object (of type p4est_t or p8est_t depending on <code>dim</code>).</p>
<dl class="section warning"><dt>Warning</dt><dd>If you modify the p4est object, internal data structures can become inconsistent. </dd></dl>

</div>
</div>
<a id="a5ba7cf46ec43269f5ba430e91996d065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba7cf46ec43269f5ba430e91996d065">&#9670;&nbsp;</a></span>add_periodicity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::add_periodicity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt;::<a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In addition to the action in the base class <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>, this function joins faces in the p4est forest for periodic boundary conditions. As a result, each pair of faces will differ by at most one refinement level and ghost neighbors will be available across these faces.</p>
<p>The vector can be filled by the function <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>.</p>
<p>For more information on periodic boundary conditions see <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>, <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints</a> and step-45.</p>
<dl class="section note"><dt>Note</dt><dd>Before this function can be used the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a> has to be initialized and must not be refined. Calling this function more than once is possible, but not recommended: The function destroys and rebuilds the p4est forest each time it is called. </dd></dl>

</div>
</div>
<a id="aa76bd5ba9c0072f52360805b5139cb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76bd5ba9c0072f52360805b5139cb61">&#9670;&nbsp;</a></span>update_cell_relations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::update_cell_relations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Go through all p4est trees and record the relations between locally owned p4est quadrants and active deal.II cells in the private member vector local_cell_relations.</p>
<p>The vector contains an active cell iterator for every locally owned p4est quadrant, as well as a CellStatus flag to describe their relation.</p>
<p>The stored vector will be ordered by the occurrence of quadrants in the corresponding local sc_array of the parallel_forest. p4est requires this specific ordering for its transfer functions. Therefore, the size of this vector will be equal to the number of locally owned quadrants in the parallel_forest object.</p>
<p>These relations will be established for example in the mesh refinement process: after adapting the parallel_forest, but before applying these changes to this triangulation, we will record how cells will change in the refinement process. With this information, we can prepare all buffers for data transfer accordingly. </p>

<p>Implements <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a74fe86d32d73e4c12d1e505739b3662a">parallel::DistributedTriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a232e33c7dbc34de152ec06348e08582c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232e33c7dbc34de152ec06348e08582c">&#9670;&nbsp;</a></span>init_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt;dim&gt;::tree* <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::init_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dealii_coarse_cell_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the p4est tree that belongs to the given dealii_coarse_cell_index() </p>

</div>
</div>
<a id="aff58f98f967850202c11ac70103a83ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff58f98f967850202c11ac70103a83ff">&#9670;&nbsp;</a></span>setup_coarse_cell_to_p4est_tree_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::setup_coarse_cell_to_p4est_tree_permutation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The function that computes the permutation between the two data storage schemes. </p>

</div>
</div>
<a id="ac34f8cf1b84fd708c2e2a01d68016c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34f8cf1b84fd708c2e2a01d68016c63">&#9670;&nbsp;</a></span>copy_new_triangulation_to_p4est() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::copy_new_triangulation_to_p4est </td>
          <td>(</td>
          <td class="paramtype">std::integral_constant&lt; <a class="el" href="classint.html">int</a>, 2 &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Take the contents of a newly created triangulation we are attached to and copy it to p4est data structures.</p>
<p>This function exists in 2d and 3d variants. </p>

</div>
</div>
<a id="a7c270d4283241cb67c13e3f47cdb15e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c270d4283241cb67c13e3f47cdb15e0">&#9670;&nbsp;</a></span>copy_new_triangulation_to_p4est() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::copy_new_triangulation_to_p4est </td>
          <td>(</td>
          <td class="paramtype">std::integral_constant&lt; <a class="el" href="classint.html">int</a>, 3 &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93a0e407bc3a785f18ab3c64563caf03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a0e407bc3a785f18ab3c64563caf03">&#9670;&nbsp;</a></span>copy_local_forest_to_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::copy_local_forest_to_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy the local part of the refined forest from p4est into the attached triangulation. </p>

</div>
</div>
<a id="a3311500b4531f0b801f9c3dbdeeafea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3311500b4531f0b801f9c3dbdeeafea3">&#9670;&nbsp;</a></span>get_cell_weights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::get_cell_weights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal function notifying all registered slots to provide their weights before repartitioning occurs. Called from <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">execute_coarsening_and_refinement()</a> and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a12cc5327a81ae46b8a6d9a3eb4bd9893">repartition()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of unsigned integers representing the weight or computational load of every cell after the refinement/coarsening/ repartition cycle. Note that the number of entries does not need to be equal to either <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells()</a> or <a class="el" href="classparallel_1_1TriangulationBase.html#a74e904416671ca175093274144e49439">n_locally_owned_active_cells()</a>, because the triangulation is not updated yet. The weights are sorted in the order that p4est will encounter them while iterating over them. </dd></dl>

</div>
</div>
<a id="afe8631e7836b12461acc21d119f8fabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8631e7836b12461acc21d119f8fabf">&#9670;&nbsp;</a></span>mark_locally_active_vertices_on_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::mark_locally_active_vertices_on_level </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns a bit vector of length tria.n_vertices() indicating the locally active vertices on a level, i.e., the vertices touched by the locally owned level cells for use in geometric multigrid (possibly including the vertices due to periodic boundary conditions) are marked by true.</p>
<p>Used by DoFHandler::Policy::ParallelDistributed. </p>

</div>
</div>
<a id="acc6af7d3e309cef138d916aa6e0b3494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6af7d3e309cef138d916aa6e0b3494">&#9670;&nbsp;</a></span>coarse_cell_id_to_coarse_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::coarse_cell_id_to_coarse_cell_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a>&#160;</td>
          <td class="paramname"><em>coarse_cell_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate the unique id of a coarse cell to its index. See the glossary entry on <a class="el" href="DEALGlossary.html#GlossCoarseCellId">coarse cell IDs</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>For serial and shared triangulation both id and index are the same. For distributed triangulations setting both might differ, since the id might correspond to a global id and the index to a local id.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coarse_cell_id</td><td>Unique id of the coarse cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the coarse cell within the current triangulation. </dd></dl>

<p>Reimplemented from <a class="el" href="classTriangulation.html#af01ec1d50a410f7cc29c543b212edefc">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a5ee4a0a9c73acef08adae3cdfabf60f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee4a0a9c73acef08adae3cdfabf60f2">&#9670;&nbsp;</a></span>coarse_cell_index_to_coarse_cell_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::coarse_cell_index_to_coarse_cell_id </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarse_cell_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate the index of coarse cell to its unique id. See the glossary entry on <a class="el" href="DEALGlossary.html#GlossCoarseCellId">coarse cell IDs</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>See the note of the method <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">coarse_cell_id_to_coarse_cell_index()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coarse_cell_index</td><td>Index of the coarse cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of the coarse cell. </dd></dl>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a9ef633762716a14deb9a4dcda02a26f0">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a2f0c10f7a8cd32d961e9367173685047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0c10f7a8cd32d961e9367173685047">&#9670;&nbsp;</a></span>save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not save <em>all</em> member variables of the current triangulation. Rather, only certain kinds of information are stored. For more information see the general documentation of this class. </dd></dl>

</div>
</div>
<a id="ae2f72d5fbb277ec65dbe0382ae72a929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f72d5fbb277ec65dbe0382ae72a929">&#9670;&nbsp;</a></span>load() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. Throw away the previous content.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not reset <em>all</em> member variables of the current triangulation to the ones of the triangulation that was previously stored to an archive. Rather, only certain kinds of information are loaded. For more information see the general documentation of this class.</dd>
<dd>
This function calls the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">Triangulation::clear()</a> function and consequently triggers the "clear" signal. After loading all data from the archive, it then triggers the "create" signal. For more information on signals, see the general documentation of this class. </dd></dl>

</div>
</div>
<a id="acb1a95528832932bf2fad380f8098367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1a95528832932bf2fad380f8098367">&#9670;&nbsp;</a></span>register_data_attach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::register_data_attach </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::vector&lt; char &gt;(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pack_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>returns_variable_size_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Register a function that can be used to attach data of fixed size to cells. This is useful for two purposes: (i) Upon refinement and coarsening of a triangulation (<em>e.g</em>. in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation::execute_coarsening_and_refinement()</a>), one needs to be able to store one or more data vectors per cell that characterizes the solution values on the cell so that this data can then be transferred to the new owning processor of the cell (or its parent/children) when the mesh is re-partitioned; (ii) when serializing a computation to a file, it is necessary to attach data to cells so that it can be saved (<em>e.g</em>. in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation::save()</a>) along with the cell's other information and, if necessary, later be reloaded from disk with a different subdivision of cells among the processors.</p>
<p>The way this function works is that it allows any number of interest parties to register their intent to attach data to cells. One example of classes that do this is <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> where each <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> object that works on the current <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a> object then needs to register its intent. Each of these parties registers a callback function (the first argument here, <code>pack_callback</code>) that will be called whenever the triangulation's <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">save()</a> functions are called.</p>
<p>The current function then returns an integer handle that corresponds to the number of data set that the callback provided here will attach. While this number could be given a precise meaning, this is not important: You will never actually have to do anything with this number except return it to the <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a> function. In other words, each interested party (i.e., the caller of the current function) needs to store their respective returned handle for later use when unpacking data in the callback provided to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>.</p>
<p>Whenever <code>pack_callback</code> is then called by <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">load()</a> on a given cell, it receives a number of arguments. In particular, the first argument passed to the callback indicates the cell for which it is supposed to attach data. This is always an active cell.</p>
<p>The second, CellStatus, argument provided to the callback function will tell you if the given cell will be coarsened, refined, or will persist as is. (This status may be different than the refinement or coarsening flags set on that cell, to accommodate things such as the "one hanging node per edge" rule.). These flags need to be read in context with the p4est quadrant they belong to, as their relations are gathered in local_cell_relations.</p>
<p>Specifically, the values for this argument mean the following:</p>
<ul>
<li><code>CELL_PERSIST</code>: The cell won't be refined/coarsened, but might be moved to a different processor. If this is the case, the callback will want to pack up the data on this cell into an array and store it at the provided address for later unpacking wherever this cell may land.</li>
<li><code>CELL_REFINE</code>: This cell will be refined into 4 or 8 cells (in 2d and 3d, respectively). However, because these children don't exist yet, you cannot access them at the time when the callback is called. Thus, in local_cell_relations, the corresponding p4est quadrants of the children cells are linked to the deal.II cell which is going to be refined. To be specific, only the very first child is marked with <code>CELL_REFINE</code>, whereas the others will be marked with <code>CELL_INVALID</code>, which indicates that these cells will be ignored by default during the packing or unpacking process. This ensures that data is only transferred once onto or from the parent cell. If the callback is called with <code>CELL_REFINE</code>, the callback will want to pack up the data on this cell into an array and store it at the provided address for later unpacking in a way so that it can then be transferred to the children of the cell that will then be available. In other words, if the data the callback will want to pack up corresponds to a finite element field, then the prolongation from parent to (new) children will have to happen during unpacking.</li>
<li><code>CELL_COARSEN</code>: The children of this cell will be coarsened into the given cell. These children still exist, so if this is the value given to the callback as second argument, the callback will want to transfer data from the children to the current parent cell and pack it up so that it can later be unpacked again on a cell that then no longer has any children (and may also be located on a different processor). In other words, if the data the callback will want to pack up corresponds to a finite element field, then it will need to do the restriction from children to parent at this point.</li>
<li><code>CELL_INVALID</code>: See <code>CELL_REFINE</code>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If this function is used for serialization of data using <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">save()</a> and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">load()</a>, then the cell status argument with which the callback is called will always be <code>CELL_PERSIST</code>.</dd></dl>
<p>The callback function is expected to return a memory chunk of the format <code>std::vector&lt;char&gt;</code>, representing the packed data on a certain cell.</p>
<p>The second parameter <code>returns_variable_size_data</code> indicates whether the returned size of the memory region from the callback function varies by cell (<code>=true</code>) or stays constant on each one throughout the whole domain (<code>=false</code>).</p>
<dl class="section note"><dt>Note</dt><dd>The purpose of this function is to register intent to attach data for a single, subsequent call to <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">execute_coarsening_and_refinement()</a> and <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">save()</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">load()</a>. Consequently, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">save()</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">load()</a> all forget the registered callbacks once these callbacks have been called, and you will have to re-register them with a triangulation if you want them to be active for another call to these functions. </dd></dl>

</div>
</div>
<a id="a6fbdf11dcfacd414a8936e6d26fecb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbdf11dcfacd414a8936e6d26fecb76">&#9670;&nbsp;</a></span>notify_ready_to_unpack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::notify_ready_to_unpack </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb254bd3c238056d5c44627167944253">cell_iterator</a> &amp;, const <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a>, const boost::iterator_range&lt; std::vector&lt; char &gt;::const_iterator &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>unpack_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is the opposite of <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. It is called <em>after</em> the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">save()</a>/load() functions are done when classes and functions that have previously attached data to a triangulation for either transfer to other processors, across mesh refinement, or serialization of data to a file are ready to receive that data back. The important part about this process is that the triangulation cannot do this right away from the end of <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">execute_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">load()</a> via a previously attached callback function (as the <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a> function does) because the classes that eventually want the data back may need to do some setup between the point in time where the mesh has been recreated and when the data can actually be received. An example is the <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> class that can really only receive the data once not only the mesh is completely available again on the current processor, but only after a <a class="el" href="classDoFHandler.html">DoFHandler</a> has been reinitialized and distributed degrees of freedom. In other words, there is typically a significant amount of set up that needs to happen in user space before the classes that can receive data attached to cell are ready to actually do so. When they are, they use the current function to tell the triangulation object that now is the time when they are ready by calling the current function.</p>
<p>The supplied callback function is then called for each newly locally owned cell. The first argument to the callback is an iterator that designates the cell; the second argument indicates the status of the cell in question; and the third argument localizes a memory area by two iterators that contains the data that was previously saved from the callback provided to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>.</p>
<p>The CellStatus will indicate if the cell was refined, coarsened, or persisted unchanged. The <code>cell_iterator</code> argument to the callback will then either be an active, locally owned cell (if the cell was not refined), or the immediate parent if it was refined during <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">execute_coarsening_and_refinement()</a>. Therefore, contrary to during <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>, you can now access the children if the status is <code>CELL_REFINE</code> but no longer for callbacks with status <code>CELL_COARSEN</code>.</p>
<p>The first argument to this function, <code>handle</code>, corresponds to the return value of <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a>. (The precise meaning of what the numeric value of this handle is supposed to represent is neither important, nor should you try to use it for anything other than transmit information between a call to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#acb1a95528832932bf2fad380f8098367">register_data_attach()</a> to the corresponding call to <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#a6fbdf11dcfacd414a8936e6d26fecb76">notify_ready_to_unpack()</a>.) </p>

</div>
</div>
<a id="a53caa007ddc9229fa461a0fd925482ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53caa007ddc9229fa461a0fd925482ae">&#9670;&nbsp;</a></span>save_attached_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::save_attached_data </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_first_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save additional cell-attached data into the given file. The first arguments are used to determine the offsets where to write buffers to.</p>
<p>Called by <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">save</a>. </p>

</div>
</div>
<a id="aeef794a63c63ff09e2c1c231998083f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef794a63c63ff09e2c1c231998083f2">&#9670;&nbsp;</a></span>load_attached_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::load_attached_data </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_first_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>global_num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>local_num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_attached_deserialize_fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_attached_deserialize_variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load additional cell-attached data from the given file, if any was saved. The first arguments are used to determine the offsets where to read buffers from.</p>
<p>Called by <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">load</a>. </p>

</div>
</div>
<a id="a77b606a3f26f71603f7759dc16d33db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b606a3f26f71603f7759dc16d33db9">&#9670;&nbsp;</a></span>get_communicator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMPI__Comm.html">MPI_Comm</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::get_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return MPI communicator used by this triangulation. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a1005ad6002b51c5bc4592da7246b6a49">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a7ba82cc28f325167d0950150e23cf037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba82cc28f325167d0950150e23cf037">&#9670;&nbsp;</a></span>copy_triangulation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::copy_triangulation </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>old_tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the same function as in the base class.</p>
<dl class="section note"><dt>Note</dt><dd>This function copies the cells, but not the communicator, of the source triangulation. In other words, the resulting triangulation will operate on the communicator it was constructed with. </dd></dl>

</div>
</div>
<a id="a1bca327fa47f88b58086dacc20028064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bca327fa47f88b58086dacc20028064">&#9670;&nbsp;</a></span>copy_triangulation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::copy_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other_tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy <code>other_tria</code> to this triangulation. This operation is not cheap, so you should be careful with using this. We do not implement this function as a copy constructor, since it makes it easier to maintain collections of triangulations if you can assign them values later on.</p>
<p>Keep in mind that this function also copies the pointer to the boundary descriptor previously set by the <code>set_manifold</code> function. You must therefore also guarantee that the <a class="el" href="classManifold.html">Manifold</a> objects describing the boundary have a lifetime at least as long as the copied triangulation.</p>
<p>This triangulation must be empty beforehand.</p>
<p>The function is made <code>virtual</code> since some derived classes might want to disable or extend the functionality of this function.</p>
<dl class="section note"><dt>Note</dt><dd>Calling this function triggers the 'copy' signal on other_tria, i.e. the triangulation being copied <em>from</em>. It also triggers the 'create' signal of the current triangulation. See the section on signals in the general documentation for more information.</dd>
<dd>
The list of connections to signals is not copied from the old to the new triangulation since these connections were established to monitor how the old triangulation changes, not how any triangulation it may be copied to changes. </dd></dl>

<p>Reimplemented in <a class="el" href="classPersistentTriangulation.html#a62d8ee4421ec25e3408f15613a7a9b3f">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a74e904416671ca175093274144e49439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e904416671ca175093274144e49439">&#9670;&nbsp;</a></span>n_locally_owned_active_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_locally_owned_active_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of active cells in the triangulation that are locally owned, i.e. that have a subdomain_id equal to <a class="el" href="classparallel_1_1TriangulationBase.html#a41b129156d89f37482d2095de5751d9c">locally_owned_subdomain()</a>. Note that there may be more active cells in the triangulation stored on the present processor, such as for example ghost cells, or cells further away from the locally owned block of cells but that are needed to ensure that the triangulation that stores this processor's set of active cells still remains balanced with respect to the 2:1 size ratio of adjacent cells.</p>
<p>As a consequence of the remark above, the result of this function is always smaller or equal to the result of the function with the same name in the <a class="el" href="classTriangulation.html">Triangulation</a> base class, which includes the active ghost and artificial cells (see also <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a> and <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a>). </p>

</div>
</div>
<a id="a46548d5ed479030dbc75d8fbb2b68d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46548d5ed479030dbc75d8fbb2b68d11">&#9670;&nbsp;</a></span>n_global_active_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_global_active_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the sum over all processors of the number of active cells owned by each processor. This equals the overall number of active cells in the triangulation. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a05502400e5b4bdd3bb7e0fd410fdf0fb">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ab94c22b8116e1b5f4284ae01b221a2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94c22b8116e1b5f4284ae01b221a2e2">&#9670;&nbsp;</a></span>n_global_levels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_global_levels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global maximum level. This may be bigger than the number <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">Triangulation::n_levels()</a> (a function in this class's base class) returns if the current processor only stores cells in parts of the domain that are not very refined, but if other processors store cells in more deeply refined parts of the domain. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a41b129156d89f37482d2095de5751d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b129156d89f37482d2095de5751d9c">&#9670;&nbsp;</a></span>locally_owned_subdomain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::locally_owned_subdomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the subdomain id of those cells that are owned by the current processor. All cells in the triangulation that do not have this subdomain id are either owned by another processor or have children that only exist on other processors. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a5827cdfafd5fef99803cde97b70e86bc">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a5e24708aa6563bf529cd8a10ca0cbe12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e24708aa6563bf529cd8a10ca0cbe12">&#9670;&nbsp;</a></span>ghost_owners()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&gt;&amp; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::ghost_owners </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a set of MPI ranks of the processors that have at least one ghost cell adjacent to the cells of the local processor. In other words, this is the set of <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a> for all ghost cells.</p>
<p>The returned sets are symmetric, that is if <code>i</code> is contained in the list of processor <code>j</code>, then <code>j</code> will also be contained in the list of processor <code>i</code>. </p>

</div>
</div>
<a id="abff00f28a17583c0316af55b04b139e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff00f28a17583c0316af55b04b139e3">&#9670;&nbsp;</a></span>level_ghost_owners()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&gt;&amp; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::level_ghost_owners </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a set of MPI ranks of the processors that have at least one level ghost cell adjacent to our cells used in geometric multigrid. In other words, this is the set of level_subdomain_id() for all level ghost cells.</p>
<p>The returned sets are symmetric, that is if <code>i</code> is contained in the list of processor <code>j</code>, then <code>j</code> will also be contained in the list of processor <code>i</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The level ghost owners can only be determined if the multigrid ownership has been assigned (by setting the construct_multigrid_hierarchy flag at construction time), otherwise the returned set will be empty. </dd></dl>

</div>
</div>
<a id="a640568c9b7f4b50cf45b5c52a8420b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640568c9b7f4b50cf45b5c52a8420b05">&#9670;&nbsp;</a></span>global_active_cell_index_partitioner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::weak_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::global_active_cell_index_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return partitioner for the global indices of the cells on the active level of the triangulation. </p>

</div>
</div>
<a id="a8513533c19e088ed8303ea50198b9920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8513533c19e088ed8303ea50198b9920">&#9670;&nbsp;</a></span>global_level_cell_index_partitioner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::weak_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::global_level_cell_index_partitioner </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return partitioner for the global indices of the cells on the given <code>level</code> of the triangulation. </p>

</div>
</div>
<a id="a1e1acf0c97fceec538c4552ee300213c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1acf0c97fceec538c4552ee300213c">&#9670;&nbsp;</a></span>get_boundary_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::get_boundary_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return a vector containing all boundary indicators assigned to boundary faces of active cells of this <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a> object. Note, that each boundary indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function involves a global communication gathering all current IDs from all processes. </dd></dl>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a05662a55166596efb520479b495275f8">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a51f63aebdfa85dc769c1503c00670a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f63aebdfa85dc769c1503c00670a7e">&#9670;&nbsp;</a></span>get_manifold_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&gt; <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::get_manifold_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Return a vector containing all manifold indicators assigned to the objects of the active cells of this <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>. Note, that each manifold indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function involves a global communication gathering all current IDs from all processes. </dd></dl>

<p>Reimplemented from <a class="el" href="group__manifold.html#ga0ee729ae049af6f1495d0059d6086e52">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ad63df2c11257f1e6fb482e4f9ea4589f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63df2c11257f1e6fb482e4f9ea4589f">&#9670;&nbsp;</a></span>communicate_locally_moved_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::communicate_locally_moved_vertices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_locally_moved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When vertices have been moved locally, for example using code like </p><div class="fragment"><div class="line">cell-&gt;vertex(0) = new_location;</div></div><!-- fragment --><p> then this function can be used to update the location of vertices between MPI processes.</p>
<p>All the vertices that have been moved and might be in the ghost layer of a process have to be reported in the <code>vertex_locally_moved</code> argument. This ensures that that part of the information that has to be send between processes is actually sent. Additionally, it is quite important that vertices on the boundary between processes are reported on exactly one process (e.g. the one with the highest id). Otherwise we could expect undesirable results if multiple processes move a vertex differently. A typical strategy is to let processor \(i\) move those vertices that are adjacent to cells whose owners include processor \(i\) but no other processor \(j\) with \(j&lt;i\); in other words, for vertices at the boundary of a subdomain, the processor with the lowest subdomain id "owns" a vertex.</p>
<dl class="section note"><dt>Note</dt><dd>It only makes sense to move vertices that are either located on locally owned cells or on cells in the ghost layer. This is because you can be sure that these vertices indeed exist on the finest mesh aggregated over all processors, whereas vertices on artificial cells but not at least in the ghost layer may or may not exist on the globally finest mesh. Consequently, the <code>vertex_locally_moved</code> argument may not contain vertices that aren't at least on ghost cells.</dd>
<dd>
This function moves vertices in such a way that on every processor, the vertices of every locally owned and ghost cell is consistent with the corresponding location of these cells on other processors. On the other hand, the locations of artificial cells will in general be wrong since artificial cells may or may not exist on other processors and consequently it is not possible to determine their location in any way. This is not usually a problem since one never does anything on artificial cells. However, it may lead to problems if the mesh with moved vertices is refined in a later step. If that's what you want to do, the right way to do it is to save the offset applied to every vertex, call this function, and before refining or coarsening the mesh apply the opposite offset and call this function again.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_locally_moved</td><td>A bitmap indicating which vertices have been moved. The size of this array must be equal to <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a> and must be a subset of those vertices flagged by <a class="el" href="namespaceGridTools.html#a538d5bfd6cea7aa42224ba8d5952dd05">GridTools::get_locally_owned_vertices()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>This function is used, for example, in <a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random()</a>. </dd></dl>

</div>
</div>
<a id="ae5d830897853a1098344e718dd878147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d830897853a1098344e718dd878147">&#9670;&nbsp;</a></span>n_global_coarse_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_global_coarse_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of coarse cells. If the coarse mesh is replicated on each process, this simply returns <code>n_cells(0)</code>. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a1bff048d1ed54471bbd2dcfc76a46523">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ab5164a6fb30048f0ce5e81f67b60285f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5164a6fb30048f0ce5e81f67b60285f">&#9670;&nbsp;</a></span>update_number_cache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::update_number_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the number_cache variable after mesh creation or refinement. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a89a526bc8b590574c7e8013246260473">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a10cf6c4bfa4a3d00d8c76792d1b9872a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10cf6c4bfa4a3d00d8c76792d1b9872a">&#9670;&nbsp;</a></span>update_reference_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::update_reference_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Update the internal reference_cells vector. </p>

<p>Reimplemented from <a class="el" href="group__Exceptions.html#ga5ecff6fdc386de47c156781fb4217bcc">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="adac35d252ab3fcbcdc675d6ac526b24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac35d252ab3fcbcdc675d6ac526b24c">&#9670;&nbsp;</a></span>reset_global_cell_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::reset_global_cell_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset global active cell indices and global level cell indices. </p>

</div>
</div>
<a id="a4a302f66ccc9bd281cf850fdc4f76e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a302f66ccc9bd281cf850fdc4f76e50">&#9670;&nbsp;</a></span>set_mesh_smoothing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_mesh_smoothing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td>
          <td class="paramname"><em>mesh_smoothing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the mesh smoothing to <code>mesh_smoothing</code>. This overrides the MeshSmoothing given to the constructor. It is allowed to call this function only if the triangulation is empty. </p>

</div>
</div>
<a id="a06df95bfd43216e389a132786f87474f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06df95bfd43216e389a132786f87474f">&#9670;&nbsp;</a></span>get_mesh_smoothing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&amp; <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_mesh_smoothing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the mesh smoothing requirements that are obeyed. </p>

</div>
</div>
<a id="abbbee6e665998c3e4a745cd7836df364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbee6e665998c3e4a745cd7836df364">&#9670;&nbsp;</a></span>create_triangulation_compatibility()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation_compatibility </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For backward compatibility, only. This function takes the cell data in the ordering as requested by deal.II versions up to 5.2, converts it to the new (lexicographic) ordering and calls <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a85f8516b5fe9b8fc6e8784c987f9263f">create_triangulation()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function internally calls create_triangulation and therefore can throw the same exception as the other function. </dd></dl>

<p>Reimplemented in <a class="el" href="classPersistentTriangulation.html#ad6215eb2339ec45320d5858ccae5aab6">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="afdc34248a9ba0c38fd0020256a8def5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc34248a9ba0c38fd0020256a8def5c">&#9670;&nbsp;</a></span>flip_all_direction_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::flip_all_direction_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Revert or flip the direction_flags of a dim&lt;spacedim triangulation, see <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a>.</p>
<p>This function throws an exception if dim equals spacedim. </p>

</div>
</div>
<a id="aed8e461d4b2b23a0e1730afdef36e694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8e461d4b2b23a0e1730afdef36e694">&#9670;&nbsp;</a></span>set_all_refine_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_refine_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag all active cells for refinement. This will refine all cells of all levels which are not already refined (i.e. only cells are refined which do not yet have children). The cells are only flagged, not refined, thus you have the chance to save the refinement flags. </p>

</div>
</div>
<a id="a6ad0b3fb24aae17f4668427a433dea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad0b3fb24aae17f4668427a433dea19">&#9670;&nbsp;</a></span>refine_global()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::refine_global </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refine all cells <code>times</code> times. In other words, in each one of the <code>times</code> iterations, loop over all cells and refine each cell uniformly into \(2^\text{dim}\) children. In practice, this function repeats the following operations <code>times</code> times: call <a class="el" href="classTriangulation.html#aed8e461d4b2b23a0e1730afdef36e694">set_all_refine_flags()</a> followed by <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">execute_coarsening_and_refinement()</a>. The end result is that the number of cells increases by a factor of \((2^\text{dim})^\text{times}=2^{\text{dim} \times \text{times}}\).</p>
<p>The <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">execute_coarsening_and_refinement()</a> function called in this loop may throw an exception if it creates cells that are distorted (see its documentation for an explanation). This exception will be propagated through this function if that happens, and you may not get the actual number of refinement steps in that case.</p>
<dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing each individual refinement cycle (i.e. more than once if <code>times &gt; 1</code>) . See the section on signals in the general documentation of this class. </dd></dl>

</div>
</div>
<a id="a6552fa04ee753657bd9f92571d76cf09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6552fa04ee753657bd9f92571d76cf09">&#9670;&nbsp;</a></span>coarsen_global()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarsen_global </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen all cells the given number of times.</p>
<p>In each of one of the <code>times</code> iterations, all cells will be marked for coarsening. If an active cell is already on the coarsest level, it will be ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing each individual coarsening cycle (i.e. more than once if <code>times &gt; 1</code>) . See the section on signals in the general documentation of this class. </dd></dl>

</div>
</div>
<a id="aca5cfa9068a5d3ad32dfca87e2901a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5cfa9068a5d3ad32dfca87e2901a87">&#9670;&nbsp;</a></span>save_refine_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the addresses of the cells which are flagged for refinement to <code>out</code>. For usage, read the general documentation for this class. </p>

</div>
</div>
<a id="affce5fca29acccbb2dc1294ebe404a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affce5fca29acccbb2dc1294ebe404a03">&#9670;&nbsp;</a></span>save_refine_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

</div>
</div>
<a id="a43fc07c3f9e1f02658ca556f41087c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fc07c3f9e1f02658ca556f41087c85">&#9670;&nbsp;</a></span>load_refine_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="ac924a05e66d5e76458ad088a2b7b5583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac924a05e66d5e76458ad088a2b7b5583">&#9670;&nbsp;</a></span>load_refine_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="af64b6155fd89f8f29d4c02795c1a10d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64b6155fd89f8f29d4c02795c1a10d9">&#9670;&nbsp;</a></span>save_coarsen_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="abaaecbe89311fdaa8a9b999209ff9155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaaecbe89311fdaa8a9b999209ff9155">&#9670;&nbsp;</a></span>save_coarsen_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

</div>
</div>
<a id="aa4029122ffe741f843f2f3a7deeceea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4029122ffe741f843f2f3a7deeceea9">&#9670;&nbsp;</a></span>load_coarsen_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

</div>
</div>
<a id="a48a9463dcf9aeb3a69831e5e1a321053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a9463dcf9aeb3a69831e5e1a321053">&#9670;&nbsp;</a></span>load_coarsen_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

</div>
</div>
<a id="a178e9ce017916f190ddf7a734ef15902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178e9ce017916f190ddf7a734ef15902">&#9670;&nbsp;</a></span>get_anisotropic_refinement_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_anisotropic_refinement_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this triangulation has ever undergone anisotropic (as opposed to only isotropic) refinement. </p>

</div>
</div>
<a id="aaa726b33b52f694cfca48fae8e761661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa726b33b52f694cfca48fae8e761661">&#9670;&nbsp;</a></span>clear_user_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a6a9971ee882f15fe521afc4e079383b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9971ee882f15fe521afc4e079383b5">&#9670;&nbsp;</a></span>save_user_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user flags. See the general documentation for this class and the documentation for the <code>save_refine_flags</code> for more details. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="aad25280beb6c2607418a0d3e903819a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad25280beb6c2607418a0d3e903819a3">&#9670;&nbsp;</a></span>save_user_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="af3612ed3c7f7f9cccd3003d85b6f7350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3612ed3c7f7f9cccd3003d85b6f7350">&#9670;&nbsp;</a></span>load_user_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="ac17946286639b12a03804ebc400eab51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17946286639b12a03804ebc400eab51">&#9670;&nbsp;</a></span>load_user_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="af8896f8e838dd34ed5b7c1aa351f76f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8896f8e838dd34ed5b7c1aa351f76f5">&#9670;&nbsp;</a></span>clear_user_flags_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a2b7d8e059d6f8f903879eea858215fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7d8e059d6f8f903879eea858215fb8">&#9670;&nbsp;</a></span>save_user_flags_line() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a02adea7b298cd5047ee5a5755f87ae36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02adea7b298cd5047ee5a5755f87ae36">&#9670;&nbsp;</a></span>save_user_flags_line() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a25190c31d16cde2a01fa0f2318aa0b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25190c31d16cde2a01fa0f2318aa0b74">&#9670;&nbsp;</a></span>load_user_flags_line() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a87294511c2f203a57531aaaf2bd2ce39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87294511c2f203a57531aaaf2bd2ce39">&#9670;&nbsp;</a></span>load_user_flags_line() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a1dd263157214206ceb637c402552f0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd263157214206ceb637c402552f0eb">&#9670;&nbsp;</a></span>clear_user_flags_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="acf4a2db0492d38971366bfcd159cbbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4a2db0492d38971366bfcd159cbbc1">&#9670;&nbsp;</a></span>save_user_flags_quad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a431026974872f49e59f6a799ee0a19d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431026974872f49e59f6a799ee0a19d6">&#9670;&nbsp;</a></span>save_user_flags_quad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a5e868cde85c04bcc8cec82ba09f24e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e868cde85c04bcc8cec82ba09f24e7b">&#9670;&nbsp;</a></span>load_user_flags_quad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a8651e0def48d61e3f8f0aa8051ae5985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8651e0def48d61e3f8f0aa8051ae5985">&#9670;&nbsp;</a></span>load_user_flags_quad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a7cbe198bb49c3135378bb680582afd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbe198bb49c3135378bb680582afd46">&#9670;&nbsp;</a></span>clear_user_flags_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a1d5512376f914359303ce7d4666d550b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5512376f914359303ce7d4666d550b">&#9670;&nbsp;</a></span>save_user_flags_hex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="ae57c92493d66995cf29bef79f0e8e09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57c92493d66995cf29bef79f0e8e09b">&#9670;&nbsp;</a></span>save_user_flags_hex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a6e15f4d848adbe6c8bf1af374e467a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e15f4d848adbe6c8bf1af374e467a31">&#9670;&nbsp;</a></span>load_user_flags_hex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a77e827086d26927d08129c8489fdcd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e827086d26927d08129c8489fdcd45">&#9670;&nbsp;</a></span>load_user_flags_hex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a26562806fd764afdffb973dce92554e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26562806fd764afdffb973dce92554e8">&#9670;&nbsp;</a></span>clear_user_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user pointers and indices and allow the use of both for next access. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="ae3794cd2d7f80bd81f69fcb828535412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3794cd2d7f80bd81f69fcb828535412">&#9670;&nbsp;</a></span>save_user_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user indices. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a12a2359968a027a8b14ae381c8886d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a2359968a027a8b14ae381c8886d30">&#9670;&nbsp;</a></span>load_user_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#ae3794cd2d7f80bd81f69fcb828535412">save_user_indices()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a03a41f6c10b5db7d540a9df15742ebf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a41f6c10b5db7d540a9df15742ebf0">&#9670;&nbsp;</a></span>save_user_pointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user pointers. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a2f8891e8277a047b9dd4fe86943d1321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8891e8277a047b9dd4fe86943d1321">&#9670;&nbsp;</a></span>load_user_pointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#a03a41f6c10b5db7d540a9df15742ebf0">save_user_pointers()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a451b2af8e62783f4780552088fd9ad88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451b2af8e62783f4780552088fd9ad88">&#9670;&nbsp;</a></span>save_user_indices_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a7b2160dd04545294d138ca00deb4af42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2160dd04545294d138ca00deb4af42">&#9670;&nbsp;</a></span>load_user_indices_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a8d65cc99c33ea13361700a58ff9d6686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d65cc99c33ea13361700a58ff9d6686">&#9670;&nbsp;</a></span>save_user_indices_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a1020c09b32fbb78156b00b833271e21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1020c09b32fbb78156b00b833271e21d">&#9670;&nbsp;</a></span>load_user_indices_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a8a18d1c25ca9c0b7cef07c6e92fdd28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a18d1c25ca9c0b7cef07c6e92fdd28f">&#9670;&nbsp;</a></span>save_user_indices_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="abad8869b9c8234d6c81c24c69dd97d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad8869b9c8234d6c81c24c69dd97d39">&#9670;&nbsp;</a></span>load_user_indices_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a699d7c1b73eccc41bc53009003ab3d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699d7c1b73eccc41bc53009003ab3d28">&#9670;&nbsp;</a></span>save_user_pointers_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a879d77427982a2d69d2dd9512d4ba6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879d77427982a2d69d2dd9512d4ba6c9">&#9670;&nbsp;</a></span>load_user_pointers_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a7d27b23e1d873b38817d08b7bb6884f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d27b23e1d873b38817d08b7bb6884f8">&#9670;&nbsp;</a></span>save_user_pointers_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user pointers on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a4f771811ec221a4ca0c49f3a09164fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f771811ec221a4ca0c49f3a09164fec">&#9670;&nbsp;</a></span>load_user_pointers_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="ac42ad416119dff0589b8b67dd3de02e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42ad416119dff0589b8b67dd3de02e8">&#9670;&nbsp;</a></span>save_user_pointers_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user pointers on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a03dad0c49d2423e8c4410efcc773ad82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03dad0c49d2423e8c4410efcc773ad82">&#9670;&nbsp;</a></span>load_user_pointers_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a36fb6b15f119483143c433dd10df9b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fb6b15f119483143c433dd10df9b26">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used cell on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#ab94c22b8116e1b5f4284ae01b221a2e2">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#ab94c22b8116e1b5f4284ae01b221a2e2">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="afe6c58805fe436a94b141c1585606c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6c58805fe436a94b141c1585606c7f">&#9670;&nbsp;</a></span>begin_active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gaa80b689a21d72f777095aa12bbe01afa">active_cell_iterator</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active cell on level <code>level</code>. If the given level does not contain any active cells (i.e., all cells on this level are further refined, then this function returns <code>end_active(level)</code> so that loops of the kind </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> cell=tria.begin_active(level);</div><div class="line">     cell!=tria.end_active(level);</div><div class="line">     ++cell)</div><div class="line">  {</div><div class="line">    ...</div><div class="line">  }</div></div><!-- fragment --><p> have zero iterations, as may be expected if there are no active cells on this level.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#ab94c22b8116e1b5f4284ae01b221a2e2">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#ab94c22b8116e1b5f4284ae01b221a2e2">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a92c41c89a9cf1e020050985822196dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c41c89a9cf1e020050985822196dff">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a9597b118c84fce0addf7f4db3b067659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9597b118c84fce0addf7f4db3b067659">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator which is the first iterator not on level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#ab94c22b8116e1b5f4284ae01b221a2e2">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#ab94c22b8116e1b5f4284ae01b221a2e2">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="ab0967cc6653ea9a08e94fe9da4d11793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0967cc6653ea9a08e94fe9da4d11793">&#9670;&nbsp;</a></span>end_active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gaa80b689a21d72f777095aa12bbe01afa">active_cell_iterator</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an active iterator which is the first active iterator not on the given level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classparallel_1_1TriangulationBase.html#ab94c22b8116e1b5f4284ae01b221a2e2">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classparallel_1_1TriangulationBase.html#ab94c22b8116e1b5f4284ae01b221a2e2">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="ab51f6fbd9bcd9e41757039a7b4954d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51f6fbd9bcd9e41757039a7b4954d2a">&#9670;&nbsp;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last used cell. </p>

</div>
</div>
<a id="a2eb00096abe5ef91413440e1e1b66c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb00096abe5ef91413440e1e1b66c00">&#9670;&nbsp;</a></span>last_active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gaa80b689a21d72f777095aa12bbe01afa">active_cell_iterator</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last active cell. </p>

</div>
</div>
<a id="a367c0bd718b0ae9316f3b6f52d0ff4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367c0bd718b0ae9316f3b6f52d0ff4c6">&#9670;&nbsp;</a></span>create_cell_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_cell_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCellId.html">CellId</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator to a cell of this <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a> object constructed from an independent <a class="el" href="classCellId.html">CellId</a> object.</p>
<p>If the given argument corresponds to a valid cell in this triangulation, this operation will always succeed for sequential triangulations where the current processor stores all cells that are part of the triangulation. On the other hand, if this is a parallel triangulation, then the current processor may not actually know about this cell. In this case, this operation will succeed for locally relevant cells, but may not for artificial cells that are less refined on the current processor. </p>

</div>
</div>
<a id="abd8e77917e8512bd1e70bf180929f407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8e77917e8512bd1e70bf180929f407">&#9670;&nbsp;</a></span>begin_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used face. </p>

</div>
</div>
<a id="af7e8d4115aad4a2a5c97a7f7c06d34d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e8d4115aad4a2a5c97a7f7c06d34d5">&#9670;&nbsp;</a></span>begin_active_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active face. </p>

</div>
</div>
<a id="a359dfdc82f2269b68b1d30c8a2286c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359dfdc82f2269b68b1d30c8a2286c6f">&#9670;&nbsp;</a></span>end_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="aa76498325599ace7304627cb64e5fcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76498325599ace7304627cb64e5fcd2">&#9670;&nbsp;</a></span>begin_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used vertex. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="a0e8705fe160c08af9a2372c605525ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8705fe160c08af9a2372c605525ef0">&#9670;&nbsp;</a></span>begin_active_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active vertex. Because all vertices are active, <a class="el" href="classTriangulation.html#aa76498325599ace7304627cb64e5fcd2">begin_vertex()</a> and <a class="el" href="classTriangulation.html#a0e8705fe160c08af9a2372c605525ef0">begin_active_vertex()</a> return the same vertex. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="aaad93f466afba9b3f003d09a685a615f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad93f466afba9b3f003d09a685a615f">&#9670;&nbsp;</a></span>end_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="a46edbe1027405ca9545e3c2289eb3938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46edbe1027405ca9545e3c2289eb3938">&#9670;&nbsp;</a></span>n_lines() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In the following, most functions are provided in two versions, with and without an argument describing the level. The versions with this argument are only applicable for objects describing the cells of the present triangulation. For example: in 2D <code>n_lines(level)</code> cannot be called, only <code><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a></code>, as lines are faces in 2D and therefore have no level. Return the total number of used lines, active or not. </p>

</div>
</div>
<a id="aee5ba9d51dfdd307da590e31c9262c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5ba9d51dfdd307da590e31c9262c28">&#9670;&nbsp;</a></span>n_lines() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used lines, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="a76c9d6f7b2068f5afa429020086b6b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c9d6f7b2068f5afa429020086b6b8c">&#9670;&nbsp;</a></span>n_active_lines() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active lines. </p>

</div>
</div>
<a id="a21d30203bdeaa3b9e2b416f24b7e9d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d30203bdeaa3b9e2b416f24b7e9d6d">&#9670;&nbsp;</a></span>n_active_lines() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active lines, on level <code>level</code>. </p>

</div>
</div>
<a id="a105d0305d8c801076bea2404087f29a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105d0305d8c801076bea2404087f29a7">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used quads, active or not. </p>

</div>
</div>
<a id="af0817fceed7429359f89928eec87d381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0817fceed7429359f89928eec87d381">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used quads, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="ab7a0837c6dabdda21930bf3d49e9852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a0837c6dabdda21930bf3d49e9852d">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active quads, active or not. </p>

</div>
</div>
<a id="abf97ad6187b553b2980043dd1c8d75db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf97ad6187b553b2980043dd1c8d75db">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active quads, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="aaa75fe811e9d1707ce798f874aa2e117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa75fe811e9d1707ce798f874aa2e117">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used hexahedra, active or not. </p>

</div>
</div>
<a id="a015bc7a2fecb2cba52050a8f2bfbafe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015bc7a2fecb2cba52050a8f2bfbafe1">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used hexahedra, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="aee621a8e59e259c252ccc64f19e37301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee621a8e59e259c252ccc64f19e37301">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active hexahedra, active or not. </p>

</div>
</div>
<a id="ade8bbb4c8ffd9f8adb683b39a82a9b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8bbb4c8ffd9f8adb683b39a82a9b1e">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active hexahedra, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="abea687f123f3f5a8b09d7485cf03be72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea687f123f3f5a8b09d7485cf03be72">&#9670;&nbsp;</a></span>n_cells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used cells, active or not. Maps to <code><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a></code> in one space dimension and so on. </p>

</div>
</div>
<a id="a40c5623c62d2e43aa63f1eb4904eeec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c5623c62d2e43aa63f1eb4904eeec8">&#9670;&nbsp;</a></span>n_cells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used cells, active or not, on level <code>level</code>. Maps to <code>n_lines(level)</code> in one space dimension and so on. </p>

</div>
</div>
<a id="a5ea5c9957dbb566a562bbe2c0f3971e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea5c9957dbb566a562bbe2c0f3971e9">&#9670;&nbsp;</a></span>n_active_cells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active cells. Maps to <code><a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines()</a></code> in one space dimension and so on. </p>

</div>
</div>
<a id="a3d106ed8c9a29d6bb7d2bfb636f8df62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d106ed8c9a29d6bb7d2bfb636f8df62">&#9670;&nbsp;</a></span>n_active_cells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active cells on level <code>level</code>. Maps to <code>n_active_lines(level)</code> in one space dimension and so on. </p>

</div>
</div>
<a id="a1e297d311818e3a79bcede5804f51065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e297d311818e3a79bcede5804f51065">&#9670;&nbsp;</a></span>n_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used faces, active or not. In 2D, the result equals <a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a>, in 3D it equals <a class="el" href="classTriangulation.html#a105d0305d8c801076bea2404087f29a7">n_quads()</a>, while in 1D it equals the number of used vertices. </p>

</div>
</div>
<a id="a5ae907d55b3b12c5c75e58174c1781ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae907d55b3b12c5c75e58174c1781ff">&#9670;&nbsp;</a></span>n_active_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active faces. In 2D, the result equals <a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines()</a>, in 3D it equals <a class="el" href="classTriangulation.html#ab7a0837c6dabdda21930bf3d49e9852d">n_active_quads()</a>, while in 1D it equals the number of used vertices. </p>

</div>
</div>
<a id="a777f035a17e91a4d822971516ca11db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777f035a17e91a4d822971516ca11db5">&#9670;&nbsp;</a></span>n_levels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_levels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of levels in this triangulation.</p>
<dl class="section note"><dt>Note</dt><dd>Internally, triangulations store data in levels, and there may be more levels in this data structure than one may think &ndash; for example, imagine a triangulation that we just got by coarsening the highest level so that it was completely depopulated. That level is not removed, since it will most likely be repopulated soon by the next refinement process. As a consequence, if you happened to run through raw cell iterators (which you can't do as a user of this class, but can internally), then the number of objects in the levels hierarchy is larger than the level of the most refined cell plus one. On the other hand, since this is rarely what a user of this class cares about, the function really just returns the level of the most refined active cell plus one. (The plus one is because in a coarse, unrefined mesh, all cells have level zero &ndash; making the number of levels equal to one.) </dd></dl>

</div>
</div>
<a id="ae1aadc2300ef9a6f2368fe7bc5926fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1aadc2300ef9a6f2368fe7bc5926fe8">&#9670;&nbsp;</a></span>n_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of vertices. Some of them may not be used, which usually happens upon coarsening of a triangulation when some vertices are discarded, but we do not want to renumber the remaining ones, leading to holes in the numbers of used vertices. You can get the number of used vertices using <code>n_used_vertices</code> function. </p>

</div>
</div>
<a id="afb3059d54432e0d739534e5330bb7b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3059d54432e0d739534e5330bb7b3a">&#9670;&nbsp;</a></span>get_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt;&amp; <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to all the vertices present in this triangulation. Note that not necessarily all vertices in this array are actually used; for example, if you coarsen a mesh, then some vertices are deleted, but their positions in this array are unchanged as the indices of vertices are only allocated once. You can find out about which vertices are actually used by the function <a class="el" href="classTriangulation.html#a07690a619d2817f4c8ef3bb74c43b80a">get_used_vertices()</a>. </p>

</div>
</div>
<a id="a76937acd9dfc3ade1fb885c7ab1ae776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76937acd9dfc3ade1fb885c7ab1ae776">&#9670;&nbsp;</a></span>n_used_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_used_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of vertices that are presently in use, i.e. belong to at least one used element. </p>

</div>
</div>
<a id="aab2295fdb4bfc8ab41f51cdbc34de449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2295fdb4bfc8ab41f51cdbc34de449">&#9670;&nbsp;</a></span>vertex_used()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertex_used </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if the vertex with this <code>index</code> is used. </p>

</div>
</div>
<a id="a07690a619d2817f4c8ef3bb74c43b80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07690a619d2817f4c8ef3bb74c43b80a">&#9670;&nbsp;</a></span>get_used_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt;&amp; <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_used_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to the array of <code>bools</code> indicating whether an entry in the vertex array is used or not. </p>

</div>
</div>
<a id="aa6313a19a8cc20e07249978218b5ca6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6313a19a8cc20e07249978218b5ca6a">&#9670;&nbsp;</a></span>max_adjacent_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::max_adjacent_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximum number of cells meeting at a common vertex. Since this number is an invariant under refinement, only the cells on the coarsest level are considered. The operation is thus reasonably fast. The invariance is only true for sufficiently many cells in the coarsest triangulation (e.g. for a single cell one would be returned), so a minimum of four is returned in two dimensions, 8 in three dimensions, etc, which is how many cells meet if the triangulation is refined.</p>
<p>In one space dimension, two is returned. </p>

</div>
</div>
<a id="acbcac8668993d582f192d3c85b642dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcac8668993d582f192d3c85b642dd3">&#9670;&nbsp;</a></span>get_triangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the current object.</p>
<p>This doesn't seem to be very useful but allows to write code that can access the underlying triangulation for anything that satisfies the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a> (which may not only be a triangulation, but also a <a class="el" href="classDoFHandler.html">DoFHandler</a>, for example). </p>

</div>
</div>
<a id="aae427477f592d34c1bf3367e408f90c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae427477f592d34c1bf3367e408f90c3">&#9670;&nbsp;</a></span>get_triangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the current object. This is the const-version of the previous function. </p>

</div>
</div>
<a id="a4a466c6b1755b353d43ce8827b1518e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a466c6b1755b353d43ce8827b1518e3">&#9670;&nbsp;</a></span>n_raw_lines() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of lines, used or unused.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a615e8e8877a420fede76cea831f6ca52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615e8e8877a420fede76cea831f6ca52">&#9670;&nbsp;</a></span>n_raw_lines() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of lines, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="abbcdcdaea38195ba043370ddc6202224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcdcdaea38195ba043370ddc6202224">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of quads, used or unused.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a9f590c6799cf3bb79c3c810f972a117e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f590c6799cf3bb79c3c810f972a117e">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of quads, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="aed5a359c972a4679b5ff1be96b68efc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5a359c972a4679b5ff1be96b68efc1">&#9670;&nbsp;</a></span>n_raw_hexs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of hexs, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a947c26f9d04c1b4a4fb190334ebd1542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947c26f9d04c1b4a4fb190334ebd1542">&#9670;&nbsp;</a></span>n_raw_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of cells, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a5a7926c72a24cc478de8217c1f6988e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7926c72a24cc478de8217c1f6988e0">&#9670;&nbsp;</a></span>n_raw_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of faces, used or not. In 2d, the result equals <a class="el" href="classTriangulation.html#a4a466c6b1755b353d43ce8827b1518e3">n_raw_lines()</a>, in 3d it equals <a class="el" href="classTriangulation.html#abbcdcdaea38195ba043370ddc6202224">n_raw_quads()</a>, while in 1D it equals the number of vertices.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a7117ea716b516ef11a205a5d0020fe40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7117ea716b516ef11a205a5d0020fe40">&#9670;&nbsp;</a></span>add_periodicity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::add_periodicity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare the (coarse) face pairs given in the argument of this function as periodic. This way it is possible to obtain neighbors across periodic boundaries.</p>
<p>The vector can be filled by the function <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>.</p>
<p>For more information on periodic boundary conditions see <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>, <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints</a> and step-45.</p>
<dl class="section note"><dt>Note</dt><dd>Before this function can be used the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a> has to be initialized and must not be refined. </dd></dl>

</div>
</div>
<a id="ac34318b9fb11fa49f10ba7c5155960c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34318b9fb11fa49f10ba7c5155960c6">&#9670;&nbsp;</a></span>get_periodic_face_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::pair&lt;<a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, std::pair&lt;std::pair&lt;<a class="el" href="group__Iterators.html#ga48cef91f67c38d6ec17912922de00f90">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, std::bitset&lt;3&gt; &gt; &gt;&amp; <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_periodic_face_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the periodic_face_map. </p>

</div>
</div>
<a id="af4f08d0df83f6455dbdac86c1a0736b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f08d0df83f6455dbdac86c1a0736b8">&#9670;&nbsp;</a></span>get_reference_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classReferenceCell.html">ReferenceCell</a>&gt;&amp; <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_reference_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return vector filled with the used reference-cell types of this triangulation. </p>

</div>
</div>
<a id="a24c84e9fa932ccd35820fe68abfe1348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c84e9fa932ccd35820fe68abfe1348">&#9670;&nbsp;</a></span>all_reference_cells_are_hyper_cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::all_reference_cells_are_hyper_cube </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate if the triangulation only consists of hypercube-like cells, i.e., lines, quadrilaterals, or hexahedra. </p>

</div>
</div>
<a id="ac70afc9a4f52455c18183ab31dd6789f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70afc9a4f52455c18183ab31dd6789f">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization. using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a50c4100869e8b9e63a082320a59e7d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c4100869e8b9e63a082320a59e7d92">&#9670;&nbsp;</a></span>::FETools::internal::ExtrapolateImplementation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;int , int , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::FETools::internal::ExtrapolateImplementation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="distributed_2tria_8h_source.html#l00814">814</a> of file <a class="el" href="distributed_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a30e9b1ae1a0d06897814df4e5481ac4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e9b1ae1a0d06897814df4e5481ac4e">&#9670;&nbsp;</a></span>TemporarilyMatchRefineFlags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;int , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classparallel_1_1distributed_1_1TemporarilyMatchRefineFlags.html">TemporarilyMatchRefineFlags</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="distributed_2tria_8h_source.html#l00817">817</a> of file <a class="el" href="distributed_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab24d740e69f0f8817b6c0abd7c46bb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24d740e69f0f8817b6c0abd7c46bb45">&#9670;&nbsp;</a></span>settings</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13">Settings</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::settings</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>store the Settings. </p>

<p class="definition">Definition at line <a class="el" href="distributed_2tria_8h_source.html#l00677">677</a> of file <a class="el" href="distributed_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a20283ec6daa76bcfafe7540fa5b4c3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20283ec6daa76bcfafe7540fa5b4c3ab">&#9670;&nbsp;</a></span>triangulation_has_content</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::triangulation_has_content</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A flag that indicates whether the triangulation has actual content. </p>

<p class="definition">Definition at line <a class="el" href="distributed_2tria_8h_source.html#l00682">682</a> of file <a class="el" href="distributed_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ae5d77880dff14f4e373bfc85b0372cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d77880dff14f4e373bfc85b0372cbd">&#9670;&nbsp;</a></span>connectivity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt;dim&gt;::connectivity* <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::connectivity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A data structure that holds the connectivity between trees. Since each tree is rooted in a coarse grid cell, this data structure holds the connectivity between the cells of the coarse grid. </p>

<p class="definition">Definition at line <a class="el" href="distributed_2tria_8h_source.html#l00689">689</a> of file <a class="el" href="distributed_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="afa33ee8b97c37ea611c10fb105b43a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa33ee8b97c37ea611c10fb105b43a18">&#9670;&nbsp;</a></span>parallel_forest</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt;dim&gt;::forest* <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::parallel_forest</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A data structure that holds the local part of the global triangulation. </p>

<p class="definition">Definition at line <a class="el" href="distributed_2tria_8h_source.html#l00695">695</a> of file <a class="el" href="distributed_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a44ad171a487b4a1ace0c747c7ba9a650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ad171a487b4a1ace0c747c7ba9a650">&#9670;&nbsp;</a></span>parallel_ghost</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::<a class="el" href="structinternal_1_1p4est_1_1types.html">internal::p4est::types</a>&lt;dim&gt;::ghost* <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::parallel_ghost</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A data structure that holds some information about the ghost cells of the triangulation. </p>

<p class="definition">Definition at line <a class="el" href="distributed_2tria_8h_source.html#l00701">701</a> of file <a class="el" href="distributed_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ae7d48b3a3c96e351aad2b550bd1baa4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d48b3a3c96e351aad2b550bd1baa4f">&#9670;&nbsp;</a></span>coarse_cell_to_p4est_tree_permutation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&gt; <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::coarse_cell_to_p4est_tree_permutation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Two arrays that store which p4est tree corresponds to which coarse grid cell and vice versa. We need these arrays because p4est goes with the original order of coarse cells when it sets up its forest, and then applies the Morton ordering within each tree. But if coarse grid cells are badly ordered this may mean that individual parts of the forest stored on a local machine may be split across coarse grid cells that are not geometrically close. Consequently, we apply a hierarchical preordering according to <a class="el" href="namespaceSparsityTools.html#a576797328aeace287d271ee4e48e04a6">SparsityTools::reorder_hierarchical()</a> to ensure that the part of the forest stored by p4est is located on geometrically close coarse grid cells. </p>

<p class="definition">Definition at line <a class="el" href="distributed_2tria_8h_source.html#l00741">741</a> of file <a class="el" href="distributed_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a5cb403db4f9fb3d529ce133378ef1b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb403db4f9fb3d529ce133378ef1b48">&#9670;&nbsp;</a></span>p4est_tree_to_coarse_cell_permutation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&gt; <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt;::p4est_tree_to_coarse_cell_permutation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="distributed_2tria_8h_source.html#l00743">743</a> of file <a class="el" href="distributed_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a891e1057149129681a27bab8ffc10d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891e1057149129681a27bab8ffc10d19">&#9670;&nbsp;</a></span>local_cell_relations</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classparallel_1_1DistributedTriangulationBase.html#ae36be1617767da4972eb996d9325902f">cell_relation_t</a>&gt; <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::local_cell_relations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classVector.html">Vector</a> of pairs, each containing a deal.II cell iterator and its respective CellStatus. To update its contents, use the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa76bd5ba9c0072f52360805b5139cb61">update_cell_relations()</a> member function. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00708">708</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="a5979f543c847e88743216cb5986f7107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5979f543c847e88743216cb5986f7107">&#9670;&nbsp;</a></span>cell_attached_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structparallel_1_1DistributedTriangulationBase_1_1CellAttachedData.html">CellAttachedData</a> <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::cell_attached_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00741">741</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="afd423107278fb82665a4a64f0a6da6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd423107278fb82665a4a64f0a6da6d2">&#9670;&nbsp;</a></span>data_transfer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1DistributedTriangulationBase_1_1DataTransfer.html">DataTransfer</a> <a class="el" href="classparallel_1_1DistributedTriangulationBase.html">parallel::DistributedTriangulationBase</a>&lt; dim, spacedim &gt;::data_transfer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00896">896</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="a55959d63f6a4e18cae86f005df8605ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55959d63f6a4e18cae86f005df8605ec">&#9670;&nbsp;</a></span>mpi_communicator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::mpi_communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>MPI communicator to be used for the triangulation. We create a unique communicator for this class, which is a duplicate of the one passed to the constructor. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00301">301</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="addf7a809217fa1eb11b8c06c49b1b2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf7a809217fa1eb11b8c06c49b1b2cb">&#9670;&nbsp;</a></span>my_subdomain</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::my_subdomain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The subdomain id to be used for the current processor. This is the MPI rank. </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00307">307</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="a25846dd7a465319119e91f44d77ae0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25846dd7a465319119e91f44d77ae0b1">&#9670;&nbsp;</a></span>n_subdomains</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::n_subdomains</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The total number of subdomains (or the size of the MPI communicator). </p>

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00312">312</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="aad29d4b50a16239861deb2bb07bc6089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad29d4b50a16239861deb2bb07bc6089">&#9670;&nbsp;</a></span>number_cache</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structparallel_1_1TriangulationBase_1_1NumberCache.html">NumberCache</a> <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>&lt; dim, spacedim &gt;::number_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__base_8h_source.html#l00370">370</a> of file <a class="el" href="tria__base_8h_source.html">tria_base.h</a>.</p>

</div>
</div>
<a id="aefd8ddbf96799abebb6c05dced569329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd8ddbf96799abebb6c05dced569329">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the dimension available in function templates. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01542">1542</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a3414a986e63a95d54e961b9b35d756fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3414a986e63a95d54e961b9b35d756fb">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the space-dimension available in function templates. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01547">1547</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ad136f601f63a6d1bd8e205edd93cbae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad136f601f63a6d1bd8e205edd93cbae3">&#9670;&nbsp;</a></span>signals</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTriangulation_1_1Signals.html">Signals</a> <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::signals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signals for the various actions that a triangulation can do to itself. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l02289">2289</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/distributed/<a class="el" href="distributed_2tria_8h_source.html">tria.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
