<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_0a.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-0a tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-0a tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="23个设计模式"></a></p>
<p>TODO: doxygen it!</p>
<p>参考:</p><ul>
<li>《图说设计模式》- <a href="https://github.com/me115/design_patterns">https://github.com/me115/design_patterns</a></li>
<li>《深入设计模式》- Alexander Shvets</li>
<li>《设计模式》- 4人组</li>
<li>博士论文 - A Framework for Developing Finite Element Codes for MultiDisciplinary Applications</li>
</ul>
<h1>一. 创建型模式 </h1>
<p>创建型模式提供了创建对象的机制,能够提升已有代码的灵活性和可复用性。</p>
<p><a class="anchor" id="1FactoryMethod"></a></p><h2>1. 工厂方法 Factory Method </h2>
<p>在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型。</p>
<p>优缺点</p><ul>
<li>你可以避免创建者和具体产品之间的紧密耦合。</li>
<li>单一职责原则。你可以将产品创建代码放在程序的单一位置, 从而使得代码更容易维护。</li>
<li>开闭原则。无需更改现有客户端代码,你就可以在程序中引入新的产品类型。</li>
<li>应用工厂方法模式需要引入许多新的子类,代码可能会因此变得更复杂。最好的情况是将该模式引入创建者类的现有层次结构中。</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Product {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~Product() {}</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation() <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteProduct1 : <span class="keyword">public</span> Product {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;{Result of the ConcreteProduct1}&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keyword">class </span>ConcreteProduct2 : <span class="keyword">public</span> Product {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;{Result of the ConcreteProduct2}&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Creator {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~Creator(){};</div><div class="line">  <span class="keyword">virtual</span> Product* FactoryMethod() <span class="keyword">const</span> = 0;</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> SomeOperation()<span class="keyword"> const </span>{</div><div class="line">    <span class="comment">// Call the factory method to create a Product object.</span></div><div class="line">    Product* product = this-&gt;FactoryMethod();</div><div class="line">    <span class="comment">// Now, use the product.</span></div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> result = <span class="stringliteral">&quot;Creator: The same creator&#39;s code has just worked with &quot;</span> + product-&gt;Operation();</div><div class="line">    <span class="keyword">delete</span> product;</div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteCreator1 : <span class="keyword">public</span> Creator {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Product* FactoryMethod()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProduct1();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteCreator2 : <span class="keyword">public</span> Creator {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Product* FactoryMethod()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProduct2();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(<span class="keyword">const</span> Creator&amp; creator) {</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: I&#39;m not aware of the creator&#39;s class, but it still works.\n&quot;</span></div><div class="line">            &lt;&lt; creator.SomeOperation() &lt;&lt; std::endl;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;App: Launched with the ConcreteCreator1.\n&quot;</span>;</div><div class="line">  Creator* creator = <span class="keyword">new</span> ConcreteCreator1();</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(*creator);</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;App: Launched with the ConcreteCreator2.\n&quot;</span>;</div><div class="line">  Creator* creator2 = <span class="keyword">new</span> ConcreteCreator2();</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(*creator2);</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> creator;</div><div class="line">  <span class="keyword">delete</span> creator2;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="2AbstractFactory"></a></p><h2>2. 抽象工厂 Abstract Factory </h2>
<p>让你能创建一系列相关的对象,而无需指定其具体类。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>AbstractProductA {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~AbstractProductA(){};</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionA() <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteProductA1 : <span class="keyword">public</span> AbstractProductA {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionA()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product A1.&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteProductA2 : <span class="keyword">public</span> AbstractProductA {</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionA()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product A2.&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>AbstractProductB {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~AbstractProductB(){};</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionB() <span class="keyword">const</span> = 0;</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> AnotherUsefulFunctionB(<span class="keyword">const</span> AbstractProductA &amp;collaborator) <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteProductB1 : <span class="keyword">public</span> AbstractProductB {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionB()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product B1.&quot;</span>;</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> AnotherUsefulFunctionB(<span class="keyword">const</span> AbstractProductA &amp;collaborator)<span class="keyword"> const override </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> result = collaborator.UsefulFunctionA();</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the B1 collaborating with ( &quot;</span> + result + <span class="stringliteral">&quot; )&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteProductB2 : <span class="keyword">public</span> AbstractProductB {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionB()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product B2.&quot;</span>;</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> AnotherUsefulFunctionB(<span class="keyword">const</span> AbstractProductA &amp;collaborator)<span class="keyword"> const override </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> result = collaborator.UsefulFunctionA();</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the B2 collaborating with ( &quot;</span> + result + <span class="stringliteral">&quot; )&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>AbstractFactory {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> AbstractProductA *CreateProductA() <span class="keyword">const</span> = 0;</div><div class="line">  <span class="keyword">virtual</span> AbstractProductB *CreateProductB() <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteFactory1 : <span class="keyword">public</span> AbstractFactory {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  AbstractProductA *CreateProductA()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductA1();</div><div class="line">  }</div><div class="line">  AbstractProductB *CreateProductB()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductB1();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteFactory2 : <span class="keyword">public</span> AbstractFactory {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  AbstractProductA *CreateProductA()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductA2();</div><div class="line">  }</div><div class="line">  AbstractProductB *CreateProductB()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductB2();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(<span class="keyword">const</span> AbstractFactory &amp;factory) {</div><div class="line">  <span class="keyword">const</span> AbstractProductA *product_a = factory.CreateProductA();</div><div class="line">  <span class="keyword">const</span> AbstractProductB *product_b = factory.CreateProductB();</div><div class="line">  std::cout &lt;&lt; product_b-&gt;UsefulFunctionB() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; product_b-&gt;AnotherUsefulFunctionB(*product_a) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  <span class="keyword">delete</span> product_a;</div><div class="line">  <span class="keyword">delete</span> product_b;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: Testing client code with the first factory type:\n&quot;</span>;</div><div class="line">  ConcreteFactory1 *f1 = <span class="keyword">new</span> ConcreteFactory1();</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(*f1);</div><div class="line">  <span class="keyword">delete</span> f1;</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: Testing the same client code with the second factory type:\n&quot;</span>;</div><div class="line">  ConcreteFactory2 *f2 = <span class="keyword">new</span> ConcreteFactory2();</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(*f2);</div><div class="line">  <span class="keyword">delete</span> f2;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="3Builder"></a></p><h2>3. 生成器 Builder </h2>
<p>使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Product1{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    std::vector&lt;std::string&gt; parts_;</div><div class="line">    <span class="keywordtype">void</span> ListParts()<span class="keyword">const</span>{</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Product parts: &quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;parts_.size();i++){</div><div class="line">            <span class="keywordflow">if</span>(parts_[i]== parts_.back()){</div><div class="line">                std::cout &lt;&lt; parts_[i];</div><div class="line">            }<span class="keywordflow">else</span>{</div><div class="line">                std::cout &lt;&lt; parts_[i] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>; </div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>Builder{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> ~Builder(){}</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> ProducePartA() <span class="keyword">const</span> =0;</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> ProducePartB() <span class="keyword">const</span> =0;</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> ProducePartC() <span class="keyword">const</span> =0;</div><div class="line">};</div><div class="line"><span class="keyword">class </span>ConcreteBuilder1 : <span class="keyword">public</span> Builder{</div><div class="line">    <span class="keyword">private</span>:</div><div class="line"></div><div class="line">    Product1* product;</div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line"></div><div class="line">    ConcreteBuilder1(){</div><div class="line">        this-&gt;Reset();</div><div class="line">    }</div><div class="line"></div><div class="line">    ~ConcreteBuilder1(){</div><div class="line">        <span class="keyword">delete</span> product;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> Reset(){</div><div class="line">        this-&gt;product= <span class="keyword">new</span> Product1();</div><div class="line">    }</div><div class="line">    <span class="keywordtype">void</span> ProducePartA()<span class="keyword">const override</span>{</div><div class="line">        this-&gt;product-&gt;parts_.push_back(<span class="stringliteral">&quot;PartA1&quot;</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> ProducePartB()<span class="keyword">const override</span>{</div><div class="line">        this-&gt;product-&gt;parts_.push_back(<span class="stringliteral">&quot;PartB1&quot;</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> ProducePartC()<span class="keyword">const override</span>{</div><div class="line">        this-&gt;product-&gt;parts_.push_back(<span class="stringliteral">&quot;PartC1&quot;</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    Product1* GetProduct() {</div><div class="line">        Product1* result= this-&gt;product;</div><div class="line">        this-&gt;Reset();</div><div class="line">        <span class="keywordflow">return</span> result;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Director{</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    Builder* builder;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> set_builder(Builder* builder){</div><div class="line">        this-&gt;builder=builder;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> BuildMinimalViableProduct(){</div><div class="line">        this-&gt;builder-&gt;ProducePartA();</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordtype">void</span> BuildFullFeaturedProduct(){</div><div class="line">        this-&gt;builder-&gt;ProducePartA();</div><div class="line">        this-&gt;builder-&gt;ProducePartB();</div><div class="line">        this-&gt;builder-&gt;ProducePartC();</div><div class="line">    }</div><div class="line">};</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(Director&amp; director)</div><div class="line">{</div><div class="line">    ConcreteBuilder1* builder = <span class="keyword">new</span> ConcreteBuilder1();</div><div class="line">    director.set_builder(builder);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Standard basic product:\n&quot;</span>; </div><div class="line">    director.BuildMinimalViableProduct();</div><div class="line">    </div><div class="line">    Product1* p= builder-&gt;GetProduct();</div><div class="line">    p-&gt;ListParts();</div><div class="line">    <span class="keyword">delete</span> p;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Standard full featured product:\n&quot;</span>; </div><div class="line">    director.BuildFullFeaturedProduct();</div><div class="line"></div><div class="line">    p= builder-&gt;GetProduct();</div><div class="line">    p-&gt;ListParts();</div><div class="line">    <span class="keyword">delete</span> p;</div><div class="line"></div><div class="line">    <span class="comment">// Remember, the Builder pattern can be used without a Director class.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Custom product:\n&quot;</span>;</div><div class="line">    builder-&gt;ProducePartA();</div><div class="line">    builder-&gt;ProducePartC();</div><div class="line">    p=builder-&gt;GetProduct();</div><div class="line">    p-&gt;ListParts();</div><div class="line">    <span class="keyword">delete</span> p;</div><div class="line"></div><div class="line">    <span class="keyword">delete</span> builder;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">    Director* director= <span class="keyword">new</span> Director();</div><div class="line">    <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(*director);</div><div class="line">    <span class="keyword">delete</span> director;</div><div class="line">    <span class="keywordflow">return</span> 0;    </div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="4Prototype"></a></p><h2>4. 原型 Prototype </h2>
<p>让你能够复制已有对象,而又无需使代码依赖它们所属的类。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a>;</div><div class="line"></div><div class="line"><span class="keyword">enum</span> <a class="code" href="namespaceDesignPattern_1_1Prototype.html#aa2ba50cf2b98f70099de1d548884afb8">Type</a> {</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1Prototype.html#aa2ba50cf2b98f70099de1d548884afb8a071a6e5c9d11b7c03994be403474e538">PROTOTYPE_1</a> = 0,</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1Prototype.html#aa2ba50cf2b98f70099de1d548884afb8a47a4b1184946ae003d89e4d0d7a60666">PROTOTYPE_2</a></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Prototype {</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  <span class="keywordtype">string</span> prototype_name_;</div><div class="line">  <span class="keywordtype">float</span> prototype_field_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Prototype() {}</div><div class="line">  Prototype(<span class="keywordtype">string</span> prototype_name)</div><div class="line">      : prototype_name_(prototype_name) {</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> ~Prototype() {}</div><div class="line">  <span class="keyword">virtual</span> Prototype *Clone() <span class="keyword">const</span> = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Method(<span class="keywordtype">float</span> prototype_field) {</div><div class="line">    this-&gt;prototype_field_ = prototype_field;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Call Method from &quot;</span> &lt;&lt; prototype_name_ &lt;&lt; <span class="stringliteral">&quot; with field : &quot;</span> &lt;&lt; prototype_field &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcretePrototype1 : <span class="keyword">public</span> Prototype {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">float</span> concrete_prototype_field1_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  ConcretePrototype1(<span class="keywordtype">string</span> prototype_name, <span class="keywordtype">float</span> concrete_prototype_field)</div><div class="line">      : Prototype(prototype_name), concrete_prototype_field1_(concrete_prototype_field) {</div><div class="line">  }</div><div class="line"></div><div class="line">  Prototype *Clone()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcretePrototype1(*<span class="keyword">this</span>);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcretePrototype2 : <span class="keyword">public</span> Prototype {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">float</span> concrete_prototype_field2_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  ConcretePrototype2(<span class="keywordtype">string</span> prototype_name, <span class="keywordtype">float</span> concrete_prototype_field)</div><div class="line">      : Prototype(prototype_name), concrete_prototype_field2_(concrete_prototype_field) {</div><div class="line">  }</div><div class="line">  Prototype *Clone()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcretePrototype2(*<span class="keyword">this</span>);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>PrototypeFactory {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  std::unordered_map&lt;Type, Prototype *, std::hash&lt;int&gt;&gt; prototypes_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  PrototypeFactory() {</div><div class="line">    prototypes_[<a class="code" href="namespaceDesignPattern_1_1Prototype.html#aa2ba50cf2b98f70099de1d548884afb8a071a6e5c9d11b7c03994be403474e538">Type::PROTOTYPE_1</a>] = <span class="keyword">new</span> ConcretePrototype1(<span class="stringliteral">&quot;PROTOTYPE_1 &quot;</span>, 50.f);</div><div class="line">    prototypes_[<a class="code" href="namespaceDesignPattern_1_1Prototype.html#aa2ba50cf2b98f70099de1d548884afb8a47a4b1184946ae003d89e4d0d7a60666">Type::PROTOTYPE_2</a>] = <span class="keyword">new</span> ConcretePrototype2(<span class="stringliteral">&quot;PROTOTYPE_2 &quot;</span>, 60.f);</div><div class="line">  }</div><div class="line"></div><div class="line">  ~PrototypeFactory() {</div><div class="line">    <span class="keyword">delete</span> prototypes_[<a class="code" href="namespaceDesignPattern_1_1Prototype.html#aa2ba50cf2b98f70099de1d548884afb8a071a6e5c9d11b7c03994be403474e538">Type::PROTOTYPE_1</a>];</div><div class="line">    <span class="keyword">delete</span> prototypes_[<a class="code" href="namespaceDesignPattern_1_1Prototype.html#aa2ba50cf2b98f70099de1d548884afb8a47a4b1184946ae003d89e4d0d7a60666">Type::PROTOTYPE_2</a>];</div><div class="line">  }</div><div class="line"></div><div class="line">  Prototype *CreatePrototype(<a class="code" href="namespaceDesignPattern_1_1Prototype.html#aa2ba50cf2b98f70099de1d548884afb8">Type</a> type) {</div><div class="line">    <span class="keywordflow">return</span> prototypes_[type]-&gt;Clone();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1Prototype.html#a3963e936396bbd56fe1c2ec5ad4a3ac0">Client</a>(PrototypeFactory &amp;prototype_factory) {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Let&#39;s create a Prototype 1\n&quot;</span>;</div><div class="line"></div><div class="line">  Prototype *prototype = prototype_factory.CreatePrototype(<a class="code" href="namespaceDesignPattern_1_1Prototype.html#aa2ba50cf2b98f70099de1d548884afb8a071a6e5c9d11b7c03994be403474e538">Type::PROTOTYPE_1</a>);</div><div class="line">  prototype-&gt;Method(90);</div><div class="line">  <span class="keyword">delete</span> prototype;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Let&#39;s create a Prototype 2 \n&quot;</span>;</div><div class="line"></div><div class="line">  prototype = prototype_factory.CreatePrototype(<a class="code" href="namespaceDesignPattern_1_1Prototype.html#aa2ba50cf2b98f70099de1d548884afb8a47a4b1184946ae003d89e4d0d7a60666">Type::PROTOTYPE_2</a>);</div><div class="line">  prototype-&gt;Method(10);</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> prototype;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  PrototypeFactory *prototype_factory = <span class="keyword">new</span> PrototypeFactory();</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1Prototype.html#a3963e936396bbd56fe1c2ec5ad4a3ac0">Client</a>(*prototype_factory);</div><div class="line">  <span class="keyword">delete</span> prototype_factory;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="5Singleton"></a></p><h2>5. 单例 Singleton </h2>
<p>让你能够保证一个类只有一个实例,并提供一个访问该实例的全局节点。</p>
<p>NonThreadSafe </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Singleton</div><div class="line">{</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    Singleton(<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> value): value_(value)</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">static</span> Singleton* singleton_;</div><div class="line"></div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> value_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">    Singleton(Singleton &amp;other) = <span class="keyword">delete</span>;</div><div class="line">    <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</div><div class="line">    <span class="keyword">static</span> Singleton *GetInstance(<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a>&amp; value);</div><div class="line">    <span class="keywordtype">void</span> SomeBusinessLogic()</div><div class="line">    {</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>()<span class="keyword"> const</span>{</div><div class="line">        <span class="keywordflow">return</span> value_;</div><div class="line">    } </div><div class="line">};</div><div class="line"></div><div class="line">Singleton* Singleton::singleton_= <span class="keyword">nullptr</span>;;</div><div class="line"></div><div class="line">Singleton *Singleton::GetInstance(<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a>&amp; value)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>(singleton_==<span class="keyword">nullptr</span>){</div><div class="line">        singleton_ = <span class="keyword">new</span> Singleton(value);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> singleton_;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1Singleton.html#ab883621c0b6e943d2f3c555ef6dc438e">ThreadFoo</a>(){</div><div class="line">    <span class="comment">// 以下代码模拟了缓慢的初始化。</span></div><div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(1000));</div><div class="line">    Singleton* singleton = Singleton::GetInstance(<span class="stringliteral">&quot;FOO&quot;</span>);</div><div class="line">    std::cout &lt;&lt; singleton-&gt;value() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1Singleton.html#a2bd97c5743d2c3b28c929dd11e387eee">ThreadBar</a>(){</div><div class="line">    <span class="comment">// 以下代码模拟了缓慢的初始化。</span></div><div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(1000));</div><div class="line">    Singleton* singleton = Singleton::GetInstance(<span class="stringliteral">&quot;BAR&quot;</span>);</div><div class="line">    std::cout &lt;&lt; singleton-&gt;value() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    std::cout &lt;&lt;<span class="stringliteral">&quot;If you see the same value, then singleton was reused (yay!\n&quot;</span> &lt;&lt;</div><div class="line">                <span class="stringliteral">&quot;If you see different values, then 2 singletons were created (booo!!)\n\n&quot;</span> &lt;&lt;</div><div class="line">                <span class="stringliteral">&quot;RESULT:\n&quot;</span>;   </div><div class="line">    std::thread t1(<a class="code" href="namespaceDesignPattern_1_1Singleton.html#ab883621c0b6e943d2f3c555ef6dc438e">ThreadFoo</a>);</div><div class="line">    std::thread t2(<a class="code" href="namespaceDesignPattern_1_1Singleton.html#a2bd97c5743d2c3b28c929dd11e387eee">ThreadBar</a>);</div><div class="line">    t1.join();</div><div class="line">    t2.join();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>ThreadSafe </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Singleton</div><div class="line">{</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> Singleton * pinstance_;</div><div class="line">    <span class="keyword">static</span> std::mutex mutex_;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    Singleton(<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> value): value_(value)</div><div class="line">    {</div><div class="line">    }</div><div class="line">    ~Singleton() {}</div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> value_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Singleton(Singleton &amp;other) = <span class="keyword">delete</span>;</div><div class="line">    <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</div><div class="line">    <span class="keyword">static</span> Singleton *GetInstance(<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a>&amp; value);</div><div class="line">    <span class="keywordtype">void</span> SomeBusinessLogic()</div><div class="line">    {</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">    </div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> value()<span class="keyword"> const</span>{</div><div class="line">        <span class="keywordflow">return</span> value_;</div><div class="line">    } </div><div class="line">};</div><div class="line"></div><div class="line">Singleton* Singleton::pinstance_{<span class="keyword">nullptr</span>};</div><div class="line">std::mutex Singleton::mutex_;</div><div class="line"></div><div class="line">Singleton *Singleton::GetInstance(<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a>&amp; value)</div><div class="line">{</div><div class="line">    std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div><div class="line">    <span class="keywordflow">if</span> (pinstance_ == <span class="keyword">nullptr</span>)</div><div class="line">    {</div><div class="line">        pinstance_ = <span class="keyword">new</span> Singleton(value);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> pinstance_;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1Singleton.html#ab883621c0b6e943d2f3c555ef6dc438e">ThreadFoo</a>(){</div><div class="line">    <span class="comment">// 以下代码模拟了缓慢的初始化。</span></div><div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(1000));</div><div class="line">    Singleton* singleton = Singleton::GetInstance(<span class="stringliteral">&quot;FOO&quot;</span>);</div><div class="line">    std::cout &lt;&lt; singleton-&gt;value() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1Singleton.html#a2bd97c5743d2c3b28c929dd11e387eee">ThreadBar</a>(){</div><div class="line">    <span class="comment">// 以下代码模拟了缓慢的初始化。</span></div><div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(1000));</div><div class="line">    Singleton* singleton = Singleton::GetInstance(<span class="stringliteral">&quot;BAR&quot;</span>);</div><div class="line">    std::cout &lt;&lt; singleton-&gt;value() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{   </div><div class="line">    std::cout &lt;&lt;<span class="stringliteral">&quot;If you see the same value, then singleton was reused (yay!\n&quot;</span> &lt;&lt;</div><div class="line">                <span class="stringliteral">&quot;If you see different values, then 2 singletons were created (booo!!)\n\n&quot;</span> &lt;&lt;</div><div class="line">                <span class="stringliteral">&quot;RESULT:\n&quot;</span>;   </div><div class="line">    std::thread t1(<a class="code" href="namespaceDesignPattern_1_1Singleton.html#ab883621c0b6e943d2f3c555ef6dc438e">ThreadFoo</a>);</div><div class="line">    std::thread t2(<a class="code" href="namespaceDesignPattern_1_1Singleton.html#a2bd97c5743d2c3b28c929dd11e387eee">ThreadBar</a>);</div><div class="line">    t1.join();</div><div class="line">    t2.join();</div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1>二. 结构型模式 </h1>
<p><a class="anchor" id="6Adapter"></a></p><h2>6. 适配器 Adapter </h2>
<p>让接口不兼容的对象能够相互合作。</p>
<p>Normal </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Target {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~Target() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Request()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Target: The default target&#39;s behavior.&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Adaptee {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> SpecificRequest()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;.eetpadA eht fo roivaheb laicepS&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Adapter : <span class="keyword">public</span> Target {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  Adaptee *adaptee_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Adapter(Adaptee *adaptee) : adaptee_(adaptee) {}</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Request()<span class="keyword"> const override </span>{</div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> to_reverse = this-&gt;adaptee_-&gt;SpecificRequest();</div><div class="line">    <a class="code" href="namespacemystl.html#a1bd01cb8b4e1f829d264f5964e41e1b9">std::reverse</a>(to_reverse.begin(), to_reverse.end());</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Adapter: (TRANSLATED) &quot;</span> + to_reverse;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(<span class="keyword">const</span> Target *target) {</div><div class="line">  std::cout &lt;&lt; target-&gt;Request();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: I can work just fine with the Target objects:\n&quot;</span>;</div><div class="line">  Target *target = <span class="keyword">new</span> Target;</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(target);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div><div class="line">  Adaptee *adaptee = <span class="keyword">new</span> Adaptee;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: The Adaptee class has a weird interface. See, I don&#39;t understand it:\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Adaptee: &quot;</span> &lt;&lt; adaptee-&gt;SpecificRequest();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: But I can work with it via the Adapter:\n&quot;</span>;</div><div class="line">  Adapter *adapter = <span class="keyword">new</span> Adapter(adaptee);</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(adapter);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> target;</div><div class="line">  <span class="keyword">delete</span> adaptee;</div><div class="line">  <span class="keyword">delete</span> adapter;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>MultipleInheritance </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Target {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~Target() = <span class="keywordflow">default</span>;</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Request()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Target: The default target&#39;s behavior.&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Adaptee {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> SpecificRequest()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;.eetpadA eht fo roivaheb laicepS&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Adapter : <span class="keyword">public</span> Target, <span class="keyword">public</span> Adaptee {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Adapter() {}</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Request()<span class="keyword"> const override </span>{</div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> to_reverse = SpecificRequest();</div><div class="line">    <a class="code" href="namespacemystl.html#a1bd01cb8b4e1f829d264f5964e41e1b9">std::reverse</a>(to_reverse.begin(), to_reverse.end());</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Adapter: (TRANSLATED) &quot;</span> + to_reverse;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(<span class="keyword">const</span> Target *target) {</div><div class="line">  std::cout &lt;&lt; target-&gt;Request();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: I can work just fine with the Target objects:\n&quot;</span>;</div><div class="line">  Target *target = <span class="keyword">new</span> Target;</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(target);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div><div class="line">  Adaptee *adaptee = <span class="keyword">new</span> Adaptee;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: The Adaptee class has a weird interface. See, I don&#39;t understand it:\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Adaptee: &quot;</span> &lt;&lt; adaptee-&gt;SpecificRequest();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: But I can work with it via the Adapter:\n&quot;</span>;</div><div class="line">  Adapter *adapter = <span class="keyword">new</span> Adapter;</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(adapter);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> target;</div><div class="line">  <span class="keyword">delete</span> adaptee;</div><div class="line">  <span class="keyword">delete</span> adapter;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="7Bridge"></a></p><h2>7. 桥接 Bridge </h2>
<p>可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构,从而能在开发时分别使用。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Implementation {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~Implementation() {}</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> OperationImplementation() <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteImplementationA : <span class="keyword">public</span> Implementation {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> OperationImplementation()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;ConcreteImplementationA: Here&#39;s the result on the platform A.\n&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keyword">class </span>ConcreteImplementationB : <span class="keyword">public</span> Implementation {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> OperationImplementation()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;ConcreteImplementationB: Here&#39;s the result on the platform B.\n&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Abstraction {</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  Implementation* implementation_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Abstraction(Implementation* implementation) : implementation_(implementation) {</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> ~Abstraction() {</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Abstraction: Base operation with:\n&quot;</span> +</div><div class="line">           this-&gt;implementation_-&gt;OperationImplementation();</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keyword">class </span>ExtendedAbstraction : <span class="keyword">public</span> Abstraction {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  ExtendedAbstraction(Implementation* implementation) : Abstraction(implementation) {</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;ExtendedAbstraction: Extended operation with:\n&quot;</span> +</div><div class="line">           this-&gt;implementation_-&gt;OperationImplementation();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(<span class="keyword">const</span> Abstraction&amp; abstraction) {</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  std::cout &lt;&lt; abstraction.Operation();</div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Implementation* implementation = <span class="keyword">new</span> ConcreteImplementationA;</div><div class="line">  Abstraction* abstraction = <span class="keyword">new</span> Abstraction(implementation);</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(*abstraction);</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">  <span class="keyword">delete</span> implementation;</div><div class="line">  <span class="keyword">delete</span> abstraction;</div><div class="line"></div><div class="line">  implementation = <span class="keyword">new</span> ConcreteImplementationB;</div><div class="line">  abstraction = <span class="keyword">new</span> ExtendedAbstraction(implementation);</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(*abstraction);</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> implementation;</div><div class="line">  <span class="keyword">delete</span> abstraction;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="8Composite"></a></p><h2>8. 组合 Composite </h2>
<p>你可以使用它将对象组合成树状结构,并且能像使用独立对象一样使用它们。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="keyword">class </span>Component {</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  Component *parent_;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~Component() {}</div><div class="line">  <span class="keywordtype">void</span> SetParent(Component *parent) {</div><div class="line">    this-&gt;parent_ = parent;</div><div class="line">  }</div><div class="line">  Component *GetParent()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> this-&gt;parent_;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Add(Component *component) {}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Remove(Component *component) {}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> IsComposite()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation() <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"><span class="keyword">class </span>Leaf : <span class="keyword">public</span> Component {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Leaf&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keyword">class </span>Composite : <span class="keyword">public</span> Component {</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  std::list&lt;Component *&gt; children_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> Add(Component *component)<span class="keyword"> override </span>{</div><div class="line">    this-&gt;children_.push_back(component);</div><div class="line">    component-&gt;SetParent(<span class="keyword">this</span>);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> Remove(Component *component)<span class="keyword"> override </span>{</div><div class="line">    children_.remove(component);</div><div class="line">    component-&gt;SetParent(<span class="keyword">nullptr</span>);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">bool</span> IsComposite()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation()<span class="keyword"> const override </span>{</div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> result;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> Component *c : children_) {</div><div class="line">      <span class="keywordflow">if</span> (c == children_.back()) {</div><div class="line">        result += c-&gt;Operation();</div><div class="line">      } <span class="keywordflow">else</span> {</div><div class="line">        result += c-&gt;Operation() + <span class="stringliteral">&quot;+&quot;</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Branch(&quot;</span> + result + <span class="stringliteral">&quot;)&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(Component *component) {</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;RESULT: &quot;</span> &lt;&lt; component-&gt;Operation();</div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1Composite.html#a7106175a23e4e8a0efb57277faf4e7a6">ClientCode2</a>(Component *component1, Component *component2) {</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keywordflow">if</span> (component1-&gt;IsComposite()) {</div><div class="line">    component1-&gt;Add(component2);</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;RESULT: &quot;</span> &lt;&lt; component1-&gt;Operation();</div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Component *simple = <span class="keyword">new</span> Leaf;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: I&#39;ve got a simple component:\n&quot;</span>;</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(simple);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div><div class="line">  Component *tree = <span class="keyword">new</span> Composite;</div><div class="line">  Component *branch1 = <span class="keyword">new</span> Composite;</div><div class="line"></div><div class="line">  Component *leaf_1 = <span class="keyword">new</span> Leaf;</div><div class="line">  Component *leaf_2 = <span class="keyword">new</span> Leaf;</div><div class="line">  Component *leaf_3 = <span class="keyword">new</span> Leaf;</div><div class="line">  branch1-&gt;Add(leaf_1);</div><div class="line">  branch1-&gt;Add(leaf_2);</div><div class="line">  Component *branch2 = <span class="keyword">new</span> Composite;</div><div class="line">  branch2-&gt;Add(leaf_3);</div><div class="line">  tree-&gt;Add(branch1);</div><div class="line">  tree-&gt;Add(branch2);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: Now I&#39;ve got a composite tree:\n&quot;</span>;</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(tree);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: I don&#39;t need to check the components classes even when managing the tree:\n&quot;</span>;</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1Composite.html#a7106175a23e4e8a0efb57277faf4e7a6">ClientCode2</a>(tree, simple);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> simple;</div><div class="line">  <span class="keyword">delete</span> tree;</div><div class="line">  <span class="keyword">delete</span> branch1;</div><div class="line">  <span class="keyword">delete</span> branch2;</div><div class="line">  <span class="keyword">delete</span> leaf_1;</div><div class="line">  <span class="keyword">delete</span> leaf_2;</div><div class="line">  <span class="keyword">delete</span> leaf_3;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="9Decorator"></a></p><h2>9. 装饰 Decorator </h2>
<p>允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Component {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~Component() {}</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation() <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"><span class="keyword">class </span>ConcreteComponent : <span class="keyword">public</span> Component {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;ConcreteComponent&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keyword">class </span>Decorator : <span class="keyword">public</span> Component {</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  Component* component_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Decorator(Component* component) : component_(component) {</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> this-&gt;component_-&gt;Operation();</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keyword">class </span>ConcreteDecoratorA : <span class="keyword">public</span> Decorator {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  ConcreteDecoratorA(Component* component) : Decorator(component) {</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;ConcreteDecoratorA(&quot;</span> + Decorator::Operation() + <span class="stringliteral">&quot;)&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keyword">class </span>ConcreteDecoratorB : <span class="keyword">public</span> Decorator {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  ConcreteDecoratorB(Component* component) : Decorator(component) {</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;ConcreteDecoratorB(&quot;</span> + Decorator::Operation() + <span class="stringliteral">&quot;)&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(Component* component) {</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;RESULT: &quot;</span> &lt;&lt; component-&gt;Operation();</div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Component* simple = <span class="keyword">new</span> ConcreteComponent;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: I&#39;ve got a simple component:\n&quot;</span>;</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(simple);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div><div class="line">  Component* decorator1 = <span class="keyword">new</span> ConcreteDecoratorA(simple);</div><div class="line">  Component* decorator2 = <span class="keyword">new</span> ConcreteDecoratorB(decorator1);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: Now I&#39;ve got a decorated component:\n&quot;</span>;</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(decorator2);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> simple;</div><div class="line">  <span class="keyword">delete</span> decorator1;</div><div class="line">  <span class="keyword">delete</span> decorator2;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="10Facade"></a></p><h2>10. 外观 Facade </h2>
<p>能为程序库、框架或其他复杂类提供一个简单的接口。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Subsystem1 {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation1()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Subsystem1: Ready!\n&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> OperationN()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Subsystem1: Go!\n&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keyword">class </span>Subsystem2 {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation1()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Subsystem2: Get ready!\n&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> OperationZ()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Subsystem2: Fire!\n&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Facade {</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  Subsystem1 *subsystem1_;</div><div class="line">  Subsystem2 *subsystem2_;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Facade(</div><div class="line">      Subsystem1 *subsystem1 = <span class="keyword">nullptr</span>,</div><div class="line">      Subsystem2 *subsystem2 = <span class="keyword">nullptr</span>) {</div><div class="line">    this-&gt;subsystem1_ = subsystem1 ?: <span class="keyword">new</span> Subsystem1;</div><div class="line">    this-&gt;subsystem2_ = subsystem2 ?: <span class="keyword">new</span> Subsystem2;</div><div class="line">  }</div><div class="line">  ~Facade() {</div><div class="line">    <span class="keyword">delete</span> subsystem1_;</div><div class="line">    <span class="keyword">delete</span> subsystem2_;</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Operation() {</div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> result = <span class="stringliteral">&quot;Facade initializes subsystems:\n&quot;</span>;</div><div class="line">    result += this-&gt;subsystem1_-&gt;Operation1();</div><div class="line">    result += this-&gt;subsystem2_-&gt;Operation1();</div><div class="line">    result += <span class="stringliteral">&quot;Facade orders subsystems to perform the action:\n&quot;</span>;</div><div class="line">    result += this-&gt;subsystem1_-&gt;OperationN();</div><div class="line">    result += this-&gt;subsystem2_-&gt;OperationZ();</div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(Facade *facade) {</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  std::cout &lt;&lt; facade-&gt;Operation();</div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Subsystem1 *subsystem1 = <span class="keyword">new</span> Subsystem1;</div><div class="line">  Subsystem2 *subsystem2 = <span class="keyword">new</span> Subsystem2;</div><div class="line">  Facade *facade = <span class="keyword">new</span> Facade(subsystem1, subsystem2);</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(facade);</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> facade;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="11Flyweight"></a></p><h2>11. 享元 Flyweight </h2>
<p>摒弃了在每个对象中保存所有数据的方式,通过共享多个对象所共有的相同状态,让你能在有限的内存容量中载入更多对象。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>SharedState</div><div class="line">{</div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> brand_;</div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> model_;</div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> color_;</div><div class="line"></div><div class="line">    SharedState(<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;brand, <span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;model, <span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;color)</div><div class="line">        : brand_(brand), model_(model), color_(color)</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">friend</span> std::ostream &amp;<a class="code" href="namespaceAlgorithms.html#a83b47b723d922f5b15e66f8892fdd063">operator&lt;&lt;</a>(std::ostream &amp;os, <span class="keyword">const</span> SharedState &amp;ss)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> os &lt;&lt; <span class="stringliteral">&quot;[ &quot;</span> &lt;&lt; ss.brand_ &lt;&lt; <span class="stringliteral">&quot; , &quot;</span> &lt;&lt; ss.model_ &lt;&lt; <span class="stringliteral">&quot; , &quot;</span> &lt;&lt; ss.color_ &lt;&lt; <span class="stringliteral">&quot; ]&quot;</span>;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>UniqueState</div><div class="line">{</div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> owner_;</div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> plates_;</div><div class="line"></div><div class="line">    UniqueState(<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;owner, <span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;plates)</div><div class="line">        : owner_(owner), plates_(plates)</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">friend</span> std::ostream &amp;<a class="code" href="namespaceAlgorithms.html#a83b47b723d922f5b15e66f8892fdd063">operator&lt;&lt;</a>(std::ostream &amp;os, <span class="keyword">const</span> UniqueState &amp;us)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> os &lt;&lt; <span class="stringliteral">&quot;[ &quot;</span> &lt;&lt; us.owner_ &lt;&lt; <span class="stringliteral">&quot; , &quot;</span> &lt;&lt; us.plates_ &lt;&lt; <span class="stringliteral">&quot; ]&quot;</span>;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Flyweight</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    SharedState *shared_state_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Flyweight(<span class="keyword">const</span> SharedState *shared_state) : shared_state_(new SharedState(*shared_state))</div><div class="line">    {</div><div class="line">    }</div><div class="line">    Flyweight(<span class="keyword">const</span> Flyweight &amp;other) : shared_state_(new SharedState(*other.shared_state_))</div><div class="line">    {</div><div class="line">    }</div><div class="line">    ~Flyweight()</div><div class="line">    {</div><div class="line">        <span class="keyword">delete</span> shared_state_;</div><div class="line">    }</div><div class="line">    SharedState *shared_state()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> shared_state_;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">void</span> Operation(<span class="keyword">const</span> UniqueState &amp;unique_state)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Flyweight: Displaying shared (&quot;</span> &lt;&lt; *shared_state_ &lt;&lt; <span class="stringliteral">&quot;) and unique (&quot;</span> &lt;&lt; unique_state &lt;&lt; <span class="stringliteral">&quot;) state.\n&quot;</span>;</div><div class="line">    }</div><div class="line">};</div><div class="line"><span class="keyword">class </span>FlyweightFactory</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::unordered_map&lt;std::string, Flyweight&gt; flyweights_;</div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> GetKey(<span class="keyword">const</span> SharedState &amp;ss)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordflow">return</span> ss.brand_ + <span class="stringliteral">&quot;_&quot;</span> + ss.model_ + <span class="stringliteral">&quot;_&quot;</span> + ss.color_;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    FlyweightFactory(std::initializer_list&lt;SharedState&gt; share_states)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> SharedState &amp;ss : share_states)</div><div class="line">        {</div><div class="line">            this-&gt;flyweights_.insert(std::make_pair&lt;std::string, Flyweight&gt;(this-&gt;GetKey(ss), Flyweight(&amp;ss)));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    Flyweight GetFlyweight(<span class="keyword">const</span> SharedState &amp;shared_state)</div><div class="line">    {</div><div class="line">        <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> key = this-&gt;GetKey(shared_state);</div><div class="line">        <span class="keywordflow">if</span> (this-&gt;flyweights_.find(key) == this-&gt;flyweights_.end())</div><div class="line">        {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;FlyweightFactory: Can&#39;t find a flyweight, creating new one.\n&quot;</span>;</div><div class="line">            this-&gt;flyweights_.insert(<a class="code" href="namespacemystl.html#a198bc67aaf506d7221c90447c0535cc3">std::make_pair</a>(key, Flyweight(&amp;shared_state)));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;FlyweightFactory: Reusing existing flyweight.\n&quot;</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> this-&gt;flyweights_.at(key);</div><div class="line">    }</div><div class="line">    <span class="keywordtype">void</span> ListFlyweights()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="keywordtype">size_t</span> <a class="code" href="namespacemystl.html#a38fe2580034af5d507deff334c19eef9">count</a> = this-&gt;flyweights_.size();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\nFlyweightFactory: I have &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot; flyweights:\n&quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (std::pair&lt;std::string, Flyweight&gt; pair : this-&gt;flyweights_)</div><div class="line">        {</div><div class="line">            std::cout &lt;&lt; pair.first &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1Flyweight.html#a5e618a99f5503863b6d1cab8e95a98f5">AddCarToPoliceDatabase</a>(</div><div class="line">    FlyweightFactory &amp;ff, <span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;plates, <span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;owner,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;brand, <span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;model, <span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;color)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;\nClient: Adding a car to database.\n&quot;</span>;</div><div class="line">    <span class="keyword">const</span> Flyweight &amp;flyweight = ff.GetFlyweight({brand, model, color});</div><div class="line">    <span class="comment">// The client code either stores or calculates extrinsic state and passes it</span></div><div class="line">    <span class="comment">// to the flyweight&#39;s methods.</span></div><div class="line">    flyweight.Operation({owner, plates});</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    FlyweightFactory *factory = <span class="keyword">new</span> FlyweightFactory({{<span class="stringliteral">&quot;Chevrolet&quot;</span>, <span class="stringliteral">&quot;Camaro2018&quot;</span>, <span class="stringliteral">&quot;pink&quot;</span>}, {<span class="stringliteral">&quot;Mercedes Benz&quot;</span>, <span class="stringliteral">&quot;C300&quot;</span>, <span class="stringliteral">&quot;black&quot;</span>}, {<span class="stringliteral">&quot;Mercedes Benz&quot;</span>, <span class="stringliteral">&quot;C500&quot;</span>, <span class="stringliteral">&quot;red&quot;</span>}, {<span class="stringliteral">&quot;BMW&quot;</span>, <span class="stringliteral">&quot;M5&quot;</span>, <span class="stringliteral">&quot;red&quot;</span>}, {<span class="stringliteral">&quot;BMW&quot;</span>, <span class="stringliteral">&quot;X6&quot;</span>, <span class="stringliteral">&quot;white&quot;</span>}});</div><div class="line">    factory-&gt;ListFlyweights();</div><div class="line"></div><div class="line">    <a class="code" href="namespaceDesignPattern_1_1Flyweight.html#a5e618a99f5503863b6d1cab8e95a98f5">AddCarToPoliceDatabase</a>(*factory,</div><div class="line">                            <span class="stringliteral">&quot;CL234IR&quot;</span>,</div><div class="line">                            <span class="stringliteral">&quot;James Doe&quot;</span>,</div><div class="line">                            <span class="stringliteral">&quot;BMW&quot;</span>,</div><div class="line">                            <span class="stringliteral">&quot;M5&quot;</span>,</div><div class="line">                            <span class="stringliteral">&quot;red&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceDesignPattern_1_1Flyweight.html#a5e618a99f5503863b6d1cab8e95a98f5">AddCarToPoliceDatabase</a>(*factory,</div><div class="line">                            <span class="stringliteral">&quot;CL234IR&quot;</span>,</div><div class="line">                            <span class="stringliteral">&quot;James Doe&quot;</span>,</div><div class="line">                            <span class="stringliteral">&quot;BMW&quot;</span>,</div><div class="line">                            <span class="stringliteral">&quot;X1&quot;</span>,</div><div class="line">                            <span class="stringliteral">&quot;red&quot;</span>);</div><div class="line">    factory-&gt;ListFlyweights();</div><div class="line">    <span class="keyword">delete</span> factory;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="12Proxy"></a></p><h2>12. 代理 Proxy </h2>
<p>让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问,并允许在将请求提交给对象前后进行一些处理。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keyword">class </span>Subject {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Request() <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"><span class="keyword">class </span>RealSubject : <span class="keyword">public</span> Subject {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> Request()<span class="keyword"> const override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;RealSubject: Handling request.\n&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keyword">class </span>Proxy : <span class="keyword">public</span> Subject {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  RealSubject *real_subject_;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> CheckAccess()<span class="keyword"> const </span>{</div><div class="line">    <span class="comment">// 一些真正的检查应该在这里进行。</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Proxy: Checking access prior to firing a real request.\n&quot;</span>;</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> LogAccess()<span class="keyword"> const </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Proxy: Logging the time of request.\n&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Proxy(RealSubject *real_subject) : real_subject_(new RealSubject(*real_subject)) {</div><div class="line">  }</div><div class="line"></div><div class="line">  ~Proxy() {</div><div class="line">    <span class="keyword">delete</span> real_subject_;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> Request()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">if</span> (this-&gt;CheckAccess()) {</div><div class="line">      this-&gt;real_subject_-&gt;Request();</div><div class="line">      this-&gt;LogAccess();</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(<span class="keyword">const</span> Subject &amp;subject) {</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  subject.Request();</div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: Executing the client code with a real subject:\n&quot;</span>;</div><div class="line">  RealSubject *real_subject = <span class="keyword">new</span> RealSubject;</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(*real_subject);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: Executing the same client code with a proxy:\n&quot;</span>;</div><div class="line">  Proxy *proxy = <span class="keyword">new</span> Proxy(real_subject);</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(*proxy);</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> real_subject;</div><div class="line">  <span class="keyword">delete</span> proxy;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1>三. 行为模式 </h1>
<p><a class="anchor" id="13ChainofResponsibility"></a></p><h2>13. 责任链 Chain of Responsibility </h2>
<p>允许你将请求沿着处理者链进行发送。收到请求后,每个处理者均可对请求进行处理,或将其传递给链上的下个处理者。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Handler {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> Handler *SetNext(Handler *handler) = 0;</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Handle(<a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> request) = 0;</div><div class="line">};</div><div class="line"><span class="keyword">class </span>AbstractHandler : <span class="keyword">public</span> Handler {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  Handler *next_handler_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  AbstractHandler() : next_handler_(nullptr) {</div><div class="line">  }</div><div class="line">  Handler *SetNext(Handler *handler)<span class="keyword"> override </span>{</div><div class="line">    this-&gt;next_handler_ = handler;</div><div class="line">    <span class="comment">// 从这里返回一个处理程序将让我们以一种方便的方式连接处理程序，就像这样。</span></div><div class="line">    <span class="comment">// @f$monkey-&gt;setNext(@f$squirrel)-&gt;setNext(@f$dog);</span></div><div class="line">    <span class="keywordflow">return</span> handler;</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Handle(<a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> request)<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">if</span> (this-&gt;next_handler_) {</div><div class="line">      <span class="keywordflow">return</span> this-&gt;next_handler_-&gt;Handle(request);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> {};</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">class </span>MonkeyHandler : <span class="keyword">public</span> AbstractHandler {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Handle(<a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> request)<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">if</span> (request == <span class="stringliteral">&quot;Banana&quot;</span>) {</div><div class="line">      <span class="keywordflow">return</span> <span class="stringliteral">&quot;Monkey: I&#39;ll eat the &quot;</span> + request + <span class="stringliteral">&quot;.\n&quot;</span>;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      <span class="keywordflow">return</span> AbstractHandler::Handle(request);</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keyword">class </span>SquirrelHandler : <span class="keyword">public</span> AbstractHandler {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Handle(<a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> request)<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">if</span> (request == <span class="stringliteral">&quot;Nut&quot;</span>) {</div><div class="line">      <span class="keywordflow">return</span> <span class="stringliteral">&quot;Squirrel: I&#39;ll eat the &quot;</span> + request + <span class="stringliteral">&quot;.\n&quot;</span>;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      <span class="keywordflow">return</span> AbstractHandler::Handle(request);</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keyword">class </span>DogHandler : <span class="keyword">public</span> AbstractHandler {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> Handle(<a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> request)<span class="keyword"> override </span>{</div><div class="line">    <span class="keywordflow">if</span> (request == <span class="stringliteral">&quot;MeatBall&quot;</span>) {</div><div class="line">      <span class="keywordflow">return</span> <span class="stringliteral">&quot;Dog: I&#39;ll eat the &quot;</span> + request + <span class="stringliteral">&quot;.\n&quot;</span>;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      <span class="keywordflow">return</span> AbstractHandler::Handle(request);</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(Handler &amp;handler) {</div><div class="line">  std::vector&lt;std::string&gt; food = {<span class="stringliteral">&quot;Nut&quot;</span>, <span class="stringliteral">&quot;Banana&quot;</span>, <span class="stringliteral">&quot;Cup of coffee&quot;</span>};</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;f : food) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Client: Who wants a &quot;</span> &lt;&lt; f &lt;&lt; <span class="stringliteral">&quot;?\n&quot;</span>;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> result = handler.Handle(f);</div><div class="line">    <span class="keywordflow">if</span> (!result.empty()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; result;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; f &lt;&lt; <span class="stringliteral">&quot; was left untouched.\n&quot;</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  MonkeyHandler *monkey = <span class="keyword">new</span> MonkeyHandler;</div><div class="line">  SquirrelHandler *squirrel = <span class="keyword">new</span> SquirrelHandler;</div><div class="line">  DogHandler *dog = <span class="keyword">new</span> DogHandler;</div><div class="line">  monkey-&gt;SetNext(squirrel)-&gt;SetNext(dog);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Chain: Monkey &gt; Squirrel &gt; Dog\n\n&quot;</span>;</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(*monkey);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Subchain: Squirrel &gt; Dog\n\n&quot;</span>;</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(*squirrel);</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> monkey;</div><div class="line">  <span class="keyword">delete</span> squirrel;</div><div class="line">  <span class="keyword">delete</span> dog;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="14Command"></a></p><h2>14. 命令 Command </h2>
<p>它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中,且能实现可撤销操作。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Command {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~Command() {</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Execute() <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"><span class="keyword">class </span>SimpleCommand : <span class="keyword">public</span> Command {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> pay_load_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">explicit</span> SimpleCommand(<a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> pay_load) : pay_load_(pay_load) {</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> Execute()<span class="keyword"> const override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;SimpleCommand: See, I can do simple things like printing (&quot;</span> &lt;&lt; this-&gt;pay_load_ &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Receiver {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> DoSomething(<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;a) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Receiver: Working on (&quot;</span> &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot;.)\n&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> DoSomethingElse(<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Receiver: Also working on (&quot;</span> &lt;&lt; b &lt;&lt; <span class="stringliteral">&quot;.)\n&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ComplexCommand : <span class="keyword">public</span> Command {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  Receiver *receiver_;</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> a_;</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> b_;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  ComplexCommand(Receiver *receiver, <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> a, <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>) : receiver_(receiver), a_(a), b_(b) {</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> Execute()<span class="keyword"> const override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ComplexCommand: Complex stuff should be done by a receiver object.\n&quot;</span>;</div><div class="line">    this-&gt;receiver_-&gt;DoSomething(this-&gt;a_);</div><div class="line">    this-&gt;receiver_-&gt;DoSomethingElse(this-&gt;b_);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Invoker {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  Command *on_start_;</div><div class="line">  Command *on_finish_;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  ~Invoker() {</div><div class="line">    <span class="keyword">delete</span> on_start_;</div><div class="line">    <span class="keyword">delete</span> on_finish_;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> SetOnStart(Command *command) {</div><div class="line">    this-&gt;on_start_ = command;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> SetOnFinish(Command *command) {</div><div class="line">    this-&gt;on_finish_ = command;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> DoSomethingImportant() {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Invoker: Does anybody want something done before I begin?\n&quot;</span>;</div><div class="line">    <span class="keywordflow">if</span> (this-&gt;on_start_) {</div><div class="line">      this-&gt;on_start_-&gt;Execute();</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Invoker: ...doing something really important...\n&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Invoker: Does anybody want something done after I finish?\n&quot;</span>;</div><div class="line">    <span class="keywordflow">if</span> (this-&gt;on_finish_) {</div><div class="line">      this-&gt;on_finish_-&gt;Execute();</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Invoker *invoker = <span class="keyword">new</span> Invoker;</div><div class="line">  invoker-&gt;SetOnStart(<span class="keyword">new</span> SimpleCommand(<span class="stringliteral">&quot;Say Hi!&quot;</span>));</div><div class="line">  Receiver *receiver = <span class="keyword">new</span> Receiver;</div><div class="line">  invoker-&gt;SetOnFinish(<span class="keyword">new</span> ComplexCommand(receiver, <span class="stringliteral">&quot;Send email&quot;</span>, <span class="stringliteral">&quot;Save report&quot;</span>));</div><div class="line">  invoker-&gt;DoSomethingImportant();</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> invoker;</div><div class="line">  <span class="keyword">delete</span> receiver;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="15Iterator"></a></p><h2>15. 迭代器 Iterator </h2>
<p>让你能在不暴露集合底层表现形式(列表、栈和树等)的情况下遍历集合中所有的元素。 </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div><div class="line"><span class="keyword">class </span>Iterator {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;T&gt;::iterator iter_type;</div><div class="line">  Iterator(<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a> *p_data, <span class="keywordtype">bool</span> <a class="code" href="namespacemystl.html#a1bd01cb8b4e1f829d264f5964e41e1b9">reverse</a> = <span class="keyword">false</span>) : m_p_data_(p_data) {</div><div class="line">    m_it_ = m_p_data_-&gt;m_data_.begin();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> First() {</div><div class="line">    m_it_ = m_p_data_-&gt;m_data_.begin();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Next() {</div><div class="line">    m_it_++;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> IsDone() {</div><div class="line">    <span class="keywordflow">return</span> (m_it_ == m_p_data_-&gt;m_data_.end());</div><div class="line">  }</div><div class="line"></div><div class="line">  iter_type Current() {</div><div class="line">    <span class="keywordflow">return</span> m_it_;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a> *m_p_data_;</div><div class="line">  iter_type m_it_;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class </span>Container {</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span>Iterator&lt;<a class="code" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T</a>, Container&gt;;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> Add(<a class="code" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T</a> a) {</div><div class="line">    m_data_.push_back(a);</div><div class="line">  }</div><div class="line"></div><div class="line">  Iterator&lt;T, Container&gt; *CreateIterator() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> Iterator&lt;T, Container&gt;(<span class="keyword">this</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  std::vector&lt;T&gt; m_data_;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Data {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Data(<span class="keywordtype">int</span> a = 0) : m_data_(a) {}</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> set_data(<span class="keywordtype">int</span> a) {</div><div class="line">    m_data_ = a;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> data() {</div><div class="line">    <span class="keywordflow">return</span> m_data_;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">int</span> m_data_;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>() {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;________________Iterator with int______________________________________&quot;</span> &lt;&lt; std::endl;</div><div class="line">  Container&lt;int&gt; cont;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; i++) {</div><div class="line">    cont.Add(i);</div><div class="line">  }</div><div class="line"></div><div class="line">  Iterator&lt;int, Container&lt;int&gt;&gt; *it = cont.CreateIterator();</div><div class="line">  <span class="keywordflow">for</span> (it-&gt;First(); !it-&gt;IsDone(); it-&gt;Next()) {</div><div class="line">    std::cout &lt;&lt; *it-&gt;Current() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  Container&lt;Data&gt; cont2;</div><div class="line">  Data a(100), <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>(1000), c(10000);</div><div class="line">  cont2.Add(a);</div><div class="line">  cont2.Add(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>);</div><div class="line">  cont2.Add(c);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;________________Iterator with custom Class______________________________&quot;</span> &lt;&lt; std::endl;</div><div class="line">  Iterator&lt;Data, Container&lt;Data&gt;&gt; *it2 = cont2.CreateIterator();</div><div class="line">  <span class="keywordflow">for</span> (it2-&gt;First(); !it2-&gt;IsDone(); it2-&gt;Next()) {</div><div class="line">    std::cout &lt;&lt; it2-&gt;Current()-&gt;data() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keyword">delete</span> it;</div><div class="line">  <span class="keyword">delete</span> it2;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="16Mediator"></a></p><h2>16. 中介者 Mediator </h2>
<p>能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互,迫使它们通过一个中介者对象进行合作。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="keyword">class </span>BaseComponent;</div><div class="line"><span class="keyword">class </span>Mediator {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Notify(BaseComponent *sender, <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> event) <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>BaseComponent {</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  Mediator *mediator_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  BaseComponent(Mediator *mediator = <span class="keyword">nullptr</span>) : mediator_(mediator) {</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> set_mediator(Mediator *mediator) {</div><div class="line">    this-&gt;mediator_ = mediator;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Component1 : <span class="keyword">public</span> BaseComponent {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> DoA() {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Component 1 does A.\n&quot;</span>;</div><div class="line">    this-&gt;mediator_-&gt;Notify(<span class="keyword">this</span>, <span class="stringliteral">&quot;A&quot;</span>);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> DoB() {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Component 1 does B.\n&quot;</span>;</div><div class="line">    this-&gt;mediator_-&gt;Notify(<span class="keyword">this</span>, <span class="stringliteral">&quot;B&quot;</span>);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Component2 : <span class="keyword">public</span> BaseComponent {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> DoC() {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Component 2 does C.\n&quot;</span>;</div><div class="line">    this-&gt;mediator_-&gt;Notify(<span class="keyword">this</span>, <span class="stringliteral">&quot;C&quot;</span>);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> DoD() {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Component 2 does D.\n&quot;</span>;</div><div class="line">    this-&gt;mediator_-&gt;Notify(<span class="keyword">this</span>, <span class="stringliteral">&quot;D&quot;</span>);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteMediator : <span class="keyword">public</span> Mediator {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  Component1 *component1_;</div><div class="line">  Component2 *component2_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  ConcreteMediator(Component1 *c1, Component2 *c2) : component1_(c1), component2_(c2) {</div><div class="line">    this-&gt;component1_-&gt;set_mediator(<span class="keyword">this</span>);</div><div class="line">    this-&gt;component2_-&gt;set_mediator(<span class="keyword">this</span>);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> Notify(BaseComponent *sender, <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> event)<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">if</span> (event == <span class="stringliteral">&quot;A&quot;</span>) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Mediator reacts on A and triggers following operations:\n&quot;</span>;</div><div class="line">      this-&gt;component2_-&gt;DoC();</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (event == <span class="stringliteral">&quot;D&quot;</span>) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Mediator reacts on D and triggers following operations:\n&quot;</span>;</div><div class="line">      this-&gt;component1_-&gt;DoB();</div><div class="line">      this-&gt;component2_-&gt;DoC();</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>() {</div><div class="line">  Component1 *c1 = <span class="keyword">new</span> Component1;</div><div class="line">  Component2 *c2 = <span class="keyword">new</span> Component2;</div><div class="line">  ConcreteMediator *mediator = <span class="keyword">new</span> ConcreteMediator(c1, c2);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client triggers operation A.\n&quot;</span>;</div><div class="line">  c1-&gt;DoA();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client triggers operation D.\n&quot;</span>;</div><div class="line">  c2-&gt;DoD();</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> c1;</div><div class="line">  <span class="keyword">delete</span> c2;</div><div class="line">  <span class="keyword">delete</span> mediator;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="17Memento"></a></p><h2>17. 备忘录 Memento </h2>
<p>允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;ctime&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Memento {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> GetName() <span class="keyword">const</span> = 0;</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> date() <span class="keyword">const</span> = 0;</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> state() <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteMemento : <span class="keyword">public</span> Memento {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> state_;</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> date_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  ConcreteMemento(<a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> state) : state_(state) {</div><div class="line">    this-&gt;state_ = state;</div><div class="line">    std::time_t now = std::time(0);</div><div class="line">    this-&gt;date_ = std::ctime(&amp;now);</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> state()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> this-&gt;state_;</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> GetName()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> this-&gt;date_ + <span class="stringliteral">&quot; / (&quot;</span> + this-&gt;state_.substr(0, 9) + <span class="stringliteral">&quot;...)&quot;</span>;</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> date()<span class="keyword"> const override </span>{</div><div class="line">    <span class="keywordflow">return</span> this-&gt;date_;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Originator {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> state_;</div><div class="line"></div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> GenerateRandomString(<span class="keywordtype">int</span> length = 10) {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> alphanum[] =</div><div class="line">        <span class="stringliteral">&quot;0123456789&quot;</span></div><div class="line">        <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></div><div class="line">        <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</div><div class="line">    <span class="keywordtype">int</span> stringLength = <span class="keyword">sizeof</span>(alphanum) - 1;</div><div class="line"></div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> random_string;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; length; i++) {</div><div class="line">      random_string += alphanum[std::rand() % stringLength];</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> random_string;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Originator(<a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> state) : state_(state) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Originator: My initial state is: &quot;</span> &lt;&lt; this-&gt;state_ &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> DoSomething() {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Originator: I&#39;m doing something important.\n&quot;</span>;</div><div class="line">    this-&gt;state_ = this-&gt;GenerateRandomString(30);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Originator: and my state has changed to: &quot;</span> &lt;&lt; this-&gt;state_ &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  Memento *Save() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteMemento(this-&gt;state_);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> Restore(Memento *memento) {</div><div class="line">    this-&gt;state_ = memento-&gt;state();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Originator: My state has changed to: &quot;</span> &lt;&lt; this-&gt;state_ &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Caretaker {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  std::vector&lt;Memento *&gt; mementos_;</div><div class="line"></div><div class="line">  Originator *originator_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Caretaker(Originator *originator) : originator_(originator) {</div><div class="line">    this-&gt;originator_ = originator;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Backup() {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;\nCaretaker: Saving Originator&#39;s state...\n&quot;</span>;</div><div class="line">    this-&gt;mementos_.push_back(this-&gt;originator_-&gt;Save());</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> Undo() {</div><div class="line">    <span class="keywordflow">if</span> (!this-&gt;mementos_.size()) {</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line">    Memento *memento = this-&gt;mementos_.back();</div><div class="line">    this-&gt;mementos_.pop_back();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Caretaker: Restoring state to: &quot;</span> &lt;&lt; memento-&gt;GetName() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">      this-&gt;originator_-&gt;Restore(memento);</div><div class="line">    } <span class="keywordflow">catch</span> (...) {</div><div class="line">      this-&gt;Undo();</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> ShowHistory()<span class="keyword"> const </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Caretaker: Here&#39;s the list of mementos:\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (Memento *memento : this-&gt;mementos_) {</div><div class="line">      std::cout &lt;&lt; memento-&gt;GetName() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>() {</div><div class="line">  Originator *originator = <span class="keyword">new</span> Originator(<span class="stringliteral">&quot;Super-duper-super-puper-super.&quot;</span>);</div><div class="line">  Caretaker *caretaker = <span class="keyword">new</span> Caretaker(originator);</div><div class="line">  caretaker-&gt;Backup();</div><div class="line">  originator-&gt;DoSomething();</div><div class="line">  caretaker-&gt;Backup();</div><div class="line">  originator-&gt;DoSomething();</div><div class="line">  caretaker-&gt;Backup();</div><div class="line">  originator-&gt;DoSomething();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  caretaker-&gt;ShowHistory();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\nClient: Now, let&#39;s rollback!\n\n&quot;</span>;</div><div class="line">  caretaker-&gt;Undo();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\nClient: Once more!\n\n&quot;</span>;</div><div class="line">  caretaker-&gt;Undo();</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> originator;</div><div class="line">  <span class="keyword">delete</span> caretaker;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::srand(static_cast&lt;unsigned int&gt;(std::time(NULL)));</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="18Observer"></a></p><h2>18. 观察者 Observer </h2>
<p>允许你定义一种订阅机制,可在对象事件发生时通知多个“观察”该对象的其他对象。 </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>IObserver {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~IObserver(){};</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Update(<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;message_from_subject) = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ISubject {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~ISubject(){};</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Attach(IObserver *observer) = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Detach(IObserver *observer) = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Notify() = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Subject : <span class="keyword">public</span> ISubject {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~Subject() {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Goodbye, I was the Subject.\n&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Attach(IObserver *observer)<span class="keyword"> override </span>{</div><div class="line">    list_observer_.push_back(observer);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> Detach(IObserver *observer)<span class="keyword"> override </span>{</div><div class="line">    list_observer_.remove(observer);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> Notify()<span class="keyword"> override </span>{</div><div class="line">    std::list&lt;IObserver *&gt;::iterator iterator = list_observer_.begin();</div><div class="line">    HowManyObserver();</div><div class="line">    <span class="keywordflow">while</span> (iterator != list_observer_.end()) {</div><div class="line">      (*iterator)-&gt;Update(message_);</div><div class="line">      ++iterator;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> CreateMessage(<a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> message = <span class="stringliteral">&quot;Empty&quot;</span>) {</div><div class="line">    this-&gt;message_ = message;</div><div class="line">    Notify();</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> HowManyObserver() {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;There are &quot;</span> &lt;&lt; list_observer_.size() &lt;&lt; <span class="stringliteral">&quot; observers in the list.\n&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> SomeBusinessLogic() {</div><div class="line">    this-&gt;message_ = <span class="stringliteral">&quot;change message message&quot;</span>;</div><div class="line">    Notify();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;I&#39;m about to do some thing important\n&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  std::list&lt;IObserver *&gt; list_observer_;</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> message_;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Observer : <span class="keyword">public</span> IObserver {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Observer(Subject &amp;subject) : subject_(subject) {</div><div class="line">    this-&gt;subject_.Attach(<span class="keyword">this</span>);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Hi, I&#39;m the Observer \&quot;&quot;</span> &lt;&lt; ++Observer::static_number_ &lt;&lt; <span class="stringliteral">&quot;\&quot;.\n&quot;</span>;</div><div class="line">    this-&gt;number_ = Observer::static_number_;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> ~Observer() {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Goodbye, I was the Observer \&quot;&quot;</span> &lt;&lt; this-&gt;number_ &lt;&lt; <span class="stringliteral">&quot;\&quot;.\n&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Update(<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;message_from_subject)<span class="keyword"> override </span>{</div><div class="line">    message_from_subject_ = message_from_subject;</div><div class="line">    PrintInfo();</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> RemoveMeFromTheList() {</div><div class="line">    subject_.Detach(<span class="keyword">this</span>);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Observer \&quot;&quot;</span> &lt;&lt; number_ &lt;&lt; <span class="stringliteral">&quot;\&quot; removed from the list.\n&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> PrintInfo() {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Observer \&quot;&quot;</span> &lt;&lt; this-&gt;number_ &lt;&lt; <span class="stringliteral">&quot;\&quot;: a new message is available --&gt; &quot;</span> &lt;&lt; this-&gt;message_from_subject_ &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> message_from_subject_;</div><div class="line">  Subject &amp;subject_;</div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> static_number_;</div><div class="line">  <span class="keywordtype">int</span> number_;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> Observer::static_number_ = 0;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>() {</div><div class="line">  Subject *subject = <span class="keyword">new</span> Subject;</div><div class="line">  Observer *observer1 = <span class="keyword">new</span> Observer(*subject);</div><div class="line">  Observer *observer2 = <span class="keyword">new</span> Observer(*subject);</div><div class="line">  Observer *observer3 = <span class="keyword">new</span> Observer(*subject);</div><div class="line">  Observer *observer4;</div><div class="line">  Observer *observer5;</div><div class="line"></div><div class="line">  subject-&gt;CreateMessage(<span class="stringliteral">&quot;Hello World! :D&quot;</span>);</div><div class="line">  observer3-&gt;RemoveMeFromTheList();</div><div class="line"></div><div class="line">  subject-&gt;CreateMessage(<span class="stringliteral">&quot;The weather is hot today! :p&quot;</span>);</div><div class="line">  observer4 = <span class="keyword">new</span> Observer(*subject);</div><div class="line"></div><div class="line">  observer2-&gt;RemoveMeFromTheList();</div><div class="line">  observer5 = <span class="keyword">new</span> Observer(*subject);</div><div class="line"></div><div class="line">  subject-&gt;CreateMessage(<span class="stringliteral">&quot;My new car is great! ;)&quot;</span>);</div><div class="line">  observer5-&gt;RemoveMeFromTheList();</div><div class="line"></div><div class="line">  observer4-&gt;RemoveMeFromTheList();</div><div class="line">  observer1-&gt;RemoveMeFromTheList();</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> observer5;</div><div class="line">  <span class="keyword">delete</span> observer4;</div><div class="line">  <span class="keyword">delete</span> observer3;</div><div class="line">  <span class="keyword">delete</span> observer2;</div><div class="line">  <span class="keyword">delete</span> observer1;</div><div class="line">  <span class="keyword">delete</span> subject;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="19State"></a></p><h2>19. 状态 State </h2>
<p>让你能在一个对象的内部状态变化时改变其行为,使其看上去就像改变了自身所属的类一样。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;typeinfo&gt;</span></div><div class="line"><span class="keyword">class </span>Context;</div><div class="line"></div><div class="line"><span class="keyword">class </span><a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638">State</a> {</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  Context *context_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638">State</a>() {</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> set_context(Context *context) {</div><div class="line">    this-&gt;context_ = context;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Handle1() = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Handle2() = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Context {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638">State</a> *state_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Context(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638">State</a> *state) : state_(nullptr) {</div><div class="line">    this-&gt;TransitionTo(state);</div><div class="line">  }</div><div class="line">  ~Context() {</div><div class="line">    <span class="keyword">delete</span> state_;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> TransitionTo(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638">State</a> *state) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Context: Transition to &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(*state).name() &lt;&lt; <span class="stringliteral">&quot;.\n&quot;</span>;</div><div class="line">    <span class="keywordflow">if</span> (this-&gt;state_ != <span class="keyword">nullptr</span>)</div><div class="line">      <span class="keyword">delete</span> this-&gt;state_;</div><div class="line">    this-&gt;state_ = state;</div><div class="line">    this-&gt;state_-&gt;set_context(<span class="keyword">this</span>);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> Request1() {</div><div class="line">    this-&gt;state_-&gt;Handle1();</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> Request2() {</div><div class="line">    this-&gt;state_-&gt;Handle2();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteStateA : <span class="keyword">public</span> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638">State</a> {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> Handle1() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Handle2()<span class="keyword"> override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ConcreteStateA handles request2.\n&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteStateB : <span class="keyword">public</span> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638">State</a> {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> Handle1()<span class="keyword"> override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ConcreteStateB handles request1.\n&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> Handle2()<span class="keyword"> override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ConcreteStateB handles request2.\n&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ConcreteStateB wants to change the state of the context.\n&quot;</span>;</div><div class="line">    this-&gt;context_-&gt;TransitionTo(<span class="keyword">new</span> ConcreteStateA);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ConcreteStateA::Handle1() {</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ConcreteStateA handles request1.\n&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ConcreteStateA wants to change the state of the context.\n&quot;</span>;</div><div class="line"></div><div class="line">    this-&gt;context_-&gt;TransitionTo(<span class="keyword">new</span> ConcreteStateB);</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>() {</div><div class="line">  Context *context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStateA);</div><div class="line">  context-&gt;Request1();</div><div class="line">  context-&gt;Request2();</div><div class="line">  <span class="keyword">delete</span> context;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="20Strategy"></a></p><h2>20. 策略 Strategy </h2>
<p>能让你定义一系列算法,并将每种算法分别放入独立的类中, 以使算法的对象能够相互替换。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Strategy</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> ~Strategy() {}</div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> DoAlgorithm(<span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;data) <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Context</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Strategy *strategy_;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Context(Strategy *strategy = <span class="keyword">nullptr</span>) : strategy_(strategy)</div><div class="line">    {</div><div class="line">    }</div><div class="line">    ~Context()</div><div class="line">    {</div><div class="line">        <span class="keyword">delete</span> this-&gt;strategy_;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">void</span> set_strategy(Strategy *strategy)</div><div class="line">    {</div><div class="line">        <span class="keyword">delete</span> this-&gt;strategy_;</div><div class="line">        this-&gt;strategy_ = strategy;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">void</span> DoSomeBusinessLogic()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Context: Sorting data using the strategy (not sure how it&#39;ll do it)\n&quot;</span>;</div><div class="line">        <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> result = this-&gt;strategy_-&gt;DoAlgorithm(std::vector&lt;std::string&gt;{<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;e&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;d&quot;</span>});</div><div class="line">        std::cout &lt;&lt; result &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteStrategyA : <span class="keyword">public</span> Strategy</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> DoAlgorithm(<span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;data)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> result;</div><div class="line">        <a class="code" href="namespacemystl.html#aa7240d74e4539424c5eced139aee7270">std::for_each</a>(<a class="code" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">std::begin</a>(data), <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">std::end</a>(data), [&amp;result](<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;letter) {</div><div class="line">            result += letter;</div><div class="line">        });</div><div class="line">        <a class="code" href="namespacemystl.html#a94d37bb41e3a6da5764373cc839d8cd5">std::sort</a>(<a class="code" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">std::begin</a>(result), <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">std::end</a>(result));</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> result;</div><div class="line">    }</div><div class="line">};</div><div class="line"><span class="keyword">class </span>ConcreteStrategyB : <span class="keyword">public</span> Strategy</div><div class="line">{</div><div class="line">    <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> DoAlgorithm(<span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;data)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> result;</div><div class="line">        <a class="code" href="namespacemystl.html#aa7240d74e4539424c5eced139aee7270">std::for_each</a>(<a class="code" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">std::begin</a>(data), <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">std::end</a>(data), [&amp;result](<span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> &amp;letter) {</div><div class="line">            result += letter;</div><div class="line">        });</div><div class="line">        <a class="code" href="namespacemystl.html#a94d37bb41e3a6da5764373cc839d8cd5">std::sort</a>(<a class="code" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">std::begin</a>(result), <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">std::end</a>(result));</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; result.size() / 2; i++)</div><div class="line">        {</div><div class="line">            <a class="code" href="namespaceMemorySpace.html#aa305d2cf39a99e7571fdaf256ce130ec">std::swap</a>(result[i], result[result.size() - i - 1]);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> result;</div><div class="line">    }</div><div class="line">};</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>()</div><div class="line">{</div><div class="line">    Context *context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategyA);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Client: Strategy is set to normal sorting.\n&quot;</span>;</div><div class="line">    context-&gt;DoSomeBusinessLogic();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Client: Strategy is set to reverse sorting.\n&quot;</span>;</div><div class="line">    context-&gt;set_strategy(<span class="keyword">new</span> ConcreteStrategyB);</div><div class="line">    context-&gt;DoSomeBusinessLogic();</div><div class="line">    <span class="keyword">delete</span> context;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>();</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="21TemplateMethod"></a></p><h2>21. 模板方法 Template Method </h2>
<p>在超类中定义一个算法的框架,允许子类在不修改结构的情况下重写算法的特定步骤。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>AbstractClass {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> TemplateMethod()<span class="keyword"> const </span>{</div><div class="line">    this-&gt;BaseOperation1();</div><div class="line">    this-&gt;RequiredOperations1();</div><div class="line">    this-&gt;BaseOperation2();</div><div class="line">    this-&gt;Hook1();</div><div class="line">    this-&gt;RequiredOperation2();</div><div class="line">    this-&gt;BaseOperation3();</div><div class="line">    this-&gt;Hook2();</div><div class="line">  }</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  <span class="keywordtype">void</span> BaseOperation1()<span class="keyword"> const </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;AbstractClass says: I am doing the bulk of the work\n&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> BaseOperation2()<span class="keyword"> const </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;AbstractClass says: But I let subclasses override some operations\n&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> BaseOperation3()<span class="keyword"> const </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;AbstractClass says: But I am doing the bulk of the work anyway\n&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> RequiredOperations1() <span class="keyword">const</span> = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> RequiredOperation2() <span class="keyword">const</span> = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Hook1()<span class="keyword"> const </span>{}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Hook2()<span class="keyword"> const </span>{}</div><div class="line">};</div><div class="line"><span class="keyword">class </span>ConcreteClass1 : <span class="keyword">public</span> AbstractClass {</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  <span class="keywordtype">void</span> RequiredOperations1()<span class="keyword"> const override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ConcreteClass1 says: Implemented Operation1\n&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> RequiredOperation2()<span class="keyword"> const override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ConcreteClass1 says: Implemented Operation2\n&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keyword">class </span>ConcreteClass2 : <span class="keyword">public</span> AbstractClass {</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  <span class="keywordtype">void</span> RequiredOperations1()<span class="keyword"> const override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ConcreteClass2 says: Implemented Operation1\n&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> RequiredOperation2()<span class="keyword"> const override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ConcreteClass2 says: Implemented Operation2\n&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> Hook1()<span class="keyword"> const override </span>{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ConcreteClass2 says: Overridden Hook1\n&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(AbstractClass *class_) {</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  class_-&gt;TemplateMethod();</div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Same client code can work with different subclasses:\n&quot;</span>;</div><div class="line">  ConcreteClass1 *concreteClass1 = <span class="keyword">new</span> ConcreteClass1;</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(concreteClass1);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Same client code can work with different subclasses:\n&quot;</span>;</div><div class="line">  ConcreteClass2 *concreteClass2 = <span class="keyword">new</span> ConcreteClass2;</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(concreteClass2);</div><div class="line">  <span class="keyword">delete</span> concreteClass1;</div><div class="line">  <span class="keyword">delete</span> concreteClass2;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="22Visitor"></a></p><h2>22. 访问者 Visitor </h2>
<p>将算法与其所作用的对象隔离开来。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteComponentA;</div><div class="line"><span class="keyword">class </span>ConcreteComponentB;</div><div class="line"></div><div class="line"><span class="keyword">class </span>Visitor {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> VisitConcreteComponentA(<span class="keyword">const</span> ConcreteComponentA *element) <span class="keyword">const</span> = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> VisitConcreteComponentB(<span class="keyword">const</span> ConcreteComponentB *element) <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Component {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~Component() {}</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Accept(Visitor *visitor) <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteComponentA : <span class="keyword">public</span> Component {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> Accept(Visitor *visitor)<span class="keyword"> const override </span>{</div><div class="line">    visitor-&gt;VisitConcreteComponentA(<span class="keyword">this</span>);</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> ExclusiveMethodOfConcreteComponentA()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;A&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteComponentB : <span class="keyword">public</span> Component {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> Accept(Visitor *visitor)<span class="keyword"> const override </span>{</div><div class="line">    visitor-&gt;VisitConcreteComponentB(<span class="keyword">this</span>);</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> SpecialMethodOfConcreteComponentB()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;B&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteVisitor1 : <span class="keyword">public</span> Visitor {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> VisitConcreteComponentA(<span class="keyword">const</span> ConcreteComponentA *element)<span class="keyword"> const override </span>{</div><div class="line">    std::cout &lt;&lt; element-&gt;ExclusiveMethodOfConcreteComponentA() &lt;&lt; <span class="stringliteral">&quot; + ConcreteVisitor1\n&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> VisitConcreteComponentB(<span class="keyword">const</span> ConcreteComponentB *element)<span class="keyword"> const override </span>{</div><div class="line">    std::cout &lt;&lt; element-&gt;SpecialMethodOfConcreteComponentB() &lt;&lt; <span class="stringliteral">&quot; + ConcreteVisitor1\n&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteVisitor2 : <span class="keyword">public</span> Visitor {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> VisitConcreteComponentA(<span class="keyword">const</span> ConcreteComponentA *element)<span class="keyword"> const override </span>{</div><div class="line">    std::cout &lt;&lt; element-&gt;ExclusiveMethodOfConcreteComponentA() &lt;&lt; <span class="stringliteral">&quot; + ConcreteVisitor2\n&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> VisitConcreteComponentB(<span class="keyword">const</span> ConcreteComponentB *element)<span class="keyword"> const override </span>{</div><div class="line">    std::cout &lt;&lt; element-&gt;SpecialMethodOfConcreteComponentB() &lt;&lt; <span class="stringliteral">&quot; + ConcreteVisitor2\n&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(std::array&lt;const Component *, 2&gt; components, Visitor *visitor) {</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> Component *comp : components) {</div><div class="line">    comp-&gt;Accept(visitor);</div><div class="line">  }</div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::array&lt;const Component *, 2&gt; components = {<span class="keyword">new</span> ConcreteComponentA, <span class="keyword">new</span> ConcreteComponentB};</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The client code works with all visitors via the base Visitor interface:\n&quot;</span>;</div><div class="line">  ConcreteVisitor1 *visitor1 = <span class="keyword">new</span> ConcreteVisitor1;</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(components, visitor1);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;It allows the same client code to work with different types of visitors:\n&quot;</span>;</div><div class="line">  ConcreteVisitor2 *visitor2 = <span class="keyword">new</span> ConcreteVisitor2;</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(components, visitor2);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> Component *comp : components) {</div><div class="line">    <span class="keyword">delete</span> comp;</div><div class="line">  }</div><div class="line">  <span class="keyword">delete</span> visitor1;</div><div class="line">  <span class="keyword">delete</span> visitor2;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>AbstractProductA</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~AbstractProductA(){};</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionA() <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteProductA1 : <span class="keyword">public</span> AbstractProductA</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionA()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product A1.&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteProductA2 : <span class="keyword">public</span> AbstractProductA</div><div class="line">{</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionA()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product A2.&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>AbstractProductB</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~AbstractProductB(){};</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionB() <span class="keyword">const</span> = 0;</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a></div><div class="line">  AnotherUsefulFunctionB(<span class="keyword">const</span> AbstractProductA &amp;collaborator) <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteProductB1 : <span class="keyword">public</span> AbstractProductB</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionB()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product B1.&quot;</span>;</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a></div><div class="line">  AnotherUsefulFunctionB(<span class="keyword">const</span> AbstractProductA &amp;collaborator)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> result = collaborator.UsefulFunctionA();</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the B1 collaborating with ( &quot;</span> + result + <span class="stringliteral">&quot; )&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteProductB2 : <span class="keyword">public</span> AbstractProductB</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionB()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product B2.&quot;</span>;</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a></div><div class="line">  AnotherUsefulFunctionB(<span class="keyword">const</span> AbstractProductA &amp;collaborator)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> result = collaborator.UsefulFunctionA();</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the B2 collaborating with ( &quot;</span> + result + <span class="stringliteral">&quot; )&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>AbstractFactory</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> AbstractProductA *CreateProductA() <span class="keyword">const</span> = 0;</div><div class="line">  <span class="keyword">virtual</span> AbstractProductB *CreateProductB() <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteFactory1 : <span class="keyword">public</span> AbstractFactory</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AbstractProductA *CreateProductA()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductA1();</div><div class="line">  }</div><div class="line">  AbstractProductB *CreateProductB()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductB1();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteFactory2 : <span class="keyword">public</span> AbstractFactory</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AbstractProductA *CreateProductA()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductA2();</div><div class="line">  }</div><div class="line">  AbstractProductB *CreateProductB()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductB2();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(<span class="keyword">const</span> AbstractFactory &amp;factory)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> AbstractProductA *product_a = factory.CreateProductA();</div><div class="line">  <span class="keyword">const</span> AbstractProductB *product_b = factory.CreateProductB();</div><div class="line">  std::cout &lt;&lt; product_b-&gt;UsefulFunctionB() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; product_b-&gt;AnotherUsefulFunctionB(*product_a) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  <span class="keyword">delete</span> product_a;</div><div class="line">  <span class="keyword">delete</span> product_b;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: Testing client code with the first factory type:\n&quot;</span>;</div><div class="line">  ConcreteFactory1 *f1 = <span class="keyword">new</span> ConcreteFactory1();</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(*f1);</div><div class="line">  <span class="keyword">delete</span> f1;</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">  std::cout</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;Client: Testing the same client code with the second factory type:\n&quot;</span>;</div><div class="line">  ConcreteFactory2 *f2 = <span class="keyword">new</span> ConcreteFactory2();</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(*f2);</div><div class="line">  <span class="keyword">delete</span> f2;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">} * </div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>用于测试代码的结果。 *</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>AbstractProductA</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~AbstractProductA(){};</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionA() <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteProductA1 : <span class="keyword">public</span> AbstractProductA</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionA()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product A1.&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteProductA2 : <span class="keyword">public</span> AbstractProductA</div><div class="line">{</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionA()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product A2.&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>AbstractProductB</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~AbstractProductB(){};</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionB() <span class="keyword">const</span> = 0;</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a></div><div class="line">  AnotherUsefulFunctionB(<span class="keyword">const</span> AbstractProductA &amp;collaborator) <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteProductB1 : <span class="keyword">public</span> AbstractProductB</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionB()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product B1.&quot;</span>;</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a></div><div class="line">  AnotherUsefulFunctionB(<span class="keyword">const</span> AbstractProductA &amp;collaborator)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> result = collaborator.UsefulFunctionA();</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the B1 collaborating with ( &quot;</span> + result + <span class="stringliteral">&quot; )&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteProductB2 : <span class="keyword">public</span> AbstractProductB</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> UsefulFunctionB()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product B2.&quot;</span>;</div><div class="line">  }</div><div class="line">  <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a></div><div class="line">  AnotherUsefulFunctionB(<span class="keyword">const</span> AbstractProductA &amp;collaborator)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> result = collaborator.UsefulFunctionA();</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the B2 collaborating with ( &quot;</span> + result + <span class="stringliteral">&quot; )&quot;</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>AbstractFactory</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> AbstractProductA *CreateProductA() <span class="keyword">const</span> = 0;</div><div class="line">  <span class="keyword">virtual</span> AbstractProductB *CreateProductB() <span class="keyword">const</span> = 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteFactory1 : <span class="keyword">public</span> AbstractFactory</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AbstractProductA *CreateProductA()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductA1();</div><div class="line">  }</div><div class="line">  AbstractProductB *CreateProductB()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductB1();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>ConcreteFactory2 : <span class="keyword">public</span> AbstractFactory</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AbstractProductA *CreateProductA()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductA2();</div><div class="line">  }</div><div class="line">  AbstractProductB *CreateProductB()<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductB2();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(<span class="keyword">const</span> AbstractFactory &amp;factory)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> AbstractProductA *product_a = factory.CreateProductA();</div><div class="line">  <span class="keyword">const</span> AbstractProductB *product_b = factory.CreateProductB();</div><div class="line">  std::cout &lt;&lt; product_b-&gt;UsefulFunctionB() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  std::cout &lt;&lt; product_b-&gt;AnotherUsefulFunctionB(*product_a) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">  <span class="keyword">delete</span> product_a;</div><div class="line">  <span class="keyword">delete</span> product_b;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: Testing client code with the first factory type:\n&quot;</span>;</div><div class="line">  ConcreteFactory1 *f1 = <span class="keyword">new</span> ConcreteFactory1();</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(*f1);</div><div class="line">  <span class="keyword">delete</span> f1;</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">  std::cout</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;Client: Testing the same client code with the second factory type:\n&quot;</span>;</div><div class="line">  ConcreteFactory2 *f2 = <span class="keyword">new</span> ConcreteFactory2();</div><div class="line">  <a class="code" href="namespaceDesignPattern_1_1AbstractFactory.html#ad27eba3befd345620140ce97c670c44e">ClientCode</a>(*f2);</div><div class="line">  <span class="keyword">delete</span> f2;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
