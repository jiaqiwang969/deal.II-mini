<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classConvergenceTable.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: ConvergenceTable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classConvergenceTable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ConvergenceTable Class Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__textoutput.html">Textual output</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="convergence__table_8h_source.html">deal.II/base/convergence_table.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ConvergenceTable:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classConvergenceTable__inherit__graph.svg" width="152" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae1ef1c23deebd739950f52b0740ecaab"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaab">RateMode</a> { <a class="el" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba42f9e1dca86047602856df0e19b9f307">none</a>, 
<a class="el" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba7eb96994a8f6f2903e0d68ccae4c5a72">reduction_rate</a>, 
<a class="el" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">reduction_rate_log2</a>
 }</td></tr>
<tr class="separator:ae1ef1c23deebd739950f52b0740ecaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84255fd53f3c75dcbdc4706079d56d8a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8a">TextOutputFormat</a> { <a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8aa3a2f08767f7c1c0c87d0ff4916696317">table_with_headers</a>, 
<a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8aabc13cea8f6e7f62b88b05bf8028f9b58">table_with_separate_column_description</a>, 
<a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8aa1f608224ad0de4e828c4baf4ab071ba0">simple_table_with_separate_column_description</a>, 
<a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8aab8dfaad92bc515243a8a3704f92f6a1a">org_mode_table</a>
 }</td></tr>
<tr class="separator:a84255fd53f3c75dcbdc4706079d56d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a649720e0f6b59cada21788bfead18aa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConvergenceTable.html#a649720e0f6b59cada21788bfead18aa9">ConvergenceTable</a> ()=default</td></tr>
<tr class="separator:a649720e0f6b59cada21788bfead18aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cfdc644108e52ef46372a2111b9cdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConvergenceTable.html#aa5cfdc644108e52ef46372a2111b9cdc">evaluate_convergence_rates</a> (const std::string &amp;data_column_key, const std::string &amp;reference_column_key, const <a class="el" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaab">RateMode</a> rate_mode, const unsigned <a class="el" href="classint.html">int</a> dim=2)</td></tr>
<tr class="separator:aa5cfdc644108e52ef46372a2111b9cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66bf1d7875276dd66a73a2e979ea411"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConvergenceTable.html#ac66bf1d7875276dd66a73a2e979ea411">evaluate_convergence_rates</a> (const std::string &amp;data_column_key, const <a class="el" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaab">RateMode</a> rate_mode)</td></tr>
<tr class="separator:ac66bf1d7875276dd66a73a2e979ea411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad109be44a9b558dd2305b920f2a54623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConvergenceTable.html#ad109be44a9b558dd2305b920f2a54623">omit_column_from_convergence_rate_evaluation</a> (const std::string &amp;key)</td></tr>
<tr class="separator:ad109be44a9b558dd2305b920f2a54623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db85ab54d7c34449061b03ed7fd2dbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConvergenceTable.html#a6db85ab54d7c34449061b03ed7fd2dbf">evaluate_all_convergence_rates</a> (const std::string &amp;reference_column_key, const <a class="el" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaab">RateMode</a> rate_mode)</td></tr>
<tr class="separator:a6db85ab54d7c34449061b03ed7fd2dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18176bb54d7e370c8fd5101234a3ef7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConvergenceTable.html#a18176bb54d7e370c8fd5101234a3ef7d">evaluate_all_convergence_rates</a> (const <a class="el" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaab">RateMode</a> rate_mode)</td></tr>
<tr class="separator:a18176bb54d7e370c8fd5101234a3ef7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be10de14f8b3cc9caadad77ea3247b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a3be10de14f8b3cc9caadad77ea3247b2">declare_column</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a3be10de14f8b3cc9caadad77ea3247b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5484a9516db419a90540a40aba4c6d84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5484a9516db419a90540a40aba4c6d84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a> (const std::string &amp;key, const T value)</td></tr>
<tr class="separator:a5484a9516db419a90540a40aba4c6d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d43be403f341a60b9cc61ac761c5706"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a2d43be403f341a60b9cc61ac761c5706">start_new_row</a> ()</td></tr>
<tr class="separator:a2d43be403f341a60b9cc61ac761c5706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb7335fc1afcc338b6d57e43be39116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a4cb7335fc1afcc338b6d57e43be39116">set_auto_fill_mode</a> (const <a class="el" href="classbool.html">bool</a> state)</td></tr>
<tr class="separator:a4cb7335fc1afcc338b6d57e43be39116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cd640c9e3a2736dfe5c345ebe652d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ab3cd640c9e3a2736dfe5c345ebe652d1">add_column_to_supercolumn</a> (const std::string &amp;key, const std::string &amp;superkey)</td></tr>
<tr class="separator:ab3cd640c9e3a2736dfe5c345ebe652d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83b34eb9cbd403bf2cff04d162ebccc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ab83b34eb9cbd403bf2cff04d162ebccc">set_column_order</a> (const std::vector&lt; std::string &gt; &amp;new_order)</td></tr>
<tr class="separator:ab83b34eb9cbd403bf2cff04d162ebccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4766582d0900d3095fc2efad21ae83e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#af4766582d0900d3095fc2efad21ae83e">set_precision</a> (const std::string &amp;key, const unsigned <a class="el" href="classint.html">int</a> precision)</td></tr>
<tr class="separator:af4766582d0900d3095fc2efad21ae83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded59db14d0341e6ea6cc27165fa918d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#aded59db14d0341e6ea6cc27165fa918d">set_scientific</a> (const std::string &amp;key, const <a class="el" href="classbool.html">bool</a> scientific)</td></tr>
<tr class="separator:aded59db14d0341e6ea6cc27165fa918d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85c292764a506f0691507a0d29b10ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ac85c292764a506f0691507a0d29b10ff">set_tex_caption</a> (const std::string &amp;key, const std::string &amp;tex_caption)</td></tr>
<tr class="separator:ac85c292764a506f0691507a0d29b10ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ab3fd473ea2f8a21d0bb914db59342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a36ab3fd473ea2f8a21d0bb914db59342">set_tex_table_caption</a> (const std::string &amp;table_caption)</td></tr>
<tr class="separator:a36ab3fd473ea2f8a21d0bb914db59342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed20f49e64bfc90d0ab72e6fad5376ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#aed20f49e64bfc90d0ab72e6fad5376ef">set_tex_table_label</a> (const std::string &amp;table_label)</td></tr>
<tr class="separator:aed20f49e64bfc90d0ab72e6fad5376ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3896a239cd72d9839f8a55db563f0f57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a3896a239cd72d9839f8a55db563f0f57">set_tex_supercaption</a> (const std::string &amp;superkey, const std::string &amp;tex_supercaption)</td></tr>
<tr class="separator:a3896a239cd72d9839f8a55db563f0f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11013123ef4b3e44e4ee22e40be21b67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a11013123ef4b3e44e4ee22e40be21b67">set_tex_format</a> (const std::string &amp;key, const std::string &amp;format=&quot;c&quot;)</td></tr>
<tr class="separator:a11013123ef4b3e44e4ee22e40be21b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c4ec9981f3880c6c852ed3aceb08fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a45c4ec9981f3880c6c852ed3aceb08fe">write_text</a> (std::ostream &amp;out, const <a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8a">TextOutputFormat</a> format=<a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8aa3a2f08767f7c1c0c87d0ff4916696317">table_with_headers</a>) const</td></tr>
<tr class="separator:a45c4ec9981f3880c6c852ed3aceb08fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35a3f91ac146fad800eb38437b5e74e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ab35a3f91ac146fad800eb38437b5e74e">write_tex</a> (std::ostream &amp;file, const <a class="el" href="classbool.html">bool</a> with_header=true) const</td></tr>
<tr class="separator:ab35a3f91ac146fad800eb38437b5e74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b814947450218cde1fa257d7968a30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a90b814947450218cde1fa257d7968a30">clear</a> ()</td></tr>
<tr class="separator:a90b814947450218cde1fa257d7968a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad554fd6402d33e6db20b33604758182f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ad554fd6402d33e6db20b33604758182f">clear_current_row</a> ()</td></tr>
<tr class="separator:ad554fd6402d33e6db20b33604758182f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3896c62fe9aeb1830446d9d1c27b1fdb"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a3896c62fe9aeb1830446d9d1c27b1fdb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a3896c62fe9aeb1830446d9d1c27b1fdb">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a3896c62fe9aeb1830446d9d1c27b1fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga8ebf8e9373d39ac4a85263ef552d9263"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8ebf8e9373d39ac4a85263ef552d9263">ExcRateColumnAlreadyExists</a> (std::string arg1)</td></tr>
<tr class="separator:ga8ebf8e9373d39ac4a85263ef552d9263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1964d29d3dd7fab64ca4a4bd1a2bbed5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1964d29d3dd7fab64ca4a4bd1a2bbed5">ExcColumnNotExistent</a> (std::string arg1)</td></tr>
<tr class="separator:ga1964d29d3dd7fab64ca4a4bd1a2bbed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66c6e7096fbed10aee78fcd37407ff6a"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga66c6e7096fbed10aee78fcd37407ff6a">ExcSuperColumnNotExistent</a> (std::string arg1)</td></tr>
<tr class="separator:ga66c6e7096fbed10aee78fcd37407ff6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc45c15bf5ae0b1950b0d810d66914d"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5cc45c15bf5ae0b1950b0d810d66914d">ExcColumnOrSuperColumnNotExistent</a> (std::string arg1)</td></tr>
<tr class="separator:ga5cc45c15bf5ae0b1950b0d810d66914d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fe2afaa41c467464137ae6afb5b32ab"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga6fe2afaa41c467464137ae6afb5b32ab">ExcWrongNumberOfDataEntries</a> (std::string arg1, <a class="el" href="classint.html">int</a> arg2, std::string arg3, <a class="el" href="classint.html">int</a> arg4)</td></tr>
<tr class="separator:ga6fe2afaa41c467464137ae6afb5b32ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fdf1a66743a8f55586aa75deda2cb0"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga24fdf1a66743a8f55586aa75deda2cb0">ExcUndefinedTexFormat</a> (std::string arg1)</td></tr>
<tr class="separator:ga24fdf1a66743a8f55586aa75deda2cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a69b916dc7fb2f171f3965ab1b0fe4d65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a69b916dc7fb2f171f3965ab1b0fe4d65">get_selected_columns</a> (std::vector&lt; std::string &gt; &amp;sel_columns) const</td></tr>
<tr class="separator:a69b916dc7fb2f171f3965ab1b0fe4d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670d250f5bce3406d55ab3d4bc72cded"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a670d250f5bce3406d55ab3d4bc72cded">n_rows</a> () const</td></tr>
<tr class="separator:a670d250f5bce3406d55ab3d4bc72cded"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae9eadbc232f49cf4a39b9eea5318b0c7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ae9eadbc232f49cf4a39b9eea5318b0c7">column_order</a></td></tr>
<tr class="separator:ae9eadbc232f49cf4a39b9eea5318b0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc479809cac5dad2ebb0b8b202ca3d1b"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="structTableHandler_1_1Column.html">Column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#afc479809cac5dad2ebb0b8b202ca3d1b">columns</a></td></tr>
<tr class="separator:afc479809cac5dad2ebb0b8b202ca3d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8ccfeb4f8cb5df5ab21a8e1d53c3b3"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a7d8ccfeb4f8cb5df5ab21a8e1d53c3b3">supercolumns</a></td></tr>
<tr class="separator:a7d8ccfeb4f8cb5df5ab21a8e1d53c3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fadd66861022772b9901ee96b5b6004"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a8fadd66861022772b9901ee96b5b6004">tex_supercaptions</a></td></tr>
<tr class="separator:a8fadd66861022772b9901ee96b5b6004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0920e405beec2a978f2921ccf88ea1d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#aa0920e405beec2a978f2921ccf88ea1d">tex_table_caption</a></td></tr>
<tr class="separator:aa0920e405beec2a978f2921ccf88ea1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ba6a6cc6f4b5c170bdfc9bc0313e26"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a98ba6a6cc6f4b5c170bdfc9bc0313e26">tex_table_label</a></td></tr>
<tr class="separator:a98ba6a6cc6f4b5c170bdfc9bc0313e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825579ea69b3eb16e52f1ec2673b6dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a825579ea69b3eb16e52f1ec2673b6dec">auto_fill_mode</a></td></tr>
<tr class="separator:a825579ea69b3eb16e52f1ec2673b6dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ConvergenceTable类是TableHandler类的一个应用，它存储了一些收敛数据，比如cg方法的残差，或者一些离散解的评估<em>L<sup>2</sup></em>-错误等，并评估收敛率或顺序。 已经实现的::RateMode是::reduction_rate，其中收敛率是下面两行的商，以及::reduction_rate_log2，它评估收敛的顺序。这些标准评估对全局细化很有用，对于局部细化来说，这可能不是一个合适的方法，因为收敛率的设置应该与单元数或DoF数有关。这些非标准方法的实现是留给用户的。 例如，可以通过调用<code>add_value("n cells", n_cells)</code>将单元格的数量添加到表中。DoF的数量可以通过调用`add_value("n
dofs", n_dofs)`添加到表中。当然，我们也可以通过调用add_value()和其他参数来添加更多种类的信息。在任何情况下，在输出表格之前，可以调用函数evaluate_convergence_rates()和evaluate_all_convergence_rates()。 对于如何评估同一RateMode中多列的收敛率，有两种可能性。 </p><ol>
<li>
对所有需要的列调用evaluate_convergence_rates() </li>
<li>
对所有不需要这种评估的列调用omit_column_from_convergence_rate_evaluation() ，然后evaluate_all_convergence_rates() 来评估所有没有被标记为忽略的列的收敛率。 </li>
</ol>
<p>在 <a class="el" href="step_7.html">step-7</a> 和 <a class="el" href="step_13.html">step-13</a> 的示例程序中也可以找到关于这个类的详细讨论。它也被用在 <a class="el" href="step_74.html">step-74</a> 中。 </p>

<p class="definition">Definition at line <a class="el" href="convergence__table_8h_source.html#l00045">45</a> of file <a class="el" href="convergence__table_8h_source.html">convergence_table.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ae1ef1c23deebd739950f52b0740ecaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ef1c23deebd739950f52b0740ecaab">&#9670;&nbsp;</a></span>RateMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaab">ConvergenceTable::RateMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>相对于行的比率。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae1ef1c23deebd739950f52b0740ecaaba42f9e1dca86047602856df0e19b9f307"></a>none&#160;</td><td class="fielddoc"><p>不做任何事情。 </p>
</td></tr>
<tr><td class="fieldname"><a id="ae1ef1c23deebd739950f52b0740ecaaba7eb96994a8f6f2903e0d68ccae4c5a72"></a>reduction_rate&#160;</td><td class="fielddoc"><p>前一行和这一行的值的商数。 </p>
</td></tr>
<tr><td class="fieldname"><a id="ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c"></a>reduction_rate_log2&#160;</td><td class="fielddoc"><p>以2为底的::reduction_rate的对数，代表网格大小减半时的收敛顺序，例如，从h到h/2。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="convergence__table_8h_source.html#l00058">58</a> of file <a class="el" href="convergence__table_8h_source.html">convergence_table.h</a>.</p>

</div>
</div>
<a id="a84255fd53f3c75dcbdc4706079d56d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84255fd53f3c75dcbdc4706079d56d8a">&#9670;&nbsp;</a></span>TextOutputFormat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8a">TableHandler::TextOutputFormat</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一组选项，当用write_text()函数输出时，应该如何格式化一个表格。存在以下可能性。</p>
<ul>
<li><code>table_with_headers</code> : 表格的格式是，内容在每一列的键下对齐，也就是说，键位于每一列的顶部。这适合于列数不多的表格，在这种情况下，整个表格可以显示在屏幕上。输出看起来像这样。 <div class="fragment"><div class="line">key1 key2 key3</div><div class="line">0    0    <span class="stringliteral">&quot;&quot;</span></div><div class="line">1    0    <span class="stringliteral">&quot;&quot;</span></div><div class="line">2    13   a</div><div class="line">1    0    <span class="stringliteral">&quot;&quot;</span></div></div><!-- fragment --></li>
<li><code>table_with_separate_column_description</code> : 当有很多列，而表格整体不能显示在屏幕上时，这是一种更好的格式。在这里，列键首先被逐一列在自己的行上，并被编号以提高可读性。此外，这些描述行的前缀是'#'，以标明这些行是注释，供那些想把下面的表作为数据来读的程序使用，应该忽略这些描述行。GNUPLOT就是这样一个程序，它将自动忽略这些前缀的行。使用这个选项的输出结果看起来像这样。 <div class="fragment"><div class="line"><span class="preprocessor"># 1: key1</span></div><div class="line"><span class="preprocessor"># 2: key2</span></div><div class="line"><span class="preprocessor"># 3: key3</span></div><div class="line">0 0  <span class="stringliteral">&quot;&quot;</span></div><div class="line">1 0  <span class="stringliteral">&quot;&quot;</span></div><div class="line">2 13 a</div><div class="line">1 0  <span class="stringliteral">&quot;&quot;</span></div></div><!-- fragment --></li>
<li><code>simple_table_with_separate_column_description</code> : 这种格式与 <code>table_with_separate_column_description</code> 非常相似，但它跳过了用额外的空白空间对齐列。这提高了大表的write_text()的性能。输出示例。 <div class="fragment"><div class="line"><span class="preprocessor"># 1: key1</span></div><div class="line"><span class="preprocessor"># 2: key2</span></div><div class="line"><span class="preprocessor"># 3: key3</span></div><div class="line">0 0 <span class="stringliteral">&quot;&quot;</span></div><div class="line">1 0 <span class="stringliteral">&quot;&quot;</span></div><div class="line">2 13 a</div><div class="line">1 0 <span class="stringliteral">&quot;&quot;</span></div></div><!-- fragment --></li>
<li><code>org_mode_table</code> : 输出为 org-mode (<a href="http://orgmode.org/">http://orgmode.org/</a>) 表格格式。将org-mode表格转换为HTML/LaTeX/csv很容易。 输出示例。 <div class="fragment"><div class="line">| key1 | key2 | key3 |</div><div class="line">| 0    | 0    | <span class="stringliteral">&quot;&quot;</span>   |</div><div class="line">| 1    | 0    | <span class="stringliteral">&quot;&quot;</span>   |</div><div class="line">| 2    | 13   | a    |</div><div class="line">| 1    | 0    | <span class="stringliteral">&quot;&quot;</span>   |</div></div><!-- fragment --> </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a84255fd53f3c75dcbdc4706079d56d8aa3a2f08767f7c1c0c87d0ff4916696317"></a>table_with_headers&#160;</td><td class="fielddoc"><p>打印带有页眉的表格。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a84255fd53f3c75dcbdc4706079d56d8aabc13cea8f6e7f62b88b05bf8028f9b58"></a>table_with_separate_column_description&#160;</td><td class="fielddoc"><p>为每一列标签单独打印表格。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a84255fd53f3c75dcbdc4706079d56d8aa1f608224ad0de4e828c4baf4ab071ba0"></a>simple_table_with_separate_column_description&#160;</td><td class="fielddoc"><p>像table_with_separate_column_description一样，但不对包含列标签的列进行对齐。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a84255fd53f3c75dcbdc4706079d56d8aab8dfaad92bc515243a8a3704f92f6a1a"></a>org_mode_table&#160;</td><td class="fielddoc"><p>以org模式的格式打印表格。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00311">311</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a649720e0f6b59cada21788bfead18aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649720e0f6b59cada21788bfead18aa9">&#9670;&nbsp;</a></span>ConvergenceTable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConvergenceTable::ConvergenceTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构建器。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa5cfdc644108e52ef46372a2111b9cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cfdc644108e52ef46372a2111b9cdc">&#9670;&nbsp;</a></span>evaluate_convergence_rates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConvergenceTable::evaluate_convergence_rates </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data_column_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reference_column_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaab">RateMode</a>&#160;</td>
          <td class="paramname"><em>rate_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>评估数据列<code>data_column_key</code>的收敛率，由于::RateMode与参考列&lt;tt&gt;reference_column_key的关系。要确保数据列和参考数据列的表项的值类型是一个数字，即double, float, (unsigned) int，等等。 由于这个类没有关于参考列与值列所依据的空间维度的信息，所以需要作为最后一个参数传递给这个方法。<em>default dimension for the reference column</em>是2，这对于2D中的单元格数量是合适的。如果参考列是 \(1/h\) ，记得在三维中工作时也要将维数设置为1，以获得正确的速率。 新的速率列和数据列将被合并为一个超级列。 超级列的文本标题将（默认）与数据列的标题相同。这可以通过使用基类TableHandler的<code>set_tex_supercaption (..)</code>函数来改变。 这个方法的行为方式是这样的。 如果RateMode是reduction_rate，那么计算出来的输出是 \( \frac{e_{n-1}/k_{n-1}}{e_n/k_n}, \) ，其中 \(k\) 是参考列（没有维度依赖！）。 如果RateMode是reduction_rate_log2，那么计算的输出结果是 \( dim \frac{\log |e_{n-1}/e_{n}|}{\log |k_n/k_{n-1}|} \) 。 这很有用，例如，如果我们使用自由度的数量作为参考键，或者更好的是使用单元格的数量。 假设二维的误差与 \( C (1/\sqrt{k})^r \) 成正比，那么这个方法将产生 \(r\) 的结果。对于一般的维度，如这个函数的最后一个参数所描述的，公式需要是 \( C (1/\sqrt[dim]{k})^r \) 。 </p><dl class="section note"><dt>Note</dt><dd>因为这个函数是在几行已经被填满之后才向表格添加列的，所以它关闭了TableHandler基类的自动填充模式。如果你打算用自动填充的方式进一步添加数据，你必须在调用这个函数后重新启用它。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="convergence__table_8cc_source.html#l00023">23</a> of file <a class="el" href="convergence__table_8cc_source.html">convergence_table.cc</a>.</p>

</div>
</div>
<a id="ac66bf1d7875276dd66a73a2e979ea411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66bf1d7875276dd66a73a2e979ea411">&#9670;&nbsp;</a></span>evaluate_convergence_rates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConvergenceTable::evaluate_convergence_rates </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data_column_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaab">RateMode</a>&#160;</td>
          <td class="paramname"><em>rate_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>评估数据列<code>data_column_key</code>由于::RateMode的收敛率。 要确保数据列的表项的值类型是一个数字，即双数、浮点数、（无符号）int，等等。 新的速率列和数据列将被合并为一个超级列。 超级列的文本标题将（默认）与数据列的标题相同。这可以通过使用基类TableHandler的set_tex_supercaption()函数来改变。 </p><dl class="section note"><dt>Note</dt><dd>由于这个函数是在几行已经被填满之后才向表添加列的，所以它关闭了TableHandler基类的自动填充模式。如果你打算用自动填充的方式进一步添加数据，你必须在调用这个函数后重新启用它。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="convergence__table_8cc_source.html#l00127">127</a> of file <a class="el" href="convergence__table_8cc_source.html">convergence_table.cc</a>.</p>

</div>
</div>
<a id="ad109be44a9b558dd2305b920f2a54623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad109be44a9b558dd2305b920f2a54623">&#9670;&nbsp;</a></span>omit_column_from_convergence_rate_evaluation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConvergenceTable::omit_column_from_convergence_rate_evaluation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在评估 "所有
"列的收敛率时省略此列<code>key</code>（不是超级列！）（见下面两个函数）。 <a class="el" href="structTableHandler_1_1Column.html#a510700c8677b3bdc733c276803ee4b27">Column::flag</a>==1 是为从收敛率评估中省略该列而保留的。 </p>

<p class="definition">Definition at line <a class="el" href="convergence__table_8cc_source.html#l00218">218</a> of file <a class="el" href="convergence__table_8cc_source.html">convergence_table.cc</a>.</p>

</div>
</div>
<a id="a6db85ab54d7c34449061b03ed7fd2dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db85ab54d7c34449061b03ed7fd2dbf">&#9670;&nbsp;</a></span>evaluate_all_convergence_rates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConvergenceTable::evaluate_all_convergence_rates </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reference_column_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaab">RateMode</a>&#160;</td>
          <td class="paramname"><em>rate_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>评估由于<code>rate_mode</code>与参考列<code>reference_column_key</code>有关的收敛率。这个函数评估所有列的速率，除了要省略的列（见前面的函数）和以前评估过的速率列之外。 这个函数允许评估一个表中几乎所有列的收敛率，而不需要为每一列单独调用evaluate_convergence_rates()。 例子。像<code>n cells</code>或<code>n dofs</code>列可能希望在评估收敛率时被省略。因此他们应该通过调用 <a class="el" href="classConvergenceTable.html#ad109be44a9b558dd2305b920f2a54623">omit_column_from_convergence_rate_evaluation()</a>来省略。 </p>

<p class="definition">Definition at line <a class="el" href="convergence__table_8cc_source.html#l00230">230</a> of file <a class="el" href="convergence__table_8cc_source.html">convergence_table.cc</a>.</p>

</div>
</div>
<a id="a18176bb54d7e370c8fd5101234a3ef7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18176bb54d7e370c8fd5101234a3ef7d">&#9670;&nbsp;</a></span>evaluate_all_convergence_rates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConvergenceTable::evaluate_all_convergence_rates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaab">RateMode</a>&#160;</td>
          <td class="paramname"><em>rate_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>评估由于<code>rate_mode</code>引起的收敛率。这个函数评估所有列的速率，除了将被省略的列（见前一个函数）和先前评估的速率列之外。 这个函数允许评估一个表中几乎所有列的收敛率，而不需要为每一列单独调用evaluate_convergence_rates()。 例子。像<code>n cells</code>或<code>n dofs</code>列可能希望在评估收敛率时被省略。因此他们应该通过调用 <a class="el" href="classConvergenceTable.html#ad109be44a9b558dd2305b920f2a54623">omit_column_from_convergence_rate_evaluation()</a>来省略。 </p>

<p class="definition">Definition at line <a class="el" href="convergence__table_8cc_source.html#l00246">246</a> of file <a class="el" href="convergence__table_8cc_source.html">convergence_table.cc</a>.</p>

</div>
</div>
<a id="a3be10de14f8b3cc9caadad77ea3247b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be10de14f8b3cc9caadad77ea3247b2">&#9670;&nbsp;</a></span>declare_column()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::declare_column </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过给它一个名字来声明表格中的一个列的存在。 正如在该类的文档中所讨论的，这通常是不必要的。</p>
<ul>
<li>只是通过add_value()函数为一个给定的列键添加一个值，也声明了该列。因此，这个函数只有在以下情况下才是必要的：你希望一个列也能显示出来，即使你从未在这一列的任何行中添加过条目；或者，更有可能的是，如果你想规定以后打印列的顺序，在条目被放进列之前以特定顺序声明列。 后者的目的也可以通过在程序中以任何顺序向表中添加条目，然后调用set_column_order()来实现。然而，这种方法需要知道</li>
<li>在你的软件的一个中心位置</li>
<li>软件的其他部分写入的所有列键，以及它们应该如何排序。这对小程序来说很容易做到，但对大型代码库来说可能不可行，因为代码库的部分内容只根据运行时的参数来执行。) </li>
</ul>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00204">204</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a5484a9516db419a90540a40aba4c6d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5484a9516db419a90540a40aba4c6d84">&#9670;&nbsp;</a></span>add_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::add_value </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>添加一个键为<code>key</code>的列（如果尚未存在），并将类型为<code>T</code>的值添加到该列。<code>T</code>类型的值必须可以转换为<code>int, unsigned int, double, std::uint64_t, std::string</code> 中的一种，否则将导致编译器错误。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00865">865</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="a2d43be403f341a60b9cc61ac761c5706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d43be403f341a60b9cc61ac761c5706">&#9670;&nbsp;</a></span>start_new_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::start_new_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果一行只被部分填满，那么就把该行中某一列中不存在元素的所有元素设置为空字符串。这类似于在介绍中描述的 "auto_fill_mode"，但更普遍，因为它允许你开始向新行的某一列中写入内容，而不必知道该列在前一行已经被写入。 如果当前行的所有列都被写入了，那么这个函数根本就不做任何事情。换句话说，从概念上讲，这个函数 "完成 "了当前行，尽管它的用例是 "开始 "一个新行。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00218">218</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a4cb7335fc1afcc338b6d57e43be39116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb7335fc1afcc338b6d57e43be39116">&#9670;&nbsp;</a></span>set_auto_fill_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_auto_fill_mode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>开启或关闭自动填充模式。关于自动填充模式的描述，请参见该类的一般文档。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00245">245</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="ab3cd640c9e3a2736dfe5c345ebe652d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cd640c9e3a2736dfe5c345ebe652d1">&#9670;&nbsp;</a></span>add_column_to_supercolumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::add_column_to_supercolumn </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>superkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建一个超级列（如果还不存在的话）并将列纳入其中。 列和超级列的键分别是<code>key</code>和<code>superkey</code>。 要将两个列<code>c1</code>和<code>c2</code>合并到一个超级列<code>sc</code>，因此调用<code>add_column_to_supercolumn(c1,sc)</code>和<code>add_column_to_supercolumn(c2,sc)</code>。 关于列的顺序，超级列取代了被添加到超级列的第一列。在超级列中，输出的顺序是按照添加到超级列中的列的顺序。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00252">252</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="ab83b34eb9cbd403bf2cff04d162ebccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83b34eb9cbd403bf2cff04d162ebccc">&#9670;&nbsp;</a></span>set_column_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_column_order </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>改变表格中列和超级列的顺序。 <code>new_order</code>包括列和超列的键和超键，其顺序是用户希望它们被输出。如果包含了超键，子列的键就不需要在这个向量中明确提及。 超级列内的子列的顺序是不可改变的，仍然是按照列被添加到超级列的顺序。 这个函数也可以用来把列数太多的大表分解成小表。例如，你可以用前五列调用这个函数，然后调用其中一个<code>write_*</code>函数，然后用下五列调用这个函数，再一次<code>write_*</code>，如此循环。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00296">296</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="af4766582d0900d3095fc2efad21ae83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4766582d0900d3095fc2efad21ae83e">&#9670;&nbsp;</a></span>set_precision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_precision </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置<code>precision</code>，例如，双数或浮点数变量的写入方式。<code>precision</code>与调用<code>out&lt;&lt;setprecision(precision)</code>时相同。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00359">359</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="aded59db14d0341e6ea6cc27165fa918d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded59db14d0341e6ea6cc27165fa918d">&#9670;&nbsp;</a></span>set_scientific()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_scientific </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置<code>scientific_flag</code>。真表示科学，假表示定点记数法。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00372">372</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="ac85c292764a506f0691507a0d29b10ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85c292764a506f0691507a0d29b10ff">&#9670;&nbsp;</a></span>set_tex_caption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_tex_caption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tex_caption</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置tex输出的<code>key</code>列的标题。你可能想选择与<code>key</code>不同的，如果它包含公式或类似结构。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00310">310</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a36ab3fd473ea2f8a21d0bb914db59342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ab3fd473ea2f8a21d0bb914db59342">&#9670;&nbsp;</a></span>set_tex_table_caption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_tex_table_caption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>table_caption</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置整个<code>table</code>的tex标题，用于tex输出。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00320">320</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="aed20f49e64bfc90d0ab72e6fad5376ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed20f49e64bfc90d0ab72e6fad5376ef">&#9670;&nbsp;</a></span>set_tex_table_label()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_tex_table_label </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>table_label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置这个<code>表的标签</code>，用于文本输出。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00328">328</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a3896a239cd72d9839f8a55db563f0f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3896a239cd72d9839f8a55db563f0f57">&#9670;&nbsp;</a></span>set_tex_supercaption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_tex_supercaption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>superkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tex_supercaption</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置超级列的标题<code>superkey</code>，用于特克斯输出。 你可能想选择与<code>superkey</code>不同的，如果它包含公式或类似的结构。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00336">336</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a11013123ef4b3e44e4ee22e40be21b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11013123ef4b3e44e4ee22e40be21b67">&#9670;&nbsp;</a></span>set_tex_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_tex_format </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;c&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置一个列的tex输出格式，例如：<code>c</code>, <code>r</code>, <code>l</code>, 或者<code>p{3cm}</code>。默认是<code>c</code>。另外，如果没有为某一列调用这个函数，默认值将被预设为<code>c</code>。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00347">347</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a45c4ec9981f3880c6c852ed3aceb08fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c4ec9981f3880c6c852ed3aceb08fe">&#9670;&nbsp;</a></span>write_text()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::write_text </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8a">TextOutputFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8aa3a2f08767f7c1c0c87d0ff4916696317">table_with_headers</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将表格作为格式化的文本写入给定的流中。文本的格式是这样的：它将数据表示为格式化的文本列。为了避免在自动读取这些表格时出现问题，例如用于后处理，如果该表的某个单元格中的条目是空的（即它是通过调用add_value()函数用空字符串创建的），那么该表的条目将被打印为 <code>""</code> 。 第二个参数表示如何显示列键。更多信息请参见TextOutputFormat的描述。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00384">384</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="ab35a3f91ac146fad800eb38437b5e74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35a3f91ac146fad800eb38437b5e74e">&#9670;&nbsp;</a></span>write_tex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::write_tex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>with_header</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将表写成一个tex文件。如果 <code>with_header</code> 被设置为false，那么就不使用 <code>\documentclass{...}</code>, <code>\begin{document}</code> 和 <code>\end{document}</code> 。这样，该文件就可以用 <code>\input{table_file}</code> 这样的命令包含到一个现有的tex文件中。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00600">600</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a90b814947450218cde1fa257d7968a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b814947450218cde1fa257d7968a30">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>清除表格的行，即在所有底层存储数据结构上调用clear()。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00742">742</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="ad554fd6402d33e6db20b33604758182f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad554fd6402d33e6db20b33604758182f">&#9670;&nbsp;</a></span>clear_current_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::clear_current_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>删除所有在当前行添加的值。例如，当一个时间步长被拒绝，所有关于它的数据记录都需要被丢弃时，这就很有用。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00807">807</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a3896c62fe9aeb1830446d9d1c27b1fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3896c62fe9aeb1830446d9d1c27b1fdb">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00924">924</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="a69b916dc7fb2f171f3965ab1b0fe4d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b916dc7fb2f171f3965ab1b0fe4d65">&#9670;&nbsp;</a></span>get_selected_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::get_selected_columns </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sel_columns</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>帮助函数，给出<code>column_order</code>中提到的所有列的键的向量，其中每个超级列的键被其子列的键所替代。 这个函数隐含地检查数据的一致性。结果在<code>sel_columns</code>中返回。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00776">776</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a670d250f5bce3406d55ab3d4bc72cded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670d250f5bce3406d55ab3d4bc72cded">&#9670;&nbsp;</a></span>n_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> TableHandler::n_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>内置函数，给出表中的行数，并检查每一列的行数是否相等。这个函数可以在写输出之前调用。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00755">755</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae9eadbc232f49cf4a39b9eea5318b0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9eadbc232f49cf4a39b9eea5318b0c7">&#9670;&nbsp;</a></span>column_order</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; TableHandler::column_order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个变量，按照用户希望的顺序存储列和超列的键。默认情况下这是添加列的顺序。这个顺序可以通过set_column_order()来改变。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00688">688</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="afc479809cac5dad2ebb0b8b202ca3d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc479809cac5dad2ebb0b8b202ca3d1b">&#9670;&nbsp;</a></span>columns</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="structTableHandler_1_1Column.html">Column</a>&gt; TableHandler::columns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个从列键到列的映射（不是超级列）。 这个字段被声明为可变的，以便write_text()和write_tex()函数可以是常数，即使它们在'auto_fill_mode'开启的情况下可能会在下面填充列。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00695">695</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="a7d8ccfeb4f8cb5df5ab21a8e1d53c3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8ccfeb4f8cb5df5ab21a8e1d53c3b3">&#9670;&nbsp;</a></span>supercolumns</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;std::string&gt; &gt; TableHandler::supercolumns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个从每个超级列的键到其子列的键的正确顺序的映射。 允许一个超级列与一个列有相同的键。 注意，我们在这里不使用<code>multimap</code>，因为每个超级列键的顺序是相关的。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00703">703</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="a8fadd66861022772b9901ee96b5b6004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fadd66861022772b9901ee96b5b6004">&#9670;&nbsp;</a></span>tex_supercaptions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::string&gt; TableHandler::tex_supercaptions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个从超级列键到超级列标题的映射，在tex输出中使用。 默认情况下，这些只是超级列的键，但它们可以通过<code>set_tex_supercaptions(...)</code>改变。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00710">710</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="aa0920e405beec2a978f2921ccf88ea1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0920e405beec2a978f2921ccf88ea1d">&#9670;&nbsp;</a></span>tex_table_caption</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string TableHandler::tex_table_caption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>表格本身的标题。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00716">716</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="a98ba6a6cc6f4b5c170bdfc9bc0313e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ba6a6cc6f4b5c170bdfc9bc0313e26">&#9670;&nbsp;</a></span>tex_table_label</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string TableHandler::tex_table_label</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>该表的标签。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00721">721</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="a825579ea69b3eb16e52f1ec2673b6dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825579ea69b3eb16e52f1ec2673b6dec">&#9670;&nbsp;</a></span>auto_fill_mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TableHandler::auto_fill_mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>表示是否应该使用自动填充模式的标志。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00727">727</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="convergence__table_8h_source.html">convergence_table.h</a></li>
<li>source/base/<a class="el" href="convergence__table_8cc_source.html">convergence_table.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
