<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classhp_1_1FECollection.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: hp::FECollection&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehp.html">hp</a></li><li class="navelem"><a class="el" href="classhp_1_1FECollection.html">FECollection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classhp_1_1FECollection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hp::FECollection&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__hp.html">hp-finite element support</a><a class="el" href="group__hp.html">hp-finite element support</a> &raquo;  &#124; <a class="el" href="group__hpcollection.html">hp-Collections</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fe__collection_8h_source.html">deal.II/hp/fe_collection.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for hp::FECollection&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhp_1_1FECollection__inherit__graph.svg" width="1410" height="294"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhp_1_1FECollection_1_1DefaultHierarchy.html">DefaultHierarchy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af94bc4d5c944da27c3e0189cd92e979c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#af94bc4d5c944da27c3e0189cd92e979c">FECollection</a> ()</td></tr>
<tr class="separator:af94bc4d5c944da27c3e0189cd92e979c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b557e20b5abc09c7be5158c3f034955"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a6b557e20b5abc09c7be5158c3f034955">FECollection</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe)</td></tr>
<tr class="separator:a6b557e20b5abc09c7be5158c3f034955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63763c1f266928722f599e9da1f2baf9"><td class="memTemplParams" colspan="2">template&lt;class... FETypes&gt; </td></tr>
<tr class="memitem:a63763c1f266928722f599e9da1f2baf9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a63763c1f266928722f599e9da1f2baf9">FECollection</a> (const FETypes &amp;... fes)</td></tr>
<tr class="separator:a63763c1f266928722f599e9da1f2baf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33779cbf32c4f124cda38eeb790a8c62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a33779cbf32c4f124cda38eeb790a8c62">FECollection</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;fes)</td></tr>
<tr class="separator:a33779cbf32c4f124cda38eeb790a8c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f7b4ccf64ce616f22e046fabd215e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#ad8f7b4ccf64ce616f22e046fabd215e6">FECollection</a> (const <a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;)=default</td></tr>
<tr class="separator:ad8f7b4ccf64ce616f22e046fabd215e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2495f87c9518a2e3afa78599823e2d4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a2495f87c9518a2e3afa78599823e2d4f">FECollection</a> (<a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&amp;) noexcept(std::is_nothrow_move_constructible&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;&gt;&gt;::value &amp;&amp;std::is_nothrow_move_constructible&lt; std::function&lt; unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt;&gt;::value)=default</td></tr>
<tr class="separator:a2495f87c9518a2e3afa78599823e2d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f70cf84f2dc79b9cc2858d9dbf27fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a02f70cf84f2dc79b9cc2858d9dbf27fa">operator=</a> (<a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&amp;)=default</td></tr>
<tr class="separator:a02f70cf84f2dc79b9cc2858d9dbf27fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3282c173b24b3e937b30baffd8c087f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a3282c173b24b3e937b30baffd8c087f6">operator==</a> (const <a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;fe_collection) const</td></tr>
<tr class="separator:a3282c173b24b3e937b30baffd8c087f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cfe7309c06d410f18cf0623aac4c85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a80cfe7309c06d410f18cf0623aac4c85">operator!=</a> (const <a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;fe_collection) const</td></tr>
<tr class="separator:a80cfe7309c06d410f18cf0623aac4c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0e75a805ff012e76d33ad6d4c3eac8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;new_fe)</td></tr>
<tr class="separator:a4b0e75a805ff012e76d33ad6d4c3eac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4bafb2f8e59ae8c0165f31db334205"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a> () const</td></tr>
<tr class="separator:add4bafb2f8e59ae8c0165f31db334205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8eea6cc97389fe6ea1f479cdbadd60c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#ad8eea6cc97389fe6ea1f479cdbadd60c">n_blocks</a> () const</td></tr>
<tr class="separator:ad8eea6cc97389fe6ea1f479cdbadd60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd571a96bd66ee1cfd970dc87434d88"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a6cd571a96bd66ee1cfd970dc87434d88">max_degree</a> () const</td></tr>
<tr class="separator:a6cd571a96bd66ee1cfd970dc87434d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173d07546d8bd925c5a113b11fa63ae8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a173d07546d8bd925c5a113b11fa63ae8">max_dofs_per_vertex</a> () const</td></tr>
<tr class="separator:a173d07546d8bd925c5a113b11fa63ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5e8de2d3c1c033fb4bddddfc35314f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a0a5e8de2d3c1c033fb4bddddfc35314f">max_dofs_per_line</a> () const</td></tr>
<tr class="separator:a0a5e8de2d3c1c033fb4bddddfc35314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9864eddabbc3df8729ce06b822464d84"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a9864eddabbc3df8729ce06b822464d84">max_dofs_per_quad</a> () const</td></tr>
<tr class="separator:a9864eddabbc3df8729ce06b822464d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d152cf2356925186c85a22370c3a26f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a0d152cf2356925186c85a22370c3a26f">max_dofs_per_hex</a> () const</td></tr>
<tr class="separator:a0d152cf2356925186c85a22370c3a26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c51e1333e89c241e6ce856b206f8ba"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a71c51e1333e89c241e6ce856b206f8ba">max_dofs_per_face</a> () const</td></tr>
<tr class="separator:a71c51e1333e89c241e6ce856b206f8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae849636cc622a9fdd00305698b9d455c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#ae849636cc622a9fdd00305698b9d455c">max_dofs_per_cell</a> () const</td></tr>
<tr class="separator:ae849636cc622a9fdd00305698b9d455c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a5f7c2639e467e2192d6eb0c97b468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a29a5f7c2639e467e2192d6eb0c97b468">hp_constraints_are_implemented</a> () const</td></tr>
<tr class="separator:a29a5f7c2639e467e2192d6eb0c97b468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432501b9eb6b276132e1da0ec83a03ef"><td class="memItemLeft" align="right" valign="top">std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a432501b9eb6b276132e1da0ec83a03ef">find_common_fes</a> (const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;fes, const unsigned <a class="el" href="classint.html">int</a> codim=0) const</td></tr>
<tr class="separator:a432501b9eb6b276132e1da0ec83a03ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eba9b691c9f0b12f04b39fd2cac89ad"><td class="memItemLeft" align="right" valign="top">std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a6eba9b691c9f0b12f04b39fd2cac89ad">find_enclosing_fes</a> (const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;fes, const unsigned <a class="el" href="classint.html">int</a> codim=0) const</td></tr>
<tr class="separator:a6eba9b691c9f0b12f04b39fd2cac89ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df6ca3a652ba86592d6ea0b94a03e1d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a6df6ca3a652ba86592d6ea0b94a03e1d">find_dominating_fe</a> (const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;fes, const unsigned <a class="el" href="classint.html">int</a> codim=0) const</td></tr>
<tr class="separator:a6df6ca3a652ba86592d6ea0b94a03e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719793132cab791f215ee96b4d5f0c75"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a719793132cab791f215ee96b4d5f0c75">find_dominated_fe</a> (const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;fes, const unsigned <a class="el" href="classint.html">int</a> codim=0) const</td></tr>
<tr class="separator:a719793132cab791f215ee96b4d5f0c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4f34d801d827773a91ff539ffabadd"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a1c4f34d801d827773a91ff539ffabadd">find_dominating_fe_extended</a> (const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;fes, const unsigned <a class="el" href="classint.html">int</a> codim=0) const</td></tr>
<tr class="separator:a1c4f34d801d827773a91ff539ffabadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4e336f83e16ba6291d3748d52438d8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#aae4e336f83e16ba6291d3748d52438d8">find_dominated_fe_extended</a> (const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;fes, const unsigned <a class="el" href="classint.html">int</a> codim=0) const</td></tr>
<tr class="separator:aae4e336f83e16ba6291d3748d52438d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae7823f04f51f2daaf0b770a151b1b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a8ae7823f04f51f2daaf0b770a151b1b1">set_hierarchy</a> (const std::function&lt; unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;next, const std::function&lt; unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;prev)</td></tr>
<tr class="separator:a8ae7823f04f51f2daaf0b770a151b1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573c653d73cc02496fd61ebee6c00b00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a573c653d73cc02496fd61ebee6c00b00">set_default_hierarchy</a> ()</td></tr>
<tr class="separator:a573c653d73cc02496fd61ebee6c00b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dab011b71ea35f86c433392d42ca15b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a0dab011b71ea35f86c433392d42ca15b">get_hierarchy_sequence</a> (const unsigned <a class="el" href="classint.html">int</a> fe_index=0) const</td></tr>
<tr class="separator:a0dab011b71ea35f86c433392d42ca15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520c6b1493b469686e9a36f6aae087ec"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a520c6b1493b469686e9a36f6aae087ec">next_in_hierarchy</a> (const unsigned <a class="el" href="classint.html">int</a> fe_index) const</td></tr>
<tr class="separator:a520c6b1493b469686e9a36f6aae087ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091d817c47838ec112afba864ef51fdb"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a091d817c47838ec112afba864ef51fdb">previous_in_hierarchy</a> (const unsigned <a class="el" href="classint.html">int</a> fe_index) const</td></tr>
<tr class="separator:a091d817c47838ec112afba864ef51fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdf2f55585aa8a5777535b57b220a17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const</td></tr>
<tr class="separator:a7cdf2f55585aa8a5777535b57b220a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d17b05f9180827ea291fdb798dca525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a5d17b05f9180827ea291fdb798dca525">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const</td></tr>
<tr class="separator:a5d17b05f9180827ea291fdb798dca525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f643ca875e5a1e40500cd0d9e43e37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#ac8f643ca875e5a1e40500cd0d9e43e37">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;sym_tensor) const</td></tr>
<tr class="separator:ac8f643ca875e5a1e40500cd0d9e43e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb50939b9305ac2880d54007a827d22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#afbb50939b9305ac2880d54007a827d22">component_mask</a> (const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;<a class="el" href="classhp_1_1FECollection.html#af8afd8e5ed60f7ad7fc71e3f96e2f5f3">block_mask</a>) const</td></tr>
<tr class="separator:afbb50939b9305ac2880d54007a827d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8afd8e5ed60f7ad7fc71e3f96e2f5f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#af8afd8e5ed60f7ad7fc71e3f96e2f5f3">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const</td></tr>
<tr class="separator:af8afd8e5ed60f7ad7fc71e3f96e2f5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9e9f51f57c6526d643104df76384fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#acf9e9f51f57c6526d643104df76384fd">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const</td></tr>
<tr class="separator:acf9e9f51f57c6526d643104df76384fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030037ceecf42a6ca0719eb8385fc2a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a030037ceecf42a6ca0719eb8385fc2a3">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;sym_tensor) const</td></tr>
<tr class="separator:a030037ceecf42a6ca0719eb8385fc2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb077f2b8eb8671342ac13e232fd520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a6bb077f2b8eb8671342ac13e232fd520">block_mask</a> (const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>) const</td></tr>
<tr class="separator:a6bb077f2b8eb8671342ac13e232fd520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e43005f6dc7f4096e9f03fb77ac7fa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1Collection.html#a1e43005f6dc7f4096e9f03fb77ac7fa1">push_back</a> (const std::shared_ptr&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &gt; &amp;new_entry)</td></tr>
<tr class="separator:a1e43005f6dc7f4096e9f03fb77ac7fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cd609468d1724dd4bbe4e7d3676c09"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1Collection.html#ae7cd609468d1724dd4bbe4e7d3676c09">operator[]</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:ae7cd609468d1724dd4bbe4e7d3676c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e51c9371e925145c42840d72f4a0bf7"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1Collection.html#a9e51c9371e925145c42840d72f4a0bf7">size</a> () const</td></tr>
<tr class="separator:a9e51c9371e925145c42840d72f4a0bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8900b5562cbfa4523e0aff131ad3190"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1Collection.html#aa8900b5562cbfa4523e0aff131ad3190">memory_consumption</a> () const</td></tr>
<tr class="separator:aa8900b5562cbfa4523e0aff131ad3190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">异常情况 @{</div></td></tr>
<tr class="memitem:gaef4c33e67a59b701207418cc5526d54a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaef4c33e67a59b701207418cc5526d54a">DeclException0</a> (ExcNoFiniteElements)</td></tr>
<tr class="separator:gaef4c33e67a59b701207418cc5526d54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4076a62850571b131946f2221ed87a28"><td class="memItemLeft" align="right" valign="top">std::function&lt; unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a4076a62850571b131946f2221ed87a28">hierarchy_next</a></td></tr>
<tr class="separator:a4076a62850571b131946f2221ed87a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca57244f0a037efa4ae8ce5e06c24314"><td class="memItemLeft" align="right" valign="top">std::function&lt; unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#aca57244f0a037efa4ae8ce5e06c24314">hierarchy_prev</a></td></tr>
<tr class="separator:aca57244f0a037efa4ae8ce5e06c24314"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class hp::FECollection&lt; dim, spacedim &gt;</h3>

<p>该类作为DoFHandler中使用的有限元对象的集合。 它实现了doxygen文档中描述的 <a class="el" href="group__hpcollection.html">hp-Collections</a> 模块中的概念。 除了提供对集合元素的访问外，该类还提供对每个顶点、线等的最大自由度的访问，以便在使用与三角形单元相关的有限元时，在最坏的情况下分配尽可能多的内存。 这个类还没有实现在一维情况下的使用（<code>spacedim != dim </code>）。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00045">45</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af94bc4d5c944da27c3e0189cd92e979c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94bc4d5c944da27c3e0189cd92e979c">&#9670;&nbsp;</a></span>FECollection() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::<a class="el" href="classhp_1_1FECollection.html">FECollection</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>默认构造函数。导致一个空的集合，以后可以用push_back()来填充。建立一个有限元的层次结构，与它们在集合中的索引相对应。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00240">240</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a6b557e20b5abc09c7be5158c3f034955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b557e20b5abc09c7be5158c3f034955">&#9670;&nbsp;</a></span>FECollection() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::<a class="el" href="classhp_1_1FECollection.html">FECollection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>转换构造函数。这个构造函数从一个单一的有限元创建一个FECollection。如果需要，可以用push_back()添加更多的有限元对象，尽管用同样的方式添加所有的映射可能会更清楚。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00248">248</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a63763c1f266928722f599e9da1f2baf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63763c1f266928722f599e9da1f2baf9">&#9670;&nbsp;</a></span>FECollection() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class... FETypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::<a class="el" href="classhp_1_1FECollection.html">FECollection</a> </td>
          <td>(</td>
          <td class="paramtype">const FETypes &amp;...&#160;</td>
          <td class="paramname"><em>fes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构造函数。这个构造函数从传递给构造函数的一个或多个有限元对象创建一个FECollection。为了使这个调用有效，所有的参数都需要是派生自FiniteElement&lt;dim,spacedim&gt;类的类型。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00575">575</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a33779cbf32c4f124cda38eeb790a8c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33779cbf32c4f124cda38eeb790a8c62">&#9670;&nbsp;</a></span>FECollection() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::<a class="el" href="classhp_1_1FECollection.html">FECollection</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。和上面一样，但是对于任何数量的元素。元素的指针以向量形式传递给这个构造函数。如上所述，参数所指向的有限元对象除了在内部创建副本外，实际上并不使用。因此，你可以在调用这个构造函数后立即再次删除这些指针。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00258">258</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="ad8f7b4ccf64ce616f22e046fabd215e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f7b4ccf64ce616f22e046fabd215e6">&#9670;&nbsp;</a></span>FECollection() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::<a class="el" href="classhp_1_1FECollection.html">FECollection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>拷贝构造函数。 </p>

</div>
</div>
<a id="a2495f87c9518a2e3afa78599823e2d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2495f87c9518a2e3afa78599823e2d4f">&#9670;&nbsp;</a></span>FECollection() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::<a class="el" href="classhp_1_1FECollection.html">FECollection</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动构造函数。 </p><dl class="section note"><dt>Note</dt><dd>标准数据类型的实现可能会随着不同的库而改变，所以它们的移动成员可能会或不会被标记为非抛出。 我们需要根据其成员变量显式地设置noexcept指定器，以便仍然获得性能优势（并满足clang-tidy）。 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a02f70cf84f2dc79b9cc2858d9dbf27fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f70cf84f2dc79b9cc2858d9dbf27fa">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动赋值运算符。 </p>

</div>
</div>
<a id="a3282c173b24b3e937b30baffd8c087f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3282c173b24b3e937b30baffd8c087f6">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_collection</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>等价比较运算符。所有存储的FiniteElement对象都按顺序进行比较。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00615">615</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a80cfe7309c06d410f18cf0623aac4c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cfe7309c06d410f18cf0623aac4c85">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_collection</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>非等价比较运算符。所有存储的FiniteElement对象按顺序进行比较。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00633">633</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a4b0e75a805ff012e76d33ad6d4c3eac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0e75a805ff012e76d33ad6d4c3eac8">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_fe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>添加一个有限元素。这个函数生成一个给定元素的副本，即你可以做类似<code>push_back(FE_Q&lt;dim&gt;(1));</code>的事情。 这个内部拷贝后来在整个集合被销毁时被这个对象销毁。 当一个新的元素被添加时，它需要拥有与已经在集合中的所有其他元素相同数量的向量成分。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00273">273</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="add4bafb2f8e59ae8c0165f31db334205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4bafb2f8e59ae8c0165f31db334205">&#9670;&nbsp;</a></span>n_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::n_components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个集合中的有限元素的向量分量的数量。 这个数字对于集合中的所有元素必须是相同的。 这个函数调用 <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components</a>. 更多信息见 <a class="el" href="DEALGlossary.html#GlossComponent">术语表</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00595">595</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="ad8eea6cc97389fe6ea1f479cdbadd60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8eea6cc97389fe6ea1f479cdbadd60c">&#9670;&nbsp;</a></span>n_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::n_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个集合中的有限元素的向量块的数量。虽然这个类保证了存储在其中的所有元素都有相同数量的向量分量，但是对于每个元素所组成的块数却没有这样的保证（一个元素的块数可能少于向量分量，更多信息见 术语表 ）。例如，你可能有一个FECollection对象，它存储了一份带有 <code>dim</code> FE_Q对象的FESystem和一份FE_RaviartThomas元素的副本。两者都有 <code>dim</code> 向量成分，但前者有 <code>dim</code> 块，后者只有一个。因此，如果所有元素的块数不一样，这个函数将抛出一个断言。如果它们相同，该函数返回的结果是 <a class="el" href="classFiniteElementData.html#a4c1c4ca934f26ff463caf35a574e9f14">FiniteElement::n_blocks()</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00566">566</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a6cd571a96bd66ee1cfd970dc87434d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd571a96bd66ee1cfd970dc87434d88">&#9670;&nbsp;</a></span>max_degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::max_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回 <a class="el" href="namespaceinternal.html#acbc4eb5d23ccaa14762fb4d43251f15b">FiniteElement::get_degree()</a> 在这个集合的所有元素上返回的值的最大值。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00642">642</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a173d07546d8bd925c5a113b11fa63ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173d07546d8bd925c5a113b11fa63ae8">&#9670;&nbsp;</a></span>max_dofs_per_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::max_dofs_per_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回此集合所有元素中每个顶点的最大自由度数。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00657">657</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a0a5e8de2d3c1c033fb4bddddfc35314f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5e8de2d3c1c033fb4bddddfc35314f">&#9670;&nbsp;</a></span>max_dofs_per_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::max_dofs_per_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个集合的所有元素中每条线的最大自由度数。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00672">672</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a9864eddabbc3df8729ce06b822464d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9864eddabbc3df8729ce06b822464d84">&#9670;&nbsp;</a></span>max_dofs_per_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::max_dofs_per_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个集合中所有元素的每个四边形的最大自由度数。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00687">687</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a0d152cf2356925186c85a22370c3a26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d152cf2356925186c85a22370c3a26f">&#9670;&nbsp;</a></span>max_dofs_per_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::max_dofs_per_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个集合中所有元素中每个六度的最大自由度数。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00702">702</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a71c51e1333e89c241e6ce856b206f8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c51e1333e89c241e6ce856b206f8ba">&#9670;&nbsp;</a></span>max_dofs_per_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::max_dofs_per_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个集合的所有元素中每个面的最大自由度数。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00717">717</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="ae849636cc622a9fdd00305698b9d455c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae849636cc622a9fdd00305698b9d455c">&#9670;&nbsp;</a></span>max_dofs_per_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::max_dofs_per_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个集合的所有元素中每个单元的最大自由度数。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00732">732</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a29a5f7c2639e467e2192d6eb0c97b468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a5f7c2639e467e2192d6eb0c97b468">&#9670;&nbsp;</a></span>hp_constraints_are_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::hp_constraints_are_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个集合中的所有元素是否以新的方式实现了悬挂节点约束，这必须用于使元素 "hp-compatible"。如果不是这样，该函数返回false，这意味着FECollection中至少有一个元素不支持新的面孔接口约束。另一方面，如果这个方法确实返回true，这并不意味着hp-方法会起作用。 这种行为与以下事实有关，即提供新式悬挂节点约束的FiniteElement类可能仍然没有为所有可能的情况提供这些约束。如果FE_Q和FE_RaviartThomas元素包含在FECollection中，并且都正确实现了get_face_interpolation_matrix方法，这个方法将返回true。 但是get_face_interpolation_matrix可能仍然无法找到这两个元素之间的插值矩阵。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00746">746</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a432501b9eb6b276132e1da0ec83a03ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432501b9eb6b276132e1da0ec83a03ef">&#9670;&nbsp;</a></span>find_common_fes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::find_common_fes </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个FECollection中支配所有与所提供的索引集相关的元素的有限元素的索引 <code>fes</code>. 你可以在其各自的类文档或其继承的成员函数的实现中找到关于有限元素的支配行为的信息 <a class="el" href="classFiniteElement.html#a1719468736ca8342cf3927564e57ed66">FiniteElement::compare_for_domination()</a>. 考虑到一个有限元素可能支配也可能不支配它自己（例如FE_Nothing元素）。 例如，如果一个FEC集合由<code>{<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>,<a class="el" href="classFE__Q.html">FE_Q(3)</a>,<a class="el" href="classFE__Q.html">FE_Q(4)</a>}</code>元素组成，我们要寻找支配这个集合中间元素的有限元素（即 <code>fes</code> 为<code>{1,2}</code>），那么答案是<code>{<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a></code>，因此这个函数将返回它们在FEC集合中的索引，即<code>{0,1}</code>。 <code>codim</code> 参数描述了被调查的子空间的码率，并指定它受此比较。更多信息见 <a class="el" href="classFiniteElement.html#a1719468736ca8342cf3927564e57ed66">FiniteElement::compare_for_domination()</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00027">27</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a6eba9b691c9f0b12f04b39fd2cac89ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eba9b691c9f0b12f04b39fd2cac89ad">&#9670;&nbsp;</a></span>find_enclosing_fes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::find_enclosing_fes </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回此FECollection中被与所提供的指数集相关的所有元素支配的有限元的指数 <code>fes</code>. 你可以在其各自的类文件或其继承的成员函数的实现中找到关于有限元的支配行为的信息 <a class="el" href="classFiniteElement.html#a1719468736ca8342cf3927564e57ed66">FiniteElement::compare_for_domination()</a>. 考虑到一个有限元可能支配也可能不支配自己（例如，FE_Nothing元素）。 例如，如果一个FEC集合由<code>{<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>,<a class="el" href="classFE__Q.html">FE_Q(3)</a>,<a class="el" href="classFE__Q.html">FE_Q(4)</a>}</code>元素组成，我们要寻找被这个集合的中间元素支配的有限元素（即。 <code>fes</code> 是<code>{1,2}</code>，那么答案是<code>{<a class="el" href="classFE__Q.html">FE_Q(3)</a>,<a class="el" href="classFE__Q.html">FE_Q(4)</a></code>，因此这个函数将返回它们在FEC集合中的索引，即<code>{2,3}</code>。 <code>codim</code> 参数描述了被调查的子空间的码率，并指定它受此比较。更多信息见 <a class="el" href="classFiniteElement.html#a1719468736ca8342cf3927564e57ed66">FiniteElement::compare_for_domination()</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00067">67</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a6df6ca3a652ba86592d6ea0b94a03e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df6ca3a652ba86592d6ea0b94a03e1d">&#9670;&nbsp;</a></span>find_dominating_fe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::find_dominating_fe </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回所提供的指数集 <code>fes</code> 中的一个有限元素的指数，该元素支配着这个非常集合中的所有其他元素。 你可以在其各自的类文件中或在其继承的成员函数的实现中找到关于有限元的支配行为的信息 <a class="el" href="classFiniteElement.html#a1719468736ca8342cf3927564e57ed66">FiniteElement::compare_for_domination()</a>. 考虑到一个有限元可能支配也可能不支配自己（例如FE_Nothing元素）。 如果这个集合正好由一个元素组成，我们认为它是支配性的，并返回其相应的索引。此外，如果函数根本无法找到一个有限元素，则返回 <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>. 例如，如果一个FEC集合由<code>{<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>,<a class="el" href="classFE__Q.html">FE_Q(3)</a>,<a class="el" href="classFE__Q.html">FE_Q(4)</a>}</code>元素组成，我们要在这个集合的中间元素中寻找主导的有限元素（即。 <code>fes</code> 是<code>{1,2}</code>），那么答案是FE_Q(2)，因此这个函数将返回它在FEC集合中的索引，即<code>1</code>。 当然，有可能存在不止一个元素支配着所有被选中的元素。例如，如果集合由<code>{<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>}</code>组成，并且<code>fes</code>涵盖所有的索引，那么可以返回0或1。 在这种情况下，该函数要么返回 "0"，要么返回 "1"，因为两者之间不存在平局。 <code>codim</code> 参数描述了被调查的子空间的二维度，并指定它要接受这种比较。更多信息见 <a class="el" href="classFiniteElement.html#a1719468736ca8342cf3927564e57ed66">FiniteElement::compare_for_domination()</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00107">107</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a719793132cab791f215ee96b4d5f0c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719793132cab791f215ee96b4d5f0c75">&#9670;&nbsp;</a></span>find_dominated_fe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::find_dominated_fe </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回所提供的指数集 <code>fes</code> 中的一个有限元素的指数，该元素被这个非常集合的所有其他元素所支配。 你可以在其各自的类文件中或其继承成员函数的实现中找到关于有限元的支配行为的信息 <a class="el" href="classFiniteElement.html#a1719468736ca8342cf3927564e57ed66">FiniteElement::compare_for_domination()</a>. 考虑到一个有限元可能支配自己，也可能不支配自己（例如FE_Nothing元素）。 如果这个集合正好由一个元素组成，我们认为它是被支配的，并返回其相应的索引。此外，如果函数根本无法找到有限元，则返回 <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>. 例如，如果一个FEC集合由<code>{<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>,<a class="el" href="classFE__Q.html">FE_Q(3)</a>,<a class="el" href="classFE__Q.html">FE_Q(4)</a>}</code>元素组成，我们在这个集合的中间元素中寻找支配的有限元（即。 <code>fes</code> 是<code>{1,2}</code>），那么答案是FE_Q(3)，因此这个函数将返回它在FEC集合中的索引，即<code>2</code>。 当然，有可能存在不止一个元素被所有选定的元素所支配。例如，如果集合由<code>{<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>}</code>组成，并且<code>fes</code>覆盖了所有的索引，那么可以返回2或3。 在这种情况下，该函数要么返回<code>2</code>，要么返回<code>3</code>，因为两者之间没有平局。 <code>codim</code> 参数描述了被调查的子空间的维度，并指定它要接受这种比较。更多信息见 <a class="el" href="classFiniteElement.html#a1719468736ca8342cf3927564e57ed66">FiniteElement::compare_for_domination()</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00154">154</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a1c4f34d801d827773a91ff539ffabadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4f34d801d827773a91ff539ffabadd">&#9670;&nbsp;</a></span>find_dominating_fe_extended()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::find_dominating_fe_extended </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回所提供的指数集 <code>fes</code> 中的一个有限元素的指数，该元素支配着这个非常集合中的所有其他元素。如果我们没有成功，我们就在整个集合上扩大搜索范围，挑选最不占优势的，也就是描述最大的有限元空间的元素，所提供的集合 <code>fes</code> 的所有有限元都是其中的一部分。 你可以在其各自的类文件中或其继承的成员函数的实现中找到关于有限元的支配行为的信息 <a class="el" href="classFiniteElement.html#a1719468736ca8342cf3927564e57ed66">FiniteElement::compare_for_domination()</a>. 考虑到一个有限元可以支配也可以不支配自己（例如FE_Nothing元素）。 如果这个集合正好由一个元素组成，我们认为它是被支配的，并返回其相应的索引。此外，如果函数根本无法找到一个有限元，则返回 <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>. <code>codim</code> 参数描述了所研究的子空间的二维度，并指定它受此比较。更多信息见 <a class="el" href="classFiniteElement.html#a1719468736ca8342cf3927564e57ed66">FiniteElement::compare_for_domination()</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00201">201</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="aae4e336f83e16ba6291d3748d52438d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4e336f83e16ba6291d3748d52438d8">&#9670;&nbsp;</a></span>find_dominated_fe_extended()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::find_dominated_fe_extended </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回所提供的指数集 <code>fes</code> 中的一个有限元素的指数，该元素被这个非常集的所有其他元素所支配。如果我们没有成功，我们就在整个集合上扩展搜索，挑选出最被支配的，也就是描述最小的有限元空间的元素，该空间包括所提供集合的所有有限元 <code>fes</code>. 你可以在其各自的类文档中或其继承成员函数的实现中找到关于有限元支配行为的信息 <a class="el" href="classFiniteElement.html#a1719468736ca8342cf3927564e57ed66">FiniteElement::compare_for_domination()</a>. 考虑到一个有限元可能支配也可能不支配自己（例如，FE_Nothing元素）。 如果这个集合正好由一个元素组成，我们就认为它是支配性的，并返回其相应的索引。此外，如果该函数根本无法找到一个有限元素，则返回 <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>. <code>codim</code> 参数描述了被调查的子空间的二维度，并指定其受此比较。更多信息见 <a class="el" href="classFiniteElement.html#a1719468736ca8342cf3927564e57ed66">FiniteElement::compare_for_domination()</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00221">221</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a8ae7823f04f51f2daaf0b770a151b1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae7823f04f51f2daaf0b770a151b1b1">&#9670;&nbsp;</a></span>set_hierarchy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::set_hierarchy </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>确定有限元层次的集合函数，即一个函数 <code>next</code> 返回给定的有限元后的索引，一个函数 <code>prev</code> 返回前一个。 这两个函数都需要一个 <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> 来传递有限元索引，在其基础上找到并返回新的索引。 </p><dl class="section note"><dt>Note</dt><dd>传递和返回的索引都必须在这个集合的索引范围内有效，即在[0, <a class="el" href="classhp_1_1Collection.html#a9e51c9371e925145c42840d72f4a0bf7">size()</a>]内。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00291">291</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a573c653d73cc02496fd61ebee6c00b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573c653d73cc02496fd61ebee6c00b00">&#9670;&nbsp;</a></span>set_default_hierarchy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::set_default_hierarchy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置与集合中每个有限元的索引相对应的默认层次结构。 这个默认层次是通过函数 <a class="el" href="structhp_1_1FECollection_1_1DefaultHierarchy.html#a2ebf0b6b6b35f67e7e5ffbf55bb29c7a">DefaultHierarchy::next_index()</a> 和 <a class="el" href="structhp_1_1FECollection_1_1DefaultHierarchy.html#a310d829aa99a422a79eff9bf21bb8153">DefaultHierarchy::previous_index()</a>. 建立的。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00308">308</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a0dab011b71ea35f86c433392d42ca15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dab011b71ea35f86c433392d42ca15b">&#9670;&nbsp;</a></span>get_hierarchy_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::get_hierarchy_sequence </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个对应于注册层次结构的FE指数序列，以升序排列，即FE指数从低到高排序。 用set_hierarchy()注册的一个自定义层次结构可以有多个FE指数序列。该函数将返回包含用户提供的索引 <code>fe_index</code> 的序列，该索引可以位于序列内的任何位置。通过set_default_hierarchy()设置的默认层次结构，对应于升序的FE指数，只包含一个序列。 例如，这个函数可以用来验证你所提供的层次结构是否涵盖了所有的元素，并符合所需的顺序。 如果返回的容器的大小等于这个对象的元素数，则只存在一个FE指数序列，即 <a class="el" href="classhp_1_1Collection.html#a9e51c9371e925145c42840d72f4a0bf7">FECollection::size()</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00319">319</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a520c6b1493b469686e9a36f6aae087ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520c6b1493b469686e9a36f6aae087ec">&#9670;&nbsp;</a></span>next_in_hierarchy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::next_in_hierarchy </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>函数返回层次结构中给定的 <code>fe_index</code> 之后的有限元的索引。 默认情况下，将返回 <code>fe_index</code> 之后的索引。如果 <code>fe_index</code> 已经对应于最后一个索引，将返回最后一个索引。 可以通过成员函数set_hierachy()提供一个自定义的层次结构。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00365">365</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a091d817c47838ec112afba864ef51fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091d817c47838ec112afba864ef51fdb">&#9670;&nbsp;</a></span>previous_in_hierarchy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::previous_in_hierarchy </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>函数返回层次结构中给定 <code>fe_index</code> 之前的有限元的索引。 默认情况下，将返回 <code>fe_index</code> 之前的索引。如果 <code>fe_index</code> 已经对应于第一个索引，第一个索引将被返回。 可以通过成员函数set_hierachy()提供一个自定义的层次结构。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00380">380</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a7cdf2f55585aa8a5777535b57b220a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdf2f55585aa8a5777535b57b220a17">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个分量掩码，其元素数量与此对象的向量分量相同，并且其中正好有一个分量是真实的，与给定的参数相对应。 </p><dl class="section note"><dt>Note</dt><dd>这个函数等同于 <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> ，参数相同。它验证了它是否从存储在这个FECollection中的每一个元素中得到了相同的结果。如果不是这样的话，它会抛出一个异常。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">标量</td><td>一个代表该有限元的单一标量矢量分量的对象。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个分量掩码，在所有分量中都是假的，除了与参数相对应的那一个。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00395">395</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a5d17b05f9180827ea291fdb798dca525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d17b05f9180827ea291fdb798dca525">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个分量掩码，其元素数与此对象的向量分量相同，其中与给定参数对应的 <code>dim</code> 分量为真。 </p><dl class="section note"><dt>Note</dt><dd>这个函数等同于 <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> ，参数相同。它验证了它从存储在这个FECollection中的每一个元素中得到相同的结果。如果不是这样，它会抛出一个异常。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">矢量</td><td>一个表示该有限元的微弱矢量成分的对象。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个分量掩码，在所有分量中都是假的，除了与参数相对应的分量。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00415">415</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="ac8f643ca875e5a1e40500cd0d9e43e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f643ca875e5a1e40500cd0d9e43e37">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sym_tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个分量掩码，其元素数与此对象的向量分量相同，其中与给定参数对应的 <code>dim*(dim+1)/2</code> 分量为真。 </p><dl class="section note"><dt>Note</dt><dd>这个函数等同于 <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> ，参数相同。它验证了它从存储在这个FECollection中的每一个元素中得到相同的结果。如果不是这样，它会抛出一个异常。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym_tensor</td><td>一个表示该有限元的dim*(dim+1)/2组件的对象，这些组件共同被解释为形成一个对称张量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个分量掩码，在所有分量中都是假的，除了与参数相对应的分量。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00435">435</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="afbb50939b9305ac2880d54007a827d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb50939b9305ac2880d54007a827d22">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>block_mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>这个函数等同于 <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> ，参数相同。它验证了它从存储在这个FECollection中的每一个元素中得到相同的结果。如果不是这样，它会抛出一个异常。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_mask</td><td>选择有限元单个块的掩码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>选择那些与输入参数的选定块对应的组件的掩码。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00455">455</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="af8afd8e5ed60f7ad7fc71e3f96e2f5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8afd8e5ed60f7ad7fc71e3f96e2f5f3">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个块掩码，其元素数与此对象的块数相同，并且其中正好有一个与给定参数相对应的成分是真的。更多信息请参见 <a class="el" href="DEALGlossary.html#GlossBlockMask">术语表</a> 。 </p><dl class="section note"><dt>Note</dt><dd>这个函数只有在参数所引用的标量包含一个完整的块时才会成功。换句话说，例如，如果你传递了一个单一 \(x\) 速度的提取器，并且这个对象代表一个FE_RaviartThomas对象，那么你选择的单一标量对象是一个更大的块的一部分，因此没有代表它的块屏蔽。然后该函数将产生一个异常。 </dd>
<dd>
这个函数相当于 <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> ，参数相同。它验证了它从存储在这个FECollection中的每一个元素中得到相同的结果。如果不是这样的话，它会抛出一个异常。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">标量</td><td>一个代表该有限元的单个标量向量分量的对象。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个分量掩码，在所有分量中都是假的，除了与参数相对应的那一个。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00476">476</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="acf9e9f51f57c6526d643104df76384fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9e9f51f57c6526d643104df76384fd">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个分量掩码，其元素数与此对象的向量分量相同，并且其中对应于给定参数的 <code>dim</code> 分量为真。更多信息见 <a class="el" href="DEALGlossary.html#GlossBlockMask">术语表</a> 。 </p><dl class="section note"><dt>Note</dt><dd>这个函数等同于 <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> ，参数相同。它验证是否从存储在这个FECollection中的每一个元素中得到相同的结果。如果不是这样的话，它会抛出一个异常。 </dd>
<dd>
同样的注意事项适用于上述函数的版本。 作为参数传递的提取器对象必须使其对应于完整的块，而不是分割这个元素的块。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>一个表示该有限元的dim向量分量的对象。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个分量掩码，在所有分量中都是假的，除了与参数相对应的分量。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00498">498</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a030037ceecf42a6ca0719eb8385fc2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030037ceecf42a6ca0719eb8385fc2a3">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sym_tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个分量掩码，其元素数与此对象的向量分量相同，其中与给定参数对应的 <code>dim*(dim+1)/2</code> 分量为真。更多信息见 <a class="el" href="DEALGlossary.html#GlossBlockMask">术语表</a> 。 </p><dl class="section note"><dt>Note</dt><dd>同样的注意事项适用于上述函数的版本。 作为参数传递的提取器对象必须使其对应于完整的块，而不是分割此元素的块。 </dd>
<dd>
这个函数等同于 <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> ，参数相同。它验证了它从存储在这个FECollection中的每一个元素中得到相同的结果。如果不是这样，它会抛出一个异常。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym_tensor</td><td>一个代表该有限元的dim*(dim+1)/2组件的对象，这些组件共同被解释为形成一个对称张量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个分量掩码，在所有分量中都是假的，除了与参数相对应的那些。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00520">520</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a6bb077f2b8eb8671342ac13e232fd520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb077f2b8eb8671342ac13e232fd520">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>这个函数只有在参数所引用的组件包含完整的块时才会成功。换句话说，例如，如果你传递了一个单一 \(x\) 速度的组件掩码，而这个对象代表一个FE_RaviartThomas对象，那么你选择的单一组件是一个更大的块的一部分，因此，没有代表它的块掩码。然后该函数将产生一个异常。 </dd>
<dd>
这个函数相当于 <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> ，参数相同。它验证了它从存储在这个FECollection中的每一个元素中得到相同的结果。如果不是这样，它会抛出一个异常。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component_mask</td><td>选择有限元个别组件的掩码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>选择那些与输入参数的选定块对应的掩码。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__collection_8cc_source.html#l00543">543</a> of file <a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a>.</p>

</div>
</div>
<a id="a1e43005f6dc7f4096e9f03fb77ac7fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e43005f6dc7f4096e9f03fb77ac7fa1">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhp_1_1Collection.html">hp::Collection</a>&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;  &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;  &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>添加一个新的对象。 </p>

<p class="definition">Definition at line <a class="el" href="collection_8h_source.html#l00101">101</a> of file <a class="el" href="collection_8h_source.html">collection.h</a>.</p>

</div>
</div>
<a id="ae7cd609468d1724dd4bbe4e7d3676c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cd609468d1724dd4bbe4e7d3676c09">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;  &amp; <a class="el" href="classhp_1_1Collection.html">hp::Collection</a>&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;  &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回用户为活动FE索引指定的对象，该索引是作为参数提供给该方法的。 </p><dl class="section pre"><dt>Precondition</dt><dd><code>index</code> 必须在0和集合的元素数之间。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="collection_8h_source.html#l00118">118</a> of file <a class="el" href="collection_8h_source.html">collection.h</a>.</p>

</div>
</div>
<a id="a9e51c9371e925145c42840d72f4a0bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e51c9371e925145c42840d72f4a0bf7">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1Collection.html">hp::Collection</a>&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;  &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回存储在这个容器中的对象的数量。 </p>

<p class="definition">Definition at line <a class="el" href="collection_8h_source.html#l00110">110</a> of file <a class="el" href="collection_8h_source.html">collection.h</a>.</p>

</div>
</div>
<a id="aa8900b5562cbfa4523e0aff131ad3190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8900b5562cbfa4523e0aff131ad3190">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classhp_1_1Collection.html">hp::Collection</a>&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;  &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>确定这个对象的内存消耗（以字节为单位）的估计值。 </p>

<p class="definition">Definition at line <a class="el" href="collection_8h_source.html#l00092">92</a> of file <a class="el" href="collection_8h_source.html">collection.h</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4076a62850571b131946f2221ed87a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4076a62850571b131946f2221ed87a28">&#9670;&nbsp;</a></span>hierarchy_next</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt;dim, spacedim&gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::hierarchy_next</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>函数返回层次结构中给定元素之后的有限元素的索引。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00558">558</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="aca57244f0a037efa4ae8ce5e06c24314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca57244f0a037efa4ae8ce5e06c24314">&#9670;&nbsp;</a></span>hierarchy_prev</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt;dim, spacedim&gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::hierarchy_prev</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回在层次结构中给定的有限元之前的有限元的索引的函数。 </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00566">566</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/hp/<a class="el" href="fe__collection_8h_source.html">fe_collection.h</a></li>
<li>source/hp/<a class="el" href="fe__collection_8cc_source.html">fe_collection.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
