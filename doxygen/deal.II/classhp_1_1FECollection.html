<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classhp_1_1FECollection.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: hp::FECollection&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehp.html">hp</a></li><li class="navelem"><a class="el" href="classhp_1_1FECollection.html">FECollection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classhp_1_1FECollection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hp::FECollection&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__hp.html">hp finite element support</a><a class="el" href="group__hp.html">hp finite element support</a> &raquo;  &#124; <a class="el" href="group__hpcollection.html">hp Collections</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fe__collection_8h_source.html">deal.II/hp/fe_collection.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for hp::FECollection&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classhp_1_1FECollection__inherit__graph.svg" width="1288" height="294"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhp_1_1FECollection_1_1DefaultHierarchy.html">DefaultHierarchy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af94bc4d5c944da27c3e0189cd92e979c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#af94bc4d5c944da27c3e0189cd92e979c">FECollection</a> ()</td></tr>
<tr class="separator:af94bc4d5c944da27c3e0189cd92e979c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b557e20b5abc09c7be5158c3f034955"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a6b557e20b5abc09c7be5158c3f034955">FECollection</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe)</td></tr>
<tr class="separator:a6b557e20b5abc09c7be5158c3f034955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63763c1f266928722f599e9da1f2baf9"><td class="memTemplParams" colspan="2">template&lt;class... FETypes&gt; </td></tr>
<tr class="memitem:a63763c1f266928722f599e9da1f2baf9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a63763c1f266928722f599e9da1f2baf9">FECollection</a> (const FETypes &amp;... fes)</td></tr>
<tr class="separator:a63763c1f266928722f599e9da1f2baf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33779cbf32c4f124cda38eeb790a8c62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a33779cbf32c4f124cda38eeb790a8c62">FECollection</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;fes)</td></tr>
<tr class="separator:a33779cbf32c4f124cda38eeb790a8c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f7b4ccf64ce616f22e046fabd215e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#ad8f7b4ccf64ce616f22e046fabd215e6">FECollection</a> (const <a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;)=default</td></tr>
<tr class="separator:ad8f7b4ccf64ce616f22e046fabd215e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2495f87c9518a2e3afa78599823e2d4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a2495f87c9518a2e3afa78599823e2d4f">FECollection</a> (<a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&amp;) noexcept(std::is_nothrow_move_constructible&lt; std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;&gt;&gt;::value &amp;&amp;std::is_nothrow_move_constructible&lt; std::function&lt; unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt;&gt;::value)=default</td></tr>
<tr class="separator:a2495f87c9518a2e3afa78599823e2d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f70cf84f2dc79b9cc2858d9dbf27fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a02f70cf84f2dc79b9cc2858d9dbf27fa">operator=</a> (<a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&amp;)=default</td></tr>
<tr class="separator:a02f70cf84f2dc79b9cc2858d9dbf27fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3282c173b24b3e937b30baffd8c087f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a3282c173b24b3e937b30baffd8c087f6">operator==</a> (const <a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;fe_collection) const</td></tr>
<tr class="separator:a3282c173b24b3e937b30baffd8c087f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cfe7309c06d410f18cf0623aac4c85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a80cfe7309c06d410f18cf0623aac4c85">operator!=</a> (const <a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;fe_collection) const</td></tr>
<tr class="separator:a80cfe7309c06d410f18cf0623aac4c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0e75a805ff012e76d33ad6d4c3eac8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;new_fe)</td></tr>
<tr class="separator:a4b0e75a805ff012e76d33ad6d4c3eac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4bafb2f8e59ae8c0165f31db334205"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a> () const</td></tr>
<tr class="separator:add4bafb2f8e59ae8c0165f31db334205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8eea6cc97389fe6ea1f479cdbadd60c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#ad8eea6cc97389fe6ea1f479cdbadd60c">n_blocks</a> () const</td></tr>
<tr class="separator:ad8eea6cc97389fe6ea1f479cdbadd60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd571a96bd66ee1cfd970dc87434d88"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a6cd571a96bd66ee1cfd970dc87434d88">max_degree</a> () const</td></tr>
<tr class="separator:a6cd571a96bd66ee1cfd970dc87434d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173d07546d8bd925c5a113b11fa63ae8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a173d07546d8bd925c5a113b11fa63ae8">max_dofs_per_vertex</a> () const</td></tr>
<tr class="separator:a173d07546d8bd925c5a113b11fa63ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5e8de2d3c1c033fb4bddddfc35314f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a0a5e8de2d3c1c033fb4bddddfc35314f">max_dofs_per_line</a> () const</td></tr>
<tr class="separator:a0a5e8de2d3c1c033fb4bddddfc35314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9864eddabbc3df8729ce06b822464d84"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a9864eddabbc3df8729ce06b822464d84">max_dofs_per_quad</a> () const</td></tr>
<tr class="separator:a9864eddabbc3df8729ce06b822464d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d152cf2356925186c85a22370c3a26f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a0d152cf2356925186c85a22370c3a26f">max_dofs_per_hex</a> () const</td></tr>
<tr class="separator:a0d152cf2356925186c85a22370c3a26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c51e1333e89c241e6ce856b206f8ba"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a71c51e1333e89c241e6ce856b206f8ba">max_dofs_per_face</a> () const</td></tr>
<tr class="separator:a71c51e1333e89c241e6ce856b206f8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae849636cc622a9fdd00305698b9d455c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#ae849636cc622a9fdd00305698b9d455c">max_dofs_per_cell</a> () const</td></tr>
<tr class="separator:ae849636cc622a9fdd00305698b9d455c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a5f7c2639e467e2192d6eb0c97b468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a29a5f7c2639e467e2192d6eb0c97b468">hp_constraints_are_implemented</a> () const</td></tr>
<tr class="separator:a29a5f7c2639e467e2192d6eb0c97b468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b344455872d2ff9dcebdc665423fd15"><td class="memItemLeft" align="right" valign="top">std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a6b344455872d2ff9dcebdc665423fd15">find_common_fes</a> (const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;fes, const unsigned <a class="el" href="classint.html">int</a> codim=0) const</td></tr>
<tr class="separator:a6b344455872d2ff9dcebdc665423fd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8d9c03d87c90753485bde0f7bf42fe"><td class="memItemLeft" align="right" valign="top">std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#aaf8d9c03d87c90753485bde0f7bf42fe">find_enclosing_fes</a> (const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;fes, const unsigned <a class="el" href="classint.html">int</a> codim=0) const</td></tr>
<tr class="separator:aaf8d9c03d87c90753485bde0f7bf42fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df6ca3a652ba86592d6ea0b94a03e1d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a6df6ca3a652ba86592d6ea0b94a03e1d">find_dominating_fe</a> (const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;fes, const unsigned <a class="el" href="classint.html">int</a> codim=0) const</td></tr>
<tr class="separator:a6df6ca3a652ba86592d6ea0b94a03e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719793132cab791f215ee96b4d5f0c75"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a719793132cab791f215ee96b4d5f0c75">find_dominated_fe</a> (const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;fes, const unsigned <a class="el" href="classint.html">int</a> codim=0) const</td></tr>
<tr class="separator:a719793132cab791f215ee96b4d5f0c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4f34d801d827773a91ff539ffabadd"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a1c4f34d801d827773a91ff539ffabadd">find_dominating_fe_extended</a> (const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;fes, const unsigned <a class="el" href="classint.html">int</a> codim=0) const</td></tr>
<tr class="separator:a1c4f34d801d827773a91ff539ffabadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4e336f83e16ba6291d3748d52438d8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#aae4e336f83e16ba6291d3748d52438d8">find_dominated_fe_extended</a> (const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;fes, const unsigned <a class="el" href="classint.html">int</a> codim=0) const</td></tr>
<tr class="separator:aae4e336f83e16ba6291d3748d52438d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae7823f04f51f2daaf0b770a151b1b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a8ae7823f04f51f2daaf0b770a151b1b1">set_hierarchy</a> (const std::function&lt; unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;next, const std::function&lt; unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;prev)</td></tr>
<tr class="separator:a8ae7823f04f51f2daaf0b770a151b1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573c653d73cc02496fd61ebee6c00b00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a573c653d73cc02496fd61ebee6c00b00">set_default_hierarchy</a> ()</td></tr>
<tr class="separator:a573c653d73cc02496fd61ebee6c00b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd05bf480984a510901e6f4a15a3d929"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#abd05bf480984a510901e6f4a15a3d929">get_hierarchy_sequence</a> (const unsigned <a class="el" href="classint.html">int</a> fe_index=0) const</td></tr>
<tr class="separator:abd05bf480984a510901e6f4a15a3d929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520c6b1493b469686e9a36f6aae087ec"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a520c6b1493b469686e9a36f6aae087ec">next_in_hierarchy</a> (const unsigned <a class="el" href="classint.html">int</a> fe_index) const</td></tr>
<tr class="separator:a520c6b1493b469686e9a36f6aae087ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091d817c47838ec112afba864ef51fdb"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a091d817c47838ec112afba864ef51fdb">previous_in_hierarchy</a> (const unsigned <a class="el" href="classint.html">int</a> fe_index) const</td></tr>
<tr class="separator:a091d817c47838ec112afba864ef51fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdf2f55585aa8a5777535b57b220a17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const</td></tr>
<tr class="separator:a7cdf2f55585aa8a5777535b57b220a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d17b05f9180827ea291fdb798dca525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a5d17b05f9180827ea291fdb798dca525">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const</td></tr>
<tr class="separator:a5d17b05f9180827ea291fdb798dca525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f643ca875e5a1e40500cd0d9e43e37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#ac8f643ca875e5a1e40500cd0d9e43e37">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;sym_tensor) const</td></tr>
<tr class="separator:ac8f643ca875e5a1e40500cd0d9e43e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb50939b9305ac2880d54007a827d22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#afbb50939b9305ac2880d54007a827d22">component_mask</a> (const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;<a class="el" href="classhp_1_1FECollection.html#af8afd8e5ed60f7ad7fc71e3f96e2f5f3">block_mask</a>) const</td></tr>
<tr class="separator:afbb50939b9305ac2880d54007a827d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8afd8e5ed60f7ad7fc71e3f96e2f5f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#af8afd8e5ed60f7ad7fc71e3f96e2f5f3">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const</td></tr>
<tr class="separator:af8afd8e5ed60f7ad7fc71e3f96e2f5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9e9f51f57c6526d643104df76384fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#acf9e9f51f57c6526d643104df76384fd">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const</td></tr>
<tr class="separator:acf9e9f51f57c6526d643104df76384fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030037ceecf42a6ca0719eb8385fc2a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a030037ceecf42a6ca0719eb8385fc2a3">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;sym_tensor) const</td></tr>
<tr class="separator:a030037ceecf42a6ca0719eb8385fc2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb077f2b8eb8671342ac13e232fd520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a6bb077f2b8eb8671342ac13e232fd520">block_mask</a> (const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>) const</td></tr>
<tr class="separator:a6bb077f2b8eb8671342ac13e232fd520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e43005f6dc7f4096e9f03fb77ac7fa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1Collection.html#a1e43005f6dc7f4096e9f03fb77ac7fa1">push_back</a> (const std::shared_ptr&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &gt; &amp;new_entry)</td></tr>
<tr class="separator:a1e43005f6dc7f4096e9f03fb77ac7fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cd609468d1724dd4bbe4e7d3676c09"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1Collection.html#ae7cd609468d1724dd4bbe4e7d3676c09">operator[]</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:ae7cd609468d1724dd4bbe4e7d3676c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e51c9371e925145c42840d72f4a0bf7"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1Collection.html#a9e51c9371e925145c42840d72f4a0bf7">size</a> () const</td></tr>
<tr class="separator:a9e51c9371e925145c42840d72f4a0bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8900b5562cbfa4523e0aff131ad3190"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1Collection.html#aa8900b5562cbfa4523e0aff131ad3190">memory_consumption</a> () const</td></tr>
<tr class="separator:aa8900b5562cbfa4523e0aff131ad3190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exceptions</div></td></tr>
<tr class="memitem:gaef4c33e67a59b701207418cc5526d54a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaef4c33e67a59b701207418cc5526d54a">DeclException0</a> (ExcNoFiniteElements)</td></tr>
<tr class="separator:gaef4c33e67a59b701207418cc5526d54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4076a62850571b131946f2221ed87a28"><td class="memItemLeft" align="right" valign="top">std::function&lt; unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#a4076a62850571b131946f2221ed87a28">hierarchy_next</a></td></tr>
<tr class="separator:a4076a62850571b131946f2221ed87a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca57244f0a037efa4ae8ce5e06c24314"><td class="memItemLeft" align="right" valign="top">std::function&lt; unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhp_1_1FECollection.html#aca57244f0a037efa4ae8ce5e06c24314">hierarchy_prev</a></td></tr>
<tr class="separator:aca57244f0a037efa4ae8ce5e06c24314"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class hp::FECollection&lt; dim, spacedim &gt;</h3>

<p>This class acts as a collection of finite element objects used in the <a class="el" href="classDoFHandler.html">DoFHandler</a>.</p>
<p>It implements the concepts stated in the <a class="el" href="group__hpcollection.html">hp Collections</a> module described in the doxygen documentation.</p>
<p>In addition to offering access to the elements of the collection, this class provides access to the maximal number of degrees of freedom per vertex, line, etc, to allow allocation of as much memory as is necessary in the worst case when using the finite elements associated with the cells of a triangulation.</p>
<p>This class has not yet been implemented for the use in the codimension one case (<code>spacedim != dim </code>). </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00053">53</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af94bc4d5c944da27c3e0189cd92e979c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94bc4d5c944da27c3e0189cd92e979c">&#9670;&nbsp;</a></span>FECollection() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::<a class="el" href="classhp_1_1FECollection.html">FECollection</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Leads to an empty collection that can later be filled using <a class="el" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back()</a>. Establishes a hierarchy of finite elements corresponding to their index in the collection. </p>

</div>
</div>
<a id="a6b557e20b5abc09c7be5158c3f034955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b557e20b5abc09c7be5158c3f034955">&#9670;&nbsp;</a></span>FECollection() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::<a class="el" href="classhp_1_1FECollection.html">FECollection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Conversion constructor. This constructor creates a <a class="el" href="classhp_1_1FECollection.html">FECollection</a> from a single finite element. More finite element objects can be added with <a class="el" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back()</a>, if desired, though it would probably be clearer to add all mappings the same way. </p>

</div>
</div>
<a id="a63763c1f266928722f599e9da1f2baf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63763c1f266928722f599e9da1f2baf9">&#9670;&nbsp;</a></span>FECollection() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class... FETypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::<a class="el" href="classhp_1_1FECollection.html">FECollection</a> </td>
          <td>(</td>
          <td class="paramtype">const FETypes &amp;...&#160;</td>
          <td class="paramname"><em>fes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. This constructor creates a <a class="el" href="classhp_1_1FECollection.html">FECollection</a> from one or more finite element objects passed to the constructor. For this call to be valid, all arguments need to be of types derived from class FiniteElement&lt;dim,spacedim&gt;. </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00768">768</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a33779cbf32c4f124cda38eeb790a8c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33779cbf32c4f124cda38eeb790a8c62">&#9670;&nbsp;</a></span>FECollection() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::<a class="el" href="classhp_1_1FECollection.html">FECollection</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Same as above but for any number of elements. Pointers to the elements are passed in a vector to this constructor. As above, the finite element objects pointed to by the argument are not actually used other than to create copies internally. Consequently, you can delete these pointers immediately again after calling this constructor. </p>

</div>
</div>
<a id="ad8f7b4ccf64ce616f22e046fabd215e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f7b4ccf64ce616f22e046fabd215e6">&#9670;&nbsp;</a></span>FECollection() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::<a class="el" href="classhp_1_1FECollection.html">FECollection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a id="a2495f87c9518a2e3afa78599823e2d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2495f87c9518a2e3afa78599823e2d4f">&#9670;&nbsp;</a></span>FECollection() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::<a class="el" href="classhp_1_1FECollection.html">FECollection</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor.</p>
<dl class="section note"><dt>Note</dt><dd>The implementation of standard datatypes may change with different libraries, so their move members may or may not be flagged non-throwing. We need to explicitly set the noexcept specifier according to its member variables to still get the performance benefits (and to satisfy clang-tidy). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a02f70cf84f2dc79b9cc2858d9dbf27fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f70cf84f2dc79b9cc2858d9dbf27fa">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator. </p>

</div>
</div>
<a id="a3282c173b24b3e937b30baffd8c087f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3282c173b24b3e937b30baffd8c087f6">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_collection</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equality comparison operator. All stored <a class="el" href="classFiniteElement.html">FiniteElement</a> objects are compared in order. </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00808">808</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a80cfe7309c06d410f18cf0623aac4c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cfe7309c06d410f18cf0623aac4c85">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1FECollection.html">FECollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_collection</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Non-equality comparison operator. All stored <a class="el" href="classFiniteElement.html">FiniteElement</a> objects are compared in order. </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00826">826</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a4b0e75a805ff012e76d33ad6d4c3eac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0e75a805ff012e76d33ad6d4c3eac8">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_fe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a finite element. This function generates a copy of the given element, i.e. you can do things like <code>push_back(FE_Q&lt;dim&gt;(1));</code>. The internal copy is later destroyed by this object upon destruction of the entire collection.</p>
<p>When a new element is added, it needs to have the same number of vector components as all other elements already in the collection. </p>

</div>
</div>
<a id="add4bafb2f8e59ae8c0165f31db334205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4bafb2f8e59ae8c0165f31db334205">&#9670;&nbsp;</a></span>n_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::n_components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of vector components of the finite elements in this collection. This number must be the same for all elements in the collection.</p>
<p>This function calls <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components</a>. See <a class="el" href="DEALGlossary.html#GlossComponent">the glossary</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00788">788</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="ad8eea6cc97389fe6ea1f479cdbadd60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8eea6cc97389fe6ea1f479cdbadd60c">&#9670;&nbsp;</a></span>n_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::n_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of vector blocks of the finite elements in this collection. While this class ensures that all elements stored in it have the same number of vector components, there is no such guarantees for the number of blocks each element is made up of (an element may have fewer blocks than vector components; see <a class="el" href="DEALGlossary.html#GlossBlock">the glossary</a> for more information). For example, you may have an <a class="el" href="classhp_1_1FECollection.html">FECollection</a> object that stores one copy of an <a class="el" href="classFESystem.html">FESystem</a> with <code>dim</code> <a class="el" href="classFE__Q.html">FE_Q</a> objects and one copy of an <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> element. Both have <code>dim</code> vector components but while the former has <code>dim</code> blocks the latter has only one. Consequently, this function will throw an assertion if the number of blocks is not the same for all elements. If they are the same, this function returns the result of <a class="el" href="classFiniteElementData.html#a4c1c4ca934f26ff463caf35a574e9f14">FiniteElement::n_blocks()</a>. </p>

</div>
</div>
<a id="a6cd571a96bd66ee1cfd970dc87434d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd571a96bd66ee1cfd970dc87434d88">&#9670;&nbsp;</a></span>max_degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::max_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximum of values returned by <a class="el" href="namespaceinternal.html#acbc4eb5d23ccaa14762fb4d43251f15b">FiniteElement::get_degree()</a> over all elements of this collection. </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00835">835</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a173d07546d8bd925c5a113b11fa63ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173d07546d8bd925c5a113b11fa63ae8">&#9670;&nbsp;</a></span>max_dofs_per_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::max_dofs_per_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximal number of degrees of freedom per vertex over all elements of this collection. </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00850">850</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a0a5e8de2d3c1c033fb4bddddfc35314f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5e8de2d3c1c033fb4bddddfc35314f">&#9670;&nbsp;</a></span>max_dofs_per_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::max_dofs_per_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximal number of degrees of freedom per line over all elements of this collection. </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00865">865</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a9864eddabbc3df8729ce06b822464d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9864eddabbc3df8729ce06b822464d84">&#9670;&nbsp;</a></span>max_dofs_per_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::max_dofs_per_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximal number of degrees of freedom per quad over all elements of this collection. </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00880">880</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a0d152cf2356925186c85a22370c3a26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d152cf2356925186c85a22370c3a26f">&#9670;&nbsp;</a></span>max_dofs_per_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::max_dofs_per_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximal number of degrees of freedom per hex over all elements of this collection. </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00895">895</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a71c51e1333e89c241e6ce856b206f8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c51e1333e89c241e6ce856b206f8ba">&#9670;&nbsp;</a></span>max_dofs_per_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::max_dofs_per_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximal number of degrees of freedom per face over all elements of this collection. </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00910">910</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="ae849636cc622a9fdd00305698b9d455c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae849636cc622a9fdd00305698b9d455c">&#9670;&nbsp;</a></span>max_dofs_per_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::max_dofs_per_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximal number of degrees of freedom per cell over all elements of this collection. </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00925">925</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a29a5f7c2639e467e2192d6eb0c97b468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a5f7c2639e467e2192d6eb0c97b468">&#9670;&nbsp;</a></span>hp_constraints_are_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::hp_constraints_are_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether all elements in this collection implement the hanging node constraints in the new way, which has to be used to make elements "hp-compatible". If this is not the case, the function returns false, which implies, that at least one element in the <a class="el" href="classhp_1_1FECollection.html">FECollection</a> does not support the new face interface constraints. On the other hand, if this method does return true, this does not imply that the hp-method will work!</p>
<p>This behavior is related to the fact, that <a class="el" href="classFiniteElement.html">FiniteElement</a> classes, which provide the new style hanging node constraints might still not provide them for all possible cases. If <a class="el" href="classFE__Q.html">FE_Q</a> and <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> elements are included in the <a class="el" href="classhp_1_1FECollection.html">FECollection</a> and both properly implement the get_face_interpolation_matrix method, this method will return true. But the get_face_interpolation_matrix might still fail to find an interpolation matrix between these two elements. </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00939">939</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="a6b344455872d2ff9dcebdc665423fd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b344455872d2ff9dcebdc665423fd15">&#9670;&nbsp;</a></span>find_common_fes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::find_common_fes </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the indices of finite elements in this <a class="el" href="classhp_1_1FECollection.html">FECollection</a> that dominate all elements associated with the provided set of indices <code>fes</code>.</p>
<p>You may find information about the domination behavior of finite elements in their respective class documentation or in the implementation of their inherited member function <a class="el" href="classFiniteElement.html#a0acf7f396d861978209890fa268bdcbe">FiniteElement::compare_for_domination()</a>. Consider that a finite element may or may not dominate itself (e.g. <a class="el" href="classFE__Nothing.html">FE_Nothing</a> elements).</p>
<p>For example, if a <a class="el" href="classhp_1_1FECollection.html">FECollection</a> consists of <code>{<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>,<a class="el" href="classFE__Q.html">FE_Q(3)</a>,<a class="el" href="classFE__Q.html">FE_Q(4)</a>}</code> elements and we are looking for the finite elements that dominate the middle elements of this collection (i.e., <code>fes</code> is <code>{1,2}</code>), then the answer is <code>{<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a></code> and therefore this function will return their indices in the <a class="el" href="classhp_1_1FECollection.html">FECollection</a>, namely <code>{0,1}</code>.</p>
<p>The <code>codim</code> parameter describes the codimension of the investigated subspace and specifies that it is subject to this comparison. See <a class="el" href="classFiniteElement.html#a0acf7f396d861978209890fa268bdcbe">FiniteElement::compare_for_domination()</a> for more information. </p>

</div>
</div>
<a id="aaf8d9c03d87c90753485bde0f7bf42fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8d9c03d87c90753485bde0f7bf42fe">&#9670;&nbsp;</a></span>find_enclosing_fes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::find_enclosing_fes </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the indices of finite elements in this <a class="el" href="classhp_1_1FECollection.html">FECollection</a> that are dominated by all elements associated with the provided set of indices <code>fes</code>.</p>
<p>You may find information about the domination behavior of finite elements in their respective class documentation or in the implementation of their inherited member function <a class="el" href="classFiniteElement.html#a0acf7f396d861978209890fa268bdcbe">FiniteElement::compare_for_domination()</a>. Consider that a finite element may or may not dominate itself (e.g. <a class="el" href="classFE__Nothing.html">FE_Nothing</a> elements).</p>
<p>For example, if a <a class="el" href="classhp_1_1FECollection.html">FECollection</a> consists of <code>{<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>,<a class="el" href="classFE__Q.html">FE_Q(3)</a>,<a class="el" href="classFE__Q.html">FE_Q(4)</a>}</code> elements and we are looking for the finite elements that are dominated by the middle elements of this collection (i.e., <code>fes</code> is <code>{1,2}</code>), then the answer is <code>{<a class="el" href="classFE__Q.html">FE_Q(3)</a>,<a class="el" href="classFE__Q.html">FE_Q(4)</a></code> and therefore this function will return their indices in the <a class="el" href="classhp_1_1FECollection.html">FECollection</a>, namely <code>{2,3}</code>.</p>
<p>The <code>codim</code> parameter describes the codimension of the investigated subspace and specifies that it is subject to this comparison. See <a class="el" href="classFiniteElement.html#a0acf7f396d861978209890fa268bdcbe">FiniteElement::compare_for_domination()</a> for more information. </p>

</div>
</div>
<a id="a6df6ca3a652ba86592d6ea0b94a03e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df6ca3a652ba86592d6ea0b94a03e1d">&#9670;&nbsp;</a></span>find_dominating_fe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::find_dominating_fe </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the index of a finite element from the provided set of indices <code>fes</code> that dominates all other elements of this very set.</p>
<p>You may find information about the domination behavior of finite elements in their respective class documentation or in the implementation of their inherited member function <a class="el" href="classFiniteElement.html#a0acf7f396d861978209890fa268bdcbe">FiniteElement::compare_for_domination()</a>. Consider that a finite element may or may not dominate itself (e.g. <a class="el" href="classFE__Nothing.html">FE_Nothing</a> elements).</p>
<p>If this set consists of exactly one element, we consider it to be the dominating one and return its corresponding index. Further, if the function is not able to find a finite element at all, it returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>.</p>
<p>For example, if a <a class="el" href="classhp_1_1FECollection.html">FECollection</a> consists of <code>{<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>,<a class="el" href="classFE__Q.html">FE_Q(3)</a>,<a class="el" href="classFE__Q.html">FE_Q(4)</a>}</code> elements and we are looking for the dominating finite element among the middle elements of this collection (i.e., <code>fes</code> is <code>{1,2}</code>), then the answer is <a class="el" href="classFE__Q.html">FE_Q(2)</a> and therefore this function will return its index in the <a class="el" href="classhp_1_1FECollection.html">FECollection</a>, namely <code>1</code>.</p>
<p>It is of course possible that there is more than one element that dominates all selected elements. For example, if the collection consists of <code>{<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>}</code> and <code>fes</code> covers all indices, then one could return zero or one. In that case, the function returns either <code>0</code> or <code>1</code> since there is no tie-breaker between the two.</p>
<p>The <code>codim</code> parameter describes the codimension of the investigated subspace and specifies that it is subject to this comparison. See <a class="el" href="classFiniteElement.html#a0acf7f396d861978209890fa268bdcbe">FiniteElement::compare_for_domination()</a> for more information. </p>

</div>
</div>
<a id="a719793132cab791f215ee96b4d5f0c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719793132cab791f215ee96b4d5f0c75">&#9670;&nbsp;</a></span>find_dominated_fe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::find_dominated_fe </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the index of a finite element from the provided set of indices <code>fes</code> that is dominated by all other elements of this very set.</p>
<p>You may find information about the domination behavior of finite elements in their respective class documentation or in the implementation of their inherited member function <a class="el" href="classFiniteElement.html#a0acf7f396d861978209890fa268bdcbe">FiniteElement::compare_for_domination()</a>. Consider that a finite element may or may not dominate itself (e.g. <a class="el" href="classFE__Nothing.html">FE_Nothing</a> elements).</p>
<p>If this set consists of exactly one element, we consider it to be the dominated one and return its corresponding index. Further, if the function is not able to find a finite element at all, it returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>.</p>
<p>For example, if a <a class="el" href="classhp_1_1FECollection.html">FECollection</a> consists of <code>{<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>,<a class="el" href="classFE__Q.html">FE_Q(3)</a>,<a class="el" href="classFE__Q.html">FE_Q(4)</a>}</code> elements and we are looking for the dominated finite element among the middle elements of this collection (i.e., <code>fes</code> is <code>{1,2}</code>), then the answer is <a class="el" href="classFE__Q.html">FE_Q(3)</a> and therefore this function will return its index in the <a class="el" href="classhp_1_1FECollection.html">FECollection</a>, namely <code>2</code>.</p>
<p>It is of course possible that there is more than one element that is dominated by all selected elements. For example, if the collection consists of <code>{<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(1)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>,<a class="el" href="classFE__Q.html">FE_Q(2)</a>}</code> and <code>fes</code> covers all indices, then one could return two or three. In that case, the function returns either <code>2</code> or <code>3</code> since there is no tie-breaker between the two.</p>
<p>The <code>codim</code> parameter describes the codimension of the investigated subspace and specifies that it is subject to this comparison. See <a class="el" href="classFiniteElement.html#a0acf7f396d861978209890fa268bdcbe">FiniteElement::compare_for_domination()</a> for more information. </p>

</div>
</div>
<a id="a1c4f34d801d827773a91ff539ffabadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4f34d801d827773a91ff539ffabadd">&#9670;&nbsp;</a></span>find_dominating_fe_extended()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::find_dominating_fe_extended </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the index of a finite element from the provided set of indices <code>fes</code> that dominates all other elements of this very set. If we do not succeed, we extend our search on the whole collection by picking the least dominating one, which is the element that describes the largest finite element space of which all of the finite elements of the provided set <code>fes</code> are part of.</p>
<p>You may find information about the domination behavior of finite elements in their respective class documentation or in the implementation of their inherited member function <a class="el" href="classFiniteElement.html#a0acf7f396d861978209890fa268bdcbe">FiniteElement::compare_for_domination()</a>. Consider that a finite element may or may not dominate itself (e.g. <a class="el" href="classFE__Nothing.html">FE_Nothing</a> elements).</p>
<p>If this set consists of exactly one element, we consider it to be the dominated one and return its corresponding index. Further, if the function is not able to find a finite element at all, it returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>.</p>
<p>The <code>codim</code> parameter describes the codimension of the investigated subspace and specifies that it is subject to this comparison. See <a class="el" href="classFiniteElement.html#a0acf7f396d861978209890fa268bdcbe">FiniteElement::compare_for_domination()</a> for more information. </p>

</div>
</div>
<a id="aae4e336f83e16ba6291d3748d52438d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4e336f83e16ba6291d3748d52438d8">&#9670;&nbsp;</a></span>find_dominated_fe_extended()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::find_dominated_fe_extended </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the index of a finite element from the provided set of indices <code>fes</code> that is dominated by all other elements of this very set. If we do not succeed, we extend our search on the whole collection by picking the most dominated one, which is the element that describes the smallest finite element space which includes all finite elements of the provided set <code>fes</code>.</p>
<p>You may find information about the domination behavior of finite elements in their respective class documentation or in the implementation of their inherited member function <a class="el" href="classFiniteElement.html#a0acf7f396d861978209890fa268bdcbe">FiniteElement::compare_for_domination()</a>. Consider that a finite element may or may not dominate itself (e.g. <a class="el" href="classFE__Nothing.html">FE_Nothing</a> elements).</p>
<p>If this set consists of exactly one element, we consider it to be the dominating one and return its corresponding index. Further, if the function is not able to find a finite element at all, it returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>.</p>
<p>The <code>codim</code> parameter describes the codimension of the investigated subspace and specifies that it is subject to this comparison. See <a class="el" href="classFiniteElement.html#a0acf7f396d861978209890fa268bdcbe">FiniteElement::compare_for_domination()</a> for more information. </p>

</div>
</div>
<a id="a8ae7823f04f51f2daaf0b770a151b1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae7823f04f51f2daaf0b770a151b1b1">&#9670;&nbsp;</a></span>set_hierarchy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::set_hierarchy </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set functions determining the hierarchy of finite elements, i.e. a function <code>next</code> that returns the index of the finite element following the given one, and a function <code>prev</code> returning the preceding one.</p>
<p>Both functions expect an <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> to be passed along with a finite element index, on whose basis the new index will be found and returned.</p>
<dl class="section note"><dt>Note</dt><dd>Both passed and returned indices have to be valid within the index range of this collection, i.e. within [0, <a class="el" href="classhp_1_1Collection.html#a9e51c9371e925145c42840d72f4a0bf7">size()</a>). </dd></dl>

</div>
</div>
<a id="a573c653d73cc02496fd61ebee6c00b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573c653d73cc02496fd61ebee6c00b00">&#9670;&nbsp;</a></span>set_default_hierarchy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::set_default_hierarchy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the default hierarchy corresponding to the index of each finite element in the collection.</p>
<p>This default hierarchy is established with functions <a class="el" href="structhp_1_1FECollection_1_1DefaultHierarchy.html#a2ebf0b6b6b35f67e7e5ffbf55bb29c7a">DefaultHierarchy::next_index()</a> and <a class="el" href="structhp_1_1FECollection_1_1DefaultHierarchy.html#a310d829aa99a422a79eff9bf21bb8153">DefaultHierarchy::previous_index()</a>. </p>

</div>
</div>
<a id="abd05bf480984a510901e6f4a15a3d929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd05bf480984a510901e6f4a15a3d929">&#9670;&nbsp;</a></span>get_hierarchy_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::get_hierarchy_sequence </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a sequence of FE indices that corresponds to the registered hierarchy in ascending order, i.e., FE indices are sorted from lowest to highest level.</p>
<p>Multiple sequences of FE indices are possible with a single custom hierarchy that can be registered with <a class="el" href="classhp_1_1FECollection.html#a8ae7823f04f51f2daaf0b770a151b1b1">set_hierarchy()</a>. This function will return the sequence that contains the user-provided index <code>fe_index</code> which could be located anywhere inside the sequence. The default hierarchy set via <a class="el" href="classhp_1_1FECollection.html#a573c653d73cc02496fd61ebee6c00b00">set_default_hierarchy()</a>, which corresponds to FE indices in ascending order, consists of only one sequence.</p>
<p>This function can be used, for example, to verify that your provided hierarchy covers all elements in the desired order.</p>
<p>Only one sequence of FE indices exists if the size of the returned container equals the number of elements of this object, i.e., <a class="el" href="classhp_1_1Collection.html#a9e51c9371e925145c42840d72f4a0bf7">FECollection::size()</a>. </p>

</div>
</div>
<a id="a520c6b1493b469686e9a36f6aae087ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a520c6b1493b469686e9a36f6aae087ec">&#9670;&nbsp;</a></span>next_in_hierarchy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::next_in_hierarchy </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function returning the index of the finite element following the given <code>fe_index</code> in hierarchy.</p>
<p>By default, the index succeeding <code>fe_index</code> will be returned. If <code>fe_index</code> already corresponds to the last index, the last index will be returned. A custom hierarchy can be supplied via the member function set_hierachy(). </p>

</div>
</div>
<a id="a091d817c47838ec112afba864ef51fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091d817c47838ec112afba864ef51fdb">&#9670;&nbsp;</a></span>previous_in_hierarchy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::previous_in_hierarchy </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function returning the index of the finite element preceding the given <code>fe_index</code> in hierarchy.</p>
<p>By default, the index preceding <code>fe_index</code> will be returned. If <code>fe_index</code> already corresponds to the first index, the first index will be returned. A custom hierarchy can be supplied via the member function set_hierachy(). </p>

</div>
</div>
<a id="a7cdf2f55585aa8a5777535b57b220a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdf2f55585aa8a5777535b57b220a17">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the one component is true that corresponds to the given argument.</p>
<dl class="section note"><dt>Note</dt><dd>This function is the equivalent of <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> with the same arguments. It verifies that it gets the same result from every one of the elements that are stored in this <a class="el" href="classhp_1_1FECollection.html">FECollection</a>. If this is not the case, it throws an exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>An object that represents a single scalar vector component of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the one that corresponds to the argument. </dd></dl>

</div>
</div>
<a id="a5d17b05f9180827ea291fdb798dca525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d17b05f9180827ea291fdb798dca525">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim</code> components are true that correspond to the given argument.</p>
<dl class="section note"><dt>Note</dt><dd>This function is the equivalent of <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> with the same arguments. It verifies that it gets the same result from every one of the elements that are stored in this <a class="el" href="classhp_1_1FECollection.html">FECollection</a>. If this is not the case, it throws an exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>An object that represents dim vector components of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

</div>
</div>
<a id="ac8f643ca875e5a1e40500cd0d9e43e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f643ca875e5a1e40500cd0d9e43e37">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sym_tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim*(dim+1)/2</code> components are true that correspond to the given argument.</p>
<dl class="section note"><dt>Note</dt><dd>This function is the equivalent of <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> with the same arguments. It verifies that it gets the same result from every one of the elements that are stored in this <a class="el" href="classhp_1_1FECollection.html">FECollection</a>. If this is not the case, it throws an exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym_tensor</td><td>An object that represents dim*(dim+1)/2 components of this finite element that are jointly to be interpreted as forming a symmetric tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

</div>
</div>
<a id="afbb50939b9305ac2880d54007a827d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb50939b9305ac2880d54007a827d22">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>block_mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a block mask (see <a class="el" href="DEALGlossary.html#GlossBlockMask">this glossary entry</a> ), produce a component mask (see <a class="el" href="DEALGlossary.html#GlossComponentMask">this glossary entry</a> ) that represents the components that correspond to the blocks selected in the input argument. This is essentially a conversion operator from <a class="el" href="classBlockMask.html">BlockMask</a> to <a class="el" href="classComponentMask.html">ComponentMask</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function is the equivalent of <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> with the same arguments. It verifies that it gets the same result from every one of the elements that are stored in this <a class="el" href="classhp_1_1FECollection.html">FECollection</a>. If this is not the case, it throws an exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_mask</td><td>The mask that selects individual blocks of the finite element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mask that selects those components corresponding to the selected blocks of the input argument. </dd></dl>

</div>
</div>
<a id="af8afd8e5ed60f7ad7fc71e3f96e2f5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8afd8e5ed60f7ad7fc71e3f96e2f5f3">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a block mask with as many elements as this object has blocks and of which exactly the one component is true that corresponds to the given argument. See <a class="el" href="DEALGlossary.html#GlossBlockMask">the glossary</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>This function will only succeed if the scalar referenced by the argument encompasses a complete block. In other words, if, for example, you pass an extractor for the single \(x\) velocity and this object represents an <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> object, then the single scalar object you selected is part of a larger block and consequently there is no block mask that would represent it. The function will then produce an exception.</dd>
<dd>
This function is the equivalent of <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> with the same arguments. It verifies that it gets the same result from every one of the elements that are stored in this <a class="el" href="classhp_1_1FECollection.html">FECollection</a>. If this is not the case, it throws an exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>An object that represents a single scalar vector component of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the one that corresponds to the argument. </dd></dl>

</div>
</div>
<a id="acf9e9f51f57c6526d643104df76384fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9e9f51f57c6526d643104df76384fd">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim</code> components are true that correspond to the given argument. See <a class="el" href="DEALGlossary.html#GlossBlockMask">the glossary</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>This function is the equivalent of <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> with the same arguments. It verifies that it gets the same result from every one of the elements that are stored in this <a class="el" href="classhp_1_1FECollection.html">FECollection</a>. If this is not the case, it throws an exception.</dd>
<dd>
The same caveat applies as to the version of the function above: The extractor object passed as argument must be so that it corresponds to full blocks and does not split blocks of this element.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>An object that represents dim vector components of this finite element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

</div>
</div>
<a id="a030037ceecf42a6ca0719eb8385fc2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030037ceecf42a6ca0719eb8385fc2a3">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sym_tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a component mask with as many elements as this object has vector components and of which exactly the <code>dim*(dim+1)/2</code> components are true that correspond to the given argument. See <a class="el" href="DEALGlossary.html#GlossBlockMask">the glossary</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The same caveat applies as to the version of the function above: The extractor object passed as argument must be so that it corresponds to full blocks and does not split blocks of this element.</dd>
<dd>
This function is the equivalent of <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> with the same arguments. It verifies that it gets the same result from every one of the elements that are stored in this <a class="el" href="classhp_1_1FECollection.html">FECollection</a>. If this is not the case, it throws an exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym_tensor</td><td>An object that represents dim*(dim+1)/2 components of this finite element that are jointly to be interpreted as forming a symmetric tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A component mask that is false in all components except for the ones that corresponds to the argument. </dd></dl>

</div>
</div>
<a id="a6bb077f2b8eb8671342ac13e232fd520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb077f2b8eb8671342ac13e232fd520">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a component mask (see <a class="el" href="DEALGlossary.html#GlossComponentMask">this glossary entry</a> ), produce a block mask (see <a class="el" href="DEALGlossary.html#GlossBlockMask">this glossary entry</a> ) that represents the blocks that correspond to the components selected in the input argument. This is essentially a conversion operator from <a class="el" href="classComponentMask.html">ComponentMask</a> to <a class="el" href="classBlockMask.html">BlockMask</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function will only succeed if the components referenced by the argument encompasses complete blocks. In other words, if, for example, you pass an component mask for the single \(x\) velocity and this object represents an <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> object, then the single component you selected is part of a larger block and consequently there is no block mask that would represent it. The function will then produce an exception.</dd>
<dd>
This function is the equivalent of <a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">FiniteElement::component_mask()</a> with the same arguments. It verifies that it gets the same result from every one of the elements that are stored in this <a class="el" href="classhp_1_1FECollection.html">FECollection</a>. If this is not the case, it throws an exception.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component_mask</td><td>The mask that selects individual components of the finite element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mask that selects those blocks corresponding to the selected blocks of the input argument. </dd></dl>

</div>
</div>
<a id="a1e43005f6dc7f4096e9f03fb77ac7fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e43005f6dc7f4096e9f03fb77ac7fa1">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhp_1_1Collection.html">hp::Collection</a>&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;  &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;  &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a new object. </p>

<p class="definition">Definition at line <a class="el" href="collection_8h_source.html#l00100">100</a> of file <a class="el" href="collection_8h_source.html">collection.h</a>.</p>

</div>
</div>
<a id="ae7cd609468d1724dd4bbe4e7d3676c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cd609468d1724dd4bbe4e7d3676c09">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;  &amp; <a class="el" href="classhp_1_1Collection.html">hp::Collection</a>&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;  &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the object which was specified by the user for the active FE index which is provided as a parameter to this method.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>index</code> must be between zero and the number of elements of the collection. </dd></dl>

<p class="definition">Definition at line <a class="el" href="collection_8h_source.html#l00117">117</a> of file <a class="el" href="collection_8h_source.html">collection.h</a>.</p>

</div>
</div>
<a id="a9e51c9371e925145c42840d72f4a0bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e51c9371e925145c42840d72f4a0bf7">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classhp_1_1Collection.html">hp::Collection</a>&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;  &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of objects stored in this container. </p>

<p class="definition">Definition at line <a class="el" href="collection_8h_source.html#l00109">109</a> of file <a class="el" href="collection_8h_source.html">collection.h</a>.</p>

</div>
</div>
<a id="aa8900b5562cbfa4523e0aff131ad3190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8900b5562cbfa4523e0aff131ad3190">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classhp_1_1Collection.html">hp::Collection</a>&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;  &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

<p class="definition">Definition at line <a class="el" href="collection_8h_source.html#l00091">91</a> of file <a class="el" href="collection_8h_source.html">collection.h</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4076a62850571b131946f2221ed87a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4076a62850571b131946f2221ed87a28">&#9670;&nbsp;</a></span>hierarchy_next</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt;dim, spacedim&gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::hierarchy_next</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function returning the index of the finite element following the given one in hierarchy. </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00751">751</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<a id="aca57244f0a037efa4ae8ce5e06c24314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca57244f0a037efa4ae8ce5e06c24314">&#9670;&nbsp;</a></span>hierarchy_prev</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;unsigned <a class="el" href="classint.html">int</a>(const typename <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt;dim, spacedim&gt; &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt;::hierarchy_prev</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function returning the index of the finite element preceding the given one in hierarchy. </p>

<p class="definition">Definition at line <a class="el" href="fe__collection_8h_source.html#l00759">759</a> of file <a class="el" href="fe__collection_8h_source.html">fe_collection.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/hp/<a class="el" href="fe__collection_8h_source.html">fe_collection.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
