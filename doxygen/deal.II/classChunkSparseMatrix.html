<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classChunkSparseMatrix.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: ChunkSparseMatrix&lt; number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classChunkSparseMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ChunkSparseMatrix&lt; number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="chunk__sparse__matrix_8h_source.html">deal.II/lac/chunk_sparse_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ChunkSparseMatrix&lt; number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classChunkSparseMatrix__inherit__graph.svg" width="170" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structChunkSparseMatrix_1_1Traits.html">Traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acaa0c8eae0bf77fa8b9045865e30c920"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:acaa0c8eae0bf77fa8b9045865e30c920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0eb36be6940f36b1e8c58fe231e5301"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#ac0eb36be6940f36b1e8c58fe231e5301">value_type</a> = number</td></tr>
<tr class="separator:ac0eb36be6940f36b1e8c58fe231e5301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27b79afda83b7a8679a3adbcc613af6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#ad27b79afda83b7a8679a3adbcc613af6">real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; number &gt;::<a class="el" href="classChunkSparseMatrix.html#ad27b79afda83b7a8679a3adbcc613af6">real_type</a></td></tr>
<tr class="separator:ad27b79afda83b7a8679a3adbcc613af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d981c89d9320893773a110319c6d19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a19d981c89d9320893773a110319c6d19">const_iterator</a> = <a class="el" href="classChunkSparseMatrixIterators_1_1Iterator.html">ChunkSparseMatrixIterators::Iterator</a>&lt; number, true &gt;</td></tr>
<tr class="separator:a19d981c89d9320893773a110319c6d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a9b7b6c1696c99915d83c0dd1786d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a54a9b7b6c1696c99915d83c0dd1786d5">iterator</a> = <a class="el" href="classChunkSparseMatrixIterators_1_1Iterator.html">ChunkSparseMatrixIterators::Iterator</a>&lt; number, false &gt;</td></tr>
<tr class="separator:a54a9b7b6c1696c99915d83c0dd1786d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ga56b8c5a67710dd1d10dc9634aa7efb70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga56b8c5a67710dd1d10dc9634aa7efb70">DeclException2</a> (ExcInvalidIndex, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are trying to access the matrix entry with index &lt;&quot;&lt;&lt; arg1&lt;&lt; ','&lt;&lt; arg2&lt;&lt; &quot;&gt;, but this entry does not exist in the sparsity pattern &quot; &quot;of this matrix.&quot; &quot;\&quot; &quot;The most common cause for this problem is that you used &quot; &quot;a method to build the sparsity pattern that did not &quot; &quot;(completely) take into account all of the entries you &quot; &quot;will later try to write into. An example would be &quot; &quot;building a sparsity pattern that does not include &quot; &quot;the entries you will write into due to constraints &quot; &quot;on degrees of freedom such as hanging nodes or periodic &quot; &quot;boundary conditions. In such cases, building the &quot; &quot;sparsity pattern will succeed, but you will get errors &quot; &quot;such as the current one at one point or other when &quot; &quot;trying to write into the entries of the matrix.&quot;)</td></tr>
<tr class="separator:ga56b8c5a67710dd1d10dc9634aa7efb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga779dd9a0db181024dca85ca7651f3be3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga779dd9a0db181024dca85ca7651f3be3">DeclException0</a> (ExcDifferentChunkSparsityPatterns)</td></tr>
<tr class="separator:ga779dd9a0db181024dca85ca7651f3be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebaa7afc06023a45ad844176d4cf0424"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaebaa7afc06023a45ad844176d4cf0424">DeclException2</a> (ExcIteratorRange, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The iterators denote a range of &quot;&lt;&lt; arg1&lt;&lt; &quot; elements, but the given number of rows was &quot;&lt;&lt; arg2)</td></tr>
<tr class="separator:gaebaa7afc06023a45ad844176d4cf0424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39ce23aacffc671a4bb83ba556fc6f5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga39ce23aacffc671a4bb83ba556fc6f5e">DeclExceptionMsg</a> (ExcSourceEqualsDestination, &quot;You are attempting an operation on two matrices that &quot; &quot;are the same object, but the operation requires that the &quot; &quot;two objects are in fact different.&quot;)</td></tr>
<tr class="separator:ga39ce23aacffc671a4bb83ba556fc6f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">构造器和初始化。</div></td></tr>
<tr class="memitem:aaa57c76a8291aee0adb129b3666c12d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#aaa57c76a8291aee0adb129b3666c12d3">ChunkSparseMatrix</a> ()</td></tr>
<tr class="separator:aaa57c76a8291aee0adb129b3666c12d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32df0b72f53ad4db74701f22be8307d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#ad32df0b72f53ad4db74701f22be8307d">ChunkSparseMatrix</a> (const <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> &amp;)</td></tr>
<tr class="separator:ad32df0b72f53ad4db74701f22be8307d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102e0d70bc668c79b36a4a960983c164"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a102e0d70bc668c79b36a4a960983c164">ChunkSparseMatrix</a> (const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:a102e0d70bc668c79b36a4a960983c164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e93d54649971acf31eeb6ee715de259"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a8e93d54649971acf31eeb6ee715de259">ChunkSparseMatrix</a> (const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> &amp;sparsity, const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;id)</td></tr>
<tr class="separator:a8e93d54649971acf31eeb6ee715de259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784db3144358fc607af7612469406699"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a784db3144358fc607af7612469406699">~ChunkSparseMatrix</a> () override</td></tr>
<tr class="separator:a784db3144358fc607af7612469406699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212f23c500156be81b186fcc867bb43c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a212f23c500156be81b186fcc867bb43c">operator=</a> (const <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt; &amp;)</td></tr>
<tr class="separator:a212f23c500156be81b186fcc867bb43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0925ec9c7f06f37df4581dbcbb04e917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a0925ec9c7f06f37df4581dbcbb04e917">operator=</a> (const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;id)</td></tr>
<tr class="separator:a0925ec9c7f06f37df4581dbcbb04e917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af740cc20f7df852be517f73a1f11c60e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#af740cc20f7df852be517f73a1f11c60e">operator=</a> (const <a class="el" href="classdouble.html">double</a> d)</td></tr>
<tr class="separator:af740cc20f7df852be517f73a1f11c60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44551560de47e8e7becd549bfce76447"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a44551560de47e8e7becd549bfce76447">reinit</a> (const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:a44551560de47e8e7becd549bfce76447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dc610cca5ebb55cd39402abdd29489"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#aa3dc610cca5ebb55cd39402abdd29489">clear</a> ()</td></tr>
<tr class="separator:aa3dc610cca5ebb55cd39402abdd29489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">矩阵的信息</div></td></tr>
<tr class="memitem:a36be14410bf17daa8dd8d836aeeebc52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a36be14410bf17daa8dd8d836aeeebc52">empty</a> () const</td></tr>
<tr class="separator:a36be14410bf17daa8dd8d836aeeebc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0224abfda5ad78be88a59132e9f581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a8a0224abfda5ad78be88a59132e9f581">m</a> () const</td></tr>
<tr class="separator:a8a0224abfda5ad78be88a59132e9f581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37be64dec5b2d13a1e70ea2f8d06e62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#af37be64dec5b2d13a1e70ea2f8d06e62">n</a> () const</td></tr>
<tr class="separator:af37be64dec5b2d13a1e70ea2f8d06e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db4c03728a021f0b20dc3945e52e0b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a9db4c03728a021f0b20dc3945e52e0b7">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:a9db4c03728a021f0b20dc3945e52e0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca045aab5ce8ef486a7323755d8f5bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a8ca045aab5ce8ef486a7323755d8f5bc">n_actually_nonzero_elements</a> () const</td></tr>
<tr class="separator:a8ca045aab5ce8ef486a7323755d8f5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b9d10a53255165eb22a36d5be0bc99"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a22b9d10a53255165eb22a36d5be0bc99">get_sparsity_pattern</a> () const</td></tr>
<tr class="separator:a22b9d10a53255165eb22a36d5be0bc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade39cbfa1db0d00d455a7497790918cd"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#ade39cbfa1db0d00d455a7497790918cd">memory_consumption</a> () const</td></tr>
<tr class="separator:ade39cbfa1db0d00d455a7497790918cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">修改条目</div></td></tr>
<tr class="memitem:a2c56d5270b6912d2dd9ec96b1ed83d6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a2c56d5270b6912d2dd9ec96b1ed83d6b">set</a> (const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> i, const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> j, const number value)</td></tr>
<tr class="separator:a2c56d5270b6912d2dd9ec96b1ed83d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bfb50598b15c0090cecdfeb259ad24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a29bfb50598b15c0090cecdfeb259ad24">add</a> (const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> i, const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> j, const number value)</td></tr>
<tr class="separator:a29bfb50598b15c0090cecdfeb259ad24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fd80495c44053f8edbb9e5fe8b5fb7"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ae1fd80495c44053f8edbb9e5fe8b5fb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#ae1fd80495c44053f8edbb9e5fe8b5fb7">add</a> (const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> row, const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> n_cols, const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> *col_indices, const number2 *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:ae1fd80495c44053f8edbb9e5fe8b5fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080e6e1634e85ef703e77fba4a11f14e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a080e6e1634e85ef703e77fba4a11f14e">operator*=</a> (const number factor)</td></tr>
<tr class="separator:a080e6e1634e85ef703e77fba4a11f14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058e57167ecd1cb2196bf37773520323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a058e57167ecd1cb2196bf37773520323">operator/=</a> (const number factor)</td></tr>
<tr class="separator:a058e57167ecd1cb2196bf37773520323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af697f7b5333f310a1677f7a210882e3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#af697f7b5333f310a1677f7a210882e3e">symmetrize</a> ()</td></tr>
<tr class="separator:af697f7b5333f310a1677f7a210882e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c87b0a238bc20cd59ffeb11a466182"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a46c87b0a238bc20cd59ffeb11a466182"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a46c87b0a238bc20cd59ffeb11a466182">copy_from</a> (const <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; somenumber &gt; &amp;source)</td></tr>
<tr class="separator:a46c87b0a238bc20cd59ffeb11a466182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f26970e2bb19722be9b06f30b66d60f"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a4f26970e2bb19722be9b06f30b66d60f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a4f26970e2bb19722be9b06f30b66d60f">copy_from</a> (const ForwardIterator <a class="el" href="classChunkSparseMatrix.html#a286ab054d0cf5dbef6e64c59259e2ec3">begin</a>, const ForwardIterator <a class="el" href="classChunkSparseMatrix.html#a54be8e540bd30af316991c93a84493f4">end</a>)</td></tr>
<tr class="separator:a4f26970e2bb19722be9b06f30b66d60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd84b5af4d2a58875711fa414617efb"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a9fd84b5af4d2a58875711fa414617efb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a9fd84b5af4d2a58875711fa414617efb">copy_from</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; somenumber &gt; &amp;matrix)</td></tr>
<tr class="separator:a9fd84b5af4d2a58875711fa414617efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be3fb49f3eb6cdd3f1903bbc9dd769b"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a9be3fb49f3eb6cdd3f1903bbc9dd769b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a9be3fb49f3eb6cdd3f1903bbc9dd769b">add</a> (const number factor, const <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; somenumber &gt; &amp;matrix)</td></tr>
<tr class="separator:a9be3fb49f3eb6cdd3f1903bbc9dd769b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">条目访问</div></td></tr>
<tr class="memitem:aafde355fc7dbaaf328b1c43f003fcc5a"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#aafde355fc7dbaaf328b1c43f003fcc5a">operator()</a> (const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> i, const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> j) const</td></tr>
<tr class="separator:aafde355fc7dbaaf328b1c43f003fcc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab901489e331632e1104710a61a359f32"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#ab901489e331632e1104710a61a359f32">el</a> (const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> i, const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> j) const</td></tr>
<tr class="separator:ab901489e331632e1104710a61a359f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50e9178202c53c7403a6fb73d4960dc"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#ad50e9178202c53c7403a6fb73d4960dc">diag_element</a> (const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> i) const</td></tr>
<tr class="separator:ad50e9178202c53c7403a6fb73d4960dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451b9e62b83d2b08e128bdab8c0580c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a451b9e62b83d2b08e128bdab8c0580c2">extract_row_copy</a> (const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> row, const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> array_length, <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> &amp;row_length, <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> *column_indices, number *values) const</td></tr>
<tr class="separator:a451b9e62b83d2b08e128bdab8c0580c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">矩阵矢量乘法</div></td></tr>
<tr class="memitem:a8eaf70ff412d44250b45f89878db3213"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a8eaf70ff412d44250b45f89878db3213"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a8eaf70ff412d44250b45f89878db3213">vmult</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:a8eaf70ff412d44250b45f89878db3213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad069c45a5c9e4d7b675e1942897c84"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a1ad069c45a5c9e4d7b675e1942897c84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a1ad069c45a5c9e4d7b675e1942897c84">Tvmult</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:a1ad069c45a5c9e4d7b675e1942897c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef88c76f839c11dc52380961e6de873"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a5ef88c76f839c11dc52380961e6de873"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a5ef88c76f839c11dc52380961e6de873">vmult_add</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:a5ef88c76f839c11dc52380961e6de873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab048e4226ca71b562cec4615f5b281cc"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:ab048e4226ca71b562cec4615f5b281cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#ab048e4226ca71b562cec4615f5b281cc">Tvmult_add</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:ab048e4226ca71b562cec4615f5b281cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706ee4be9202cf93f6058bc90e91710a"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a706ee4be9202cf93f6058bc90e91710a"><td class="memTemplItemLeft" align="right" valign="top">somenumber&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a706ee4be9202cf93f6058bc90e91710a">matrix_norm_square</a> (const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v) const</td></tr>
<tr class="separator:a706ee4be9202cf93f6058bc90e91710a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037fe5b69373d24ab9b4216be372cc85"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a037fe5b69373d24ab9b4216be372cc85"><td class="memTemplItemLeft" align="right" valign="top">somenumber&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a037fe5b69373d24ab9b4216be372cc85">matrix_scalar_product</a> (const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;u, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v) const</td></tr>
<tr class="separator:a037fe5b69373d24ab9b4216be372cc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af072b09d14970f9d9f23eaadf1340ab9"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:af072b09d14970f9d9f23eaadf1340ab9"><td class="memTemplItemLeft" align="right" valign="top">somenumber&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#af072b09d14970f9d9f23eaadf1340ab9">residual</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;x, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b) const</td></tr>
<tr class="separator:af072b09d14970f9d9f23eaadf1340ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">矩阵规范</div></td></tr>
<tr class="memitem:a535c46f55dfa1b4bf671608739ebe909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#ad27b79afda83b7a8679a3adbcc613af6">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a535c46f55dfa1b4bf671608739ebe909">l1_norm</a> () const</td></tr>
<tr class="separator:a535c46f55dfa1b4bf671608739ebe909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6d854fd4b63124327e10695b56de61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#ad27b79afda83b7a8679a3adbcc613af6">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a0b6d854fd4b63124327e10695b56de61">linfty_norm</a> () const</td></tr>
<tr class="separator:a0b6d854fd4b63124327e10695b56de61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef82bc2e32be8901a4b8dac6242b72db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#ad27b79afda83b7a8679a3adbcc613af6">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#aef82bc2e32be8901a4b8dac6242b72db">frobenius_norm</a> () const</td></tr>
<tr class="separator:aef82bc2e32be8901a4b8dac6242b72db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">预处理方法</div></td></tr>
<tr class="memitem:a1370f081371599bb4ce33f3a90e5da0f"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a1370f081371599bb4ce33f3a90e5da0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a1370f081371599bb4ce33f3a90e5da0f">precondition_Jacobi</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number omega=1.) const</td></tr>
<tr class="separator:a1370f081371599bb4ce33f3a90e5da0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0fdf6ad96e82e58b6c54ecd9f38491"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a2e0fdf6ad96e82e58b6c54ecd9f38491"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a2e0fdf6ad96e82e58b6c54ecd9f38491">precondition_SSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number om=1.) const</td></tr>
<tr class="separator:a2e0fdf6ad96e82e58b6c54ecd9f38491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c673458fef8603c29f3e09959fe8ab"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a65c673458fef8603c29f3e09959fe8ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a65c673458fef8603c29f3e09959fe8ab">precondition_SOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number om=1.) const</td></tr>
<tr class="separator:a65c673458fef8603c29f3e09959fe8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e7a3e151cc4d44f3b0e643641a2e95"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a83e7a3e151cc4d44f3b0e643641a2e95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a83e7a3e151cc4d44f3b0e643641a2e95">precondition_TSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number om=1.) const</td></tr>
<tr class="separator:a83e7a3e151cc4d44f3b0e643641a2e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f766ef056d5d4a26be590b4c4dc82b2"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a7f766ef056d5d4a26be590b4c4dc82b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a7f766ef056d5d4a26be590b4c4dc82b2">SSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const number omega=1.) const</td></tr>
<tr class="separator:a7f766ef056d5d4a26be590b4c4dc82b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53944dc7b09001d11ed026255cb358f"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ad53944dc7b09001d11ed026255cb358f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#ad53944dc7b09001d11ed026255cb358f">SOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const number om=1.) const</td></tr>
<tr class="separator:ad53944dc7b09001d11ed026255cb358f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f939ccb2ac6f1ede6c15a64e8eebf56"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a8f939ccb2ac6f1ede6c15a64e8eebf56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a8f939ccb2ac6f1ede6c15a64e8eebf56">TSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const number om=1.) const</td></tr>
<tr class="separator:a8f939ccb2ac6f1ede6c15a64e8eebf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1430bdc53438500b2ffbbf503bbdcae"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:af1430bdc53438500b2ffbbf503bbdcae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#af1430bdc53438500b2ffbbf503bbdcae">PSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const std::vector&lt; <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> &gt; &amp;permutation, const std::vector&lt; <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> &gt; &amp;inverse_permutation, const number om=1.) const</td></tr>
<tr class="separator:af1430bdc53438500b2ffbbf503bbdcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf78d23112950d1909112681a15614c"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a4bf78d23112950d1909112681a15614c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a4bf78d23112950d1909112681a15614c">TPSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const std::vector&lt; <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> &gt; &amp;permutation, const std::vector&lt; <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> &gt; &amp;inverse_permutation, const number om=1.) const</td></tr>
<tr class="separator:a4bf78d23112950d1909112681a15614c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbed725005ae31c2043903c5528ba60a"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:afbed725005ae31c2043903c5528ba60a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#afbed725005ae31c2043903c5528ba60a">SOR_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const</td></tr>
<tr class="separator:afbed725005ae31c2043903c5528ba60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc459e0fd2c58f66bdc4c6bc4637b6ea"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:acc459e0fd2c58f66bdc4c6bc4637b6ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#acc459e0fd2c58f66bdc4c6bc4637b6ea">TSOR_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const</td></tr>
<tr class="separator:acc459e0fd2c58f66bdc4c6bc4637b6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad832da950d25e5161640d7cf183c40ae"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ad832da950d25e5161640d7cf183c40ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#ad832da950d25e5161640d7cf183c40ae">SSOR_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const</td></tr>
<tr class="separator:ad832da950d25e5161640d7cf183c40ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">迭代器</div></td></tr>
<tr class="memitem:a286ab054d0cf5dbef6e64c59259e2ec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#a19d981c89d9320893773a110319c6d19">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a286ab054d0cf5dbef6e64c59259e2ec3">begin</a> () const</td></tr>
<tr class="separator:a286ab054d0cf5dbef6e64c59259e2ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54be8e540bd30af316991c93a84493f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#a19d981c89d9320893773a110319c6d19">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a54be8e540bd30af316991c93a84493f4">end</a> () const</td></tr>
<tr class="separator:a54be8e540bd30af316991c93a84493f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4100cc5193b7348289b211f39d36d736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#a54a9b7b6c1696c99915d83c0dd1786d5">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a4100cc5193b7348289b211f39d36d736">begin</a> ()</td></tr>
<tr class="separator:a4100cc5193b7348289b211f39d36d736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c9785a57e579da5863ddc43379dff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#a54a9b7b6c1696c99915d83c0dd1786d5">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a79c9785a57e579da5863ddc43379dff6">end</a> ()</td></tr>
<tr class="separator:a79c9785a57e579da5863ddc43379dff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f24da71eeff7a6112ba1b2c5ddc843d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#a19d981c89d9320893773a110319c6d19">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a2f24da71eeff7a6112ba1b2c5ddc843d">begin</a> (const unsigned <a class="el" href="classint.html">int</a> r) const</td></tr>
<tr class="separator:a2f24da71eeff7a6112ba1b2c5ddc843d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecbfaac20f92179dff7896fdd512410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#a19d981c89d9320893773a110319c6d19">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#afecbfaac20f92179dff7896fdd512410">end</a> (const unsigned <a class="el" href="classint.html">int</a> r) const</td></tr>
<tr class="separator:afecbfaac20f92179dff7896fdd512410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad696f566e3390a5ca8a3103546913696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#a54a9b7b6c1696c99915d83c0dd1786d5">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#ad696f566e3390a5ca8a3103546913696">begin</a> (const unsigned <a class="el" href="classint.html">int</a> r)</td></tr>
<tr class="separator:ad696f566e3390a5ca8a3103546913696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b415b51b0577854c7e4a7e00a2c292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#a54a9b7b6c1696c99915d83c0dd1786d5">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a46b415b51b0577854c7e4a7e00a2c292">end</a> (const unsigned <a class="el" href="classint.html">int</a> r)</td></tr>
<tr class="separator:a46b415b51b0577854c7e4a7e00a2c292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">输入/输出</div></td></tr>
<tr class="memitem:a35c35410a223599aae824eac0a78437b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a35c35410a223599aae824eac0a78437b">print</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a35c35410a223599aae824eac0a78437b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f00777ef816a9e9f5255cab7ffa226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a01f00777ef816a9e9f5255cab7ffa226">print_formatted</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const unsigned <a class="el" href="classint.html">int</a> width=0, const char *zero_string=&quot; &quot;, const <a class="el" href="classdouble.html">double</a> denominator=1.) const</td></tr>
<tr class="separator:a01f00777ef816a9e9f5255cab7ffa226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f6cf6927c510eaa2102483f684581a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a48f6cf6927c510eaa2102483f684581a">print_pattern</a> (std::ostream &amp;out, const <a class="el" href="classdouble.html">double</a> threshold=0.) const</td></tr>
<tr class="separator:a48f6cf6927c510eaa2102483f684581a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6b95496132b34cfc0dcb85bf31c1bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a7f6b95496132b34cfc0dcb85bf31c1bd">block_write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a7f6b95496132b34cfc0dcb85bf31c1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae578901a05898d45a761da049b9e73b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#aae578901a05898d45a761da049b9e73b">block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:aae578901a05898d45a761da049b9e73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a102d827cd9a32ba893be5bf63aebbdd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a102d827cd9a32ba893be5bf63aebbdd9">compute_location</a> (const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> i, const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> j) const</td></tr>
<tr class="separator:a102d827cd9a32ba893be5bf63aebbdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:acb584187de65193250c82038a257c2f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a>, <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#acb584187de65193250c82038a257c2f8">cols</a></td></tr>
<tr class="separator:acb584187de65193250c82038a257c2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7cb95932e6b61792642f04f1db63b5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; number[]&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a7b7cb95932e6b61792642f04f1db63b5">val</a></td></tr>
<tr class="separator:a7b7cb95932e6b61792642f04f1db63b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc3b23a6da8262d298738110b9e1139"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#abfc3b23a6da8262d298738110b9e1139">max_len</a></td></tr>
<tr class="separator:abfc3b23a6da8262d298738110b9e1139"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a98fb5a614f41b97fa5c9b24d1214f670"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a98fb5a614f41b97fa5c9b24d1214f670"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a98fb5a614f41b97fa5c9b24d1214f670">ChunkSparseMatrix</a></td></tr>
<tr class="separator:a98fb5a614f41b97fa5c9b24d1214f670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cf5b08f0b774007e4ef33922c0bdcb"><td class="memTemplParams" colspan="2">template&lt;typename , bool &gt; </td></tr>
<tr class="memitem:a74cf5b08f0b774007e4ef33922c0bdcb"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#a74cf5b08f0b774007e4ef33922c0bdcb">ChunkSparseMatrixIterators::Iterator</a></td></tr>
<tr class="separator:a74cf5b08f0b774007e4ef33922c0bdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababcbf1d64722ec225d247ab8e68e066"><td class="memTemplParams" colspan="2">template&lt;typename , bool &gt; </td></tr>
<tr class="memitem:ababcbf1d64722ec225d247ab8e68e066"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classChunkSparseMatrix.html#ababcbf1d64722ec225d247ab8e68e066">ChunkSparseMatrixIterators::Accessor</a></td></tr>
<tr class="separator:ababcbf1d64722ec225d247ab8e68e066"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename number&gt;<br />
class ChunkSparseMatrix&lt; number &gt;</h3>

<p>稀疏矩阵。该类实现了在一个由SparsityPattern表示的稀疏矩阵的位置上存储数值的功能。稀疏模式和数值的分离是由于人们可以在这些位置上存储不同类型的数据元素而不需要SparsityPattern知道这一点，更重要的是人们可以将一个以上的矩阵与同一个稀疏模式联系起来。 这个类的使用在 <a class="el" href="step_51.html">step-51</a> 中得到了证明。</p>
<dl class="section note"><dt>Note</dt><dd>这个模板的实例化提供给<code> &lt;float&gt; 和 &lt;double&gt;</code>; 其他人可以在应用程序中生成（见手册中的 <a class="el" href="Instantiations.html">Template instantiations</a> 部分）。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="chunk__sparse__matrix_8h_source.html#l00419">419</a> of file <a class="el" href="chunk__sparse__matrix_8h_source.html">chunk_sparse_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acaa0c8eae0bf77fa8b9045865e30c920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa0c8eae0bf77fa8b9045865e30c920">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::<a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明容器大小的类型。 </p>

<p class="definition">Definition at line <a class="el" href="chunk__sparse__matrix_8h_source.html#l00426">426</a> of file <a class="el" href="chunk__sparse__matrix_8h_source.html">chunk_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ac0eb36be6940f36b1e8c58fe231e5301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0eb36be6940f36b1e8c58fe231e5301">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::<a class="el" href="classChunkSparseMatrix.html#ac0eb36be6940f36b1e8c58fe231e5301">value_type</a> =  number</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>矩阵条目的类型。这个别名类似于标准库中容器的<code>value_type</code>。 </p>

<p class="definition">Definition at line <a class="el" href="chunk__sparse__matrix_8h_source.html#l00432">432</a> of file <a class="el" href="chunk__sparse__matrix_8h_source.html">chunk_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ad27b79afda83b7a8679a3adbcc613af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27b79afda83b7a8679a3adbcc613af6">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::<a class="el" href="classChunkSparseMatrix.html#ad27b79afda83b7a8679a3adbcc613af6">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;number&gt;::<a class="el" href="classChunkSparseMatrix.html#ad27b79afda83b7a8679a3adbcc613af6">real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明一个类型，该类型持有与该类的模板参数相同精度的实值数。如果这个类的模板参数是一个实数数据类型，那么real_type就等于模板参数。 如果模板参数是一个 std::complex 类型，那么real_type等于复数的基础类型。 这个别名被用来表示规范的返回类型。 </p>

<p class="definition">Definition at line <a class="el" href="chunk__sparse__matrix_8h_source.html#l00441">441</a> of file <a class="el" href="chunk__sparse__matrix_8h_source.html">chunk_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a19d981c89d9320893773a110319c6d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d981c89d9320893773a110319c6d19">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::<a class="el" href="classChunkSparseMatrix.html#a19d981c89d9320893773a110319c6d19">const_iterator</a> =  <a class="el" href="classChunkSparseMatrixIterators_1_1Iterator.html">ChunkSparseMatrixIterators::Iterator</a>&lt;number, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个迭代器类的类型定义，在这个矩阵的所有非零条目上行走。这个迭代器不能改变矩阵的值。 </p>

<p class="definition">Definition at line <a class="el" href="chunk__sparse__matrix_8h_source.html#l00447">447</a> of file <a class="el" href="chunk__sparse__matrix_8h_source.html">chunk_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a54a9b7b6c1696c99915d83c0dd1786d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a9b7b6c1696c99915d83c0dd1786d5">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::<a class="el" href="classChunkSparseMatrix.html#a54a9b7b6c1696c99915d83c0dd1786d5">iterator</a> =  <a class="el" href="classChunkSparseMatrixIterators_1_1Iterator.html">ChunkSparseMatrixIterators::Iterator</a>&lt;number, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>遍历该矩阵所有非零项的迭代器类的类型定义。这个迭代器 <em>可以改变矩阵的值，但当然不能改变稀疏模式，因为一旦稀疏矩阵被附加到它上面，这就固定了。</em> </p>

<p class="definition">Definition at line <a class="el" href="chunk__sparse__matrix_8h_source.html#l00455">455</a> of file <a class="el" href="chunk__sparse__matrix_8h_source.html">chunk_sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaa57c76a8291aee0adb129b3666c12d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa57c76a8291aee0adb129b3666c12d3">&#9670;&nbsp;</a></span>ChunkSparseMatrix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::<a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数；将矩阵初始化为空，没有任何结构，也就是说，矩阵根本无法使用。因此，这个构造函数只对作为类的成员的矩阵有用。所有其他的矩阵都应该在数据流中的一个点上创建，在那里所有必要的信息都是可用的。 你必须在使用前用reinit(const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a>&amp;)初始化矩阵。 </p>

</div>
</div>
<a id="ad32df0b72f53ad4db74701f22be8307d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32df0b72f53ad4db74701f22be8307d">&#9670;&nbsp;</a></span>ChunkSparseMatrix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::<a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制构造函数。只有当要复制的矩阵为空时，才允许调用这个构造函数。这与ChunkSparsityPattern的原因相同，详见那里。 如果你真的想复制一个完整的矩阵，你可以使用copy_from()函数来实现。 </p>

</div>
</div>
<a id="a102e0d70bc668c79b36a4a960983c164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102e0d70bc668c79b36a4a960983c164">&#9670;&nbsp;</a></span>ChunkSparseMatrix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::<a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构造函数。使用给定的矩阵稀疏度结构来表示该矩阵的稀疏度模式。你可以在以后通过调用reinit(const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a>&amp;)函数来改变稀疏性模式。 你必须确保稀疏度结构的寿命至少和这个矩阵的寿命一样长，或者只要reinit(const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a>&amp;)没有被调用新的稀疏度模式。 构造函数被明确标记，以便不允许有人将稀疏模式代替稀疏矩阵传递给某个函数，这样就会生成一个空矩阵。 </p>

</div>
</div>
<a id="a8e93d54649971acf31eeb6ee715de259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e93d54649971acf31eeb6ee715de259">&#9670;&nbsp;</a></span>ChunkSparseMatrix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::<a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>拷贝构造函数：用身份矩阵初始化矩阵。如果稀疏模式和身份矩阵的大小不一致，或者如果稀疏模式没有在整个对角线上提供非零条目，这个构造函数将抛出一个异常。 </p>

</div>
</div>
<a id="a784db3144358fc607af7612469406699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784db3144358fc607af7612469406699">&#9670;&nbsp;</a></span>~ChunkSparseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::~<a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解构器。释放所有内存，但不释放稀疏结构的内存。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a212f23c500156be81b186fcc867bb43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212f23c500156be81b186fcc867bb43c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt;number&gt;&amp; <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制操作符。由于复制整个稀疏矩阵是一个非常昂贵的操作，我们不允许这样做，除了大小为0的空矩阵这一特殊情况。这看起来不是特别有用，但如果想有一个 <code>std::vector&lt;<a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt;double&gt; &gt;</code> ，这正是人们所需要的：在这种情况下，人们可以创建一个空矩阵的向量（需要复制对象的能力），然后用有用的东西来填充。 </p>

</div>
</div>
<a id="a0925ec9c7f06f37df4581dbcbb04e917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0925ec9c7f06f37df4581dbcbb04e917">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt;number&gt;&amp; <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制操作符：用身份矩阵来初始化矩阵。如果稀疏模式和身份矩阵的大小不一致，或者如果稀疏模式没有在整个对角线上提供非零条目，这个操作符将抛出一个异常。 </p>

</div>
</div>
<a id="af740cc20f7df852be517f73a1f11c60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af740cc20f7df852be517f73a1f11c60e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&amp; <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个操作符将一个标量分配给一个矩阵。因为这通常没有什么意义（我们应该把所有的矩阵条目都设置为这个值吗？ 仅仅是稀疏模式的非零条目？），这个操作只允许在实际要分配的值为零时进行。这个操作符的存在只是为了允许明显的符号<code>matrix=0</code>，它将矩阵的所有元素设置为零，但保留之前使用的稀疏模式。 </p>

</div>
</div>
<a id="a44551560de47e8e7becd549bfce76447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44551560de47e8e7becd549bfce76447">&#9670;&nbsp;</a></span>reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用给定的稀疏模式重新初始化稀疏矩阵。后者告诉矩阵需要保留多少个非零元素。 关于内存分配，和上面说的一样。 你必须确保稀疏结构的寿命至少与该矩阵的寿命一样长，或者只要reinit(const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a> &amp;)没有被调用，就不会有新的稀疏结构。 矩阵的元素被这个函数设置为零。 </p>

</div>
</div>
<a id="aa3dc610cca5ebb55cd39402abdd29489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3dc610cca5ebb55cd39402abdd29489">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>释放所有内存并返回到与调用默认构造函数后一样的状态。它也会忘记它之前绑定的稀疏模式。 </p>

</div>
</div>
<a id="a36be14410bf17daa8dd8d836aeeebc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36be14410bf17daa8dd8d836aeeebc52">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该对象是否为空。如果两个维度都是零或者没有关联ChunkSparsityPattern，那么它就是空的。 </p>

</div>
</div>
<a id="a8a0224abfda5ad78be88a59132e9f581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0224abfda5ad78be88a59132e9f581">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回共域（或范围）空间的维度。注意，矩阵的维度是 \(m \times n\) 。 </p>

</div>
</div>
<a id="af37be64dec5b2d13a1e70ea2f8d06e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37be64dec5b2d13a1e70ea2f8d06e62">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回域空间的维度。注意，矩阵的维度是 \(m \times n\) . </p>

</div>
</div>
<a id="a9db4c03728a021f0b20dc3945e52e0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db4c03728a021f0b20dc3945e52e0b7">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个矩阵的非零元素的数量。实际上，它返回的是稀疏模式中的条目数；如果任何一个条目碰巧是零，无论如何都会被计算在内。 </p>

</div>
</div>
<a id="a8ca045aab5ce8ef486a7323755d8f5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca045aab5ce8ef486a7323755d8f5bc">&#9670;&nbsp;</a></span>n_actually_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::n_actually_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个矩阵中实际非零元素的数量。 注意，这个函数（与n_nonzero_elements()相反）不计算稀疏模式的所有条目，只计算非零的条目。 </p>

</div>
</div>
<a id="a22b9d10a53255165eb22a36d5be0bc99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b9d10a53255165eb22a36d5be0bc99">&#9670;&nbsp;</a></span>get_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a>&amp; <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::get_sparsity_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个对该矩阵底层稀疏性模式的（常数）引用。 虽然返回值被声明为<code>const</code>，但你应该注意，如果你调用任何对其进行操作的对象的非常量函数，它可能会改变。 </p>

</div>
</div>
<a id="ade39cbfa1db0d00d455a7497790918cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade39cbfa1db0d00d455a7497790918cd">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>确定此对象的内存消耗（以字节为单位）的估计值。参见MemoryConsumption。 </p>

</div>
</div>
<a id="a2c56d5270b6912d2dd9ec96b1ed83d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c56d5270b6912d2dd9ec96b1ed83d6b">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置元素（<em>i,j</em>）为<code>value</code>。如果条目不存在或者<code>value</code>不是一个有限的数字，则抛出一个错误。尽管如此，它仍然允许在不存在的字段中存储零值。 </p>

</div>
</div>
<a id="a29bfb50598b15c0090cecdfeb259ad24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29bfb50598b15c0090cecdfeb259ad24">&#9670;&nbsp;</a></span>add() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>向元素添加<code>value</code>（<em>i,j</em>）。 如果该条目不存在或者<code>value</code>不是一个有限的数字，则抛出一个错误。尽管如此，它仍然允许在不存在的字段中存储零值。 </p>

</div>
</div>
<a id="ae1fd80495c44053f8edbb9e5fe8b5fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fd80495c44053f8edbb9e5fe8b5fb7">&#9670;&nbsp;</a></span>add() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number2 *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在给定的全局矩阵行中，在稀疏矩阵中由col_indices指定的列中添加一个由<code>values</code>给出的数值数组。 可选的参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些数据，只添加非零值。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="a080e6e1634e85ef703e77fba4a11f14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080e6e1634e85ef703e77fba4a11f14e">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&amp; <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将整个矩阵乘以一个固定系数。 </p>

</div>
</div>
<a id="a058e57167ecd1cb2196bf37773520323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058e57167ecd1cb2196bf37773520323">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&amp; <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用整个矩阵除以一个固定系数。 </p>

</div>
</div>
<a id="af697f7b5333f310a1677f7a210882e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af697f7b5333f310a1677f7a210882e3e">&#9670;&nbsp;</a></span>symmetrize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::symmetrize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过形成现有矩阵和其转置之间的平均值来对称矩阵， \(A = \frac 12(A+A^T)\) 。 这个操作假设底层的稀疏模式代表一个对称的对象。如果不是这样，那么这个操作的结果将不是一个对称矩阵，因为出于效率的考虑，它只通过在左下角的三角形部分进行循环来明确地进行对称；如果右上角的三角形有条目，那么这些元素在对称过程中会被遗漏。稀疏模式的对称化可以通过 <a class="el" href="classChunkSparsityPattern.html#a1c30e3ae9bd087342b58b777ccd77bb7">ChunkSparsityPattern::symmetrize()</a>. 得到。 </p>

</div>
</div>
<a id="a46c87b0a238bc20cd59ffeb11a466182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c87b0a238bc20cd59ffeb11a466182">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt;number&gt;&amp; <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将作为参数给出的矩阵复制到当前对象中。 复制矩阵是一个昂贵的操作，我们不希望通过编译器生成的代码意外发生 <code>operator=</code> 。（例如，如果不小心声明了当前类型的函数参数<em>by value</em>而不是<em>by reference</em>，就会发生这种情况）。复制矩阵的功能是在这个成员函数中实现的。因此，该类型对象的所有复制操作都需要一个明确的函数调用。 源矩阵可以是一个任意类型的矩阵，只要其数据类型可以转换为该矩阵的数据类型。 该函数返回一个对<code>*this</code>的引用。 </p>

</div>
</div>
<a id="a4f26970e2bb19722be9b06f30b66d60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f26970e2bb19722be9b06f30b66d60f">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数完全类似于 <a class="el" href="classChunkSparsityPattern.html#ae9c912a28714c3d40a12c1a1cf9fff63">ChunkSparsityPattern::copy_from()</a> 函数，它允许在一个步骤中初始化整个矩阵。关于参数类型及其含义的更多信息请见那里。你还可以在那里找到一个关于如何使用这个函数的小例子。 与引用的函数唯一不同的是，内部迭代器指向的对象需要是 <code>std::pair&lt;unsigned int, value</code>类型，其中<code>value</code>需要可转换为该类的元素类型，由<code>number</code>模板参数指定。 矩阵以前的内容被覆盖。注意，由输入参数指定的条目不一定要覆盖矩阵的所有元素。未覆盖的元素保持不动。 </p>

</div>
</div>
<a id="a9fd84b5af4d2a58875711fa414617efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd84b5af4d2a58875711fa414617efb">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将一个完整矩阵的非零条目复制到此对象中。之前的内容被删除。请注意，底层的稀疏模式必须适合容纳全矩阵的非零条目。 </p>

</div>
</div>
<a id="a9be3fb49f3eb6cdd3f1903bbc9dd769b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be3fb49f3eb6cdd3f1903bbc9dd769b">&#9670;&nbsp;</a></span>add() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将<code>matrix</code>按<code>factor</code>的比例添加到这个矩阵中，也就是说，矩阵<code>factor*matrix</code>被添加到<code>this</code>。如果所涉及的两个矩阵的稀疏性模式不指向同一个对象，这个函数会抛出一个错误，因为在这种情况下，操作会比较便宜。 源矩阵可以是一个任意底层标量类型的稀疏矩阵，只要其数据类型可以转换为这个矩阵的数据类型。 </p>

</div>
</div>
<a id="aafde355fc7dbaaf328b1c43f003fcc5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafde355fc7dbaaf328b1c43f003fcc5a">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回条目的值（<em>i,j</em>）。 这可能是一个昂贵的操作，你应该始终注意在哪里调用这个函数。为了避免滥用，如果所需元素在矩阵中不存在，该函数会抛出一个异常。 如果你想要一个返回零的函数（对于不在矩阵的稀疏模式中的条目），请使用el()函数。 如果你要在所有元素上循环，可以考虑使用一个迭代器类来代替，因为它们更适合稀疏的矩阵结构。 </p>

</div>
</div>
<a id="ab901489e331632e1104710a61a359f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab901489e331632e1104710a61a359f32">&#9670;&nbsp;</a></span>el()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数主要像operator()()，它返回矩阵条目的值（<em>i,j</em>）。唯一的区别是，如果这个条目不存在于稀疏模式中，那么就不会引发异常，而是返回0。虽然这在某些情况下可能很方便，但请注意，由于没有使用矩阵的稀疏性，所以写出的算法与最优解相比很简单，很慢。 如果你要在所有元素上循环，可以考虑使用一个迭代器类来代替，因为它们更适合稀疏的矩阵结构。 </p>

</div>
</div>
<a id="ad50e9178202c53c7403a6fb73d4960dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50e9178202c53c7403a6fb73d4960dc">&#9670;&nbsp;</a></span>diag_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回第<em>i</em>行中的主对角线元素。如果矩阵不是二次方的，这个函数会抛出一个错误。 这个函数比operator()()快得多，因为对于二次矩阵来说，对角线条目可能是每行中第一个被存储的，因此访问时不需要搜索正确的列号。 </p>

</div>
</div>
<a id="a451b9e62b83d2b08e128bdab8c0580c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451b9e62b83d2b08e128bdab8c0580c2">&#9670;&nbsp;</a></span>extract_row_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::extract_row_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td>
          <td class="paramname"><em>array_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>row_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> *&#160;</td>
          <td class="paramname"><em>column_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">number *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提取给定矩阵行中数值和索引的副本。 用户应该传递数组column_indices和values的长度，这就提供了一个检查我们是否写到未分配的内存的方法。这个方法是由Trilinos行矩阵中的一个类似方法激发的，与迭代器相比，这个方法可以更快地访问矩阵中的条目，而迭代器对这种矩阵类型来说是相当慢的。 </p>

</div>
</div>
<a id="a8eaf70ff412d44250b45f89878db3213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eaf70ff412d44250b45f89878db3213">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>矩阵向量乘法：让<em>dst = M*src</em>与<em>M</em>是这个矩阵。 注意，虽然这个函数可以对所有提供迭代器类的向量进行操作，但它只对类型为 <a class="el" href="classVector.html">Vector</a> 的对象真正有效。 对于所有迭代元素或随机成员访问昂贵的类来说，这个函数并不高效。特别是，如果你想与BlockVector对象相乘，你应该考虑同时使用BlockChunkSparseMatrix。 来源和目的地不能是同一个向量。 </p>

</div>
</div>
<a id="a1ad069c45a5c9e4d7b675e1942897c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad069c45a5c9e4d7b675e1942897c84">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让<em>dst = M<sup>T</sup>*src</em>与<em>M</em>为这个矩阵。这个函数与vmult()的作用相同，但需要转置的矩阵。 注意，虽然这个函数可以对所有提供迭代器类的向量进行操作，但它只对类型为 <a class="el" href="classVector.html">Vector</a> 的对象真正有效。 对于所有迭代元素或随机成员访问昂贵的类来说，这个函数并不高效。特别是，如果你想与BlockVector对象相乘，你应该考虑同时使用BlockChunkSparseMatrix。 来源和目的地不能是同一个向量。 </p>

</div>
</div>
<a id="a5ef88c76f839c11dc52380961e6de873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef88c76f839c11dc52380961e6de873">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::vmult_add </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>添加矩阵-向量的乘法。在<em>dst</em>上添加<em>M*src</em>，<em>M</em>是这个矩阵。 注意，虽然这个函数可以对所有提供迭代器类的向量进行操作，但它只对 <a class="el" href="classVector.html">Vector</a> 类型的对象真正有效。 对于所有迭代元素或随机成员访问昂贵的类来说，这个函数并不高效。特别是，如果你想与BlockVector对象相乘，你应该考虑同时使用BlockChunkSparseMatrix。 来源和目的地不能是同一个向量。 </p>

</div>
</div>
<a id="ab048e4226ca71b562cec4615f5b281cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab048e4226ca71b562cec4615f5b281cc">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>添加矩阵-向量的乘法。将<em>M<sup>T</sup>*src</em>加到<em>dst</em>，<em>M</em>是这个矩阵。这个函数与vmult_add()的操作相同，但取的是转置的矩阵。 注意，虽然这个函数可以对所有提供迭代器类的向量进行操作，但它只对类型为 <a class="el" href="classVector.html">Vector</a> 的对象真正有效。 对于所有迭代元素或随机成员访问昂贵的类来说，这个函数并不高效。特别是，如果你想与BlockVector对象相乘，你应该考虑同时使用BlockChunkSparseMatrix。 来源和目的地不能是同一个向量。 </p>

</div>
</div>
<a id="a706ee4be9202cf93f6058bc90e91710a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706ee4be9202cf93f6058bc90e91710a">&#9670;&nbsp;</a></span>matrix_norm_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">somenumber <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量 \(v\) 相对于该矩阵诱导的法线的平方，即 \(\left(v,Mv\right)\) 。这很有用，例如在有限元背景下，一个函数的 \(L_2\) 规范等于相对于代表有限元函数节点值的向量的质量矩阵的矩阵规范。 显然，对于这个操作来说，矩阵需要是二次的，而且为了使结果真正成为一个规范，它还需要是实数对称的或复数隐式的。 该矩阵和给定向量的基础模板类型应该都是实值或复值，但不是混合的，这样这个函数才有意义。 </p>

</div>
</div>
<a id="a037fe5b69373d24ab9b4216be372cc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037fe5b69373d24ab9b4216be372cc85">&#9670;&nbsp;</a></span>matrix_scalar_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">somenumber <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算矩阵标量乘积 \(\left(u,Mv\right)\) 。 </p>

</div>
</div>
<a id="af072b09d14970f9d9f23eaadf1340ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af072b09d14970f9d9f23eaadf1340ab9">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">somenumber <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算方程<em>Mx=b</em>的残差，其中残差被定义为<em>r=b-Mx</em>。将残差写入<code>dst</code>。残差向量的<em>l<sub>2</sub></em>准则被返回。 源<em>x</em>和目的<em>dst</em>不能是同一个向量。 </p>

</div>
</div>
<a id="a535c46f55dfa1b4bf671608739ebe909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535c46f55dfa1b4bf671608739ebe909">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#ad27b79afda83b7a8679a3adbcc613af6">real_type</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的l1准则，即 \(|M|_1=max_{all columns j}\sum_{all rows i} |M_ij|\) ，（最大列数之和）。 这是自然的矩阵规范，与向量的l1规范兼容，即 \(|Mv|_1\leq |M|_1 |v|_1\) 。 (参见Haemmerlin-Hoffmann : Numerische Mathematik) </p>

</div>
</div>
<a id="a0b6d854fd4b63124327e10695b56de61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6d854fd4b63124327e10695b56de61">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#ad27b79afda83b7a8679a3adbcc613af6">real_type</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的linfty-norm，即 \(|M|_infty=max_{all rows i}\sum_{all columns j} |M_ij|\) , (行的最大和)。 这是一个自然的矩阵规范，与向量的linfty-norm兼容，即 \(|Mv|_infty \leq |M|_infty |v|_infty\) 。 (参见Haemmerlin-Hoffmann : Numerische Mathematik) </p>

</div>
</div>
<a id="aef82bc2e32be8901a4b8dac6242b72db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef82bc2e32be8901a4b8dac6242b72db">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#ad27b79afda83b7a8679a3adbcc613af6">real_type</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的frobenius norm，即矩阵中所有条目的平方之和的平方根。 </p>

</div>
</div>
<a id="a1370f081371599bb4ce33f3a90e5da0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1370f081371599bb4ce33f3a90e5da0f">&#9670;&nbsp;</a></span>precondition_Jacobi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::precondition_Jacobi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>应用雅可比预处理方法，将<code>src</code>向量的每个元素乘以各自对角线元素的逆值，并将结果与松弛因子<code>omega</code>相乘。 </p>

</div>
</div>
<a id="a2e0fdf6ad96e82e58b6c54ecd9f38491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0fdf6ad96e82e58b6c54ecd9f38491">&#9670;&nbsp;</a></span>precondition_SSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::precondition_SSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对<code>src</code>应用SSOR预处理。 </p>

</div>
</div>
<a id="a65c673458fef8603c29f3e09959fe8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c673458fef8603c29f3e09959fe8ab">&#9670;&nbsp;</a></span>precondition_SOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::precondition_SOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将SOR预处理矩阵应用于<code>src</code>。 </p>

</div>
</div>
<a id="a83e7a3e151cc4d44f3b0e643641a2e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e7a3e151cc4d44f3b0e643641a2e95">&#9670;&nbsp;</a></span>precondition_TSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::precondition_TSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对<code>src</code>应用转置的SOR预处理矩阵。 </p>

</div>
</div>
<a id="a7f766ef056d5d4a26be590b4c4dc82b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f766ef056d5d4a26be590b4c4dc82b2">&#9670;&nbsp;</a></span>SSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::SSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>就地执行SSOR预处理。 应用预处理矩阵而不复制到第二个向量。 <code>omega</code>是放松参数。 </p>

</div>
</div>
<a id="ad53944dc7b09001d11ed026255cb358f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53944dc7b09001d11ed026255cb358f">&#9670;&nbsp;</a></span>SOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::SOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>就地执行SOR预处理。 <code>omega</code>是松弛参数。 </p>

</div>
</div>
<a id="a8f939ccb2ac6f1ede6c15a64e8eebf56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f939ccb2ac6f1ede6c15a64e8eebf56">&#9670;&nbsp;</a></span>TSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::TSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>就地进行转置SOR预处理。 <code>omega</code>是松弛参数。 </p>

</div>
</div>
<a id="af1430bdc53438500b2ffbbf503bbdcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1430bdc53438500b2ffbbf503bbdcae">&#9670;&nbsp;</a></span>PSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::PSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>就地进行移置的SOR预处理。 标准的SOR方法按照<code>permutation</code>规定的顺序应用，即先是行<code>permutation[0]</code>，然后是<code>permutation[1]</code>等等。出于效率的考虑，需要排列组合以及它的逆向排列。 <code>omega</code>是放松参数。 </p>

</div>
</div>
<a id="a4bf78d23112950d1909112681a15614c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf78d23112950d1909112681a15614c">&#9670;&nbsp;</a></span>TPSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::TPSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>就地进行转置的包络SOR预处理。 转置的SOR方法按照<code>permutation</code>规定的顺序应用，即首先是行<code>permutation[<a class="el" href="classChunkSparseMatrix.html#a8a0224abfda5ad78be88a59132e9f581">m()</a>-1]</code>，然后是<code>permutation[<a class="el" href="classChunkSparseMatrix.html#a8a0224abfda5ad78be88a59132e9f581">m()</a>-2]</code>等等。出于效率的考虑，需要用到permutation以及它的逆向。 <code>omega</code>是放松参数。 </p>

</div>
</div>
<a id="afbed725005ae31c2043903c5528ba60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbed725005ae31c2043903c5528ba60a">&#9670;&nbsp;</a></span>SOR_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::SOR_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对<code>v</code>做一个SOR步骤。 对右边的<code>b</code>进行直接的SOR步骤。 </p>

</div>
</div>
<a id="acc459e0fd2c58f66bdc4c6bc4637b6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc459e0fd2c58f66bdc4c6bc4637b6ea">&#9670;&nbsp;</a></span>TSOR_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::TSOR_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对<code>v</code>做一个邻接的SOR步骤。 对<code>b</code>的右手边做一个直接的TSOR步骤。 </p>

</div>
</div>
<a id="ad832da950d25e5161640d7cf183c40ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad832da950d25e5161640d7cf183c40ae">&#9670;&nbsp;</a></span>SSOR_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::SSOR_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对<code>v</code>做一个SSOR步骤。 通过在SOR之后执行TSOR，对右手边的<code>b</code>直接执行SSOR步骤。 </p>

</div>
</div>
<a id="a286ab054d0cf5dbef6e64c59259e2ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286ab054d0cf5dbef6e64c59259e2ec3">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#a19d981c89d9320893773a110319c6d19">const_iterator</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>迭代器从矩阵的第一个条目开始。这是对常数矩阵的版本。 请注意，由于ChunkSparseMatrix中的布局，对矩阵条目的迭代要比稀疏矩阵的迭代慢得多，因为迭代器是逐行旅行的，而数据是以若干行和列的块状形式存储的。 </p>

</div>
</div>
<a id="a54be8e540bd30af316991c93a84493f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54be8e540bd30af316991c93a84493f4">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#a19d981c89d9320893773a110319c6d19">const_iterator</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>最后的迭代器。这是用于常数矩阵的版本。 请注意，由于ChunkSparseMatrix的布局，对矩阵条目的迭代要比稀疏矩阵慢得多，因为迭代器是逐行进行的，而数据是以若干行和列的块来存储的。 </p>

</div>
</div>
<a id="a4100cc5193b7348289b211f39d36d736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4100cc5193b7348289b211f39d36d736">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#a54a9b7b6c1696c99915d83c0dd1786d5">iterator</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>迭代器从矩阵的第一个条目开始。这是对非常数矩阵的版本。 请注意，由于ChunkSparseMatrix的布局，对矩阵条目的迭代比稀疏矩阵的迭代要慢得多，因为迭代器是逐行进行的，而数据是以几行几列的块状存储的。 </p>

</div>
</div>
<a id="a79c9785a57e579da5863ddc43379dff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c9785a57e579da5863ddc43379dff6">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#a54a9b7b6c1696c99915d83c0dd1786d5">iterator</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>最终迭代器。这是用于非恒定矩阵的版本。 请注意，由于ChunkSparseMatrix的布局，对矩阵条目的迭代要比稀疏矩阵的迭代慢得多，因为迭代器是逐行进行的，而数据是以若干行和列的块来存储的。 </p>

</div>
</div>
<a id="a2f24da71eeff7a6112ba1b2c5ddc843d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f24da71eeff7a6112ba1b2c5ddc843d">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#a19d981c89d9320893773a110319c6d19">const_iterator</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>迭代器从<code>r</code>行的第一个条目开始。这是对常数矩阵的版本。 注意，如果给定的行是空的，即不包含任何非零条目，那么这个函数返回的迭代器就等于<code>end(r)</code>。还要注意的是，在这种情况下，迭代器可能无法被解除引用。 请注意，由于ChunkSparseMatrix的布局，对矩阵条目的迭代要比稀疏矩阵慢得多，因为迭代器是逐行进行的，而数据是以几行几列的块状存储的。 </p>

</div>
</div>
<a id="afecbfaac20f92179dff7896fdd512410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afecbfaac20f92179dff7896fdd512410">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#a19d981c89d9320893773a110319c6d19">const_iterator</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>行<code>r</code>的最终迭代器。它指向过了 <code>r</code>, 行末尾的第一个元素或过了整个稀疏模式的末尾。这是对常数矩阵的版本。 请注意，结束迭代器不一定是可取消引用的。特别是如果它是一个矩阵最后一行的结束迭代器，情况更是如此。 请注意，由于ChunkSparseMatrix的布局，对矩阵条目的迭代要比稀疏矩阵的迭代慢得多，因为迭代器是逐行进行的，而数据是以若干行和列的块来存储的。 </p>

</div>
</div>
<a id="ad696f566e3390a5ca8a3103546913696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad696f566e3390a5ca8a3103546913696">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#a54a9b7b6c1696c99915d83c0dd1786d5">iterator</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>迭代器从<code>r</code>行的第一个条目开始。这是用于非恒定矩阵的版本。 注意，如果给定的行是空的，即不包含任何非零条目，那么这个函数返回的迭代器就等于<code>end(r)</code>。还要注意的是，在这种情况下，迭代器可能无法被解除引用。 请注意，由于ChunkSparseMatrix的布局，对矩阵条目的迭代要比稀疏矩阵慢得多，因为迭代器是逐行进行的，而数据是以几行几列的块状存储的。 </p>

</div>
</div>
<a id="a46b415b51b0577854c7e4a7e00a2c292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b415b51b0577854c7e4a7e00a2c292">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#a54a9b7b6c1696c99915d83c0dd1786d5">iterator</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>行<code>r</code>的最终迭代器。它指向超过行 <code>r</code>, 末尾的第一个元素，或者超过整个稀疏模式的末尾。这是对非恒定矩阵的版本。 请注意，结束迭代器不一定是可取消引用的。特别是如果它是一个矩阵最后一行的结束迭代器，情况更是如此。 请注意，由于ChunkSparseMatrix的布局，对矩阵条目的迭代要比稀疏矩阵的迭代慢得多，因为迭代器是逐行进行的，而数据是以若干行和列的块来存储的。 </p>

</div>
</div>
<a id="a35c35410a223599aae824eac0a78437b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c35410a223599aae824eac0a78437b">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印矩阵到给定的流，使用格式&lt;tt&gt;(line,col) value，即每行一个非零的矩阵条目。 </p>

</div>
</div>
<a id="a01f00777ef816a9e9f5255cab7ffa226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f00777ef816a9e9f5255cab7ffa226">&#9670;&nbsp;</a></span>print_formatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::print_formatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>zero_string</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>denominator</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>以通常的格式打印矩阵，即作为矩阵而不是作为非零元素的列表。为了提高可读性，不在矩阵中的元素显示为空白，而明确设置为零的矩阵元素则显示为空白。 参数允许对输出格式进行灵活设置。 <code>precision</code>和<code>scientific</code>用于确定数字格式，其中<code>scientific = false</code>表示固定点符号。 <code>width</code>的一个零条目使函数计算出一个宽度，但如果输出粗略的话，可以将其改为一个正值。 此外，还可以指定一个空值的字符。 最后，整个矩阵可以与一个共同的分母相乘，以产生更可读的输出，甚至是整数。 </p><dl class="section attention"><dt>Attention</dt><dd>如果应用于一个大的矩阵，这个函数可能会产生<b>large</b>量的输出! </dd></dl>

</div>
</div>
<a id="a48f6cf6927c510eaa2102483f684581a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f6cf6927c510eaa2102483f684581a">&#9670;&nbsp;</a></span>print_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::print_pattern </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印矩阵的实际模式。对于每个绝对值大于阈值的条目，打印一个'*'，对于每个较小的数值打印一个':'，对于每个未分配的条目打印一个'.'。 </p>

</div>
</div>
<a id="a7f6b95496132b34cfc0dcb85bf31c1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6b95496132b34cfc0dcb85bf31c1bd">&#9670;&nbsp;</a></span>block_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::block_write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将此对象的数据全部写到文件中。这是以二进制模式进行的，所以输出的数据既不能被人类阅读，也不能（可能）被其他使用不同操作系统或数字格式的计算机阅读。 这个函数的目的是，如果你的内存不足，想在不同的程序之间进行交流，或者允许对象在程序的不同运行中持续存在，你可以把矩阵和稀疏模式换出来。 </p>

</div>
</div>
<a id="aae578901a05898d45a761da049b9e73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae578901a05898d45a761da049b9e73b">&#9670;&nbsp;</a></span>block_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::block_read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从文件中读取先前由block_write()写入的数据。 这是用上述函数的逆运算来完成的，所以它的速度相当快，因为除了前面的几个数字，比特流是不被解释的。 在这个操作中，对象被调整了大小，所有以前的内容都会丢失。然而，请注意，没有检查新数据和底层的ChunkSparsityPattern对象是否适合在一起。你有责任确保稀疏度模式和要读取的数据是匹配的。 一个原始形式的错误检查会被执行，它将识别最直白的尝试，即把一些数据解释为一个矩阵，以比特方式存储到一个实际上不是以这种方式创建的文件，但不会更多。 </p>

</div>
</div>
<a id="a102d827cd9a32ba893be5bf63aebbdd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102d827cd9a32ba893be5bf63aebbdd9">&#9670;&nbsp;</a></span>compute_location()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::compute_location </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回Val数组中条目 \((i,j)\) 的位置。 </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a98fb5a614f41b97fa5c9b24d1214f670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98fb5a614f41b97fa5c9b24d1214f670">&#9670;&nbsp;</a></span>ChunkSparseMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="chunk__sparse__matrix_8h_source.html#l01233">1233</a> of file <a class="el" href="chunk__sparse__matrix_8h_source.html">chunk_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a74cf5b08f0b774007e4ef33922c0bdcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74cf5b08f0b774007e4ef33922c0bdcb">&#9670;&nbsp;</a></span>ChunkSparseMatrixIterators::Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename , bool &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classChunkSparseMatrixIterators_1_1Iterator.html">ChunkSparseMatrixIterators::Iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="chunk__sparse__matrix_8h_source.html#l01237">1237</a> of file <a class="el" href="chunk__sparse__matrix_8h_source.html">chunk_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ababcbf1d64722ec225d247ab8e68e066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababcbf1d64722ec225d247ab8e68e066">&#9670;&nbsp;</a></span>ChunkSparseMatrixIterators::Accessor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename , bool &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classChunkSparseMatrixIterators_1_1Accessor.html">ChunkSparseMatrixIterators::Accessor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="chunk__sparse__matrix_8h_source.html#l01239">1239</a> of file <a class="el" href="chunk__sparse__matrix_8h_source.html">chunk_sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acb584187de65193250c82038a257c2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb584187de65193250c82038a257c2f8">&#9670;&nbsp;</a></span>cols</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classChunkSparsityPattern.html">ChunkSparsityPattern</a>, <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt;number&gt; &gt; <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::cols</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向用于该矩阵的稀疏模式的指针。为了保证它在使用中不被删除，我们使用SmartPointer类来订阅它。 </p>

<p class="definition">Definition at line <a class="el" href="chunk__sparse__matrix_8h_source.html#l01210">1210</a> of file <a class="el" href="chunk__sparse__matrix_8h_source.html">chunk_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a7b7cb95932e6b61792642f04f1db63b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7cb95932e6b61792642f04f1db63b5">&#9670;&nbsp;</a></span>val</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;number[]&gt; <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::val</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>所有非零条目的数值数组。一个条目在矩阵中的位置，也就是这个数组中给定值的行号和列号，只能用稀疏模式来推导。同样的道理也适用于更常见的通过坐标寻找一个条目的操作。 </p>

<p class="definition">Definition at line <a class="el" href="chunk__sparse__matrix_8h_source.html#l01216">1216</a> of file <a class="el" href="chunk__sparse__matrix_8h_source.html">chunk_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="abfc3b23a6da8262d298738110b9e1139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc3b23a6da8262d298738110b9e1139">&#9670;&nbsp;</a></span>max_len</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classChunkSparseMatrix.html#acaa0c8eae0bf77fa8b9045865e30c920">size_type</a> <a class="el" href="classChunkSparseMatrix.html">ChunkSparseMatrix</a>&lt; number &gt;::max_len</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>拨出的::val的大小。如果在过去的某个时候，通过使用reinit()函数，将具有较小尺寸的稀疏模式与该对象相关联，从而减少了矩阵的尺寸，则该尺寸可能大于实际使用的部分。 </p>

<p class="definition">Definition at line <a class="el" href="chunk__sparse__matrix_8h_source.html#l01222">1222</a> of file <a class="el" href="chunk__sparse__matrix_8h_source.html">chunk_sparse_matrix.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="chunk__sparse__matrix_8h_source.html">chunk_sparse_matrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
