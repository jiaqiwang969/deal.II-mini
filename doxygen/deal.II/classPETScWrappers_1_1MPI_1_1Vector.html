<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classPETScWrappers_1_1MPI_1_1Vector.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: PETScWrappers::MPI::Vector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacePETScWrappers.html">PETScWrappers</a></li><li class="navelem"><a class="el" href="namespacePETScWrappers_1_1MPI.html">MPI</a></li><li class="navelem"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classPETScWrappers_1_1MPI_1_1Vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PETScWrappers::MPI::Vector Class Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__PETScWrappers.html">PETScWrappers</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo;  &#124; <a class="el" href="group__Vectors.html">Vector classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="petsc__vector_8h_source.html">deal.II/lac/petsc_vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PETScWrappers::MPI::Vector:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classPETScWrappers_1_1MPI_1_1Vector__inherit__graph.svg" width="214" height="202"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a01bcb631a52f0218a009456f214ce2fe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:a01bcb631a52f0218a009456f214ce2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d5cfc5012497c28255604950825729"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a49d5cfc5012497c28255604950825729">value_type</a> = PetscScalar</td></tr>
<tr class="separator:a49d5cfc5012497c28255604950825729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e5b2150479de88863461b40d87a667"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a> = PetscReal</td></tr>
<tr class="separator:ac0e5b2150479de88863461b40d87a667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5f8fab8b2b2af5ad61b5bfb7915617"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4a5f8fab8b2b2af5ad61b5bfb7915617">reference</a> = internal::VectorReference</td></tr>
<tr class="separator:a4a5f8fab8b2b2af5ad61b5bfb7915617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab282addb9f8950cf5293fc051c607603"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ab282addb9f8950cf5293fc051c607603">const_reference</a> = const internal::VectorReference</td></tr>
<tr class="separator:ab282addb9f8950cf5293fc051c607603"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5424155269bd22011e9ff796e0c77e69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a5424155269bd22011e9ff796e0c77e69">Vector</a> ()</td></tr>
<tr class="separator:a5424155269bd22011e9ff796e0c77e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509703c693bb9122817d36b7dc266a4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a509703c693bb9122817d36b7dc266a4a">Vector</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a8bb29704b2ee7f8e0f888201bcd71c62">communicator</a>, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> n, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> <a class="el" href="classPETScWrappers_1_1VectorBase.html#acff4e7a74af91a2ab885cf10d0feb961">locally_owned_size</a>)</td></tr>
<tr class="separator:a509703c693bb9122817d36b7dc266a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c55c5d951bb863e3421489123ed615"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a16c55c5d951bb863e3421489123ed615"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a16c55c5d951bb863e3421489123ed615">Vector</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a8bb29704b2ee7f8e0f888201bcd71c62">communicator</a>, const ::<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;v, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> <a class="el" href="classPETScWrappers_1_1VectorBase.html#acff4e7a74af91a2ab885cf10d0feb961">locally_owned_size</a>)</td></tr>
<tr class="separator:a16c55c5d951bb863e3421489123ed615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468d6de9a0f34d61ffbfe0b4ba5b7dc9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a468d6de9a0f34d61ffbfe0b4ba5b7dc9">Vector</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a8bb29704b2ee7f8e0f888201bcd71c62">communicator</a>, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> <a class="el" href="classPETScWrappers_1_1VectorBase.html#a2dfc89d53e2a916f1f392255b061cd4e">local_size</a>)</td></tr>
<tr class="separator:a468d6de9a0f34d61ffbfe0b4ba5b7dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2acb2fb0af41a7f3a0f0216b71a34d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#afb2acb2fb0af41a7f3a0f0216b71a34d">Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;ghost, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a8bb29704b2ee7f8e0f888201bcd71c62">communicator</a>)</td></tr>
<tr class="separator:afb2acb2fb0af41a7f3a0f0216b71a34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722e6d3ef4cce01c80e78d8959fc6789"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a722e6d3ef4cce01c80e78d8959fc6789">Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a8bb29704b2ee7f8e0f888201bcd71c62">communicator</a>)</td></tr>
<tr class="separator:a722e6d3ef4cce01c80e78d8959fc6789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e4685e7a2a5dd43d67c3541ba67574"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a34e4685e7a2a5dd43d67c3541ba67574">Vector</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v)</td></tr>
<tr class="separator:a34e4685e7a2a5dd43d67c3541ba67574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99916352f41d79dd048ccd00132a34b2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a99916352f41d79dd048ccd00132a34b2">clear</a> () override</td></tr>
<tr class="separator:a99916352f41d79dd048ccd00132a34b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe7192a480321cb76a2271dd1886123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#adbe7192a480321cb76a2271dd1886123">operator=</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v)</td></tr>
<tr class="separator:adbe7192a480321cb76a2271dd1886123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a2f17234eccc7e627186bcd2d29e85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a25a2f17234eccc7e627186bcd2d29e85">operator=</a> (const PetscScalar s)</td></tr>
<tr class="separator:a25a2f17234eccc7e627186bcd2d29e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324a18fcb0a4c286727ef57d820b63fc"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a324a18fcb0a4c286727ef57d820b63fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a324a18fcb0a4c286727ef57d820b63fc">operator=</a> (const ::<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; number &gt; &amp;v)</td></tr>
<tr class="separator:a324a18fcb0a4c286727ef57d820b63fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf7e8a746ba5823796094a508d8c0b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a9cf7e8a746ba5823796094a508d8c0b5">reinit</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a8bb29704b2ee7f8e0f888201bcd71c62">communicator</a>, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> N, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> <a class="el" href="classPETScWrappers_1_1VectorBase.html#acff4e7a74af91a2ab885cf10d0feb961">locally_owned_size</a>, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:a9cf7e8a746ba5823796094a508d8c0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c2d48a865eb577a317895a5d5b7b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a38c2d48a865eb577a317895a5d5b7b3f">reinit</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:a38c2d48a865eb577a317895a5d5b7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9124190f6bd3c47f78cbbc7b4083467e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a9124190f6bd3c47f78cbbc7b4083467e">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;ghost, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a8bb29704b2ee7f8e0f888201bcd71c62">communicator</a>)</td></tr>
<tr class="separator:a9124190f6bd3c47f78cbbc7b4083467e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664db0ae6a04decb80e1dc92fb933fed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a664db0ae6a04decb80e1dc92fb933fed">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a8bb29704b2ee7f8e0f888201bcd71c62">communicator</a>)</td></tr>
<tr class="separator:a664db0ae6a04decb80e1dc92fb933fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be39fc0c5574e3c314d8a356b267bef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a2be39fc0c5574e3c314d8a356b267bef">get_mpi_communicator</a> () const override</td></tr>
<tr class="separator:a2be39fc0c5574e3c314d8a356b267bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d43302d459c7cb6ae4b5bad13d31507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a4d43302d459c7cb6ae4b5bad13d31507">print</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const</td></tr>
<tr class="separator:a4d43302d459c7cb6ae4b5bad13d31507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72a04de37cc5ba8f0263809a59ec99e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#ae72a04de37cc5ba8f0263809a59ec99e">all_zero</a> () const</td></tr>
<tr class="separator:ae72a04de37cc5ba8f0263809a59ec99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6166fa37985a73755a2982af055f1a0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a6166fa37985a73755a2982af055f1a0a">compress</a> (const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:a6166fa37985a73755a2982af055f1a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ccdc09627c773d69a73d99de626cd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a36ccdc09627c773d69a73d99de626cd7">operator==</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:a36ccdc09627c773d69a73d99de626cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eea41fb4992579fe065a8ab4dfa5dc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a3eea41fb4992579fe065a8ab4dfa5dc5">operator!=</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:a3eea41fb4992579fe065a8ab4dfa5dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3875621a4c149265ca738d48614f053c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a3875621a4c149265ca738d48614f053c">size</a> () const</td></tr>
<tr class="separator:a3875621a4c149265ca738d48614f053c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfc89d53e2a916f1f392255b061cd4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a2dfc89d53e2a916f1f392255b061cd4e">local_size</a> () const</td></tr>
<tr class="separator:a2dfc89d53e2a916f1f392255b061cd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff4e7a74af91a2ab885cf10d0feb961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#acff4e7a74af91a2ab885cf10d0feb961">locally_owned_size</a> () const</td></tr>
<tr class="separator:acff4e7a74af91a2ab885cf10d0feb961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f8ac50f0d9950973f2a9ba11fdb31d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a>, <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a59f8ac50f0d9950973f2a9ba11fdb31d">local_range</a> () const</td></tr>
<tr class="separator:a59f8ac50f0d9950973f2a9ba11fdb31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4300ee4284b89549ad2069b69c1aa939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4300ee4284b89549ad2069b69c1aa939">in_local_range</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> index) const</td></tr>
<tr class="separator:a4300ee4284b89549ad2069b69c1aa939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409d3a360896b211e459b9a44ec9b77a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a409d3a360896b211e459b9a44ec9b77a">locally_owned_elements</a> () const</td></tr>
<tr class="separator:a409d3a360896b211e459b9a44ec9b77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac825d05c684a560c996101ad0efef2c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac825d05c684a560c996101ad0efef2c6">has_ghost_elements</a> () const</td></tr>
<tr class="separator:ac825d05c684a560c996101ad0efef2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5916e10c3e54f5080512c3a4c48e0424"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a5916e10c3e54f5080512c3a4c48e0424">update_ghost_values</a> () const</td></tr>
<tr class="separator:a5916e10c3e54f5080512c3a4c48e0424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bddb6f47b5f17a9e681508518a3315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4a5f8fab8b2b2af5ad61b5bfb7915617">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a97bddb6f47b5f17a9e681508518a3315">operator()</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> index)</td></tr>
<tr class="separator:a97bddb6f47b5f17a9e681508518a3315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af780eb49cad222c3db90ef05afd66fde"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#af780eb49cad222c3db90ef05afd66fde">operator()</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> index) const</td></tr>
<tr class="separator:af780eb49cad222c3db90ef05afd66fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1142b659aefd963815ba5db0c92320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4a5f8fab8b2b2af5ad61b5bfb7915617">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#aca1142b659aefd963815ba5db0c92320">operator[]</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> index)</td></tr>
<tr class="separator:aca1142b659aefd963815ba5db0c92320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0c87b6f0920ca7a451c0977f1cd80b"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4e0c87b6f0920ca7a451c0977f1cd80b">operator[]</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> index) const</td></tr>
<tr class="separator:a4e0c87b6f0920ca7a451c0977f1cd80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ada30ff781b62d03117c435cd499d72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a7ada30ff781b62d03117c435cd499d72">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> &gt; &amp;indices, const std::vector&lt; PetscScalar &gt; &amp;values)</td></tr>
<tr class="separator:a7ada30ff781b62d03117c435cd499d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590b9a811e7fb1fd96fc4b749380b1f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a590b9a811e7fb1fd96fc4b749380b1f8">extract_subvector_to</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> &gt; &amp;indices, std::vector&lt; PetscScalar &gt; &amp;values) const</td></tr>
<tr class="separator:a590b9a811e7fb1fd96fc4b749380b1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e43a21a399d5a5e2d85758ec387695"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:af9e43a21a399d5a5e2d85758ec387695"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#af9e43a21a399d5a5e2d85758ec387695">extract_subvector_to</a> (const ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:af9e43a21a399d5a5e2d85758ec387695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a4e50d8cf8b59a13b33a39d240b5ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ab6a4e50d8cf8b59a13b33a39d240b5ca">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> &gt; &amp;indices, const std::vector&lt; PetscScalar &gt; &amp;values)</td></tr>
<tr class="separator:ab6a4e50d8cf8b59a13b33a39d240b5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe79d85af013e56c003b3dfdddcfb41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a9fe79d85af013e56c003b3dfdddcfb41">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> &gt; &amp;indices, const ::<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; PetscScalar &gt; &amp;values)</td></tr>
<tr class="separator:a9fe79d85af013e56c003b3dfdddcfb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09de2357613ea712c747855030124aa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a09de2357613ea712c747855030124aa4">add</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> n_elements, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> *indices, const PetscScalar *values)</td></tr>
<tr class="separator:a09de2357613ea712c747855030124aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39aacc8d16d324843f85134bb0c1675f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a39aacc8d16d324843f85134bb0c1675f">add</a> (const PetscScalar s)</td></tr>
<tr class="separator:a39aacc8d16d324843f85134bb0c1675f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2822cc5fab76c09476de60e8d7816c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ab2822cc5fab76c09476de60e8d7816c9">add</a> (const PetscScalar a, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V)</td></tr>
<tr class="separator:ab2822cc5fab76c09476de60e8d7816c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab508c4a8bbd65a945e7a0e5fcf3012c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ab508c4a8bbd65a945e7a0e5fcf3012c0">add</a> (const PetscScalar a, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V, const PetscScalar b, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;W)</td></tr>
<tr class="separator:ab508c4a8bbd65a945e7a0e5fcf3012c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c234d28aff8aa3ab9fdd358e4c9182"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a30c234d28aff8aa3ab9fdd358e4c9182">operator*</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;vec) const</td></tr>
<tr class="separator:a30c234d28aff8aa3ab9fdd358e4c9182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c43e5142dfa22873b0f18d7dc91a4d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a5c43e5142dfa22873b0f18d7dc91a4d1">norm_sqr</a> () const</td></tr>
<tr class="separator:a5c43e5142dfa22873b0f18d7dc91a4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232af54220bbbc75b6d1fcee45bac178"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a232af54220bbbc75b6d1fcee45bac178">mean_value</a> () const</td></tr>
<tr class="separator:a232af54220bbbc75b6d1fcee45bac178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125b9d63e15ae9e3e5fcd90d3cd0fca1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a125b9d63e15ae9e3e5fcd90d3cd0fca1">l1_norm</a> () const</td></tr>
<tr class="separator:a125b9d63e15ae9e3e5fcd90d3cd0fca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6ed136b024aeaedf9e529c29cc208d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#add6ed136b024aeaedf9e529c29cc208d">l2_norm</a> () const</td></tr>
<tr class="separator:add6ed136b024aeaedf9e529c29cc208d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9d8151b66561ccb1b5c43f509d39cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a0f9d8151b66561ccb1b5c43f509d39cf">lp_norm</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a> p) const</td></tr>
<tr class="separator:a0f9d8151b66561ccb1b5c43f509d39cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9762fc464702fa826eaff4df3779d482"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a9762fc464702fa826eaff4df3779d482">linfty_norm</a> () const</td></tr>
<tr class="separator:a9762fc464702fa826eaff4df3779d482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8412866d0e82feca003db88e061e5fe1"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a8412866d0e82feca003db88e061e5fe1">add_and_dot</a> (const PetscScalar a, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;W)</td></tr>
<tr class="separator:a8412866d0e82feca003db88e061e5fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8235403dad66e00479cca97c2f4b582c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a8235403dad66e00479cca97c2f4b582c">min</a> () const</td></tr>
<tr class="separator:a8235403dad66e00479cca97c2f4b582c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9e8e45afd7b28ffc5723e246f81016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a8c9e8e45afd7b28ffc5723e246f81016">max</a> () const</td></tr>
<tr class="separator:a8c9e8e45afd7b28ffc5723e246f81016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d76f674c4699ece5dc1107d3403aaac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4d76f674c4699ece5dc1107d3403aaac">is_non_negative</a> () const</td></tr>
<tr class="separator:a4d76f674c4699ece5dc1107d3403aaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37900779c6049418c39bacc1d44f4260"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a37900779c6049418c39bacc1d44f4260">operator*=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:a37900779c6049418c39bacc1d44f4260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4beb21a67a1231346876c5d49ebc0c4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4beb21a67a1231346876c5d49ebc0c4d">operator/=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:a4beb21a67a1231346876c5d49ebc0c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2108fd9efd4f35d17accfa3c8d52e71c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a2108fd9efd4f35d17accfa3c8d52e71c">operator+=</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V)</td></tr>
<tr class="separator:a2108fd9efd4f35d17accfa3c8d52e71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad576803857b394e28549db2cff5128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a3ad576803857b394e28549db2cff5128">operator-=</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V)</td></tr>
<tr class="separator:a3ad576803857b394e28549db2cff5128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a614d48c2a904e8337025706c644433"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a5a614d48c2a904e8337025706c644433">sadd</a> (const PetscScalar s, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V)</td></tr>
<tr class="separator:a5a614d48c2a904e8337025706c644433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7a9c7bf865040f5b76ec2d7a8ac3ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a0d7a9c7bf865040f5b76ec2d7a8ac3ff">sadd</a> (const PetscScalar s, const PetscScalar a, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V)</td></tr>
<tr class="separator:a0d7a9c7bf865040f5b76ec2d7a8ac3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57deb429a909bfa17e885ca20660f521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a57deb429a909bfa17e885ca20660f521">scale</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;scaling_factors)</td></tr>
<tr class="separator:a57deb429a909bfa17e885ca20660f521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80e009e532257f82980c49b70072018"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ad80e009e532257f82980c49b70072018">equ</a> (const PetscScalar a, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V)</td></tr>
<tr class="separator:ad80e009e532257f82980c49b70072018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf51494f6194764f1a0a32e97d59fb1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#abf51494f6194764f1a0a32e97d59fb1b">write_ascii</a> (const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="separator:abf51494f6194764f1a0a32e97d59fb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab185a8ff0370c08fab553ba1e75194c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ab185a8ff0370c08fab553ba1e75194c3">swap</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v)</td></tr>
<tr class="separator:ab185a8ff0370c08fab553ba1e75194c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5e08d408ee79da10cceb7642bfa1da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ade5e08d408ee79da10cceb7642bfa1da">operator const Vec &amp;</a> () const</td></tr>
<tr class="separator:ade5e08d408ee79da10cceb7642bfa1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cd6e2cf47c7d44cbcbb9bdd44613fd"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a49cd6e2cf47c7d44cbcbb9bdd44613fd">memory_consumption</a> () const</td></tr>
<tr class="separator:a49cd6e2cf47c7d44cbcbb9bdd44613fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2ea4c0209a2905f35db0092f533c431d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a2ea4c0209a2905f35db0092f533c431d">create_vector</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> n, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> <a class="el" href="classPETScWrappers_1_1VectorBase.html#acff4e7a74af91a2ab885cf10d0feb961">locally_owned_size</a>)</td></tr>
<tr class="separator:a2ea4c0209a2905f35db0092f533c431d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a877be575fc723ffc5470a24f4d9a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a79a877be575fc723ffc5470a24f4d9a3">create_vector</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> n, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> <a class="el" href="classPETScWrappers_1_1VectorBase.html#acff4e7a74af91a2ab885cf10d0feb961">locally_owned_size</a>, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;ghostnodes)</td></tr>
<tr class="separator:a79a877be575fc723ffc5470a24f4d9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada190205c9e3a51bba688969b5846eeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ada190205c9e3a51bba688969b5846eeb">do_set_add_operation</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> n_elements, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a> *indices, const PetscScalar *values, const <a class="el" href="classbool.html">bool</a> add_values)</td></tr>
<tr class="separator:ada190205c9e3a51bba688969b5846eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3a337ca41046f9e87ae2b4459e1e8a38"><td class="memItemLeft" align="right" valign="top">Vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a3a337ca41046f9e87ae2b4459e1e8a38">vector</a></td></tr>
<tr class="separator:a3a337ca41046f9e87ae2b4459e1e8a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afd34f59a5c4f754fa32a6f69e110b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a2afd34f59a5c4f754fa32a6f69e110b3">ghosted</a></td></tr>
<tr class="separator:a2afd34f59a5c4f754fa32a6f69e110b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0fa32597e5faa4ceb51bc7eb5c06ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a2c0fa32597e5faa4ceb51bc7eb5c06ad">ghost_indices</a></td></tr>
<tr class="separator:a2c0fa32597e5faa4ceb51bc7eb5c06ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7c95d791d77dcc89aecf77bd91251e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a2e7c95d791d77dcc89aecf77bd91251e">last_action</a></td></tr>
<tr class="separator:a2e7c95d791d77dcc89aecf77bd91251e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554f19155de441313cd0931c4faa5d6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a554f19155de441313cd0931c4faa5d6b">obtained_ownership</a></td></tr>
<tr class="separator:a554f19155de441313cd0931c4faa5d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a8bb29704b2ee7f8e0f888201bcd71c62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a8bb29704b2ee7f8e0f888201bcd71c62">communicator</a></td></tr>
<tr class="separator:a8bb29704b2ee7f8e0f888201bcd71c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:af853f838d421f8a008f6a57f3231bdc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#af853f838d421f8a008f6a57f3231bdc3">swap</a> (<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;u, <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v)</td></tr>
<tr class="separator:af853f838d421f8a008f6a57f3231bdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dd3dea1d8fea889513f82bbe5d7f35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#af0dd3dea1d8fea889513f82bbe5d7f35">swap</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;u, <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v)</td></tr>
<tr class="separator:af0dd3dea1d8fea889513f82bbe5d7f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>实现一个基于PETSC的并行向量类，并使用MPI通信来同步分布式操作。所有的功能实际上都在基类中，除了生成并行向量的调用。这是可能的，因为PETSc只在一个抽象的向量类型上工作，并在内部分配给根据实际向量类型进行实际工作的函数（很像使用虚拟函数）。只有创建特定类型向量的函数不同，并在这个特定的类中实现。 </p><h3>Parallel communication model</h3>
<p>PETSc的并行功能是建立在消息传递接口（MPI）之上的。MPI的通信模型建立在集体通信的基础上：如果一个进程想从另一个进程那里得到什么，另一个进程必须愿意接受这种通信。一个进程不能通过调用一个远程函数从另一个进程查询数据，而另一个进程不期望有这种交易。其结果是，这个类的基类中的大多数操作都必须被集体调用。例如，如果你想计算一个平行向量的l2准则， <em>所有共享这个向量的进程都必须调用</em> <code>l2_norm</code> 函数。如果你不这样做，而只是在一个进程上调用 <code>l2_norm</code> 函数，那么会发生以下情况。这一个进程将调用一个集体MPI函数，并等待所有其他进程加入到这个过程中。由于其他进程不调用这个函数，你将在第一个进程上得到一个超时，或者更糟糕的是，当下一个对PETSc函数的调用在其他进程上产生MPI消息时，你将得到一个神秘的消息，即只有一个子集的进程试图进行通信。这些错误是很难搞清楚的，除非你很熟悉MPI的通信模型，并且知道哪些函数可能产生MPI消息。 下面将讨论一个特殊的情况，即可能会意外地产生MPI消息的情况。 </p><h3>Accessing individual elements of a vector</h3>
<p>PETSc确实允许对向量的单个元素进行读取访问，但在分布式情况下，只允许读取本地存储的元素。我们通过<code>d=vec(i)</code>这样的调用来实现。然而，如果你访问本地存储范围之外的元素，就会产生一个异常。 与读访问相反，PETSc（和相应的deal.II包装类）允许对向量的单个元素进行写入（或添加），即使它们存储在不同的进程中。你可以这样写，例如，&lt;tt&gt;vec(i)=d或<code>vec(i)+=d</code>，或类似的操作。但是有一个问题，可能会导致非常混乱的错误信息。PETSc要求应用程序在从对元素的添加转换到对元素的写入时调用compress()函数。其理由是，所有进程都可能积累对元素的加法操作，即使是多个进程对相同的元素进行写入。当我们下一次调用compress()时，所有这些加法操作都已执行完毕。然而，如果一个进程对一个元素进行添加，而另一个进程对其进行覆盖，如果我们不确保在两者之间发生与compress()的同步，执行的顺序将产生非确定性的行为。 为了确保这些对compress()的调用在适当的时间发生，deal.II包装器保留了一个状态变量，用于存储当前允许的操作：添加或写入。如果它遇到了相反的操作，它就会调用compress()并翻转状态。这有时会导致非常混乱的行为，例如，代码可能看起来像这样。 </p><div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> <a class="code" href="classPETScWrappers_1_1VectorBase.html#a3a337ca41046f9e87ae2b4459e1e8a38">vector</a>;</div><div class="line">...</div><div class="line"><span class="comment">// do some write operations on the vector</span></div><div class="line">for (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;vector.<a class="code" href="classPETScWrappers_1_1VectorBase.html#a3875621a4c149265ca738d48614f053c">size</a>(); ++i)</div><div class="line">  <a class="code" href="classPETScWrappers_1_1VectorBase.html#a3a337ca41046f9e87ae2b4459e1e8a38">vector</a>(i) = i;</div><div class="line"></div><div class="line"><span class="comment">// do some additions to vector elements, but only for some elements</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;vector.<a class="code" href="classPETScWrappers_1_1VectorBase.html#a3875621a4c149265ca738d48614f053c">size</a>(); ++i)</div><div class="line">  <span class="keywordflow">if</span> (some_condition(i) == <span class="keyword">true</span>)</div><div class="line">    <a class="code" href="classPETScWrappers_1_1VectorBase.html#a3a337ca41046f9e87ae2b4459e1e8a38">vector</a>(i) += 1;</div><div class="line"></div><div class="line"><span class="comment">// do another collective operation</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a> = vector.<a class="code" href="classPETScWrappers_1_1VectorBase.html#add6ed136b024aeaedf9e529c29cc208d">l2_norm</a>();</div></div><!-- fragment --><p> 这段代码可能会遇到麻烦：当我们看到第一个加法运算时，我们需要冲刷向量的覆盖缓冲区，而deal.II库会通过调用compress()来实现。然而，它只对所有实际进行加法运算的进程进行这样的操作。</p>
<p>如果其中一个进程的条件永远不为真，那么这个进程就不会得到实际的compress()调用，而所有其他的进程都会。 这就给我们带来了麻烦，因为所有其他的进程都会在刷新写缓冲区的调用中挂起，而另一个进程则会推进到计算l2准则的调用。这时，你会得到一个错误，即某些操作只被一个子集的进程尝试了。这种行为似乎令人惊讶，除非你知道对单个元素的写/添加操作可能会触发这种行为。 这里描述的问题可以通过对compress()放置额外的调用来避免，或者确保所有进程在同一时间做相同类型的操作，例如，如果有必要，可以放置零加法。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">有鬼魂元素的向量</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__vector_8h_source.html#l00087">87</a> of file <a class="el" href="petsc__vector_8h_source.html">petsc_vector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a01bcb631a52f0218a009456f214ce2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01bcb631a52f0218a009456f214ce2fe">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">PETScWrappers::MPI::Vector::size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明容器尺寸的类型。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector_8h_source.html#l00094">94</a> of file <a class="el" href="petsc__vector_8h_source.html">petsc_vector.h</a>.</p>

</div>
</div>
<a id="a49d5cfc5012497c28255604950825729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d5cfc5012497c28255604950825729">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1VectorBase.html#a49d5cfc5012497c28255604950825729">PETScWrappers::VectorBase::value_type</a> =  PetscScalar</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>声明一些在所有容器中使用的标准类型。这些类型与<code>C++</code>标准库<code><a class="el" href="classPETScWrappers_1_1VectorBase.html#a3a337ca41046f9e87ae2b4459e1e8a38">vector&lt;...&gt;</a></code>类中的类型平行。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00250">250</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="ac0e5b2150479de88863461b40d87a667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e5b2150479de88863461b40d87a667">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">PETScWrappers::VectorBase::real_type</a> =  PetscReal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00251">251</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="a4a5f8fab8b2b2af5ad61b5bfb7915617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5f8fab8b2b2af5ad61b5bfb7915617">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1VectorBase.html#a4a5f8fab8b2b2af5ad61b5bfb7915617">PETScWrappers::VectorBase::reference</a> =  internal::VectorReference</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00253">253</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="ab282addb9f8950cf5293fc051c607603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab282addb9f8950cf5293fc051c607603">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1VectorBase.html#ab282addb9f8950cf5293fc051c607603">PETScWrappers::VectorBase::const_reference</a> =  const internal::VectorReference</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00254">254</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5424155269bd22011e9ff796e0c77e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5424155269bd22011e9ff796e0c77e69">&#9670;&nbsp;</a></span>Vector() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>默认构造函数。将向量初始化为空。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00031">31</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<a id="a509703c693bb9122817d36b7dc266a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509703c693bb9122817d36b7dc266a4a">&#9670;&nbsp;</a></span>Vector() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a>&#160;</td>
          <td class="paramname"><em>locally_owned_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构造函数。设置维度为 <code>n</code> 并将所有元素初始化为零。 </p><ul>
<li>locally_owned_size表示应存储在本进程中的块的大小。 </li>
<li>communicator表示MPI通信器，向量的不同部分应通过该通信器进行通信。 构造器是明确的，以避免类似的意外。 <code>v=0;</code>。据推测，用户想把向量的每个元素都设置为0，但结果却是这样的调用。 <code>v=向量 &lt;number&gt;(0);</code>, 即向量被一个长度为零的向量取代。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00042">42</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<a id="a16c55c5d951bb863e3421489123ed615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c55c5d951bb863e3421489123ed615">&#9670;&nbsp;</a></span>Vector() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MPI::Vector::Vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a>&#160;</td>
          <td class="paramname"><em>locally_owned_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从deal.II向量中复制构造。设置维度为给定向量的维度，并复制所有元素。 </p><ul>
<li>local_owned_size表示应存储在当前进程中的块的大小。 </li>
<li>communicator表示MPI通信器，向量的不同部分将通过该通信器通信。 </li>
</ul>

</div>
</div>
<a id="a468d6de9a0f34d61ffbfe0b4ba5b7dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468d6de9a0f34d61ffbfe0b4ba5b7dc9">&#9670;&nbsp;</a></span>Vector() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a>&#160;</td>
          <td class="paramname"><em>local_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy-constructor表示来自PETSc包装向量类的值。 </p><ul>
<li>local_size表示应存储在当前进程中的块的大小。 </li>
<li>communicator表示MPI通信器，矢量的不同部分应通过该通信器进行通信 <dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000049">Deprecated:</a></b></dt><dd>明确使用VectorBase类型的对象已被弃用：使用 <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> 代替。</dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00052">52</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<a id="afb2acb2fb0af41a7f3a0f0216b71a34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2acb2fb0af41a7f3a0f0216b71a34d">&#9670;&nbsp;</a></span>Vector() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从IndexSets中构造一个新的并行重影PETSc向量。 注意 <code>local</code> 必须是升序和1:1，见 <a class="el" href="classIndexSet.html#ae6f94fa42b0a17b33f4ae1cb42a0d98f">IndexSet::is_ascending_and_one_to_one()</a>. 特别是 <code>local</code> 中的DoF需要是连续的，这意味着你只能从有几个有限元分量的DoFHandler中创建向量，如果它们没有按分量重新排序（否则使用 PETScWrappers::BlockVector ）。 矢量的全局大小由local.size()决定。 <code>ghost</code> 中的全局索引是作为鬼魂索引提供的，这样就可以在本地读取它们。 请注意， <code>ghost</code> 的IndexSet可能是空的，并且在构造过程中，任何已经包含在 <code>local</code> 中的指数都会被忽略。这样，鬼魂参数可以等于本地相关自由度的集合，见 <a class="el" href="step_32.html">step-32</a> 。 </p><dl class="section note"><dt>Note</dt><dd>这个操作总是创建一个重影向量，它被认为是只读的。 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">有鬼魂元素的向量</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00072">72</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<a id="a722e6d3ef4cce01c80e78d8959fc6789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722e6d3ef4cce01c80e78d8959fc6789">&#9670;&nbsp;</a></span>Vector() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从IndexSet中构造一个新的没有重影元素的并行PETSc向量。 注意 <code>local</code> 必须是升序和1:1，见 <a class="el" href="classIndexSet.html#ae6f94fa42b0a17b33f4ae1cb42a0d98f">IndexSet::is_ascending_and_one_to_one()</a>. 特别是， <code>local</code> 中的DoF需要是连续的，这意味着你只能从一个有几个有限元分量的DoFHandler中创建向量，如果它们没有按分量重新排序的话（否则使用 PETScWrappers::BlockVector ）。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00104">104</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<a id="a34e4685e7a2a5dd43d67c3541ba67574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e4685e7a2a5dd43d67c3541ba67574">&#9670;&nbsp;</a></span>Vector() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制构造函数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00088">88</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a99916352f41d79dd048ccd00132a34b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99916352f41d79dd048ccd00132a34b2">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>释放所有内存并返回到与调用默认构造函数后相同的状态。 </p>

<p>Reimplemented from <a class="el" href="classPETScWrappers_1_1VectorBase.html#a0a42a4b961706fc6f19e34b3d6126f93">PETScWrappers::VectorBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00152">152</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<a id="adbe7192a480321cb76a2271dd1886123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe7192a480321cb76a2271dd1886123">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp; <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>拷贝给定的向量。如果有必要的话，调整当前向量的大小。同时接管 <code>v</code>. 的MPI通信器。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00115">115</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<a id="a25a2f17234eccc7e627186bcd2d29e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a2f17234eccc7e627186bcd2d29e85">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&amp; PETScWrappers::MPI::Vector::operator= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将向量的所有分量设置为给定的数字 <code>s</code>. 简单地将这个传给基类，但我们仍然需要声明这个函数，使讨论中给出的关于使构造函数显式的例子生效。 </p>

</div>
</div>
<a id="a324a18fcb0a4c286727ef57d820b63fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324a18fcb0a4c286727ef57d820b63fc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&amp; PETScWrappers::MPI::Vector::operator= </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将一个deal.II向量的值（相对于PETSc向量包装类的值）复制到这个对象中。 与顺序向量的情况相反，这个操作者要求现在的向量已经有正确的大小，因为我们需要有一个分区和一个通讯器存在，否则我们无法从源向量中得到。 </p>

</div>
</div>
<a id="a9cf7e8a746ba5823796094a508d8c0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf7e8a746ba5823796094a508d8c0b5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a>&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a>&#160;</td>
          <td class="paramname"><em>locally_owned_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将向量的尺寸改为 <code>N</code>. 没有说明调整向量的尺寸如何影响这个对象的内存分配；也就是说，不能保证将其调整到较小的尺寸实际上也减少了内存消耗，或者为了提高效率，使用相同的内存 <code>locally_owned_size</code> 表示在本进程中应储存多少 <code>N</code> 的值。 对于较少的数据。 <code>communicator</code> 表示此后将用于此向量的MPI通信器。 如果 <code>omit_zeroing_entries</code> 为假，则向量由零填充。 否则，这些元素将被留作未指定的状态。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00163">163</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<a id="a38c2d48a865eb577a317895a5d5b7b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c2d48a865eb577a317895a5d5b7b3f">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将维度改为向量 <code>v</code>, 的维度，同时接管对局部大小的划分，以及MPI通信器的划分。 这与其他 <code>reinit</code> 函数同样适用。 <code>v</code> 的元素没有被复制，即这个函数与调用<code>reinit(v.size(), v.local_owned_size(), omit_zeroing_entries)</code>相同。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00206">206</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<a id="a9124190f6bd3c47f78cbbc7b4083467e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9124190f6bd3c47f78cbbc7b4083467e">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>重置为一个带有鬼魂元素的向量。更多细节请见相同签名的构造函数。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">有鬼元素的向量</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00227">227</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<a id="a664db0ae6a04decb80e1dc92fb933fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664db0ae6a04decb80e1dc92fb933fed">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>作为一个没有鬼魂元素的向量重新启动。更多细节请参见具有相同签名的构造函数。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">有幽灵元素的向量</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00245">245</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<a id="a2be39fc0c5574e3c314d8a356b267bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be39fc0c5574e3c314d8a356b267bef">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&amp; PETScWrappers::MPI::Vector::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对该向量使用的MPI通信器对象的引用。 </p>

<p>Reimplemented from <a class="el" href="classPETScWrappers_1_1VectorBase.html#ae50ff45e9b33ed8020bc953ed1a61415">PETScWrappers::VectorBase</a>.</p>

</div>
</div>
<a id="a4d43302d459c7cb6ae4b5bad13d31507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d43302d459c7cb6ae4b5bad13d31507">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印到一个流。 <code>precision</code> 表示打印数值所需的精度， <code>scientific</code> 是否应使用科学符号。如果 <code>across</code> 是 <code>true</code> ，那么向量将被打印在一行中，而如果 <code>false</code> 则元素被打印在单独的一行中。 </p><dl class="section note"><dt>Note</dt><dd>这个函数重载了基类中的函数，以确保对分布在处理器上的并行向量发生正确的事情。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00363">363</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<a id="ae72a04de37cc5ba8f0263809a59ec99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72a04de37cc5ba8f0263809a59ec99e">&#9670;&nbsp;</a></span>all_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>返回向量是否只包含值为0的元素。这是一个集体操作。这个函数很昂贵，因为可能所有的元素都要被检查。 </p><dl class="section note"><dt>Note</dt><dd>这个函数重载了基类中的函数，使之成为一个集体操作。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00348">348</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<a id="a2ea4c0209a2905f35db0092f533c431d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea4c0209a2905f35db0092f533c431d">&#9670;&nbsp;</a></span>create_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::create_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a>&#160;</td>
          <td class="paramname"><em>locally_owned_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建一个长度为 <code>n</code>. 的向量 对于这个类，我们创建一个平行向量。 <code>n</code> 表示要创建的向量的总大小。 <code>local_owned_size表示这些元素中有多少应被存储在本地。</code> </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00259">259</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<a id="a79a877be575fc723ffc5470a24f4d9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a877be575fc723ffc5470a24f4d9a3">&#9670;&nbsp;</a></span>create_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::create_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a01bcb631a52f0218a009456f214ce2fe">size_type</a>&#160;</td>
          <td class="paramname"><em>locally_owned_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ghostnodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建一个全局长度为 <code>n</code>, 本地大小为 <code>local_owned_size的向量，并具有指定的ghost索引。注意，在访问这些索引之前，你需要调用update_ghost_values()。</code> </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__vector_8cc_source.html#l00277">277</a> of file <a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a>.</p>

</div>
</div>
<a id="a6166fa37985a73755a2982af055f1a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6166fa37985a73755a2982af055f1a0a">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::compress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>压缩PETSc对象的底层表示，即刷新矢量对象的缓冲区（如果它有的话）。这个函数在逐一写入矢量元素后，在对其进行任何其他操作之前是必要的。 更多信息请参见 <a class="el" href="DEALGlossary.html#GlossCompress">压缩分布式对象</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00373">373</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a36ccdc09627c773d69a73d99de626cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ccdc09627c773d69a73d99de626cd7">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::VectorBase::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>检验是否相等。这个函数假定现在的向量和要比较的向量已经有相同的大小，因为比较不同大小的向量反正没有什么意义。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00221">221</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a3eea41fb4992579fe065a8ab4dfa5dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eea41fb4992579fe065a8ab4dfa5dc5">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::VectorBase::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>测试不平等。这个函数假定现在的向量和要比较的向量已经有相同的大小，因为比较不同大小的向量反正没有什么意义。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00235">235</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a3875621a4c149265ca738d48614f053c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3875621a4c149265ca738d48614f053c">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">VectorBase::size_type</a> PETScWrappers::VectorBase::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回向量的全局尺寸。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00249">249</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a2dfc89d53e2a916f1f392255b061cd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfc89d53e2a916f1f392255b061cd4e">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">VectorBase::size_type</a> PETScWrappers::VectorBase::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回向量的局部尺寸，即存储在当前MPI进程中的元素数量。对于顺序向量，这个数字与size()相同，但对于并行向量，它可能更小。 要想知道到底哪些元素是存储在本地的，可以使用local_range()或local_owned_elements()。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000050">Deprecated:</a></b></dt><dd>用local_owned_size()代替。</dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00273">273</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="acff4e7a74af91a2ab885cf10d0feb961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff4e7a74af91a2ab885cf10d0feb961">&#9670;&nbsp;</a></span>locally_owned_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">VectorBase::size_type</a> PETScWrappers::VectorBase::locally_owned_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回向量的本地维度，即存储在当前MPI进程中的元素数量。对于顺序向量，这个数字与size()相同，但对于并行向量，它可能更小。 要想知道哪些元素确切地存储在本地，可以使用local_range()或local_owned_elements()。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00261">261</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a59f8ac50f0d9950973f2a9ba11fdb31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f8ac50f0d9950973f2a9ba11fdb31d">&#9670;&nbsp;</a></span>local_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">VectorBase::size_type</a>, <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">VectorBase::size_type</a> &gt; PETScWrappers::VectorBase::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一对指数，表明该向量的哪些元素被存储在本地。第一个数字是存储的第一个元素的索引，第二个数字是本地存储的最后一个元素之后的索引。如果这是一个顺序向量，那么结果将是一对（0,N），否则将是一对（i,i+n），其中<code>n=<a class="el" href="classPETScWrappers_1_1VectorBase.html#acff4e7a74af91a2ab885cf10d0feb961">locally_owned_size()</a></code>。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00285">285</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a4300ee4284b89549ad2069b69c1aa939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4300ee4284b89549ad2069b69c1aa939">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::VectorBase::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 <code>index</code> 是否在本地范围内，另见local_range()。 </p>

</div>
</div>
<a id="a409d3a360896b211e459b9a44ec9b77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409d3a360896b211e459b9a44ec9b77a">&#9670;&nbsp;</a></span>locally_owned_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> PETScWrappers::VectorBase::locally_owned_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个索引集，描述这个向量的哪些元素是由当前处理器拥有的。请注意，这个索引集不包括这个向量可能在本地存储为幽灵元素，但实际上是由另一个处理器拥有的元素。因此，如果这是一个分布式向量，在不同处理器上返回的索引集将形成不相交的集合，加起来就是完整的索引集。 很明显，如果一个向量只在一个处理器上创建，那么结果将满足 </p><div class="fragment"><div class="line">vec.locally_owned_elements() == <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a> (vec.size())</div></div><!-- fragment --> 
</div>
</div>
<a id="ac825d05c684a560c996101ad0efef2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac825d05c684a560c996101ad0efef2c6">&#9670;&nbsp;</a></span>has_ghost_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::VectorBase::has_ghost_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果向量包含鬼魂元素，则返回。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">含有鬼魂元素的向量</a> </dd></dl>

</div>
</div>
<a id="a5916e10c3e54f5080512c3a4c48e0424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5916e10c3e54f5080512c3a4c48e0424">&#9670;&nbsp;</a></span>update_ghost_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::update_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数的存在只是为了与 <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a></code> 类兼容，并不做任何事情：这个类以不同的方式实现鬼魂值的更新，与底层的PETSc向量对象更加匹配。 </p>

</div>
</div>
<a id="a97bddb6f47b5f17a9e681508518a3315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97bddb6f47b5f17a9e681508518a3315">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4a5f8fab8b2b2af5ad61b5bfb7915617">reference</a> PETScWrappers::VectorBase::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>提供对一个给定元素的访问，包括读和写。 </p>

</div>
</div>
<a id="af780eb49cad222c3db90ef05afd66fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af780eb49cad222c3db90ef05afd66fde">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::VectorBase::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>提供对一个元素的只读访问。 </p>

</div>
</div>
<a id="aca1142b659aefd963815ba5db0c92320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1142b659aefd963815ba5db0c92320">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4a5f8fab8b2b2af5ad61b5bfb7915617">reference</a> PETScWrappers::VectorBase::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>提供对一个给定元素的访问，包括读和写。 与operator()完全相同。 </p>

</div>
</div>
<a id="a4e0c87b6f0920ca7a451c0977f1cd80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0c87b6f0920ca7a451c0977f1cd80b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::VectorBase::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>提供对一个元素的只读访问。 与operator()完全相同。 </p>

</div>
</div>
<a id="a7ada30ff781b62d03117c435cd499d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ada30ff781b62d03117c435cd499d72">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个集体的设置操作：这个函数允许一次性设置整个元素集，而不是设置一个向量的单个元素。 要设置的元素的索引在第一个参数中说明，相应的值在第二个参数中说明。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00298">298</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a590b9a811e7fb1fd96fc4b749380b1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590b9a811e7fb1fd96fc4b749380b1f8">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与通过operator()获取向量中的单个元素不同，这个函数允许一次性获取一整组元素。要读取的元素的索引在第一个参数中说明，相应的值在第二个参数中返回。 如果当前的向量被称为 <code>v</code>, ，那么这个函数就等同于代码 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;indices.size(); ++i)</div><div class="line">  <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>[i] = v[indices[i]];</div></div><!-- fragment --> <dl class="section pre"><dt>Precondition</dt><dd><code>indices</code> 和 <code>values</code> 数组的大小必须是一致的。 </dd></dl>

</div>
</div>
<a id="af9e43a21a399d5a5e2d85758ec387695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e43a21a399d5a5e2d85758ec387695">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>values_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数不是通过operator()获得向量的单个元素，而是允许一次获得整个元素集。与前一个函数不同的是，这个函数通过取消引用前两个参数提供的迭代器范围内的所有元素来获得元素的索引，并将向量的值放入通过取消引用从第三个参数指向的位置开始的迭代器范围获得的内存位置。 如果当前的向量被称为 <code>v</code>, ，那么这个函数就等同于代码 </p><div class="fragment"><div class="line">ForwardIterator indices_p = indices_begin;</div><div class="line">OutputIterator  values_p  = values_begin;</div><div class="line"><span class="keywordflow">while</span> (indices_p != indices_end)</div><div class="line">{</div><div class="line"> values_p = v[*indices_p];</div><div class="line">  ++indices_p;</div><div class="line">  ++values_p;</div><div class="line">}</div></div><!-- fragment --> <dl class="section pre"><dt>Precondition</dt><dd>必须能够写进从 <code>values_begin</code> 开始的尽可能多的内存位置，因为有 <code>indices_begin</code> 和 <code>indices_end</code>. 之间的迭代器。 </dd></dl>

</div>
</div>
<a id="ab6a4e50d8cf8b59a13b33a39d240b5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a4e50d8cf8b59a13b33a39d240b5ca">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个集体的添加操作。这个函数将存储在 <code>values</code> 中的一整组值添加到 <code>indices</code>. 指定的向量成分中。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00309">309</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a9fe79d85af013e56c003b3dfdddcfb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe79d85af013e56c003b3dfdddcfb41">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classVector.html">Vector</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这是第二次集体添加操作。作为区别，这个函数需要一个deal.II的数值向量。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00320">320</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a09de2357613ea712c747855030124aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09de2357613ea712c747855030124aa4">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>取一个<code>n_elements</code>连续存储的地址，并将其添加到向量中。处理上述其他两个<code><a class="el" href="classPETScWrappers_1_1VectorBase.html#ab6a4e50d8cf8b59a13b33a39d240b5ca">add()</a></code>函数未涵盖的所有情况。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00331">331</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a39aacc8d16d324843f85134bb0c1675f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39aacc8d16d324843f85134bb0c1675f">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::add </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将 <code>s</code> 加到所有组件上。注意 <code>s</code> 是一个标量而不是一个向量。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00742">742</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="ab2822cc5fab76c09476de60e8d7816c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2822cc5fab76c09476de60e8d7816c9">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::add </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个向量的倍数的简单加法，即<code>*this += a*V</code>。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00754">754</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="ab508c4a8bbd65a945e7a0e5fcf3012c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab508c4a8bbd65a945e7a0e5fcf3012c0">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::add </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>缩放向量的多重加法，即：<code>*this += a*V+b*W</code>。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00766">766</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a30c234d28aff8aa3ab9fdd358e4c9182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c234d28aff8aa3ab9fdd358e4c9182">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::VectorBase::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回两个向量的标量乘积。这两个向量必须有相同的大小。 对于复值向量，这将得到 \(\left(v^\ast,vec\right)\) 。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00340">340</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a5c43e5142dfa22873b0f18d7dc91a4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c43e5142dfa22873b0f18d7dc91a4d1">&#9670;&nbsp;</a></span>norm_sqr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">VectorBase::real_type</a> PETScWrappers::VectorBase::norm_sqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 \(l_2\) -norm的平方。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00433">433</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a232af54220bbbc75b6d1fcee45bac178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232af54220bbbc75b6d1fcee45bac178">&#9670;&nbsp;</a></span>mean_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::VectorBase::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个向量的元素的平均值。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00442">442</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a125b9d63e15ae9e3e5fcd90d3cd0fca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125b9d63e15ae9e3e5fcd90d3cd0fca1">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">VectorBase::real_type</a> PETScWrappers::VectorBase::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>该向量的 \(l_1\) -norm。绝对值的总和。 </p><dl class="section note"><dt>Note</dt><dd>在3.7.0以前的复值PETSc中，这个规范被实现为复数向量元素的实部和虚部的绝对值之和。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00493">493</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="add6ed136b024aeaedf9e529c29cc208d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6ed136b024aeaedf9e529c29cc208d">&#9670;&nbsp;</a></span>l2_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">VectorBase::real_type</a> PETScWrappers::VectorBase::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\(l_2\) - 矢量的规范。 各元素的平方根之和。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00506">506</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a0f9d8151b66561ccb1b5c43f509d39cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9d8151b66561ccb1b5c43f509d39cf">&#9670;&nbsp;</a></span>lp_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">VectorBase::real_type</a> PETScWrappers::VectorBase::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>元素绝对值的p次方之和的p次根。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00519">519</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a9762fc464702fa826eaff4df3779d482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9762fc464702fa826eaff4df3779d482">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">VectorBase::real_type</a> PETScWrappers::VectorBase::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\(l_\infty\) -向量的规范。返回具有最大绝对值的向量元素的值。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00561">561</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a8412866d0e82feca003db88e061e5fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8412866d0e82feca003db88e061e5fe1">&#9670;&nbsp;</a></span>add_and_dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::VectorBase::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>执行一个矢量加法和后续内积的组合操作，返回内积的值。换句话说，这个函数的结果与用户调用 </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="classPETScWrappers_1_1VectorBase.html#ab6a4e50d8cf8b59a13b33a39d240b5ca">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div><div class="line">return_value =<span class="keyword">this</span> W;</div></div><!-- fragment --><p> 这个函数存在的原因是为了与deal.II自己的向量类兼容，后者可以用较少的内存传输实现这个功能。然而，对于PETSc向量来说，这样的组合操作是不被原生支持的，因此其代价完全等同于单独调用这两个方法。 对于复值向量，第二步中的标量乘积被实现为 \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\) . </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00362">362</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a8235403dad66e00479cca97c2f4b582c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8235403dad66e00479cca97c2f4b582c">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">VectorBase::real_type</a> PETScWrappers::VectorBase::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回具有最大负值的向量元素的值。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000051">Deprecated:</a></b></dt><dd>为了提高与其他继承自VectorSpaceVector的类的兼容性，这个函数已经被废弃。如果你需要使用这个功能，那么请使用PETSc函数VecMin代替。</dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00574">574</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a8c9e8e45afd7b28ffc5723e246f81016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9e8e45afd7b28ffc5723e246f81016">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">VectorBase::real_type</a> PETScWrappers::VectorBase::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回具有最大正值的向量元素的值。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000052">Deprecated:</a></b></dt><dd>这个函数已经被废弃，以提高与其他继承自VectorSpaceVector的类的兼容性。如果你需要使用这个功能，那么请使用PETSc函数VecMax代替。</dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00587">587</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a4d76f674c4699ece5dc1107d3403aaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d76f674c4699ece5dc1107d3403aaac">&#9670;&nbsp;</a></span>is_non_negative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::VectorBase::is_non_negative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果向量没有负的条目，即所有条目都是零或正，则返回 <code>true</code> 。例如，这个函数用于检查细化指标是否真的都是正的（或零）。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000053">Deprecated:</a></b></dt><dd>这个函数已经被废弃，以改善与其他继承自VectorSpaceVector的类的兼容性。</dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00655">655</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a37900779c6049418c39bacc1d44f4260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37900779c6049418c39bacc1d44f4260">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp; PETScWrappers::VectorBase::operator*= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将整个向量乘以一个固定的因子。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00687">687</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a4beb21a67a1231346876c5d49ebc0c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4beb21a67a1231346876c5d49ebc0c4d">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp; PETScWrappers::VectorBase::operator/= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将整个向量除以一个固定的因子。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00701">701</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a2108fd9efd4f35d17accfa3c8d52e71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2108fd9efd4f35d17accfa3c8d52e71c">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp; PETScWrappers::VectorBase::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将给定的向量添加到当前的向量中。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00718">718</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a3ad576803857b394e28549db2cff5128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad576803857b394e28549db2cff5128">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp; PETScWrappers::VectorBase::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从现在的向量中减去给定的向量。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00730">730</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a5a614d48c2a904e8337025706c644433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a614d48c2a904e8337025706c644433">&#9670;&nbsp;</a></span>sadd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::sadd </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>缩放和简单的向量相加，即<code>*this = s*(*this)+V</code>。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00785">785</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a0d7a9c7bf865040f5b76ec2d7a8ac3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7a9c7bf865040f5b76ec2d7a8ac3ff">&#9670;&nbsp;</a></span>sadd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::sadd </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>缩放和简单加法，即：<code>*this = s*(*this)+a*V</code>。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00797">797</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a57deb429a909bfa17e885ca20660f521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57deb429a909bfa17e885ca20660f521">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用参数中的相应元素来缩放这个向量的每个元素。这个函数主要是为了模拟对角线缩放矩阵的乘法（和立即重新分配）。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00815">815</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="ad80e009e532257f82980c49b70072018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80e009e532257f82980c49b70072018">&#9670;&nbsp;</a></span>equ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::equ </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>赋值 <code>*this = a*V</code>. </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00825">825</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="abf51494f6194764f1a0a32e97d59fb1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf51494f6194764f1a0a32e97d59fb1b">&#9670;&nbsp;</a></span>write_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::write_ascii </td>
          <td>(</td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>使用PETSc内部矢量查看器函数<code>VecView</code>打印PETSc矢量对象的值。默认格式是打印矢量的内容，包括矢量元素的索引。对于其他有效的视图格式，请参考http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecView.html </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00844">844</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="ab185a8ff0370c08fab553ba1e75194c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab185a8ff0370c08fab553ba1e75194c3">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>交换这个向量和另一个向量的内容 <code>v</code>. 人们可以用一个临时变量和复制数据元素来完成这个操作，但是这个函数明显更有效率，因为它只交换了两个向量的数据指针，因此不需要分配临时存储和移动数据。 这个函数类似于所有C++标准容器的 <code>swap</code> 函数。此外，还有一个全局函数<code>swap(u,v)</code>，它简单地调用<code>u.swap(v)</code>，同样与标准函数相类似。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00908">908</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="ade5e08d408ee79da10cceb7642bfa1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5e08d408ee79da10cceb7642bfa1da">&#9670;&nbsp;</a></span>operator const Vec &()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::VectorBase::operator const Vec &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>转换操作符，以获得对底层PETSc类型的访问。如果你这样做，你就切断了这个类可能需要的一些信息，所以这个转换操作符应该只在你知道你要做什么的情况下使用。特别是，它应该只用于对向量的只读操作。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00916">916</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a49cd6e2cf47c7d44cbcbb9bdd44613fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49cd6e2cf47c7d44cbcbb9bdd44613fd">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t PETScWrappers::VectorBase::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对内存消耗的估计（这个类没有实现）。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00923">923</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="ada190205c9e3a51bba688969b5846eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada190205c9e3a51bba688969b5846eeb">&#9670;&nbsp;</a></span>do_set_add_operation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::do_set_add_operation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>add_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>集合设置或添加操作。这个函数由集体 <code>set</code> 和 <code>add</code> 调用， <code>add_values</code> 标志设置为相应的值。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00945">945</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af853f838d421f8a008f6a57f3231bdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af853f838d421f8a008f6a57f3231bdc3">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>全局函数 <code>swap</code> ，它重载了C++标准库的默认实现，它使用一个临时对象。该函数简单地交换了两个向量的数据。</p>

<p class="definition">Definition at line <a class="el" href="petsc__vector_8h_source.html#l00333">333</a> of file <a class="el" href="petsc__vector_8h_source.html">petsc_vector.h</a>.</p>

</div>
</div>
<a id="af0dd3dea1d8fea889513f82bbe5d7f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0dd3dea1d8fea889513f82bbe5d7f35">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>全局函数 <code>swap</code> ，它重载了C++标准库的默认实现，它使用一个临时对象。该函数简单地交换了两个向量的数据。</p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00791">791</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8bb29704b2ee7f8e0f888201bcd71c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb29704b2ee7f8e0f888201bcd71c62">&#9670;&nbsp;</a></span>communicator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMPI__Comm.html">MPI_Comm</a> PETScWrappers::MPI::Vector::communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将用于该并行向量的通信器对象的副本。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector_8h_source.html#l00319">319</a> of file <a class="el" href="petsc__vector_8h_source.html">petsc_vector.h</a>.</p>

</div>
</div>
<a id="a3a337ca41046f9e87ae2b4459e1e8a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a337ca41046f9e87ae2b4459e1e8a38">&#9670;&nbsp;</a></span>vector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vec PETScWrappers::VectorBase::vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个PETSc中的通用向量对象。实际的类型，一个连续的向量，在构造函数中被设置。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00736">736</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="a2afd34f59a5c4f754fa32a6f69e110b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afd34f59a5c4f754fa32a6f69e110b3">&#9670;&nbsp;</a></span>ghosted</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::VectorBase::ghosted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>表示这个向量是否有与之相关的鬼魂索引。这意味着并行程序中至少有一个进程有至少一个幽灵索引。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00742">742</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="a2c0fa32597e5faa4ceb51bc7eb5c06ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0fa32597e5faa4ceb51bc7eb5c06ad">&#9670;&nbsp;</a></span>ghost_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> PETScWrappers::VectorBase::ghost_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个向量包含鬼魂值的全局索引。这个向量中的位置表示本地编号，在PETSc中使用。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00748">748</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="a2e7c95d791d77dcc89aecf77bd91251e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7c95d791d77dcc89aecf77bd91251e">&#9670;&nbsp;</a></span>last_action</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> PETScWrappers::VectorBase::last_action</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储最后一个动作是写操作还是加操作。这个变量是 <code>mutable</code> ，这样访问器类就可以写到它，即使它们引用的向量对象是常量。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00756">756</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="a554f19155de441313cd0931c4faa5d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554f19155de441313cd0931c4faa5d6b">&#9670;&nbsp;</a></span>obtained_ownership</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::VectorBase::obtained_ownership</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指定该向量是否是PETSc Vec的所有者。如果它是由这个类创建的，这就是真的，并决定它是否在析构器中被销毁。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00766">766</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="petsc__vector_8h_source.html">petsc_vector.h</a></li>
<li>source/lac/<a class="el" href="petsc__parallel__vector_8cc_source.html">petsc_parallel_vector.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
