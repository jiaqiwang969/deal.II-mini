<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFunctions_1_1FEFieldFunction.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Functions::FEFieldFunction&lt; dim, VectorType, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceFunctions.html">Functions</a></li><li class="navelem"><a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFunctions_1_1FEFieldFunction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Functions::FEFieldFunction&lt; dim, VectorType, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fe__field__function_8h_source.html">deal.II/numerics/fe_field_function.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Functions::FEFieldFunction&lt; dim, VectorType, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFunctions_1_1FEFieldFunction__inherit__graph.svg" width="1454" height="199"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a385ed76410d75f5f15304ccebaac220d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a> = typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; VectorType::value_type &gt;::real_type &gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a></td></tr>
<tr class="separator:a385ed76410d75f5f15304ccebaac220d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac25d965867c71d1139262cf383f9f593"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ac25d965867c71d1139262cf383f9f593">FEFieldFunction</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFunctions_1_1FEFieldFunction.html#ad2f57d59cb5e7cc2deefd6bbd8b72a90">dh</a>, const <a class="el" href="classVectorType.html">VectorType</a> &amp;<a class="el" href="classFunctions_1_1FEFieldFunction.html#a812a4e7584d4a8a197e1fb0866c4bdc5">data_vector</a>, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;<a class="el" href="classFunctions_1_1FEFieldFunction.html#a83e5b937b784cfbb0ca1cfae9af85ea7">mapping</a>=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim &gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html#a83e5b937b784cfbb0ca1cfae9af85ea7">mapping</a>)</td></tr>
<tr class="separator:ac25d965867c71d1139262cf383f9f593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ff880a7b80ff5f91bd3ea69f92c7a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a29ff880a7b80ff5f91bd3ea69f92c7a0">set_active_cell</a> (const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;newcell)</td></tr>
<tr class="separator:a29ff880a7b80ff5f91bd3ea69f92c7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c499a84c22d4aaedb7a5920044861c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a3c499a84c22d4aaedb7a5920044861c2">vector_value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;values) const override</td></tr>
<tr class="separator:a3c499a84c22d4aaedb7a5920044861c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd1384d693d17e682f6a30a83fab17f"><td class="memItemLeft" align="right" valign="top">virtual VectorType::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a3dd1384d693d17e682f6a30a83fab17f">value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const override</td></tr>
<tr class="separator:a3dd1384d693d17e682f6a30a83fab17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d364da356395defd1b86dc9337a4cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a00d364da356395defd1b86dc9337a4cc">value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; typename VectorType::value_type &gt; &amp;values, const unsigned <a class="el" href="classint.html">int</a> component=0) const override</td></tr>
<tr class="separator:a00d364da356395defd1b86dc9337a4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5951fbc226a1388426fd5f630e239b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a8f5951fbc226a1388426fd5f630e239b">vector_value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt;&gt; &amp;values) const override</td></tr>
<tr class="separator:a8f5951fbc226a1388426fd5f630e239b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35712b8bb018b10723cc600317526787"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a35712b8bb018b10723cc600317526787">vector_gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt;&gt; &amp;gradients) const override</td></tr>
<tr class="separator:a35712b8bb018b10723cc600317526787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a3febe9bfd596da043766a71bf6aac"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a79a3febe9bfd596da043766a71bf6aac">gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const override</td></tr>
<tr class="separator:a79a3febe9bfd596da043766a71bf6aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d75aae9b870273bac83b7d85c497d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a17d75aae9b870273bac83b7d85c497d5">vector_gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;p, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt;&gt;&gt; &amp;gradients) const override</td></tr>
<tr class="separator:a17d75aae9b870273bac83b7d85c497d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae226f81c6b7b686482b638912c82a528"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ae226f81c6b7b686482b638912c82a528">gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;p, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt;&gt; &amp;gradients, const unsigned <a class="el" href="classint.html">int</a> component=0) const override</td></tr>
<tr class="separator:ae226f81c6b7b686482b638912c82a528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299db57ebf3a55c837fc50e6206d67b1"><td class="memItemLeft" align="right" valign="top">virtual VectorType::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a299db57ebf3a55c837fc50e6206d67b1">laplacian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const override</td></tr>
<tr class="separator:a299db57ebf3a55c837fc50e6206d67b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9c62d20827c834fe01af2ec8b3a2e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#aea9c62d20827c834fe01af2ec8b3a2e4">vector_laplacian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;values) const override</td></tr>
<tr class="separator:aea9c62d20827c834fe01af2ec8b3a2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907c24d32524bb506833c46f2ff57636"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a907c24d32524bb506833c46f2ff57636">laplacian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; typename VectorType::value_type &gt; &amp;values, const unsigned <a class="el" href="classint.html">int</a> component=0) const override</td></tr>
<tr class="separator:a907c24d32524bb506833c46f2ff57636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d162944d09780d762abb6e802b0c332"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a5d162944d09780d762abb6e802b0c332">vector_laplacian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt;&gt; &amp;values) const override</td></tr>
<tr class="separator:a5d162944d09780d762abb6e802b0c332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4acd34715ed24fe62d3632634adbf74"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ad4acd34715ed24fe62d3632634adbf74">compute_point_locations</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;cells, std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt;&gt; &amp;qpoints, std::vector&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;maps) const</td></tr>
<tr class="separator:ad4acd34715ed24fe62d3632634adbf74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b4f548be005a1ffeeca7a450b028d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ad1b4f548be005a1ffeeca7a450b028d8">vector_values</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; std::vector&lt; VectorType::value_type &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:ad1b4f548be005a1ffeeca7a450b028d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddbeb5adda74140a00dfc8db3687b4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a4ddbeb5adda74140a00dfc8db3687b4a">vector_gradients</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, VectorType::value_type &gt;&gt;&gt; &amp;gradients) const</td></tr>
<tr class="separator:a4ddbeb5adda74140a00dfc8db3687b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa2ec8f2270bdee842413805c4d7442"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a8aa2ec8f2270bdee842413805c4d7442">hessian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:a8aa2ec8f2270bdee842413805c4d7442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94960fba14557566fa5df8745a721939"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a94960fba14557566fa5df8745a721939">vector_hessian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:a94960fba14557566fa5df8745a721939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e69625d9daf07615270d65d97dfebde"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a2e69625d9daf07615270d65d97dfebde">hessian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type &gt;&gt; &amp;values, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:a2e69625d9daf07615270d65d97dfebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1b732264fb498528453312e24d2f49"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#abc1b732264fb498528453312e24d2f49">vector_hessian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type &gt;&gt;&gt; &amp;values) const</td></tr>
<tr class="separator:abc1b732264fb498528453312e24d2f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e07b63ee34bd7e7ab2492be5213377"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a45e07b63ee34bd7e7ab2492be5213377">memory_consumption</a> () const</td></tr>
<tr class="separator:a45e07b63ee34bd7e7ab2492be5213377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a> () const</td></tr>
<tr class="separator:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a> (const Number new_time)</td></tr>
<tr class="separator:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb592482f587dc3f0ee6e2267215a772"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#aeb592482f587dc3f0ee6e2267215a772">advance_time</a> (const Number delta_t)</td></tr>
<tr class="separator:aeb592482f587dc3f0ee6e2267215a772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7248c7e11dc434fb7d16cdc5e41e3770"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a></td></tr>
<tr class="separator:a7248c7e11dc434fb7d16cdc5e41e3770"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ad8063ed9dcbe58753504d9173475befe"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ad8063ed9dcbe58753504d9173475befe">dimension</a></td></tr>
<tr class="separator:ad8063ed9dcbe58753504d9173475befe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a476cfd28bcdd3f8e606e4ac777950794"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a476cfd28bcdd3f8e606e4ac777950794">cell_hint_t</a> = <a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt;</td></tr>
<tr class="separator:a476cfd28bcdd3f8e606e4ac777950794"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:af85481270fd076a54b32c25032e4e346"><td class="memItemLeft" align="right" valign="top">std_cxx17::optional&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#af85481270fd076a54b32c25032e4e346">get_reference_coordinates</a> (const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;point) const</td></tr>
<tr class="separator:af85481270fd076a54b32c25032e4e346"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad2f57d59cb5e7cc2deefd6bbd8b72a90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;, <a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#ad2f57d59cb5e7cc2deefd6bbd8b72a90">dh</a></td></tr>
<tr class="separator:ad2f57d59cb5e7cc2deefd6bbd8b72a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812a4e7584d4a8a197e1fb0866c4bdc5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a812a4e7584d4a8a197e1fb0866c4bdc5">data_vector</a></td></tr>
<tr class="separator:a812a4e7584d4a8a197e1fb0866c4bdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e5b937b784cfbb0ca1cfae9af85ea7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a83e5b937b784cfbb0ca1cfae9af85ea7">mapping</a></td></tr>
<tr class="separator:a83e5b937b784cfbb0ca1cfae9af85ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd7c6fbf709bb7544475d67ddcbd1d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a4dd7c6fbf709bb7544475d67ddcbd1d2">cache</a></td></tr>
<tr class="separator:a4dd7c6fbf709bb7544475d67ddcbd1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdf397854b514503b8c0a8ed4e19842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a476cfd28bcdd3f8e606e4ac777950794">cell_hint_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a2cdf397854b514503b8c0a8ed4e19842">cell_hint</a></td></tr>
<tr class="separator:a2cdf397854b514503b8c0a8ed4e19842"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt;<br />
class Functions::FEFieldFunction&lt; dim, VectorType, spacedim &gt;</h3>

<p>This is an interpolation function for the given dof handler and the given solution vector. The points at which this function can be evaluated MUST be inside the domain of the dof handler, but except from this, no other requirement is given. This function is rather slow, as it needs to construct a quadrature object for the point (or set of points) where you want to evaluate your finite element function. In order to do so, it needs to find out where the points lie.</p>
<p>If you know in advance in which cell your points lie, you can accelerate things a bit, by calling <a class="el" href="classFunctions_1_1FEFieldFunction.html#a29ff880a7b80ff5f91bd3ea69f92c7a0">set_active_cell()</a> before asking for values or gradients of the function. If you don't do this, and your points don't lie in the cell that is currently stored, the function <a class="el" href="namespaceGridTools.html#a81430f37dc42f63e1cf0d3e62dc0a414">GridTools::find_active_cell_around_point</a> is called to find out where the point is. You can specify an optional mapping to use when looking for points in the grid. If you don't do so, this function uses a Q1 mapping.</p>
<p>Once the <a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> knows where the points lie, it creates a quadrature formula for those points, and calls <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a> or <a class="el" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">FEValues::get_function_gradients</a> with the given quadrature points.</p>
<p>If you only need the quadrature points but not the values of the finite element function (you might want this for the adjoint interpolation), you can also use the function <a class="el" href="classFunctions_1_1FEFieldFunction.html#ad4acd34715ed24fe62d3632634adbf74">compute_point_locations()</a> alone.</p>
<p>An example of how to use this function is the following:</p>
<div class="fragment"><div class="line"><span class="comment">// Generate two triangulations</span></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_1;</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria_2;</div><div class="line"></div><div class="line"><span class="comment">// Read the triangulations from files, or build them up, or get them</span></div><div class="line"><span class="comment">// from some place. Assume that tria_2 is *entirely* included in tria_1.</span></div><div class="line"></div><div class="line"><span class="comment">// Associate a dof handler and a solution to the first triangulation</span></div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dh1 (tria_1);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_1;</div><div class="line"></div><div class="line"><span class="comment">// On this first domain, set up the various data structures,</span></div><div class="line"><span class="comment">// assemble matrices, solve the linear system, and get a Nobel</span></div><div class="line"><span class="comment">// prize for the work we have done here:</span></div><div class="line">[...]</div><div class="line"></div><div class="line"><span class="comment">// Then create a DoFHandler and solution vector for the second domain:</span></div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dh2 (tria_2);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_2;</div><div class="line"></div><div class="line"><span class="comment">// Finally, project the solution on the first domain onto the</span></div><div class="line"><span class="comment">// second domain, assuming that this does not require querying</span></div><div class="line"><span class="comment">// values from outside the first domain:</span></div><div class="line"><a class="code" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction&lt;dim&gt;</a> fe_function_1 (dh_1, solution_1);</div><div class="line"><a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> (dh_2, constraints_2, quad,</div><div class="line">                      fe_function_1, solution_2);</div><div class="line"></div><div class="line"><span class="comment">// Alternatively, we could have also interpolated it:</span></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution_3;</div><div class="line"><a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a> (dh_2, fe_function_1, solution_3);</div></div><!-- fragment --><p>The snippet of code above will work assuming that the second triangulation is entirely included in the first one.</p>
<p><a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> is designed to be an easy way to get the results of your computations across different, possibly non matching, grids. No knowledge of the location of the points is assumed in this class, which makes it rely entirely on the <a class="el" href="namespaceGridTools.html#a81430f37dc42f63e1cf0d3e62dc0a414">GridTools::find_active_cell_around_point</a> utility for its job. However the class can be fed an "educated guess" of where the points that will be computed actually are by using the <a class="el" href="classFunctions_1_1FEFieldFunction.html#a29ff880a7b80ff5f91bd3ea69f92c7a0">FEFieldFunction::set_active_cell</a> method, so if you have a smart way to tell where your points are, you will save a lot of computational time by letting this class know.</p>
<h3>Using <a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> with <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a></h3>
<p>When using this class with a parallel distributed triangulation object and evaluating the solution at a particular point, not every processor will own the cell at which the solution is evaluated. Rather, it may be that the cell in which this point is found is in fact a ghost or artificial cell (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a> and <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a>). The solution can be evaluated on ghost cells, but for artificial cells we have no access to the solution there and functions that evaluate the solution at such a point will trigger an exception of type VectorTools::ExcPointNotAvailableHere.</p>
<p>To deal with this situation, you will want to use code as follows when, for example, evaluating the solution at the origin (here using a parallel <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a> vector to hold the solution): </p><div class="fragment"><div class="line"><a class="code" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction&lt;dim,TrilinosWrappers::MPI::Vector&gt;</a></div><div class="line">  solution_function (dof_handler, solution);</div><div class="line"><a class="code" href="classPoint.html">Point&lt;dim&gt;</a> origin = <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>();</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> solution_at_origin;</div><div class="line"><span class="keywordtype">bool</span>   point_found = <span class="keyword">true</span>;</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    solution_at_origin = solution_function.value (origin);</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (<span class="keyword">const</span> VectorTools::ExcPointNotAvailableHere &amp;)</div><div class="line">  {</div><div class="line">    point_found = <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (point_found == <span class="keyword">true</span>)</div><div class="line">  ...do something...;</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00167">167</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a476cfd28bcdd3f8e606e4ac777950794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476cfd28bcdd3f8e606e4ac777950794">&#9670;&nbsp;</a></span>cell_hint_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html#a476cfd28bcdd3f8e606e4ac777950794">cell_hint_t</a> =  <a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim, spacedim&gt;::active_cell_iterator&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef holding the local cell_hint. </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00450">450</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="a385ed76410d75f5f15304ccebaac220d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385ed76410d75f5f15304ccebaac220d">&#9670;&nbsp;</a></span>time_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a> =  typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;VectorType::value_type &gt;::real_type&gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The scalar-valued real type used for representing time. </p>

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00170">170</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac25d965867c71d1139262cf383f9f593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25d965867c71d1139262cf383f9f593">&#9670;&nbsp;</a></span>FEFieldFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::<a class="el" href="classFunctions_1_1FEFieldFunction.html#a83e5b937b784cfbb0ca1cfae9af85ea7">mapping</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a vector function. A smart pointers is stored to the dof handler, so you have to make sure that it make sense for the entire lifetime of this object. The number of components of this functions is equal to the number of components of the finite element object. If a mapping is specified, that is what is used to find out where the points lay. Otherwise the standard Q1 mapping is used. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a29ff880a7b80ff5f91bd3ea69f92c7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ff880a7b80ff5f91bd3ea69f92c7a0">&#9670;&nbsp;</a></span>set_active_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::set_active_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>newcell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the current cell. If you know in advance where your points lie, you can tell this object by calling this function. This will speed things up a little. </p>

</div>
</div>
<a id="a3c499a84c22d4aaedb7a5920044861c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c499a84c22d4aaedb7a5920044861c2">&#9670;&nbsp;</a></span>vector_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::vector_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get one vector value at the given point. It is inefficient to use single points. If you need more than one at a time, use the <a class="el" href="classFunctions_1_1FEFieldFunction.html#a8f5951fbc226a1388426fd5f630e239b">vector_value_list()</a> function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a3dd1384d693d17e682f6a30a83fab17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd1384d693d17e682f6a30a83fab17f">&#9670;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual VectorType::value_type <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the function at the given point. Unless there is only one component (i.e. the function is scalar), you should state the component you want to have evaluated; it defaults to zero, i.e. the first component. It is inefficient to use single points. If you need more than one at a time, use the <a class="el" href="classFunctions_1_1FEFieldFunction.html#a8f5951fbc226a1388426fd5f630e239b">vector_value_list()</a> function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a00d364da356395defd1b86dc9337a4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d364da356395defd1b86dc9337a4cc">&#9670;&nbsp;</a></span>value_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the specified component of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the points array. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a562fc1114e95e702e6696721f71528db">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a8f5951fbc226a1388426fd5f630e239b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5951fbc226a1388426fd5f630e239b">&#9670;&nbsp;</a></span>vector_value_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::vector_value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the points array. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#aa041dde994d40c068e00661197ac75a6">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a35712b8bb018b10723cc600317526787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35712b8bb018b10723cc600317526787">&#9670;&nbsp;</a></span>vector_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::vector_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of all components of the function at the given point. It is inefficient to use single points. If you need more than one at a time, use the <a class="el" href="classFunctions_1_1FEFieldFunction.html#a8f5951fbc226a1388426fd5f630e239b">vector_value_list()</a> function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#af4509a9d71dc1a1ca05cb6205161dc60">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a79a3febe9bfd596da043766a71bf6aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a3febe9bfd596da043766a71bf6aac">&#9670;&nbsp;</a></span>gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim, typename VectorType::value_type&gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the specified component of the function at the given point. It is inefficient to use single points. If you need more than one at a time, use the <a class="el" href="classFunctions_1_1FEFieldFunction.html#a8f5951fbc226a1388426fd5f630e239b">vector_value_list()</a> function. For efficiency reasons, it is better if all the points lie on the same cell. This is not mandatory, however it does speed things up.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a4b0aadc89a827b39c20f12889aa88625">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a17d75aae9b870273bac83b7d85c497d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d75aae9b870273bac83b7d85c497d5">&#9670;&nbsp;</a></span>vector_gradient_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::vector_gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of all components of the function at all the given points. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a109f7bff0fb455c042086f98bd003ede">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="ae226f81c6b7b686482b638912c82a528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae226f81c6b7b686482b638912c82a528">&#9670;&nbsp;</a></span>gradient_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename VectorType::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the specified component of the function at all the given points. This is rather efficient if all the points lie on the same cell. If this is not the case, things may slow down a bit.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#afcf557f137782b46e85461235d5bd47d">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a299db57ebf3a55c837fc50e6206d67b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299db57ebf3a55c837fc50e6206d67b1">&#9670;&nbsp;</a></span>laplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual VectorType::value_type <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::laplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of a given component at point <code>p</code>.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a763c928e78dc33bbe50873128f06e153">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="aea9c62d20827c834fe01af2ec8b3a2e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9c62d20827c834fe01af2ec8b3a2e4">&#9670;&nbsp;</a></span>vector_laplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::vector_laplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of all components at point <code>p</code> and store them in <code>values</code>.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a33430fb1069660fb8cfe599181aceefa">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a907c24d32524bb506833c46f2ff57636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907c24d32524bb506833c46f2ff57636">&#9670;&nbsp;</a></span>laplacian_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::laplacian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of one component at a set of points.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#aae80353c3a581fa918ea555c3e1c7353">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="a5d162944d09780d762abb6e802b0c332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d162944d09780d762abb6e802b0c332">&#9670;&nbsp;</a></span>vector_laplacian_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::vector_laplacian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacians of all components at a set of points.</p>
<dl class="section note"><dt>Note</dt><dd>When using this function on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you may get an exception when trying to evaluate the solution at a point that lies on an artificial cell (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>). See the section in the general documentation of this class for more information. </dd></dl>

<p>Reimplemented from <a class="el" href="classFunction.html#a6582ff5ce8fddc37866077976df598f9">Function&lt; dim, VectorType::value_type &gt;</a>.</p>

</div>
</div>
<a id="ad4acd34715ed24fe62d3632634adbf74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4acd34715ed24fe62d3632634adbf74">&#9670;&nbsp;</a></span>compute_point_locations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::compute_point_locations </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>qpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>maps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a set of points located in the domain (or, in the case of a parallel <a class="el" href="classTriangulation.html">Triangulation</a>, in the locally owned part of the domain or on the ghost cells for the current processor), sort these points into buckets for each of the cells on which at least one of the points is located.</p>
<p>This function fills three output vectors: <code>cells</code>, <code>qpoints</code> and <code>maps</code>. The first is a list of the cells that contain the points, the second is a list of quadrature points matching each cell of the first list, and the third contains the index of the given quadrature points, i.e., <code>points</code>[maps[3][4]] ends up as the 5th quadrature point in the 4th cell.</p>
<dl class="section return"><dt>Returns</dt><dd>This function returns the number of cells that collectively contain the set of points give as <code>points</code>. This also equals the lengths of the output arrays.</dd></dl>
<p>This function simply calls <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> : using the original function avoids computing a new Cache at every function call. </p>

</div>
</div>
<a id="af85481270fd076a54b32c25032e4e346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85481270fd076a54b32c25032e4e346">&#9670;&nbsp;</a></span>get_reference_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std_cxx17::optional&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::get_reference_coordinates </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a cell, return the reference coordinates of the given point within this cell if it indeed lies within the cell. Otherwise return an uninitialized std_cxx17::optional object. </p>

</div>
</div>
<a id="ad1b4f548be005a1ffeeca7a450b028d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b4f548be005a1ffeeca7a450b028d8">&#9670;&nbsp;</a></span>vector_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::vector_values </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; VectorType::value_type  &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each component of the function, fill a vector of values, one for each point.</p>
<p>The default implementation of this function in <a class="el" href="classFunction.html">Function</a> calls <a class="el" href="classFunctions_1_1FEFieldFunction.html#a00d364da356395defd1b86dc9337a4cc">value_list()</a> for each component. In order to improve performance, this can be reimplemented in derived classes to speed up performance. </p>

</div>
</div>
<a id="a4ddbeb5adda74140a00dfc8db3687b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddbeb5adda74140a00dfc8db3687b4a">&#9670;&nbsp;</a></span>vector_gradients()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::vector_gradients </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, VectorType::value_type  &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each component of the function, fill a vector of gradient values, one for each point.</p>
<p>The default implementation of this function in <a class="el" href="classFunction.html">Function</a> calls <a class="el" href="classFunctions_1_1FEFieldFunction.html#a00d364da356395defd1b86dc9337a4cc">value_list()</a> for each component. In order to improve performance, this can be reimplemented in derived classes to speed up performance. </p>

</div>
</div>
<a id="a8aa2ec8f2270bdee842413805c4d7442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa2ec8f2270bdee842413805c4d7442">&#9670;&nbsp;</a></span>hessian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim, VectorType::value_type &gt; <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::hessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of a given component at point <code>p</code>, that is the gradient of the gradient of the function. </p>

</div>
</div>
<a id="a94960fba14557566fa5df8745a721939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94960fba14557566fa5df8745a721939">&#9670;&nbsp;</a></span>vector_hessian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::vector_hessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type  &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of all components at point <code>p</code> and store them in <code>values</code>. </p>

</div>
</div>
<a id="a2e69625d9daf07615270d65d97dfebde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e69625d9daf07615270d65d97dfebde">&#9670;&nbsp;</a></span>hessian_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::hessian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type  &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of one component at a set of points. </p>

</div>
</div>
<a id="abc1b732264fb498528453312e24d2f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1b732264fb498528453312e24d2f49">&#9670;&nbsp;</a></span>vector_hessian_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::vector_hessian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorType::value_type  &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessians of all components at a set of points. </p>

</div>
</div>
<a id="a45e07b63ee34bd7e7ab2492be5213377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e07b63ee34bd7e7ab2492be5213377">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an estimate for the memory consumption, in bytes, of this object.</p>
<p>This function is virtual and can be overloaded by derived classes. </p>

</div>
</div>
<a id="ae7d37ddb04314b38cf67c6cba22923f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d37ddb04314b38cf67c6cba22923f6">&#9670;&nbsp;</a></span>get_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; Number &gt;::get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the time variable. </p>

</div>
</div>
<a id="a3a583fd8f30db3549dbaa43b2592e2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a583fd8f30db3549dbaa43b2592e2bc">&#9670;&nbsp;</a></span>set_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; Number &gt;::set_time </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>new_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the time to <code>new_time</code>, overwriting the old value. </p>

</div>
</div>
<a id="aeb592482f587dc3f0ee6e2267215a772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb592482f587dc3f0ee6e2267215a772">&#9670;&nbsp;</a></span>advance_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; Number &gt;::advance_time </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>delta_t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the time by the given time step <code>delta_t</code>. </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad2f57d59cb5e7cc2deefd6bbd8b72a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f57d59cb5e7cc2deefd6bbd8b72a90">&#9670;&nbsp;</a></span>dh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim, spacedim&gt;, <a class="el" href="classFunctions_1_1FEFieldFunction.html">FEFieldFunction</a>&lt;dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim&gt; &gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::dh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the dof handler. </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00457">457</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="a812a4e7584d4a8a197e1fb0866c4bdc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812a4e7584d4a8a197e1fb0866c4bdc5">&#9670;&nbsp;</a></span>data_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classVectorType.html">VectorType</a>&amp; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::data_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A reference to the actual data vector. </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00462">462</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="a83e5b937b784cfbb0ca1cfae9af85ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e5b937b784cfbb0ca1cfae9af85ea7">&#9670;&nbsp;</a></span>mapping</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMapping.html">Mapping</a>&lt;dim&gt;&amp; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::mapping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A reference to the mapping being used. </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00467">467</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="a4dd7c6fbf709bb7544475d67ddcbd1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd7c6fbf709bb7544475d67ddcbd1d2">&#9670;&nbsp;</a></span>cache</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt;dim, spacedim&gt; <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The Cache object </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00472">472</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="a2cdf397854b514503b8c0a8ed4e19842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdf397854b514503b8c0a8ed4e19842">&#9670;&nbsp;</a></span>cell_hint</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType = Vector&lt;double&gt;, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctions_1_1FEFieldFunction.html#a476cfd28bcdd3f8e606e4ac777950794">cell_hint_t</a> <a class="el" href="classFunctions_1_1FEFieldFunction.html">Functions::FEFieldFunction</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::cell_hint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The latest cell hint. </p>

<p class="definition">Definition at line <a class="el" href="fe__field__function_8h_source.html#l00477">477</a> of file <a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a>.</p>

</div>
</div>
<a id="ad8063ed9dcbe58753504d9173475befe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8063ed9dcbe58753504d9173475befe">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export the value of the template parameter as a static member constant. Sometimes useful for some expression template programming. </p>

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00159">159</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>

</div>
</div>
<a id="a7248c7e11dc434fb7d16cdc5e41e3770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7248c7e11dc434fb7d16cdc5e41e3770">&#9670;&nbsp;</a></span>n_components</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFunction.html">Function</a>&lt; dim, VectorType::value_type  &gt;::n_components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of vector components. </p>

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00164">164</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/numerics/<a class="el" href="fe__field__function_8h_source.html">fe_field_function.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
