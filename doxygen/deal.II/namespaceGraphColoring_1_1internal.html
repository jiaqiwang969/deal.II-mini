<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceGraphColoring_1_1internal.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: GraphColoring::internal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceGraphColoring.html">GraphColoring</a></li><li class="navelem"><a class="el" href="namespaceGraphColoring_1_1internal.html">internal</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">GraphColoring::internal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a882325d218296e70ed19ce77e8bf9f41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGraphColoring_1_1internal.html#a882325d218296e70ed19ce77e8bf9f41">have_nonempty_intersection</a> (const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices1, const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices2)</td></tr>
<tr class="separator:a882325d218296e70ed19ce77e8bf9f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ceedabe337e9a92a970e2a386121e16"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a0ceedabe337e9a92a970e2a386121e16"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGraphColoring_1_1internal.html#a0ceedabe337e9a92a970e2a386121e16">create_partitioning</a> (const Iterator &amp;begin, const typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &amp;end, const std::function&lt; std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;(const Iterator &amp;)&gt; &amp;get_conflict_indices)</td></tr>
<tr class="separator:a0ceedabe337e9a92a970e2a386121e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf2ce58eca7c18a4d7ecd6e2747d690"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:abaf2ce58eca7c18a4d7ecd6e2747d690"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGraphColoring_1_1internal.html#abaf2ce58eca7c18a4d7ecd6e2747d690">make_dsatur_coloring</a> (std::vector&lt; Iterator &gt; &amp;partition, const std::function&lt; std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;(const Iterator &amp;)&gt; &amp;get_conflict_indices, std::vector&lt; std::vector&lt; Iterator &gt;&gt; &amp;partition_coloring)</td></tr>
<tr class="separator:abaf2ce58eca7c18a4d7ecd6e2747d690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40b8dbbfb93340082f53e2c85384766"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ad40b8dbbfb93340082f53e2c85384766"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGraphColoring_1_1internal.html#ad40b8dbbfb93340082f53e2c85384766">gather_colors</a> (const std::vector&lt; std::vector&lt; std::vector&lt; Iterator &gt;&gt;&gt; &amp;partition_coloring)</td></tr>
<tr class="separator:ad40b8dbbfb93340082f53e2c85384766"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a882325d218296e70ed19ce77e8bf9f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882325d218296e70ed19ce77e8bf9f41">&#9670;&nbsp;</a></span>have_nonempty_intersection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> GraphColoring::internal::have_nonempty_intersection </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given two sets of indices that are assumed to be sorted, determine whether they will have a nonempty intersection. The actual intersection is not computed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices1</td><td>A set of indices, assumed sorted. </td></tr>
    <tr><td class="paramname">indices2</td><td>A set of indices, assumed sorted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the two sets of indices do have a nonempty intersection. </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph__coloring_8h_source.html#l00053">53</a> of file <a class="el" href="graph__coloring_8h_source.html">graph_coloring.h</a>.</p>

</div>
</div>
<a id="a0ceedabe337e9a92a970e2a386121e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ceedabe337e9a92a970e2a386121e16">&#9670;&nbsp;</a></span>create_partitioning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;Iterator&gt; &gt; GraphColoring::internal::create_partitioning </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;(const Iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_conflict_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a partitioning of the given range of iterators using a simplified version of the Cuthill-McKee algorithm (Breadth First Search algorithm). The function creates partitions that contain "zones" of iterators where the first partition contains the first iterator, the second zone contains all those iterators that have conflicts with the single element in the first zone, the third zone contains those iterators that have conflicts with the iterators of the second zone and have not previously been assigned to a zone, etc. If the iterators represent cells, then this generates partitions that are like onion shells around the very first cell. Note that elements in each zone may conflict with other elements in the same zone.</p>
<p>The question whether two iterators conflict is determined by a user- provided function. The meaning of this function is discussed in the documentation of the <a class="el" href="namespaceGraphColoring.html#a670720d11f544a762592112ae5213876">GraphColoring::make_graph_coloring()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>The first element of a range of iterators for which a partitioning is sought. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The element past the end of the range of iterators. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get_conflict_indices</td><td>A user defined function object returning a set of indicators that are descriptive of what represents a conflict. See above for a more thorough discussion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of sets of iterators (where sets are represented by std::vector for efficiency). Each element of the outermost set corresponds to the iterators pointing to objects that are in the same partition (i.e., the same zone). </dd></dl>

<p class="definition">Definition at line <a class="el" href="graph__coloring_8h_source.html#l00109">109</a> of file <a class="el" href="graph__coloring_8h_source.html">graph_coloring.h</a>.</p>

</div>
</div>
<a id="abaf2ce58eca7c18a4d7ecd6e2747d690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf2ce58eca7c18a4d7ecd6e2747d690">&#9670;&nbsp;</a></span>make_dsatur_coloring()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GraphColoring::internal::make_dsatur_coloring </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;(const Iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_conflict_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>partition_coloring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function uses DSATUR (Degree SATURation) to color the elements of a set. DSATUR works as follows:</p><ol type="1">
<li>Arrange the vertices by decreasing order of degrees.</li>
<li>Color a vertex of maximal degree with color 1.</li>
<li>Choose a vertex with a maximal saturation degree. If there is equality, choose any vertex of maximal degree in the uncolored subgraph.</li>
<li>Color the chosen vertex with the least possible (lowest numbered) color.</li>
<li>If all the vertices are colored, stop. Otherwise, return to 3.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">partition</td><td>The set of iterators that should be colored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">get_conflict_indices</td><td>A user defined function object returning a set of indicators that are descriptive of what represents a conflict. See above for a more thorough discussion. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">partition_coloring</td><td>A set of sets of iterators (where sets are represented by std::vector for efficiency). Each element of the outermost set corresponds to the iterators pointing to objects that are in the same partition (have the same color) and consequently do not conflict. The elements of different sets may conflict. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="graph__coloring_8h_source.html#l00222">222</a> of file <a class="el" href="graph__coloring_8h_source.html">graph_coloring.h</a>.</p>

</div>
</div>
<a id="ad40b8dbbfb93340082f53e2c85384766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40b8dbbfb93340082f53e2c85384766">&#9670;&nbsp;</a></span>gather_colors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;Iterator&gt; &gt; GraphColoring::internal::gather_colors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; Iterator &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>partition_coloring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a partition-coloring graph, i.e., a set of zones (partitions) each of which is colored, produce a combined coloring for the entire set of iterators. This is possible because any color on an even (resp. odd) zone does not conflict with any color of any other even (resp. odd) zone. Consequently, we can combine colors from all even and all odd zones. This function tries to create colors of similar number of elements. </p>

<p class="definition">Definition at line <a class="el" href="graph__coloring_8h_source.html#l00327">327</a> of file <a class="el" href="graph__coloring_8h_source.html">graph_coloring.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
