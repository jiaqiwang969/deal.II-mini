<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__FE__vs__Mapping__vs__FEValues.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: How Mapping, FiniteElement, and FEValues work together</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">How Mapping, FiniteElement, and FEValues work together<div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for How Mapping, FiniteElement, and FEValues work together:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__FE__vs__Mapping__vs__FEValues.svg" width="364" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</td></tr></table></center>
</div>
<h2>Introduction</h2>
<p>Most people create finite element (and, potentially, mapping) objects once but then never actually call any member functions on them &ndash; they simply use them for assembly via the <a class="el" href="classFEValues.html">FEValues</a> interface. The only other interaction most will have is by reading the <a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">FiniteElementData::dofs_per_cell</a> variable, but that is also just set during construction time. In other words, people never observe <a class="el" href="classFiniteElement.html">FiniteElement</a> or <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> objects actually <em>do</em> anything &ndash; and that is completely by design.</p>
<p>This document is therefore for those who are interested in writing finite element or mapping classes and want to understand how <a class="el" href="classFEValues.html">FEValues</a> works and interacts with the <a class="el" href="classFiniteElement.html">FiniteElement</a> and <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> classes. In the following, we will not make a distinction between <a class="el" href="classFEValues.html">FEValues</a> (which acts on cells), <a class="el" href="classFEFaceValues.html">FEFaceValues</a> (which acts on faces), and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> (which acts on the children of a face of a cell) as they conceptually all work the same. Consequently, the term "FEValues" will be used generally for all three of these classes in the text below.</p>
<h2>Who is responsible for what?</h2>
<p>Before going into detail about data and control flow, let us define which class is responsible for providing what kind of information.</p>
<h3>FEValues objects</h3>
<p><a class="el" href="classFEValues.html">FEValues</a> is an abstraction that derived from the observation that almost everything one ever does in finite element codes only requires the evaluation of finite element shape functions at quadrature points. This could be, for example, the approximation of an integral of the form </p><p class="formulaDsp">
\[ A^K_{ij} = \int_K \nabla \varphi_i(\bf x) \cdot \nabla \varphi_j(\bf x) \; dx \]
</p>
<p> by quadrature </p><p class="formulaDsp">
\[ A^K_{ij} = \sum_q \nabla \varphi_i(\bf x_q) \cdot \nabla \varphi_j(\bf x_q) \; |\text{det}\; J(\bf x_q)| w_q, \]
</p>
<p> but it is equally valid when wanting to generate graphical output: there we only need to know the values of a finite element field at the vertices of a mesh, and this too can be written as evaluating everything at quadrature points &ndash; these quadrature points are then simply the vertices of the cells (provided, for example, by QTrapez).</p>
<p><a class="el" href="classFEValues.html">FEValues</a>' role is to provide a user the values of shape functions, their gradients, etc, at quadrature points. The same is true with some geometric information, e.g., the normal vectors at the quadrature points. To this end, it provides a large number of member functions in the <a class="el" href="classFEValuesBase.html">FEValuesBase</a> base class that allow a user to query basically everything one can ask for in regard to shape functions and geometry information, but only at the quadrature points for which the <a class="el" href="classFEValues.html">FEValues</a> object was initialized.</p>
<p><a class="el" href="classFEValues.html">FEValues</a> does not actually compute this information itself. It really only provides a place to store it, and then orchestrates the interaction between mapping and finite element classes to have them compute what is requested and store the result in the locations provided by <a class="el" href="classFEValues.html">FEValues</a>.</p>
<p>As a final note, recall that <a class="el" href="classFEValues.html">FEValues</a> can provide an incredible array of information, but that almost all of it is not necessary in any given context. For example, to compute the integral above, it is not necessary to know the second derivatives of the shape functions, or to know the normal vectors at quadrature points. To this end, <a class="el" href="classFEValues.html">FEValues</a> uses UpdateFlags in its interactions with the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> and <a class="el" href="classFiniteElement.html">FiniteElement</a> class to determine what actually needs to be computed. This is discussed in slightly more detail in <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a>.</p>
<h3>Mappings</h3>
<p>Mappings (i.e., classes derived from the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> base class) are responsible for everything that has to do with the mapping from the reference (unit) cell \([0,1]^\text{dim}\) to each of the actual cells \(K\subset{\mathbb R}^\text{spacedim}\). This is facilitated by a mapping function \(\mathbf F_K:[0,1]^\text{dim} \mapsto K\). The mapping classes therefore implement interfaces that allow evaluating \(\mathbf F_K\) to map forward points \(\hat{\mathbf x}\) from the reference cell to \(K\), and to map backward from the real cell to the reference cell using \(\mathbf F_K^{-1}\). Other common operations that mappings provide is to map vectors (which you can think of as vectors attached to a point \(\hat{\mathbf x}\) on the reference cell and pointing in certain directions) to their equivalent vectors on the real cell. This is, for example, what one needs to do for the gradients of shape functions: these are vectors defined on the reference cell, and we need to map these gradients to the real cell \(K\). Similar operations can also be defined for matrices (tensors of rank 2, as opposed to vectors which are tensors of rank 1) and higher order tensors.</p>
<p>Many of these mappings do not only need the map \(\mathbf F_K\) itself, but also the gradients of this mapping, typically referred to as the Jacobian \(J_K=\hat\nabla \mathbf F_K\), as well as higher derivatives.</p>
<p>Since <a class="el" href="classFEValues.html">FEValues</a> only ever needs to evaluate these things at quadrature points, mappings do not in general need to provide the ability to evaluate at <em>arbitrary</em> points. Rather, as we will see below, they will be initialized to use a set of quadrature points defined on the reference cell, will then be "re-initialized" for a particular cell, and all further operations will then only require the evaluation of \(\mathbf F_K\) at these quadrature points on the real cell.</p>
<p>The mapping classes then have the dual role to (i) compute geometric information (e.g., the normal vectors, determinants of the Jacobians, etc) and putting them into the data structures from which <a class="el" href="classFEValues.html">FEValues</a> can provide them to the user, and (ii) to provide the support finite elements need to map shape functions and their derivatives from the reference cell to the real cell.</p>
<h3>Finite elements</h3>
<p>Finite element classes (i.e., classes derived from <a class="el" href="classFiniteElement.html">FiniteElement</a>) are responsible for defining their shape functions, derivatives, and many other aspects on the reference cell, but also for computing the mapped values and derivatives on actual cells (obviously with the help of a mapping object). For the current discussion, only the latter role is important.</p>
<p>As with mappings, all that is important for us here is that the finite element classes can provide this information at given quadrature points, and that they can put the computed information into structures provided by <a class="el" href="classFEValues.html">FEValues</a> and from which <a class="el" href="classFEValues.html">FEValues</a> member functions can then pass it on to the user through the member functions in <a class="el" href="classFEValuesBase.html">FEValuesBase</a>.</p>
<h2>What to compute?</h2>
<p>Let's say a user wants to compute the gradients of shape functions, for example to compute the integral above. Then they would initialize an <a class="el" href="classFEValues.html">FEValues</a> object by giving the update_gradients flag (as is done in basically every tutorial program, starting with step-3). What this indicates is that the user expects the <a class="el" href="classFEValues.html">FEValues</a> object to be able to provide the gradients of shape functions on the real cell, but expressed no expectation of any other information.</p>
<p><a class="el" href="classFEValues.html">FEValues</a> will then first have to find out what the mapping and finite element objects actually require of each other to make this happen. This already happens at the time the <a class="el" href="classFEValues.html">FEValues</a> constructor is run. Because the mapping does not depend on the finite element (though the latter does depend on the former), <a class="el" href="classFEValues.html">FEValues</a> first asks the finite element via <a class="el" href="classFiniteElement.html#a7ee9f47da3fcdfc8c1ca7c7a0feb1929">FiniteElement::requires_update_flags()</a> which <em>other</em> pieces of information it also requires to make the user request happen. As an example, if the finite element were of type <a class="el" href="classFE__Q.html">FE_Q</a>, then it would determine that in order to compute the gradients of the shape functions on the real cell \(K\), it will need to compute the gradients of the shape functions on the reference cell (something it can do on its own, without any external help) but that these reference gradients will then have to be multiplied by the inverse of the Jacobian of the mapping, \(J^{-1}_K\), at each of the quadrature points. This multiplication is typically referred to as a <em>covariant transformation</em>, and so <a class="el" href="classFE__Q.html">FE_Q</a>'s implementation of <a class="el" href="classFiniteElement.html#a7ee9f47da3fcdfc8c1ca7c7a0feb1929">FiniteElement::requires_update_flags()</a> function (provided in the intermediate class <a class="el" href="classFE__Poly.html">FE_Poly</a>) will return both the original update_gradients flag as well as update_covariant_transformation.</p>
<p>In a second step, the <a class="el" href="classFEValues.html">FEValues</a> object will then call the corresponding function in the mapping, <a class="el" href="classMapping.html#a4c62b5a55ca40e2b38c6a3a1f460d540">Mapping::requires_update_flags()</a> to determine what is required to provide both update_gradients and update_covariant_transformation. The former is not within the realm of the mapping, so is ignored. The latter will typically require the computation of the Jacobian matrix \(J_K\) first, which a typical mapping class will indicate by adding update_contravariant_transformation to the list.</p>
<h2>Pre-computing things</h2>
<p>At this point, the <a class="el" href="classFEValues.html">FEValues</a> object has found out the complete set of flags indicating what everyone has to compute to satisfy the user request. The next step, still during the construction of the <a class="el" href="classFEValues.html">FEValues</a> object, stems from the realization that many things could be pre-computed once and then re-used every time we move to a real cell. An example would be the fact that to compute the gradients of the shape functions on the real cell, we need to know the gradients of the shape functions on the reference cell (at the quadrature points on the reference cell) and that these will always be the same: every time we visit a new cell, these values will remain the same, so it would be inefficient to re-compute them every time. Similar arguments can be made for some of the information computed by some of the mapping classes.</p>
<p>The <a class="el" href="classFEValues.html">FEValues</a> object therefore initializes both the mapping and the finite element object it points to, using both the quadrature object and the final set of update flags computed as described in the previous section. This initialization involves pre-computing as much as these classes can already pre-compute given the set of update flags, and then storing this information for later use.</p>
<p>The question then arises: where to store this information. In practice, we do not want to store this information in the mapping or finite element object itself, because this would mean that (i) only one <a class="el" href="classFEValues.html">FEValues</a> object could use any given mapping or finite element object at a time, and (ii) that these objects could not be used in a multithreaded context.</p>
<p>Rather, the approach works like this:</p><ul>
<li><p class="startli"><a class="el" href="classFEValues.html">FEValues</a> calls <a class="el" href="classMapping.html#a2fdce92a1ba733f9652de666d3475a34">Mapping::get_data()</a> (and <a class="el" href="classFEFaceValues.html">FEFaceValues</a> calls <a class="el" href="classMapping.html#af3955d81e5bb00f69c566e0890fddeb6">Mapping::get_face_data()</a>, and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> calls <a class="el" href="classMapping.html#aa101c7827bf40a80b9adac393d830af1">Mapping::get_subface_data()</a>) with the quadrature object and the final set of update flags. The implementation of these functions in the classes derived from <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> will then allocate an object of a type derived from <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> where they can store essentially whatever it is they find useful for later re-use. <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> itself does not actually provide any member variables of significance, but it is really left to derived classes what they think they can usefully pre-compute and store already at this time. If a mapping has nothing to pre-compute (or the author of the mapping class is lazy and does not want to think about what could possibly be pre-computed), then such a class would simply derive its own InternalData object from <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> without actually adding any member variables.</p>
<p class="startli">The object so produced is then returned to the calling site in <a class="el" href="classFEValues.html">FEValues</a> and stored by the <a class="el" href="classFEValues.html">FEValues</a> object. It will be handed back every time later on the <a class="el" href="classFEValues.html">FEValues</a> object wants any information from the mapping, thereby providing the mapping object the ability to read the data it had previously stored.</p>
</li>
<li>Secondly, <a class="el" href="classFEValues.html">FEValues</a> also calls <a class="el" href="classFiniteElement.html#a83c2e3851e02752d6b241fd402cc0bcd">FiniteElement::get_data()</a> (and <a class="el" href="classFEFaceValues.html">FEFaceValues</a> calls <a class="el" href="classMapping.html#af3955d81e5bb00f69c566e0890fddeb6">Mapping::get_face_data()</a>, and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> calls <a class="el" href="classMapping.html#aa101c7827bf40a80b9adac393d830af1">Mapping::get_subface_data()</a>), again with the quadrature object and the final set of update flags. These functions do essentially the same as their counterparts in the mappings, and again the object so initialized, this time of a type derived from <a class="el" href="classFiniteElement_1_1InternalDataBase.html">FiniteElement::InternalDataBase</a>, will always be given back to the finite element whenever the <a class="el" href="classFEValues.html">FEValues</a> object wants something from the finite element object at a later time.</li>
</ul>
<p>This approach allows us to use finite element and mapping objects from multiple <a class="el" href="classFEValues.html">FEValues</a> objects at the same time, and possibly from multiple threads at the same time. The point is simply that every user of a finite element or mapping object would hold their own, unique, object returned from the <code>get_data()</code> functions, and that everything that ever happens happens on these objects, rather than on the member variables of the mapping or finite element object itself.</p>
<h2>Computing on a given cell</h2>
<p>All of the previous steps happened at the time the <a class="el" href="classFEValues.html">FEValues</a> object was created. Up to this point, all we did was set up data structures, but nothing useful has been computed so far from the perspective of the user. This only happens when <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> is called on a concrete cell \(K\).</p>
<p>The things <a class="el" href="classFEValues.html">FEValues</a> then does are, in this order:</p>
<ul>
<li><a class="el" href="classFEValues.html">FEValues</a> figures out whether the cell is a translation or other similarly simple transformation of the previous cell for which <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> was called. The result of this, stored in a CellSimilarly::Similarity object will then be passed to mapping and finite element to potentially simplify some computations. For example, if the current cell is simply a translation of the previous one, then there is no need to re-compute the Jacobian matrix \(J_K\) of the mapping (or its inverse) because it will be the same as for the previous cell.</li>
<li>Next, <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> calls <a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a> (and, obviously, <a class="el" href="classFEFaceValues.html">FEFaceValues</a> calls <a class="el" href="classMapping.html#a9baf527d46a7f2391dbb3dd5dc416864">Mapping::fill_fe_face_values()</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> calls <a class="el" href="classMapping.html#a9f7f6025bc3f10e8f7da2c8a68eaff4a">Mapping::fill_fe_subface_values()</a>). The arguments to this function include the cell (or face, or subface) which we are asked to visit, as well as the cell similarity argument from above, a reference to the object we had previously obtained from <a class="el" href="classMapping.html#a2fdce92a1ba733f9652de666d3475a34">Mapping::get_data()</a>, and a reference to an object of type internal::FEValues::MappingRelatedData into which the mapping is supposed to write its results. In particular, it will need to compute all mapping related information previously specified by the update flags, and then write them into the output object. Examples of fields in the output object that the mapping needs to fill are the computation of JxW values, the computation of Jacobian matrices and their inverses, and the normal vectors to cells (if dim is less than spacedim) and faces.</li>
<li><p class="startli">Finally, <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> calls <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> (and, obviously, <a class="el" href="classFEFaceValues.html">FEFaceValues</a> calls <a class="el" href="classFiniteElement.html#a7c5fd937dc322e6028f60c30fc65f185">FiniteElement::fill_fe_face_values()</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> calls <a class="el" href="classFiniteElement.html#ace7af117168f8d0fdb4bbdd516373625">FiniteElement::fill_fe_subface_values()</a>). The arguments to this function include the cell (or face, or subface) which we are asked to visit, as well as the cell similarity argument from above, a reference to the object we had previously obtained from <a class="el" href="classFiniteElement.html#a83c2e3851e02752d6b241fd402cc0bcd">FiniteElement::get_data()</a>, and a reference to an object of type internal::FEValues::MappingRelatedData into which the mapping is supposed to write its results.</p>
<p class="startli">In addition to these, the <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> function also receives references to the mapping object in use, as well as the <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> object we had previously received from <a class="el" href="classMapping.html#a2fdce92a1ba733f9652de666d3475a34">Mapping::get_data()</a>. The reason is that typically, the finite element wants to map values or gradients of shape functions from the reference cell to the actual cell, and these mappings are facilitated by the various <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping::transform()</a> functions &ndash; which all require a reference to the internal object that the <a class="el" href="classFEValues.html">FEValues</a> object had previously acquired from the mapping. This is probably best understood by looking at actual code, and a simple yet instructive example can be found in <a class="el" href="classFE__Poly.html#ace5fffc8621deb2a2bfe10fa5c363bb3">FE_Poly::fill_fe_values()</a>, a function that works on general scalar, polynomial finite element bases.</p>
<p class="startli">As with the mapping, the <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> functions then use whatever information they had previously computed upon construction of the <a class="el" href="classFEValues.html">FEValues</a> object (i.e., when it called <a class="el" href="classFiniteElement.html#a83c2e3851e02752d6b241fd402cc0bcd">FiniteElement::get_data()</a>), and use this and the functions in the mapping to compute whatever was requested as specified by the update flags.</p>
</li>
</ul>
<p>This all done, we are finally in a position to offer the owner of the <a class="el" href="classFEValues.html">FEValues</a> access to the fields originally requested via the update flags. </p>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
