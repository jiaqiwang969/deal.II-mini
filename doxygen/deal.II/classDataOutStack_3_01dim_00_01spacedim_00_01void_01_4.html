<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DataOutStack&lt; dim, spacedim, void &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataOutStack&lt; dim, spacedim, void &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__output.html">Graphical output</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="data__out__stack_8h_source.html">deal.II/numerics/data_out_stack.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataOutStack&lt; dim, spacedim, void &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4__inherit__graph.svg" width="235" height="247"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutStack_3_01dim_00_01spacedim_00_01void_01_4_1_1DataVector.html">DataVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a737990bc628a76b7776e07e3ad756a4d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a737990bc628a76b7776e07e3ad756a4d">VectorType</a> { <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a737990bc628a76b7776e07e3ad756a4dad75f7efc3504e89285a11ab94e69cf95">cell_vector</a>, 
<a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a737990bc628a76b7776e07e3ad756a4da6b822602b016cce0dfc25c25f45cf31c">dof_vector</a>
 }</td></tr>
<tr class="separator:a737990bc628a76b7776e07e3ad756a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adbe2514aa462ef10f3fe68709e07ea16"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#adbe2514aa462ef10f3fe68709e07ea16">~DataOutStack</a> () override=default</td></tr>
<tr class="separator:adbe2514aa462ef10f3fe68709e07ea16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f3e03fbfb4a93c1a0348c3433bd960"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a74f3e03fbfb4a93c1a0348c3433bd960">new_parameter_value</a> (const <a class="el" href="classdouble.html">double</a> parameter_value, const <a class="el" href="classdouble.html">double</a> <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a5e5f79d299002c05e45f7a70599f08ad">parameter_step</a>)</td></tr>
<tr class="separator:a74f3e03fbfb4a93c1a0348c3433bd960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e1e8ae5bec85361ea080216e40c7ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a01e1e8ae5bec85361ea080216e40c7ee">attach_dof_handler</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a64c89aa6091375cb913fbf16ba80c0a2">dof_handler</a>)</td></tr>
<tr class="separator:a01e1e8ae5bec85361ea080216e40c7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6254eb2f04eed1f6f17c805b0636c83b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a6254eb2f04eed1f6f17c805b0636c83b">declare_data_vector</a> (const std::string &amp;name, const <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a737990bc628a76b7776e07e3ad756a4d">VectorType</a> vector_type)</td></tr>
<tr class="separator:a6254eb2f04eed1f6f17c805b0636c83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a1f79fd7325d1155e19dd8da8c0109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a72a1f79fd7325d1155e19dd8da8c0109">declare_data_vector</a> (const std::vector&lt; std::string &gt; &amp;name, const <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a737990bc628a76b7776e07e3ad756a4d">VectorType</a> vector_type)</td></tr>
<tr class="separator:a72a1f79fd7325d1155e19dd8da8c0109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd91752148edf74e744e9bd9cdc0051e"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:abd91752148edf74e744e9bd9cdc0051e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#abd91752148edf74e744e9bd9cdc0051e">add_data_vector</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;vec, const std::string &amp;name)</td></tr>
<tr class="separator:abd91752148edf74e744e9bd9cdc0051e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e1792062f5f46f9cb1a87d16e55b95"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a37e1792062f5f46f9cb1a87d16e55b95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a37e1792062f5f46f9cb1a87d16e55b95">add_data_vector</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;vec, const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="separator:a37e1792062f5f46f9cb1a87d16e55b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a1bd677ab1d6463145368e1f85b4e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#ad4a1bd677ab1d6463145368e1f85b4e6">build_patches</a> (const unsigned <a class="el" href="classint.html">int</a> n_subdivisions=0)</td></tr>
<tr class="separator:ad4a1bd677ab1d6463145368e1f85b4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7948968e2bf1071fc3cdb21e61f49b96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a7948968e2bf1071fc3cdb21e61f49b96">finish_parameter_value</a> ()</td></tr>
<tr class="separator:a7948968e2bf1071fc3cdb21e61f49b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111ffc8cc587dba65142e2962e89937f"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a111ffc8cc587dba65142e2962e89937f">memory_consumption</a> () const</td></tr>
<tr class="separator:a111ffc8cc587dba65142e2962e89937f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef921f712eba5a6f05f6a5612d7237a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a4ef921f712eba5a6f05f6a5612d7237a">DeclException1</a> (ExcVectorNotDeclared, std::string,&lt;&lt; &quot;The data vector for which the first component has the name &quot;&lt;&lt; arg1&lt;&lt; &quot; has not been added before.&quot;)</td></tr>
<tr class="separator:a4ef921f712eba5a6f05f6a5612d7237a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90e63a2704c3d906d1ae0b7b0297f53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#af90e63a2704c3d906d1ae0b7b0297f53">DeclExceptionMsg</a> (ExcDataNotCleared, &quot;You cannot start a new time/<a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#add7533e80af092527d38d3f07c9e09c6">parameter</a> step before calling &quot; &quot;<a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a7948968e2bf1071fc3cdb21e61f49b96">finish_parameter_value</a>() on the previous step.&quot;)</td></tr>
<tr class="separator:af90e63a2704c3d906d1ae0b7b0297f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0913c808d7cb36e15fcdd7fd4f8ad165"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a0913c808d7cb36e15fcdd7fd4f8ad165">DeclExceptionMsg</a> (ExcDataAlreadyAdded, &quot;You cannot declare additional vectors after already calling &quot; &quot;<a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#ad4a1bd677ab1d6463145368e1f85b4e6">build_patches</a>(). All data vectors need to be declared &quot; &quot;before you call this function the first time.&quot;)</td></tr>
<tr class="separator:a0913c808d7cb36e15fcdd7fd4f8ad165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad840e019263d0f50e17643f384985bec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#ad840e019263d0f50e17643f384985bec">DeclException1</a> (ExcNameAlreadyUsed, std::string,&lt;&lt; &quot;You tried to declare a component of a data vector with &quot;&lt;&lt; &quot;the name &lt;&quot;&lt;&lt; arg1&lt;&lt; &quot;&gt;, but that name is already used.&quot;)</td></tr>
<tr class="separator:ad840e019263d0f50e17643f384985bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc05be5cd920b234e68548735852446e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#afc05be5cd920b234e68548735852446e">write_dx</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:afc05be5cd920b234e68548735852446e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2031a2a6fe56c9b7d3f9f338f20882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#aea2031a2a6fe56c9b7d3f9f338f20882">write_eps</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:aea2031a2a6fe56c9b7d3f9f338f20882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f2c3305058c94333d8aa699286b807"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ae7f2c3305058c94333d8aa699286b807">write_gmv</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ae7f2c3305058c94333d8aa699286b807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85407e870a68179ebe62410d9efc153f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a85407e870a68179ebe62410d9efc153f">write_gnuplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a85407e870a68179ebe62410d9efc153f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a15f01cb0171da2956be68ad496cd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a33a15f01cb0171da2956be68ad496cd0">write_povray</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a33a15f01cb0171da2956be68ad496cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980b995a6f5944a75721097de39069c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a980b995a6f5944a75721097de39069c1">write_tecplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a980b995a6f5944a75721097de39069c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf06b8647892769140884b3ab44a08e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a2bf06b8647892769140884b3ab44a08e">write_ucd</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a2bf06b8647892769140884b3ab44a08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad99726038e4fca7f605fdffb3317e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:acad99726038e4fca7f605fdffb3317e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c780f93105e0daaa76c6c43694b4ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a93c780f93105e0daaa76c6c43694b4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df488dad82b811ceb08cb1adf9eafcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a> (const std::string &amp;filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a5df488dad82b811ceb08cb1adf9eafcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eff778443cd0431cd807c45b6ae16d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (std::ostream &amp;out, const std::vector&lt; std::string &gt; &amp;piece_names) const</td></tr>
<tr class="separator:a1eff778443cd0431cd807c45b6ae16d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0864e51eb173c87e2a3edc9391ea8009"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a> (const std::string &amp;directory, const std::string &amp;filename_without_extension, const unsigned <a class="el" href="classint.html">int</a> counter, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator, const unsigned <a class="el" href="classint.html">int</a> n_digits_for_counter=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const unsigned <a class="el" href="classint.html">int</a> n_groups=0) const</td></tr>
<tr class="separator:a0864e51eb173c87e2a3edc9391ea8009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56595d7d5aebfb2b3abfdaad51df20d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ab56595d7d5aebfb2b3abfdaad51df20d">write_svg</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ab56595d7d5aebfb2b3abfdaad51df20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affac60e1e3799ae884642113a8e2e723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#affac60e1e3799ae884642113a8e2e723">write_deal_II_intermediate</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:affac60e1e3799ae884642113a8e2e723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ef5cf2b6515c10ff080729a9901155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXDMFEntry.html">XDMFEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a45ef5cf2b6515c10ff080729a9901155">create_xdmf_entry</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;h5_filename, const <a class="el" href="classdouble.html">double</a> cur_time, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a45ef5cf2b6515c10ff080729a9901155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0b3eec5ee65bd7915c4e46272287eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXDMFEntry.html">XDMFEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a0f0b3eec5ee65bd7915c4e46272287eb">create_xdmf_entry</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;h5_mesh_filename, const std::string &amp;h5_solution_filename, const <a class="el" href="classdouble.html">double</a> cur_time, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a0f0b3eec5ee65bd7915c4e46272287eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfab5d02f11dcede67bb61ff3ae105d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#abfab5d02f11dcede67bb61ff3ae105d2">write_xdmf_file</a> (const std::vector&lt; <a class="el" href="classXDMFEntry.html">XDMFEntry</a> &gt; &amp;entries, const std::string &amp;filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:abfab5d02f11dcede67bb61ff3ae105d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29468f4e8eca1367d44b1a2431d39e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a29468f4e8eca1367d44b1a2431d39e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fdf1cc5071d85ecb2d707d798bf063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a78fdf1cc5071d85ecb2d707d798bf063">write_hdf5_parallel</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const <a class="el" href="classbool.html">bool</a> write_mesh_file, const std::string &amp;mesh_filename, const std::string &amp;solution_filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a78fdf1cc5071d85ecb2d707d798bf063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154d8192688eef96f052f50c2f669aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a154d8192688eef96f052f50c2f669aa8">write_filtered_data</a> (<a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;filtered_data) const</td></tr>
<tr class="separator:a154d8192688eef96f052f50c2f669aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e73ad285a8792ff0f9f227b82eb108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a> (std::ostream &amp;out, const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format=<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a>) const</td></tr>
<tr class="separator:a78e73ad285a8792ff0f9f227b82eb108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dab6e0fed8d4ad90d658f71a68eb32c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a6dab6e0fed8d4ad90d658f71a68eb32c">set_default_format</a> (const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> default_format)</td></tr>
<tr class="separator:a6dab6e0fed8d4ad90d658f71a68eb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7280a24690b117454acfb0fa058299c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a> (const FlagType &amp;flags)</td></tr>
<tr class="separator:ac7280a24690b117454acfb0fa058299c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36120ca3f536c90709e135161030f16c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a> (const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format=<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a>) const</td></tr>
<tr class="separator:a36120ca3f536c90709e135161030f16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a975649e4516ee7c7a67ae2f8dddd97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a> (<a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</td></tr>
<tr class="separator:a0a975649e4516ee7c7a67ae2f8dddd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1f2f1d644d9cb1c4d1714d5173d159f2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">declare_parameters</a> (<a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</td></tr>
<tr class="separator:a1f2f1d644d9cb1c4d1714d5173d159f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8c98ce4fee01d6f3f1f181473ef56827"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a8c98ce4fee01d6f3f1f181473ef56827">patch_dim</a> = dim + 1</td></tr>
<tr class="separator:a8c98ce4fee01d6f3f1f181473ef56827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bea620f8fc49c190a7a9de9882a307"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#af3bea620f8fc49c190a7a9de9882a307">patch_spacedim</a> = spacedim + 1</td></tr>
<tr class="separator:af3bea620f8fc49c190a7a9de9882a307"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a05d5d72abcf81f4174e15fd984f1267c"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a05d5d72abcf81f4174e15fd984f1267c">get_nonscalar_data_ranges</a> () const</td></tr>
<tr class="separator:a05d5d72abcf81f4174e15fd984f1267c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3292ed269dfb832d20ae35db4177473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ac3292ed269dfb832d20ae35db4177473">validate_dataset_names</a> () const</td></tr>
<tr class="separator:ac3292ed269dfb832d20ae35db4177473"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a072edd6d53d1c5a1e4c71af22a123228"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a072edd6d53d1c5a1e4c71af22a123228">default_subdivisions</a></td></tr>
<tr class="separator:a072edd6d53d1c5a1e4c71af22a123228"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a74f241c703c02c9c3268f075b7ac02e9"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt;::<a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt; <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::<a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a8c98ce4fee01d6f3f1f181473ef56827">patch_dim</a>, <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::<a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#af3bea620f8fc49c190a7a9de9882a307">patch_spacedim</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a74f241c703c02c9c3268f075b7ac02e9">get_patches</a> () const override</td></tr>
<tr class="separator:a74f241c703c02c9c3268f075b7ac02e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c9fc801b1b6598906b7b2c22f5e7ac"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#aa8c9fc801b1b6598906b7b2c22f5e7ac">get_dataset_names</a> () const override</td></tr>
<tr class="separator:aa8c9fc801b1b6598906b7b2c22f5e7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:add7533e80af092527d38d3f07c9e09c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#add7533e80af092527d38d3f07c9e09c6">parameter</a></td></tr>
<tr class="separator:add7533e80af092527d38d3f07c9e09c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5f79d299002c05e45f7a70599f08ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a5e5f79d299002c05e45f7a70599f08ad">parameter_step</a></td></tr>
<tr class="separator:a5e5f79d299002c05e45f7a70599f08ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c89aa6091375cb913fbf16ba80c0a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;, <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a64c89aa6091375cb913fbf16ba80c0a2">dof_handler</a></td></tr>
<tr class="separator:a64c89aa6091375cb913fbf16ba80c0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac483f105d4890e24ee4539746dc6ec50"><td class="memItemLeft" align="right" valign="top">std::vector&lt;::<a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt; <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a8c98ce4fee01d6f3f1f181473ef56827">patch_dim</a>, <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#af3bea620f8fc49c190a7a9de9882a307">patch_spacedim</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#ac483f105d4890e24ee4539746dc6ec50">patches</a></td></tr>
<tr class="separator:ac483f105d4890e24ee4539746dc6ec50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1804273e1040510380c67c4fac4fea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; DataVector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a7a1804273e1040510380c67c4fac4fea">dof_data</a></td></tr>
<tr class="separator:a7a1804273e1040510380c67c4fac4fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7493de62dae9e779feb23cf65f6911a2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; DataVector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a7493de62dae9e779feb23cf65f6911a2">cell_data</a></td></tr>
<tr class="separator:a7493de62dae9e779feb23cf65f6911a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim&gt;<br />
class DataOutStack&lt; dim, spacedim, void &gt;</h3>

<p>This class is used to stack the output from several computations into one output file by stacking the data sets in another coordinate direction orthogonal to the space directions. The most common use is to stack the results of several time steps into one space-time output file, or for example to connect the results of solutions of a parameter dependent equation for several parameter value together into one. The interface is mostly modelled after the <a class="el" href="classDataOut.html">DataOut</a> class, see there for some more documentation. The class is used in step-78.</p>
<p>We will explain the concept for a time dependent problem, but instead of the time any parameter can be substituted. In our example, a solution of an equation is computed for each discrete time level. This is then added to an object of the present class and after all time levels are added, a space- time plot will be written in any of the output formats supported by the base class. Upon output, the (spatial) solution on each time level is extended into the time direction by writing it twice, once for the time level itself and once for a time equal to the time level minus a given time step. These two copies are connected, to form a space-time slab, with constant values in time.</p>
<p>Due to the piecewise constant output in time, the written solution will in general be discontinuous at discrete time levels, but the output is still sufficient in most cases. More sophisticated interpolations in time may be added in the future.</p>
<h3>Example of use</h3>
<p>The following little example shall illustrate the different steps of use of this class. It is assumed that the finite element used is composed of two components, <code>u</code> and <code>v</code>, that the solution vector is named <code>solution</code> and that a vector <code>error</code> is computed which contains an error indicator for each spatial cell.</p>
<p>Note that unlike for the <a class="el" href="classDataOut.html">DataOut</a> class it is necessary to first declare data vectors and the names of the components before first use. This is because on all time levels the same data should be present to produce reasonable time-space output. The output is generated with two subdivisions in each space and time direction, which is suitable for quadratic finite elements in space, for example.</p>
<div class="fragment"><div class="line"><a class="code" href="classDataOutStack.html">DataOutStack&lt;dim&gt;</a> data_out_stack;</div><div class="line"></div><div class="line">                               <span class="comment">// first declare the vectors</span></div><div class="line">                               <span class="comment">// to be used later</span></div><div class="line">std::vector&lt;std::string&gt; solution_names;</div><div class="line">solution_names.emplace_back (<span class="stringliteral">&quot;u&quot;</span>);</div><div class="line">solution_names.emplace_back (<span class="stringliteral">&quot;v&quot;</span>);</div><div class="line">data_out_stack.declare_data_vector (solution_names,</div><div class="line">                                    <a class="code" href="classDataOutStack.html">DataOutStack&lt;dim&gt;::dof_vector</a>);</div><div class="line">data_out_stack.declare_data_vector (<span class="stringliteral">&quot;error&quot;</span>,</div><div class="line">                                    <a class="code" href="classDataOutStack.html">DataOutStack&lt;dim&gt;::cell_vector</a>);</div><div class="line"></div><div class="line">                               <span class="comment">// now do computations</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">double</span> <a class="code" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#add7533e80af092527d38d3f07c9e09c6">parameter</a>=0; ...)</div><div class="line">  {</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim,spacedim&gt;</a> <a class="code" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a64c89aa6091375cb913fbf16ba80c0a2">dof_handler</a>;</div><div class="line">    ...                        <span class="comment">// compute something</span></div><div class="line"></div><div class="line">                               <span class="comment">// now for output</span></div><div class="line">    data_out_stack.new_parameter_value (<a class="code" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#add7533e80af092527d38d3f07c9e09c6">parameter</a>,</div><div class="line">                                        delta_parameter);</div><div class="line">    data_out_stack.attach_dof_handler (dof_handler);</div><div class="line">    data_out_stack.add_data_vector (solution, solution_names);</div><div class="line">    data_out_stack.add_data_vector (error, <span class="stringliteral">&quot;error&quot;</span>);</div><div class="line">    data_out_stack.build_patches (2);</div><div class="line">    data_out_stack.finish_parameter_value ();</div><div class="line">  };</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="data__out__stack_8h_source.html#l00134">134</a> of file <a class="el" href="data__out__stack_8h_source.html">data_out_stack.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a737990bc628a76b7776e07e3ad756a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737990bc628a76b7776e07e3ad756a4d">&#9670;&nbsp;</a></span>VectorType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::<a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a737990bc628a76b7776e07e3ad756a4d">VectorType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data type declaring the two types of vectors which are used in this class. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a737990bc628a76b7776e07e3ad756a4dad75f7efc3504e89285a11ab94e69cf95"></a>cell_vector&#160;</td><td class="fielddoc"><p>The data describes one value for each cell. </p>
</td></tr>
<tr><td class="fieldname"><a id="a737990bc628a76b7776e07e3ad756a4da6b822602b016cce0dfc25c25f45cf31c"></a>dof_vector&#160;</td><td class="fielddoc"><p>The data describes one value for each DoF. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="data__out__stack_8h_source.html#l00150">150</a> of file <a class="el" href="data__out__stack_8h_source.html">data_out_stack.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adbe2514aa462ef10f3fe68709e07ea16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe2514aa462ef10f3fe68709e07ea16">&#9670;&nbsp;</a></span>~DataOutStack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::~<a class="el" href="classDataOutStack.html">DataOutStack</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Only declared to make it <code>virtual</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a74f3e03fbfb4a93c1a0348c3433bd960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f3e03fbfb4a93c1a0348c3433bd960">&#9670;&nbsp;</a></span>new_parameter_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::new_parameter_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>parameter_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>parameter_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the next set of data for a specific parameter value. The argument <code>parameter_step</code> denotes the interval (in backward direction, counted from <code>parameter_value</code>) with which the output will be extended in parameter direction, i.e. orthogonal to the space directions. </p>

</div>
</div>
<a id="a01e1e8ae5bec85361ea080216e40c7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e1e8ae5bec85361ea080216e40c7ee">&#9670;&nbsp;</a></span>attach_dof_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::attach_dof_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach the DoF handler for the grid and data associated with the parameter previously set by <code>new_parameter_value</code>.</p>
<p>This has to happen before adding data vectors for the present parameter value. </p>

</div>
</div>
<a id="a6254eb2f04eed1f6f17c805b0636c83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6254eb2f04eed1f6f17c805b0636c83b">&#9670;&nbsp;</a></span>declare_data_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::declare_data_vector </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a737990bc628a76b7776e07e3ad756a4d">VectorType</a>&#160;</td>
          <td class="paramname"><em>vector_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a data vector. The <code>vector_type</code> argument determines whether the data vector will be considered as DoF or cell data.</p>
<p>This version may be called if the finite element presently used by the <a class="el" href="classDoFHandler.html">DoFHandler</a> (and previously attached to this object) has only one component and therefore only one name needs to be given. </p>

</div>
</div>
<a id="a72a1f79fd7325d1155e19dd8da8c0109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a1f79fd7325d1155e19dd8da8c0109">&#9670;&nbsp;</a></span>declare_data_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::declare_data_vector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a737990bc628a76b7776e07e3ad756a4d">VectorType</a>&#160;</td>
          <td class="paramname"><em>vector_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a data vector. The <code>vector_type</code> argument determines whether the data vector will be considered as DoF or cell data.</p>
<p>This version must be called if the finite element presently used by the <a class="el" href="classDoFHandler.html">DoFHandler</a> (and previously attached to this object) has more than one component and therefore more than one name needs to be given. However, you can also call this function with a <code>std::vector&lt;std::string&gt;</code> containing only one element if the finite element has only one component. </p>

</div>
</div>
<a id="abd91752148edf74e744e9bd9cdc0051e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd91752148edf74e744e9bd9cdc0051e">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a data vector for the presently set value of the parameter.</p>
<p>This version may be called if the finite element presently used by the <a class="el" href="classDoFHandler.html">DoFHandler</a> (and previously attached to this object) has only one component and therefore only one name needs to be given.</p>
<p>If <code>vec</code> is a vector with multiple components this function will generate distinct names for all components by appending an underscore and the number of each component to <code>name</code> </p>
<p>The data vector must have been registered using the <code>declare_data_vector</code> function before actually using it the first time.</p>
<p>Note that a copy of this vector is stored until <code>finish_parameter_value</code> is called the next time, so if you are short of memory you may want to call this function only after all computations involving large matrices are already done. </p>

</div>
</div>
<a id="a37e1792062f5f46f9cb1a87d16e55b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e1792062f5f46f9cb1a87d16e55b95">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a data vector for the presently set value of the parameter.</p>
<p>This version must be called if the finite element presently used by the <a class="el" href="classDoFHandler.html">DoFHandler</a> (and previously attached to this object) has more than one component and therefore more than one name needs to be given. However, you can also call this function with a <code>std::vector&lt;std::string&gt;</code> containing only one element if the finite element has only one component.</p>
<p>The data vector must have been registered using the <code>declare_data_vector</code> function before actually using it the first time.</p>
<p>Note that a copy of this vector is stored until <code>finish_parameter_value</code> is called the next time, so if you are short of memory you may want to call this function only after all computations involving large matrices are already done. </p>

</div>
</div>
<a id="ad4a1bd677ab1d6463145368e1f85b4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a1bd677ab1d6463145368e1f85b4e6">&#9670;&nbsp;</a></span>build_patches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::build_patches </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_subdivisions</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the central function of this class since it builds the list of patches to be written by the low-level functions of the base class. A patch is, in essence, some intermediate representation of the data on each cell of a triangulation and <a class="el" href="classDoFHandler.html">DoFHandler</a> object that can then be used to write files in some format that is readable by visualization programs.</p>
<p>You can find an overview of the use of this function in the general documentation of this class. An example is also provided in the documentation of this class's base class <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_subdivisions</td><td>See <a class="el" href="classDataOut.html#ab6b584c378c08f9b7ee4ca474405fed0">DataOut::build_patches()</a> for an extensive description of this parameter. The number of subdivisions is always one in the direction of the time-like parameter used by this class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7948968e2bf1071fc3cdb21e61f49b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7948968e2bf1071fc3cdb21e61f49b96">&#9670;&nbsp;</a></span>finish_parameter_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::finish_parameter_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release all data that is no more needed once <code>build_patches</code> was called and all other transactions for a given parameter value are done.</p>
<p>Counterpart of <code>new_parameter_value</code>. </p>

</div>
</div>
<a id="a111ffc8cc587dba65142e2962e89937f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111ffc8cc587dba65142e2962e89937f">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="a4ef921f712eba5a6f05f6a5612d7237a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef921f712eba5a6f05f6a5612d7237a">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcVectorNotDeclared&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The data vector for which the first component has the name &quot;&lt;&lt; arg1&lt;&lt; &quot; has not been added before.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="af90e63a2704c3d906d1ae0b7b0297f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90e63a2704c3d906d1ae0b7b0297f53">&#9670;&nbsp;</a></span>DeclExceptionMsg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcDataNotCleared&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;You cannot start a new time/<a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#add7533e80af092527d38d3f07c9e09c6">parameter</a> step before calling &quot; &quot;<a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a7948968e2bf1071fc3cdb21e61f49b96">finish_parameter_value</a>() on the previous step.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a0913c808d7cb36e15fcdd7fd4f8ad165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0913c808d7cb36e15fcdd7fd4f8ad165">&#9670;&nbsp;</a></span>DeclExceptionMsg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcDataAlreadyAdded&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;You cannot declare additional vectors after already calling &quot; &quot;<a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#ad4a1bd677ab1d6463145368e1f85b4e6">build_patches</a>(). All data vectors need to be declared &quot; &quot;before you call this function the first time.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ad840e019263d0f50e17643f384985bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad840e019263d0f50e17643f384985bec">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcNameAlreadyUsed&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a74f241c703c02c9c3268f075b7ac02e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f241c703c02c9c3268f075b7ac02e9">&#9670;&nbsp;</a></span>get_patches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;::<a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt; <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt;dim, spacedim, void&gt;::<a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a8c98ce4fee01d6f3f1f181473ef56827">patch_dim</a>, <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt;dim, spacedim, void&gt;::<a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#af3bea620f8fc49c190a7a9de9882a307">patch_spacedim</a>&gt; &gt;&amp; <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::get_patches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the function through which derived classes propagate preprocessed data in the form of Patch structures (declared in the base class <a class="el" href="namespaceDataOutBase.html">DataOutBase</a>) to the actual output function. </p>

<p>Implements <a class="el" href="classDataOutInterface.html#a7c3eeef4bc56cdb85c31e05dc09dae72">DataOutInterface&lt; dim+1, spacedim+1 &gt;</a>.</p>

</div>
</div>
<a id="aa8c9fc801b1b6598906b7b2c22f5e7ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c9fc801b1b6598906b7b2c22f5e7ac">&#9670;&nbsp;</a></span>get_dataset_names()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::get_dataset_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual function through which the names of data sets are obtained by the output functions of the base class. </p>

<p>Implements <a class="el" href="classDataOutInterface.html#a128e5dec286cc1a429b94e29dd55ab81">DataOutInterface&lt; dim+1, spacedim+1 &gt;</a>.</p>

</div>
</div>
<a id="afc05be5cd920b234e68548735852446e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc05be5cd920b234e68548735852446e">&#9670;&nbsp;</a></span>write_dx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_dx </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a74f241c703c02c9c3268f075b7ac02e9">get_patches()</a> and write it to <code>out</code> in OpenDX format. See <a class="el" href="namespaceDataOutBase.html#a75750d50e3d27159f8a1e4de7f0a8f32">DataOutBase::write_dx</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07130">7130</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="aea2031a2a6fe56c9b7d3f9f338f20882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2031a2a6fe56c9b7d3f9f338f20882">&#9670;&nbsp;</a></span>write_eps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_eps </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a74f241c703c02c9c3268f075b7ac02e9">get_patches()</a> and write it to <code>out</code> in EPS format. See <a class="el" href="namespaceDataOutBase.html#a98914588b1516419a572a1718b1bf3d5">DataOutBase::write_eps</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07182">7182</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ae7f2c3305058c94333d8aa699286b807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f2c3305058c94333d8aa699286b807">&#9670;&nbsp;</a></span>write_gmv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_gmv </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a74f241c703c02c9c3268f075b7ac02e9">get_patches()</a> and write it to <code>out</code> in GMV format. See <a class="el" href="namespaceDataOutBase.html#afa4389cfc36770d2881867f6889bc348">DataOutBase::write_gmv</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07195">7195</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a85407e870a68179ebe62410d9efc153f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85407e870a68179ebe62410d9efc153f">&#9670;&nbsp;</a></span>write_gnuplot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_gnuplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a74f241c703c02c9c3268f075b7ac02e9">get_patches()</a> and write it to <code>out</code> in GNUPLOT format. See <a class="el" href="namespaceDataOutBase.html#a3cfd561a7b5262f83e3cdc4020b377f4">DataOutBase::write_gnuplot</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07156">7156</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a33a15f01cb0171da2956be68ad496cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a15f01cb0171da2956be68ad496cd0">&#9670;&nbsp;</a></span>write_povray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_povray </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a74f241c703c02c9c3268f075b7ac02e9">get_patches()</a> and write it to <code>out</code> in POVRAY format. See <a class="el" href="namespaceDataOutBase.html#ae661c9d7979da0c39b5f08fd715ed947">DataOutBase::write_povray</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07169">7169</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a980b995a6f5944a75721097de39069c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980b995a6f5944a75721097de39069c1">&#9670;&nbsp;</a></span>write_tecplot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_tecplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a74f241c703c02c9c3268f075b7ac02e9">get_patches()</a> and write it to <code>out</code> in Tecplot format. See <a class="el" href="namespaceDataOutBase.html#ab9f9f33c200120450b6844d986a83604">DataOutBase::write_tecplot</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07208">7208</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a2bf06b8647892769140884b3ab44a08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf06b8647892769140884b3ab44a08e">&#9670;&nbsp;</a></span>write_ucd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_ucd </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a74f241c703c02c9c3268f075b7ac02e9">get_patches()</a> and write it to <code>out</code> in UCD format for AVS. See <a class="el" href="namespaceDataOutBase.html#a5ec32be3e3379b7c83dc339f52cf2ad6">DataOutBase::write_ucd</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07143">7143</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="acad99726038e4fca7f605fdffb3317e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad99726038e4fca7f605fdffb3317e4">&#9670;&nbsp;</a></span>write_vtk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtk </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a74f241c703c02c9c3268f075b7ac02e9">get_patches()</a> and write it to <code>out</code> in Vtk format. See <a class="el" href="namespaceDataOutBase.html#a336d97147011f5f8f3746cac0a3ca4ab">DataOutBase::write_vtk</a>.</p>
<dl class="section note"><dt>Note</dt><dd>VTK is a legacy format and has largely been supplanted by the VTU format (an XML-structured version of VTK). In particular, VTU allows for the compression of data and consequently leads to much smaller file sizes that equivalent VTK files for large files. Since all visualization programs that support VTK also support VTU, you should consider using the latter file format instead, by using the <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu()</a> function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07221">7221</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a93c780f93105e0daaa76c6c43694b4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c780f93105e0daaa76c6c43694b4ae">&#9670;&nbsp;</a></span>write_vtu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtu </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a74f241c703c02c9c3268f075b7ac02e9">get_patches()</a> and write it to <code>out</code> in Vtu (VTK's XML) format. See <a class="el" href="namespaceDataOutBase.html#a3aec479936b78bd0ec2ecc3674e24584">DataOutBase::write_vtu</a>.</p>
<p>Some visualization programs, such as ParaView, can read several separate VTU files to parallelize visualization. In that case, you need a <code>.pvtu</code> file that describes which VTU files form a group. The <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a> function can generate such a centralized record. Likewise, <a class="el" href="namespaceDataOutBase.html#a482d9621dcc87d6a43cf8a9651e16cd8">DataOutInterface::write_visit_record()</a> does the same for older versions of VisIt (although VisIt can also read <code>pvtu</code> records since version 2.5.1). Finally, <a class="el" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutInterface::write_pvd_record()</a> can be used to group together the files that jointly make up a time dependent simulation. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07232">7232</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a5df488dad82b811ceb08cb1adf9eafcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df488dad82b811ceb08cb1adf9eafcd">&#9670;&nbsp;</a></span>write_vtu_in_parallel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtu_in_parallel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collective MPI call to write the solution from all participating nodes (those in the given communicator) to a single compressed .vtu file on a shared file system. The communicator can be a sub communicator of the one used by the computation. This routine uses MPI I/O to achieve high performance on parallel filesystems. Also see <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07254">7254</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a1eff778443cd0431cd807c45b6ae16d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eff778443cd0431cd807c45b6ae16d9">&#9670;&nbsp;</a></span>write_pvtu_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_pvtu_record </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>piece_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Some visualization programs, such as ParaView, can read several separate VTU files that all form part of the same simulation, in order to parallelize visualization. In that case, you need a <code>.pvtu</code> file that describes which VTU files (written, for example, through the <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> function) form a group. The current function can generate such a centralized record.</p>
<p>The central record file generated by this function contains a list of (scalar or vector) fields that describes which fields can actually be found in the individual files that comprise the set of parallel VTU files along with the names of these files. This function gets the names and types of fields through the <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#aa8c9fc801b1b6598906b7b2c22f5e7ac">get_dataset_names()</a> and <a class="el" href="classDataOutInterface.html#a05d5d72abcf81f4174e15fd984f1267c">get_nonscalar_data_ranges()</a> functions of this class. The second argument to this function specifies the names of the files that form the parallel set.</p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="namespaceDataOutBase.html#a3aec479936b78bd0ec2ecc3674e24584">DataOutBase::write_vtu()</a> and <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> for writing each piece. Also note that only one parallel process needs to call the current function, listing the names of the files written by all parallel processes.</dd>
<dd>
The use of this function is explained in step-40.</dd>
<dd>
In order to tell Paraview to group together multiple <code>pvtu</code> files that each describe one time step of a time dependent simulation, see the <a class="el" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record()</a> function.</dd>
<dd>
Older versions of VisIt (before 2.5.1), can not read <code>pvtu</code> records. However, it can read visit records as written by the <a class="el" href="namespaceDataOutBase.html#a482d9621dcc87d6a43cf8a9651e16cd8">write_visit_record()</a> function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07357">7357</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a0864e51eb173c87e2a3edc9391ea8009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0864e51eb173c87e2a3edc9391ea8009">&#9670;&nbsp;</a></span>write_vtu_with_pvtu_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtu_with_pvtu_record </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_without_extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_digits_for_counter</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_groups</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function writes several .vtu files and a .pvtu record in parallel and constructs the filenames automatically. It is a combination of <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> or <a class="el" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">DataOutInterface::write_vtu_in_parallel()</a>, and <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a>.</p>
<p>For example, running <code> write_vtu_with_pvtu_record("output/", "solution", 3, comm, 4, 2) </code> on 10 processes generates the files </p><div class="fragment"><div class="line">output/solution_0003.0.<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a></div><div class="line">output/solution_0003.1.<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a></div><div class="line">output/solution_0003.pvtu</div></div><!-- fragment --><p> where the <code>.0.vtu</code> file contains the output of the first half of the processes grouped together, and the <code>.1.vtu</code> the data from the remaining half.</p>
<p>A specified <code>directory</code> and a <code>filename_without_extension</code> form the first part of the filename. The filename is then extended with a <code>counter</code> labeling the current timestep/iteration/etc., the processor ID, and finally the .vtu/.pvtu ending. Since the number of timesteps to be written depends on the application, the number of digits to be reserved in the filename can be specified as parameter <code>n_digits_for_counter</code>, and the number is not padded with leading zeros if this parameter is left at its default value <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>. If more than one file identifier is needed (e.g. time step number and iteration counter of solver), the last identifier is used as <code>counter</code>, while all other identifiers have to be added to <code>filename_without_extension</code> when calling this function.</p>
<p>In a parallel setting, several files are typically written per time step. The number of files written in parallel depends on the number of MPI processes (see parameter <code>mpi_communicator</code>), and a specified number of <code>n_groups</code> with default value 0. The background is that VTU file output supports grouping files from several CPUs into a given number of files using MPI I/O when writing on a parallel filesystem. The default value of <code>n_groups</code> is 0, meaning that every MPI rank will write one file. A value of 1 will generate one big file containing the solution over the whole domain, while a larger value will create <code>n_groups</code> files (but not more than there are MPI ranks).</p>
<p>Note that only one processor needs to generate the .pvtu file, where processor zero is chosen to take over this job.</p>
<p>The return value is the filename of the centralized file for the pvtu record.</p>
<dl class="section note"><dt>Note</dt><dd>The code simply combines the strings <code>directory</code> and <code>filename_without_extension</code>, i.e., the user has to make sure that <code>directory</code> contains a trailing character, e.g. "/", that separates the directory from the filename.</dd>
<dd>
Use an empty string "" for the first argument if output is to be written in the current working directory. </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07370">7370</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ab56595d7d5aebfb2b3abfdaad51df20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56595d7d5aebfb2b3abfdaad51df20d">&#9670;&nbsp;</a></span>write_svg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_svg </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a74f241c703c02c9c3268f075b7ac02e9">get_patches()</a> and write it to <code>out</code> in SVG format. See <a class="el" href="namespaceDataOutBase.html#ad20ab1f2f5ec29122aefe1f016ff6eac">DataOutBase::write_svg</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07243">7243</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="affac60e1e3799ae884642113a8e2e723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affac60e1e3799ae884642113a8e2e723">&#9670;&nbsp;</a></span>write_deal_II_intermediate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_deal_II_intermediate </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain data through <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a74f241c703c02c9c3268f075b7ac02e9">get_patches()</a> and write it to <code>out</code> in deal.II intermediate format. See <a class="el" href="namespaceDataOutBase.html#a70b0a895fd8b48c1555fa1c34f2cd176">DataOutBase::write_deal_II_intermediate</a>.</p>
<p>Note that the intermediate format is what its name suggests: a direct representation of internal data. It isn't standardized and will change whenever we change our internal representation. You can only expect to process files written in this format using the same version of deal.II that was used for writing. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07452">7452</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a45ef5cf2b6515c10ff080729a9901155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ef5cf2b6515c10ff080729a9901155">&#9670;&nbsp;</a></span>create_xdmf_entry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXDMFEntry.html">XDMFEntry</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::create_xdmf_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>h5_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>cur_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classXDMFEntry.html">XDMFEntry</a> based on the data in the data_filter. This assumes the mesh and solution data were written to a single file. See <a class="el" href="classDataOutInterface.html#abfab5d02f11dcede67bb61ff3ae105d2">write_xdmf_file()</a> for an example of usage. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07465">7465</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a0f0b3eec5ee65bd7915c4e46272287eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0b3eec5ee65bd7915c4e46272287eb">&#9670;&nbsp;</a></span>create_xdmf_entry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXDMFEntry.html">XDMFEntry</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::create_xdmf_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>h5_mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>h5_solution_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>cur_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classXDMFEntry.html">XDMFEntry</a> based on the data in the data_filter. This assumes the mesh and solution data were written to separate files. See <a class="el" href="classDataOutInterface.html#abfab5d02f11dcede67bb61ff3ae105d2">write_xdmf_file()</a> for an example of usage. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07479">7479</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="abfab5d02f11dcede67bb61ff3ae105d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfab5d02f11dcede67bb61ff3ae105d2">&#9670;&nbsp;</a></span>write_xdmf_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_xdmf_file </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classXDMFEntry.html">XDMFEntry</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write an XDMF file based on the provided vector of <a class="el" href="classXDMFEntry.html">XDMFEntry</a> objects. Below is an example of how to use this function with <a class="el" href="namespaceHDF5.html">HDF5</a> and the DataOutFilter:</p>
<div class="fragment"><div class="line"><a class="code" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutBase::DataOutFilterFlags</a> flags(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> data_filter(flags);</div><div class="line">std::vector&lt;XDMFEntry&gt; xdmf_entries;</div><div class="line"><span class="comment">// Filter the data and store it in data_filter</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a154d8192688eef96f052f50c2f669aa8">write_filtered_data</a>(data_filter);</div><div class="line"><span class="comment">// Write the filtered data to HDF5</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a>(data_filter, <span class="stringliteral">&quot;solution.h5&quot;</span>, MPI_COMM_WORLD);</div><div class="line"><span class="comment">// Create an XDMF entry detailing the HDF5 file</span></div><div class="line"><span class="keyword">auto</span> new_xdmf_entry = data_out.<a class="code" href="classDataOutInterface.html#a45ef5cf2b6515c10ff080729a9901155">create_xdmf_entry</a>(data_filter,</div><div class="line">                                                 <span class="stringliteral">&quot;solution.h5&quot;</span>,</div><div class="line">                                                 simulation_time,</div><div class="line">                                                 MPI_COMM_WORLD);</div><div class="line"><span class="comment">// Add the XDMF entry to the list</span></div><div class="line">xdmf_entries.push_back(new_xdmf_entry);</div><div class="line"><span class="comment">// Create an XDMF file from all stored entries</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#abfab5d02f11dcede67bb61ff3ae105d2">write_xdmf_file</a>(xdmf_entries, <span class="stringliteral">&quot;solution.xdmf&quot;</span>, MPI_COMM_WORLD);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07552">7552</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a29468f4e8eca1367d44b1a2431d39e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29468f4e8eca1367d44b1a2431d39e91">&#9670;&nbsp;</a></span>write_hdf5_parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the data in <code>data_filter</code> to a single <a class="el" href="namespaceHDF5.html">HDF5</a> file containing both the mesh and solution values. Below is an example of how to use this function with the DataOutFilter:</p>
<div class="fragment"><div class="line"><a class="code" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutBase::DataOutFilterFlags</a> flags(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> data_filter(flags);</div><div class="line"><span class="comment">// Filter the data and store it in data_filter</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a154d8192688eef96f052f50c2f669aa8">write_filtered_data</a>(data_filter);</div><div class="line"><span class="comment">// Write the filtered data to HDF5</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a>(data_filter, <span class="stringliteral">&quot;solution.h5&quot;</span>, MPI_COMM_WORLD);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07730">7730</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a78fdf1cc5071d85ecb2d707d798bf063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fdf1cc5071d85ecb2d707d798bf063">&#9670;&nbsp;</a></span>write_hdf5_parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>write_mesh_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solution_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the data in data_filter to <a class="el" href="namespaceHDF5.html">HDF5</a> file(s). If write_mesh_file is false, the mesh data will not be written and the solution file will contain only the solution values. If write_mesh_file is true and the filenames are the same, the resulting file will contain both mesh data and solution values. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07742">7742</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a154d8192688eef96f052f50c2f669aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154d8192688eef96f052f50c2f669aa8">&#9670;&nbsp;</a></span>write_filtered_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_filtered_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filtered_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DataOutFilter is an intermediate data format that reduces the amount of data that will be written to files. The object filled by this function can then later be used again to write data in a concrete file format; see, for example, <a class="el" href="namespaceDataOutBase.html#af5a956cffba0fa383f85a82bb2a4ca63">DataOutBase::write_hdf5_parallel()</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07602">7602</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a78e73ad285a8792ff0f9f227b82eb108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e73ad285a8792ff0f9f227b82eb108">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td>
          <td class="paramname"><em>output_format</em> = <code><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write data and grid to <code>out</code> according to the given data format. This function simply calls the appropriate <code>write_*</code> function. If no output format is requested, the <code>default_format</code> is written.</p>
<p>An error occurs if no format is provided and the default format is <code>default_format</code>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08134">8134</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a6dab6e0fed8d4ad90d658f71a68eb32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dab6e0fed8d4ad90d658f71a68eb32c">&#9670;&nbsp;</a></span>set_default_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::set_default_format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td>
          <td class="paramname"><em>default_format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the default format. The value set here is used anytime, output for format <code>default_format</code> is requested. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08200">8200</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ac7280a24690b117454acfb0fa058299c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7280a24690b117454acfb0fa058299c">&#9670;&nbsp;</a></span>set_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::set_flags </td>
          <td>(</td>
          <td class="paramtype">const FlagType &amp;&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the flags to be used for output. This method expects <code>flags</code> to be a member of one of the child classes of <code>OutputFlagsBase</code>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08210">8210</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a36120ca3f536c90709e135161030f16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36120ca3f536c90709e135161030f16c">&#9670;&nbsp;</a></span>default_suffix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::default_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td>
          <td class="paramname"><em>output_format</em> = <code><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that returns the same string as the respective function in the base class does; the only exception being that if the parameter is omitted, then the value for the present default format is returned, i.e. the correct suffix for the format that was set through <a class="el" href="classDataOutInterface.html#a6dab6e0fed8d4ad90d658f71a68eb32c">set_default_format()</a> or <a class="el" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters()</a> before calling this function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08245">8245</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a1f2f1d644d9cb1c4d1714d5173d159f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2f1d644d9cb1c4d1714d5173d159f2">&#9670;&nbsp;</a></span>declare_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::declare_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare parameters for all output formats by declaring subsections within the parameter file for each output format and call the respective <code>declare_parameters</code> functions of the flag classes for each output format.</p>
<p>Some of the declared subsections may not contain entries, if the respective format does not export any flags.</p>
<p>Note that the top-level parameters denoting the number of subdivisions per patch and the output format are not declared, since they are only passed to virtual functions and are not stored inside objects of this type. You have to declare them yourself. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08258">8258</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a0a975649e4516ee7c7a67ae2f8dddd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a975649e4516ee7c7a67ae2f8dddd97">&#9670;&nbsp;</a></span>parse_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::parse_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the parameters declared in <a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">declare_parameters()</a> and set the flags for the output formats accordingly.</p>
<p>The flags thus obtained overwrite all previous contents of the flag objects as default-constructed or set by the <a class="el" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08311">8311</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a05d5d72abcf81f4174e15fd984f1267c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d5d72abcf81f4174e15fd984f1267c">&#9670;&nbsp;</a></span>get_nonscalar_data_ranges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &gt; <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::get_nonscalar_data_ranges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This functions returns information about how the individual components of output files that consist of more than one data set are to be interpreted.</p>
<p>It returns a list of index pairs and corresponding name and type indicating which components of the output are to be considered vector- or tensor-valued rather than just a collection of scalar data. The index pairs are inclusive; for example, if we have a Stokes problem in 2d with components (u,v,p), then the corresponding vector data range should be (0,1), and the returned list would consist of only a single element with a tuple such as (0,1,"velocity",component_is_part_of_vector).</p>
<p>Since some of the derived classes do not know about non-scalar data, this function has a default implementation that simply returns an empty string, meaning that all data is to be considered a collection of scalar fields. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08381">8381</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ac3292ed269dfb832d20ae35db4177473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3292ed269dfb832d20ae35db4177473">&#9670;&nbsp;</a></span>validate_dataset_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::validate_dataset_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate that the names of the datasets returned by <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#aa8c9fc801b1b6598906b7b2c22f5e7ac">get_dataset_names()</a> and <a class="el" href="classDataOutInterface.html#a05d5d72abcf81f4174e15fd984f1267c">get_nonscalar_data_ranges()</a> are valid. This currently consists of checking that names are not used more than once. If an invalid state is encountered, an <a class="el" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert()</a> will be triggered in debug mode. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08393">8393</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8c98ce4fee01d6f3f1f181473ef56827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c98ce4fee01d6f3f1f181473ef56827">&#9670;&nbsp;</a></span>patch_dim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::patch_dim = dim + 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimension parameters for the patches. </p>

<p class="definition">Definition at line <a class="el" href="data__out__stack_8h_source.html#l00143">143</a> of file <a class="el" href="data__out__stack_8h_source.html">data_out_stack.h</a>.</p>

</div>
</div>
<a id="af3bea620f8fc49c190a7a9de9882a307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3bea620f8fc49c190a7a9de9882a307">&#9670;&nbsp;</a></span>patch_spacedim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::patch_spacedim = spacedim + 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="data__out__stack_8h_source.html#l00144">144</a> of file <a class="el" href="data__out__stack_8h_source.html">data_out_stack.h</a>.</p>

</div>
</div>
<a id="add7533e80af092527d38d3f07c9e09c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7533e80af092527d38d3f07c9e09c6">&#9670;&nbsp;</a></span>parameter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::parameter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Present parameter value. </p>

<p class="definition">Definition at line <a class="el" href="data__out__stack_8h_source.html#l00329">329</a> of file <a class="el" href="data__out__stack_8h_source.html">data_out_stack.h</a>.</p>

</div>
</div>
<a id="a5e5f79d299002c05e45f7a70599f08ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5f79d299002c05e45f7a70599f08ad">&#9670;&nbsp;</a></span>parameter_step</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::parameter_step</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Present parameter step, i.e. length of the parameter interval to be written next. </p>

<p class="definition">Definition at line <a class="el" href="data__out__stack_8h_source.html#l00335">335</a> of file <a class="el" href="data__out__stack_8h_source.html">data_out_stack.h</a>.</p>

</div>
</div>
<a id="a64c89aa6091375cb913fbf16ba80c0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c89aa6091375cb913fbf16ba80c0a2">&#9670;&nbsp;</a></span>dof_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim, spacedim&gt;, <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt;dim, spacedim, void&gt; &gt; <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::dof_handler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DoF handler to be used for the data corresponding to the present parameter value. </p>

<p class="definition">Definition at line <a class="el" href="data__out__stack_8h_source.html#l00343">343</a> of file <a class="el" href="data__out__stack_8h_source.html">data_out_stack.h</a>.</p>

</div>
</div>
<a id="ac483f105d4890e24ee4539746dc6ec50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac483f105d4890e24ee4539746dc6ec50">&#9670;&nbsp;</a></span>patches</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;::<a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt;<a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#a8c98ce4fee01d6f3f1f181473ef56827">patch_dim</a>, <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#af3bea620f8fc49c190a7a9de9882a307">patch_spacedim</a>&gt; &gt; <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::patches</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of patches of all past and present parameter value data sets. </p>

<p class="definition">Definition at line <a class="el" href="data__out__stack_8h_source.html#l00348">348</a> of file <a class="el" href="data__out__stack_8h_source.html">data_out_stack.h</a>.</p>

</div>
</div>
<a id="a7a1804273e1040510380c67c4fac4fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1804273e1040510380c67c4fac4fea">&#9670;&nbsp;</a></span>dof_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;DataVector&gt; <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::dof_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of DoF data vectors. </p>

<p class="definition">Definition at line <a class="el" href="data__out__stack_8h_source.html#l00377">377</a> of file <a class="el" href="data__out__stack_8h_source.html">data_out_stack.h</a>.</p>

</div>
</div>
<a id="a7493de62dae9e779feb23cf65f6911a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7493de62dae9e779feb23cf65f6911a2">&#9670;&nbsp;</a></span>cell_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;DataVector&gt; <a class="el" href="classDataOutStack.html">DataOutStack</a>&lt; dim, spacedim, void &gt;::cell_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of cell data vectors. </p>

<p class="definition">Definition at line <a class="el" href="data__out__stack_8h_source.html#l00382">382</a> of file <a class="el" href="data__out__stack_8h_source.html">data_out_stack.h</a>.</p>

</div>
</div>
<a id="a072edd6d53d1c5a1e4c71af22a123228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072edd6d53d1c5a1e4c71af22a123228">&#9670;&nbsp;</a></span>default_subdivisions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::default_subdivisions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default number of subdivisions for patches. This is filled by <a class="el" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters()</a> and should be obeyed by <a class="el" href="classDataOutStack_3_01dim_00_01spacedim_00_01void_01_4.html#ad4a1bd677ab1d6463145368e1f85b4e6">build_patches()</a> in derived classes. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l03016">3016</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/numerics/<a class="el" href="data__out__stack_8h_source.html">data_out_stack.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
