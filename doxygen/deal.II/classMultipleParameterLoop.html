<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classMultipleParameterLoop.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MultipleParameterLoop Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classMultipleParameterLoop-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MultipleParameterLoop Class Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__input.html">Input</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="parameter__handler_8h_source.html">deal.II/base/parameter_handler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MultipleParameterLoop:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classMultipleParameterLoop__inherit__graph.svg" width="166" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop_1_1Entry.html">Entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop_1_1UserClass.html">UserClass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8364dda711b93753c6809eefe2a8e827"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> { <br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a> = 0x0000, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f">Short</a> = 0x0001, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a50ae66aa378db81bb360ce7cdf96e3e1">KeepDeclarationOrder</a> = 0x0002, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a9b48379ffc293bc0a49b7aa342dbc9bf">PRM</a> = 0x0010, 
<br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">Text</a> = PRM, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3b5d289d79f36e819a7bd0d81a52ee37">LaTeX</a> = 0x0020, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a5ed7026d01b66b89ee3c1aef3efbfd4a">Description</a> = 0x0040, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510">XML</a> = 0x0080, 
<br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a456d0f94d7d72f33234d02a8b2e9030c">JSON</a> = 0x0100, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aadc1ef9748b3bb19e21e097bfe4f70b1">ShortPRM</a> = PRM | Short, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a6d91eaf8deb52a5d3cba991a9bb23ac7">ShortText</a> = ShortPRM, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aadab70cda4e49776ec93690fd9e1bbd1">ShortXML</a> = XML | Short, 
<br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a26b405ba447d5fcbeb3c178076c4580f">ShortJSON</a> = JSON | Short, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a0fbe0a13822fbc6b4e28fd6b416eb9ca">ShortLaTeX</a> = LaTeX | Short
<br />
 }</td></tr>
<tr class="separator:a8364dda711b93753c6809eefe2a8e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a90c2eea8e17afb645733c45d9bc5d562"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#a90c2eea8e17afb645733c45d9bc5d562">MultipleParameterLoop</a> ()</td></tr>
<tr class="separator:a90c2eea8e17afb645733c45d9bc5d562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b2ae95204b6d02958b55cdebcb7816"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#ac0b2ae95204b6d02958b55cdebcb7816">~MultipleParameterLoop</a> () override=default</td></tr>
<tr class="separator:ac0b2ae95204b6d02958b55cdebcb7816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978e161aae61a62c27a7dec2d7fd527b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#a978e161aae61a62c27a7dec2d7fd527b">parse_input</a> (std::istream &amp;input, const std::string &amp;filename=&quot;input file&quot;, const std::string &amp;last_line=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> skip_undefined=false) override</td></tr>
<tr class="separator:a978e161aae61a62c27a7dec2d7fd527b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd380d8bca1546e2c29fe9a33d047241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#acd380d8bca1546e2c29fe9a33d047241">loop</a> (<a class="el" href="classMultipleParameterLoop_1_1UserClass.html">UserClass</a> &amp;uc)</td></tr>
<tr class="separator:acd380d8bca1546e2c29fe9a33d047241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76c74f48e073e6ff96fa9d788d2b0bd"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#aa76c74f48e073e6ff96fa9d788d2b0bd">memory_consumption</a> () const</td></tr>
<tr class="separator:aa76c74f48e073e6ff96fa9d788d2b0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647461d59c5de46d345d56e0f856d581"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a647461d59c5de46d345d56e0f856d581">parse_input</a> (const std::string &amp;filename, const std::string &amp;last_line=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> skip_undefined=false, const <a class="el" href="classbool.html">bool</a> assert_mandatory_entries_are_found=false)</td></tr>
<tr class="separator:a647461d59c5de46d345d56e0f856d581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bb8b2735fb7e9980ec73ff7b489f7f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a79bb8b2735fb7e9980ec73ff7b489f7f">parse_input_from_string</a> (const std::string &amp;s, const std::string &amp;last_line=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> skip_undefined=false)</td></tr>
<tr class="separator:a79bb8b2735fb7e9980ec73ff7b489f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e7edb2a86419b76f4a1b69dfdd873a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a12e7edb2a86419b76f4a1b69dfdd873a">parse_input_from_xml</a> (std::istream &amp;input, const <a class="el" href="classbool.html">bool</a> skip_undefined=false)</td></tr>
<tr class="separator:a12e7edb2a86419b76f4a1b69dfdd873a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4afb8f5cc2451fb16be1fff32b4380"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#afb4afb8f5cc2451fb16be1fff32b4380">parse_input_from_json</a> (std::istream &amp;input, const <a class="el" href="classbool.html">bool</a> skip_undefined=false)</td></tr>
<tr class="separator:afb4afb8f5cc2451fb16be1fff32b4380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6184baed4eba575e422161dc86ed12e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6184baed4eba575e422161dc86ed12e3">clear</a> ()</td></tr>
<tr class="separator:a6184baed4eba575e422161dc86ed12e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d65f458be69e23a348221cb67fc411d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (const std::string &amp;entry, const std::string &amp;default_value, const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;pattern=<a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(), const std::string &amp;documentation=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> has_to_be_set=false)</td></tr>
<tr class="separator:a6d65f458be69e23a348221cb67fc411d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f3996003757093fb0e050a6729e81b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action</a> (const std::string &amp;entry, const std::function&lt; void(const std::string &amp;value)&gt; &amp;action)</td></tr>
<tr class="separator:a59f3996003757093fb0e050a6729e81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b75c02037d19fd7fd781785fcefc79"><td class="memTemplParams" colspan="2">template&lt;class ParameterType &gt; </td></tr>
<tr class="memitem:a04b75c02037d19fd7fd781785fcefc79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">add_parameter</a> (const std::string &amp;entry, ParameterType &amp;parameter, const std::string &amp;documentation=&quot;&quot;, const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;pattern= *<a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a>&lt; ParameterType &gt;::to_pattern(), const <a class="el" href="classbool.html">bool</a> has_to_be_set=false)</td></tr>
<tr class="separator:a04b75c02037d19fd7fd781785fcefc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb847561585089c4c7fcf51eddece16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aecb847561585089c4c7fcf51eddece16">declare_alias</a> (const std::string &amp;existing_entry_name, const std::string &amp;alias_name, const <a class="el" href="classbool.html">bool</a> alias_is_deprecated=false)</td></tr>
<tr class="separator:aecb847561585089c4c7fcf51eddece16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29c20cde6d44186806d559beb468696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (const std::string &amp;subsection)</td></tr>
<tr class="separator:af29c20cde6d44186806d559beb468696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599462cacd492e2f712bf7369507dcff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ()</td></tr>
<tr class="separator:a599462cacd492e2f712bf7369507dcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6142462087d1cd62d294eccb1f58867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae6142462087d1cd62d294eccb1f58867">subsection_path_exists</a> (const std::vector&lt; std::string &gt; &amp;sub_path) const</td></tr>
<tr class="separator:ae6142462087d1cd62d294eccb1f58867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cfbaca954f444047302446a4e87125"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a91cfbaca954f444047302446a4e87125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08ccf6fbd95de45a35b53ba0c09f49f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa08ccf6fbd95de45a35b53ba0c09f49f">get</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:aa08ccf6fbd95de45a35b53ba0c09f49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fa98fdc0c52980a5b1de0ee1fc5bb2"><td class="memItemLeft" align="right" valign="top">long <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a61fa98fdc0c52980a5b1de0ee1fc5bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421a09eb0548f1fb3783d97d3e85fd5c"><td class="memItemLeft" align="right" valign="top">long <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a421a09eb0548f1fb3783d97d3e85fd5c">get_integer</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a421a09eb0548f1fb3783d97d3e85fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf3c7846747695b1f327677e3716ec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a> (const std::string &amp;entry_name) const</td></tr>
<tr class="separator:aeaf3c7846747695b1f327677e3716ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913289695be07bd949bf94aa5cd5ad54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a913289695be07bd949bf94aa5cd5ad54">get_double</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a913289695be07bd949bf94aa5cd5ad54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb45dc67787e3fab7882461929b5fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a> (const std::string &amp;entry_name) const</td></tr>
<tr class="separator:a6bb45dc67787e3fab7882461929b5fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209f365b60c5b0a76080b86693baa36b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a209f365b60c5b0a76080b86693baa36b">get_bool</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a209f365b60c5b0a76080b86693baa36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6418ea655b1b550b9dcf63513030196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> (const std::string &amp;entry_name, const std::string &amp;new_value)</td></tr>
<tr class="separator:aa6418ea655b1b550b9dcf63513030196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af288e1fe38ac1a1baf1cef3058b63ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af288e1fe38ac1a1baf1cef3058b63ce1">set</a> (const std::string &amp;entry_name, const char *new_value)</td></tr>
<tr class="separator:af288e1fe38ac1a1baf1cef3058b63ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89180ba36c54e207286a3545f8371b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa89180ba36c54e207286a3545f8371b4">set</a> (const std::string &amp;entry_name, const long <a class="el" href="classint.html">int</a> new_value)</td></tr>
<tr class="separator:aa89180ba36c54e207286a3545f8371b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46b9dd6387d7e48ddca4add8baad2aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ad46b9dd6387d7e48ddca4add8baad2aa">set</a> (const std::string &amp;entry_name, const <a class="el" href="classdouble.html">double</a> new_value)</td></tr>
<tr class="separator:ad46b9dd6387d7e48ddca4add8baad2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae417f9634872a427765365cd5ee9b160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae417f9634872a427765365cd5ee9b160">set</a> (const std::string &amp;entry_name, const <a class="el" href="classbool.html">bool</a> new_value)</td></tr>
<tr class="separator:ae417f9634872a427765365cd5ee9b160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac3a8b19ade16e96e8ea25906daf23a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a> (std::ostream &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style) const</td></tr>
<tr class="separator:a4ac3a8b19ade16e96e8ea25906daf23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fde9ad56e01eed0648e56106e6bf1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a17fde9ad56e01eed0648e56106e6bf1e">print_parameters</a> (const std::string &amp;filename, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style=<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a>) const</td></tr>
<tr class="separator:a17fde9ad56e01eed0648e56106e6bf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa900e3460a10639fc4d8703ef09a7c0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa900e3460a10639fc4d8703ef09a7c0a">log_parameters</a> (<a class="el" href="classLogStream.html">LogStream</a> &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style=<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a>)</td></tr>
<tr class="separator:aa900e3460a10639fc4d8703ef09a7c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15f2618f3b24c04eead226c5271be1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae15f2618f3b24c04eead226c5271be1a">log_parameters_section</a> (<a class="el" href="classLogStream.html">LogStream</a> &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style=<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a>)</td></tr>
<tr class="separator:ae15f2618f3b24c04eead226c5271be1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df38ff67c1c8352e04de490e0c0a39e"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a5df38ff67c1c8352e04de490e0c0a39e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a5df38ff67c1c8352e04de490e0c0a39e">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:a5df38ff67c1c8352e04de490e0c0a39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a09fd2ee6d01b78079f894893aacd6c4c">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac896adce1ec1db3f525f57811764879"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:aac896adce1ec1db3f525f57811764879"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aac896adce1ec1db3f525f57811764879">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:aac896adce1ec1db3f525f57811764879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede1a749bba8ee11876fd114a16c4f3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aede1a749bba8ee11876fd114a16c4f3e">operator==</a> (const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm2) const</td></tr>
<tr class="separator:aede1a749bba8ee11876fd114a16c4f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a299c29da8a837a1b8441039d0fa79"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa5a299c29da8a837a1b8441039d0fa79">get_entries_wrongly_not_set</a> () const</td></tr>
<tr class="separator:aa5a299c29da8a837a1b8441039d0fa79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af441ab90c4d310c1c7d12c5f0050024f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af441ab90c4d310c1c7d12c5f0050024f">assert_that_entries_have_been_set</a> () const</td></tr>
<tr class="separator:af441ab90c4d310c1c7d12c5f0050024f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga55b48a9b5ced390a0c292e8103afdf91"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga55b48a9b5ced390a0c292e8103afdf91">ExcEntryAlreadyExists</a> (std::string arg1)</td></tr>
<tr class="separator:ga55b48a9b5ced390a0c292e8103afdf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b16bc7be372c9270121d278858a672f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8b16bc7be372c9270121d278858a672f">ExcValueDoesNotMatchPattern</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga8b16bc7be372c9270121d278858a672f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9213c9ff33bbb3d167b67fa890a6d9ce"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9213c9ff33bbb3d167b67fa890a6d9ce">ExcAlreadyAtTopLevel</a> ()</td></tr>
<tr class="separator:ga9213c9ff33bbb3d167b67fa890a6d9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab8cc9a7fa6a9c6114a207b795007d5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga2ab8cc9a7fa6a9c6114a207b795007d5">ExcEntryUndeclared</a> (std::string arg1)</td></tr>
<tr class="separator:ga2ab8cc9a7fa6a9c6114a207b795007d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a05434eefbd2de0314b0a483247d96d"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0a05434eefbd2de0314b0a483247d96d">ExcUnbalancedSubsections</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga0a05434eefbd2de0314b0a483247d96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8136031b245c5a29ddac3940090f0ac"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad8136031b245c5a29ddac3940090f0ac">ExcNoSubsection</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gad8136031b245c5a29ddac3940090f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa620e44b3aa3cf356feaa424a516086e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa620e44b3aa3cf356feaa424a516086e">ExcCannotParseLine</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gaa620e44b3aa3cf356feaa424a516086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3cb505bbdd65d21ef66e3ef7e383bab"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad3cb505bbdd65d21ef66e3ef7e383bab">ExcInvalidEntryForPattern</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3, std::string arg4, std::string arg5)</td></tr>
<tr class="separator:gad3cb505bbdd65d21ef66e3ef7e383bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43bb6588e469c2e12a430fb7ea316da1"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga43bb6588e469c2e12a430fb7ea316da1">ExcInvalidXMLParameterFile</a> ()</td></tr>
<tr class="separator:ga43bb6588e469c2e12a430fb7ea316da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2febc2a5dd0328f971093085bf9b4fa"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2febc2a5dd0328f971093085bf9b4fa">ExcCannotOpenIncludeStatementFile</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac2febc2a5dd0328f971093085bf9b4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2a4d4877a5f67766a8a375de6f4cb17a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#a2a4d4877a5f67766a8a375de6f4cb17a">init_branches</a> ()</td></tr>
<tr class="separator:a2a4d4877a5f67766a8a375de6f4cb17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e01c261219f65af82c3f6c5ab28a68d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#a0e01c261219f65af82c3f6c5ab28a68d">init_branches_current_section</a> ()</td></tr>
<tr class="separator:a0e01c261219f65af82c3f6c5ab28a68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58138c82fb4fb1d75f5444baf26f4aed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#a58138c82fb4fb1d75f5444baf26f4aed">fill_entry_values</a> (const unsigned <a class="el" href="classint.html">int</a> run_no)</td></tr>
<tr class="separator:a58138c82fb4fb1d75f5444baf26f4aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:acf494a63b63e0f0a52ddcd7cd3ba60b9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classMultipleParameterLoop_1_1Entry.html">Entry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#acf494a63b63e0f0a52ddcd7cd3ba60b9">multiple_choices</a></td></tr>
<tr class="separator:acf494a63b63e0f0a52ddcd7cd3ba60b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7165818f5c82fed1026e6bb489c004a8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#a7165818f5c82fed1026e6bb489c004a8">n_branches</a></td></tr>
<tr class="separator:a7165818f5c82fed1026e6bb489c004a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class <a class="el" href="classMultipleParameterLoop.html">MultipleParameterLoop</a> offers an easy possibility to test several parameter sets during one run of the program. For this it uses the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class to read in data in a standardized form, searches for variant entry values and performs a loop over all combinations of parameters.</p>
<p>Variant entry values are given like this: </p><pre class="fragment">*     set Time step size = { 0.1 | 0.2 | 0.3 }
*   </pre><p> The loop will then perform three runs of the program, one for each value of <code>Time step size</code>, while all other parameters are as specified or with their default value. If there are several variant entry values in the input, a loop is performed for each combination of variant values: </p><pre class="fragment">*     set Time step size = { 0.1 | 0.2 }
*     set Solver         = { CG  | GMRES }
*   </pre><p> will result in four runs of the programs, with time step 0.1 and 0.2 for each of the two solvers.</p>
<p>In addition to variant entries, this class also supports <em>array entries</em> that look like this: </p><pre class="fragment">*     set Output file = ofile.{{ 1 | 2 | 3 | 4 }}
*   </pre><p> This indicates that if there are variant entries producing a total of four different runs, then we will write their results to the files <code>ofile.1</code>, <code>ofile.2</code>, <code>ofile.3</code> and <code>ofile.4</code>, respectively. Array entries do not generate multiple runs of the main loop themselves, but if there are variant entries, then in the <em>n</em>th run of the main loop, also the <em>n</em>th value of an array is returned.</p>
<p>Since the different variants are constructed in the order of declaration, not in the order in which the variant entries appear in the input file, it may be difficult to guess the mapping between the different variants and the appropriate entry in an array. You will have to check the order of declaration, or use only one variant entry.</p>
<p>It is guaranteed that only selections which match the regular expression (pattern) given upon declaration of an entry are given back to the program. If a variant value does not match the regular expression, the default value is stored and an error is issued. Before the first run of the loop, all possible values are checked for their conformance, so that the error is issued at the very beginning of the program.</p>
<h3>Usage</h3>
<p>The usage of this class is similar to the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class. First the entries and subsections have to be declared, then a loop is performed in which the different parameter sets are set, a new instance of a user class is created which is then called. Taking the classes of the example for the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class, the extended program would look like this: </p><div class="fragment"><div class="line"><span class="keyword">class </span>HelperClass : <span class="keyword">public</span> <a class="code" href="classMultipleParameterLoop_1_1UserClass.html">MultipleParameterLoop::UserClass</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  HelperClass ();</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> create_new (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> run_no);</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a> (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::unique_ptr&lt;Problem&gt; p;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">HelperClass::HelperClass () : p(0) {}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> HelperClass::create_new (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> run_no)</div><div class="line">{</div><div class="line">  p = std::make_unique&lt;Problem&gt;());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> HelperClass::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  Problem::declare_parameters (prm);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">HelperClass::run</a> (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  p-&gt;get_parameters (prm);</div><div class="line">  p-&gt;do_useful_work ();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keyword">class </span><a class="code" href="classMultipleParameterLoop.html">MultipleParameterLoop</a> prm;</div><div class="line">  HelperClass h;</div><div class="line">  HelperClass::declare_parameters (prm);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a> (<span class="stringliteral">&quot;prmtest.prm&quot;</span>);</div><div class="line">  prm.loop (h);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>As can be seen, first a new helper class has to be set up. This must contain a virtual constructor for a problem class. You can also derive your problem class from <a class="el" href="classMultipleParameterLoop_1_1UserClass.html">MultipleParameterLoop::UserClass</a> and let <code>create_new</code> clear all member variables. If you have access to all inherited member variables in some way this is the recommended procedure. A third possibility is to use multiple inheritance and derive a helper class from both the <a class="el" href="classMultipleParameterLoop_1_1UserClass.html">MultipleParameterLoop::UserClass</a> and the problem class. In any case, <code>create_new</code> has to provide a clean problem object which is the problem in the second and third possibility.</p>
<p>The derived class also has to provide for member functions which declare the entries and which run the program. Running the program includes getting the parameters out of the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object.</p>
<p>After defining an object of this helper class and an object of the <a class="el" href="classMultipleParameterLoop.html">MultipleParameterLoop</a> class, the entries have to be declared in the same way as for the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class. Then the input has to be read. Finally the loop is called. This executes the following steps: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (each combination)</div><div class="line">  {</div><div class="line">    UserObject.create_new (run_no);</div><div class="line"></div><div class="line">    <span class="comment">// set parameters for this run</span></div><div class="line"></div><div class="line">    UserObject.run (*<span class="keyword">this</span>);</div><div class="line">  }</div></div><!-- fragment --><p> <code>UserObject</code> is the parameter to the <code>loop</code> function. <code>create_new</code> is given the number of the run (starting from one) to enable naming output files differently for each run.</p>
<h3>Syntax for variant and array entry values</h3>
<p>Variant values are specified like <code>prefix{ v1 | v2 | v3 | ... }postfix</code>. Whitespace to the right of the opening brace <code>{</code> is ignored as well as to the left of the closing brace <code>}</code> while whitespace on the respectively other side is not ignored. Whitespace around the mid symbols <code>|</code> is also ignored. The empty selection <code>prefix{ v1 | }postfix</code> is also allowed and produces the strings <code>prefixv1postfix</code> and <code>prefixpostfix</code>.</p>
<p>The syntax for array values is equal, apart from the double braces: <code>prefix{{ v1 | v2 | v3 }}postfix</code>.</p>
<h3>Worked example</h3>
<p>Given the above extensions to the example program for the <a class="el" href="classParameterHandler.html">ParameterHandler</a> and the following input file </p><pre class="fragment">*     set Equation 1 = Poisson
*     set Equation 2 = Navier-Stokes
*     set Output file= results.{{ 1 | 2 | 3 | 4 | 5 | 6 }}
*
*     subsection Equation 1
*       set Matrix type = Sparse
*       subsection Linear solver
*         set Solver                       = CG
*         set Maximum number of iterations = { 10 | 20 | 30 }
*       end
*     end
*
*     subsection Equation 2
*       set Matrix type = Full
*       subsection Linear solver
*         set Solver                       = { BiCGStab | GMRES }
*         set Maximum number of iterations = 100
*       end
*     end
*   </pre><p> this is the output: </p><pre class="fragment">*     LinEq: Method=CG, MaxIterations=10
*     LinEq: Method=BiCGStab, MaxIterations=100
*     Problem: outfile=results.1
*              eq1=Poisson, eq2=Navier-Stokes
*              Matrix1=Sparse, Matrix2=Full
*     LinEq: Method=CG, MaxIterations=20
*     LinEq: Method=BiCGStab, MaxIterations=100
*     Problem: outfile=results.2
*              eq1=Poisson, eq2=Navier-Stokes
*              Matrix1=Sparse, Matrix2=Full
*     LinEq: Method=CG, MaxIterations=30
*     LinEq: Method=BiCGStab, MaxIterations=100
*     Problem: outfile=results.3
*              eq1=Poisson, eq2=Navier-Stokes
*              Matrix1=Sparse, Matrix2=Full
*     LinEq: Method=CG, MaxIterations=10
*     LinEq: Method=GMRES, MaxIterations=100
*     Problem: outfile=results.4
*              eq1=Poisson, eq2=Navier-Stokes
*              Matrix1=Sparse, Matrix2=Full
*     LinEq: Method=CG, MaxIterations=20
*     LinEq: Method=GMRES, MaxIterations=100
*     Problem: outfile=results.5
*              eq1=Poisson, eq2=Navier-Stokes
*              Matrix1=Sparse, Matrix2=Full
*     LinEq: Method=CG, MaxIterations=30
*     LinEq: Method=GMRES, MaxIterations=100
*     Problem: outfile=results.6
*              eq1=Poisson, eq2=Navier-Stokes
*              Matrix1=Sparse, Matrix2=Full
*   </pre><p> Since <code>create_new</code> gets the number of the run it would also be possible to output the number of the run. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02070">2070</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a8364dda711b93753c6809eefe2a8e827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8364dda711b93753c6809eefe2a8e827">&#9670;&nbsp;</a></span>OutputStyle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of possible output formats used for functions like <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">ParameterHandler::print_parameters()</a>. The options can be categorized into two groups:</p><ul>
<li>format options: PRM, LaTeX, Description, XML, JSON</li>
<li>stylistic options: Short, KeepDeclarationOrder</li>
</ul>
<p>Only one format option may be specified at the time. Any function that accepts an OutputStyle as an option will throw if you specify more than one.</p>
<p>A number of shortcuts of commonly used option combinations are provided. E.g., ShortPRM prints the parameters in the PRM format, while skipping the documentation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48"></a>DefaultStyle&#160;</td><td class="fielddoc"><p>Default stylistic style: print documentation and sort all parameters alphabetically. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f"></a>Short&#160;</td><td class="fielddoc"><p>Write input for <a class="el" href="classParameterHandler.html">ParameterHandler</a> without comments or changed default values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a50ae66aa378db81bb360ce7cdf96e3e1"></a>KeepDeclarationOrder&#160;</td><td class="fielddoc"><p>Keep the order of the parameters as they have been declared. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a9b48379ffc293bc0a49b7aa342dbc9bf"></a>PRM&#160;</td><td class="fielddoc"><p>Write human readable output suitable to be read by <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> again. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365"></a>Text&#160;</td><td class="fielddoc"><p>Write human readable output suitable to be read by <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> again.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Use <code>PRM</code> instead of <code>Text</code>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a3b5d289d79f36e819a7bd0d81a52ee37"></a>LaTeX&#160;</td><td class="fielddoc"><p>Write parameters as a LaTeX table. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a5ed7026d01b66b89ee3c1aef3efbfd4a"></a>Description&#160;</td><td class="fielddoc"><p>Write out declared parameters with description and possible values.</p>
<dl class="section note"><dt>Note</dt><dd>This format is not suitable to be read back again. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510"></a>XML&#160;</td><td class="fielddoc"><p>Write out everything as an <a href="http://en.wikipedia.org/wiki/XML">XML</a> file suitable to be read by <a class="el" href="classParameterHandler.html#a12e7edb2a86419b76f4a1b69dfdd873a">ParameterHandler::parse_input_from_xml()</a> again.</p>
<p>See the general documentation of this class for an example of output. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a456d0f94d7d72f33234d02a8b2e9030c"></a>JSON&#160;</td><td class="fielddoc"><p>Write out everything as a <a href="http://en.wikipedia.org/wiki/JSON">JSON</a> file suitable to be read by <a class="el" href="classParameterHandler.html#afb4afb8f5cc2451fb16be1fff32b4380">ParameterHandler::parse_input_from_json()</a> again. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827aadc1ef9748b3bb19e21e097bfe4f70b1"></a>ShortPRM&#160;</td><td class="fielddoc"><p>Write the content of <a class="el" href="classParameterHandler.html">ParameterHandler</a> without comments or changed default values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a6d91eaf8deb52a5d3cba991a9bb23ac7"></a>ShortText&#160;</td><td class="fielddoc"><p>Write the content of <a class="el" href="classParameterHandler.html">ParameterHandler</a> without comments or changed default values.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Use <code>ShortPRM</code> instead of <code>ShortText</code>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827aadab70cda4e49776ec93690fd9e1bbd1"></a>ShortXML&#160;</td><td class="fielddoc"><p>Write the content of <a class="el" href="classParameterHandler.html">ParameterHandler</a> without comments or changed default values as a XML file. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a26b405ba447d5fcbeb3c178076c4580f"></a>ShortJSON&#160;</td><td class="fielddoc"><p>Write the content of <a class="el" href="classParameterHandler.html">ParameterHandler</a> without comments or changed default values as a JSON file. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a0fbe0a13822fbc6b4e28fd6b416eb9ca"></a>ShortLaTeX&#160;</td><td class="fielddoc"><p>Write the content of <a class="el" href="classParameterHandler.html">ParameterHandler</a> without comments or changed default values as a LaTeX file. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l00858">858</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a90c2eea8e17afb645733c45d9bc5d562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c2eea8e17afb645733c45d9bc5d562">&#9670;&nbsp;</a></span>MultipleParameterLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MultipleParameterLoop::MultipleParameterLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02083">2083</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ac0b2ae95204b6d02958b55cdebcb7816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b2ae95204b6d02958b55cdebcb7816">&#9670;&nbsp;</a></span>~MultipleParameterLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MultipleParameterLoop::~MultipleParameterLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Declare this only to have a virtual destructor, which is safer as we have virtual functions. It actually does nothing spectacular. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a978e161aae61a62c27a7dec2d7fd527b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978e161aae61a62c27a7dec2d7fd527b">&#9670;&nbsp;</a></span>parse_input() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultipleParameterLoop::parse_input </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;input&#160;file&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read input from a stream until the stream returns the <code>eof</code> condition or error. The second argument can be used to denote the name of the file (if that's what the input stream represents) we are reading from; this is only used when creating output for error messages.</p>
<p>If non-empty <code>last_line</code> is provided, the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object will stop parsing lines after encountering <code>last_line</code> . This is handy when adding extra data that shall be parsed manually.</p>
<p>If <code>skip_undefined</code> is <code>true</code>, the parameter handler will skip undefined sections and entries. This is useful for partially parsing a parameter file, for example to obtain only the spatial dimension of the problem. By default all entries and subsections are expected to be declared.</p>
<dl class="section note"><dt>Note</dt><dd>This is the only overload of the three <code>parse_input</code> functions implemented by <a class="el" href="classParameterHandler.html">ParameterHandler</a> overridden with new behavior by this class. This is because the other two <code>parse_input</code> functions just reformat their inputs and then call this version. </dd></dl>

<p>Reimplemented from <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler</a>.</p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02090">2090</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="acd380d8bca1546e2c29fe9a33d047241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd380d8bca1546e2c29fe9a33d047241">&#9670;&nbsp;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MultipleParameterLoop::loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMultipleParameterLoop_1_1UserClass.html">MultipleParameterLoop::UserClass</a> &amp;&#160;</td>
          <td class="paramname"><em>uc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>run the central loop. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02107">2107</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa76c74f48e073e6ff96fa9d788d2b0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76c74f48e073e6ff96fa9d788d2b0bd">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MultipleParameterLoop::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02241">2241</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a2a4d4877a5f67766a8a375de6f4cb17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4d4877a5f67766a8a375de6f4cb17a">&#9670;&nbsp;</a></span>init_branches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultipleParameterLoop::init_branches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize the different branches, i.e. construct the combinations. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02121">2121</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a0e01c261219f65af82c3f6c5ab28a68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e01c261219f65af82c3f6c5ab28a68d">&#9670;&nbsp;</a></span>init_branches_current_section()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultipleParameterLoop::init_branches_current_section </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Traverse the section currently set by <a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection()</a>/leave_subsection() and see which of the entries are variant or array entries. Then fill the multiple_choices variable using this information. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02162">2162</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a58138c82fb4fb1d75f5444baf26f4aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58138c82fb4fb1d75f5444baf26f4aed">&#9670;&nbsp;</a></span>fill_entry_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultipleParameterLoop::fill_entry_values </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>run_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transfer the entry values for one run to the entry tree. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02193">2193</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a647461d59c5de46d345d56e0f856d581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647461d59c5de46d345d56e0f856d581">&#9670;&nbsp;</a></span>parse_input() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>assert_mandatory_entries_are_found</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse input from a specified parameter file <code>filename</code> independently of the type of input file (prm, xml, json) being used. The code path selected by this function is extracted from the ending of the filename, so the user has to make sure that the content of the input file is consistent with its name.</p>
<p>The parameter <code>last_line</code> will only be used for parameter files of .prm type. See the other parse_input function for documentation.</p>
<p>The user can specify whether parameters in the input file not added to the parameter handler will be skipped by <code>skip_undefined</code> (enables partial parsing), and whether the code will assert that all parameters of the parameter handler declared with flag <code>has_to_be_set=true</code> are indeed found in the input file.</p>
<p>If the function is called with <code>skip_undefined=true</code>, it is recommended to also set <code>assert_mandatory_entries_are_found=true</code>. For example, this ensures that parameters with typos in the input file will not be skipped, while such mistakes would otherwise remain unrecognized. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00532">532</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a79bb8b2735fb7e9980ec73ff7b489f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bb8b2735fb7e9980ec73ff7b489f7f">&#9670;&nbsp;</a></span>parse_input_from_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input_from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse input from a string to populate known parameter fields. The lines in the string must be separated by <code>\n</code> characters.</p>
<p>The function in essence reads the entire file into a stream and then calls the other <a class="el" href="classMultipleParameterLoop.html#a978e161aae61a62c27a7dec2d7fd527b">parse_input()</a> function with that stream. See there for more information. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00560">560</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a12e7edb2a86419b76f4a1b69dfdd873a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e7edb2a86419b76f4a1b69dfdd873a">&#9670;&nbsp;</a></span>parse_input_from_xml()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input_from_xml </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse input from an XML stream to populate known parameter fields. This could be from a file originally written by the <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters()</a> function using the XML output style and then modified by hand as necessary, or from a file written using this method and then modified by the graphical parameter GUI (see the general documentation of this class). </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00700">700</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="afb4afb8f5cc2451fb16be1fff32b4380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4afb8f5cc2451fb16be1fff32b4380">&#9670;&nbsp;</a></span>parse_input_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input_from_json </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse input from a JSON stream to populate known parameter fields. This could be from a file originally written by the <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters()</a> function using the JSON output style and then modified by hand as necessary, or from a separate program that knows how to write JSON format for <a class="el" href="classParameterHandler.html">ParameterHandler</a> input. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00756">756</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a6184baed4eba575e422161dc86ed12e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6184baed4eba575e422161dc86ed12e3">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all contents. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00787">787</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a6d65f458be69e23a348221cb67fc411d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d65f458be69e23a348221cb67fc411d">&#9670;&nbsp;</a></span>declare_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::declare_entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em> = <code><a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>documentation</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>has_to_be_set</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare a new entry with name <code>entry</code>, default and for which any input has to match the <code>pattern</code> (default: any pattern).</p>
<p>The function generates an exception of type ExcValueDoesNotMatchPattern if the default value doesn't match the given pattern, using the C++ throw mechanism. However, this exception is only generated <em>after</em> the entry has been created; if you have code where no sensible default value for a parameter is possible, you can then catch and ignore this exception.</p>
<p>The parameter <code>documentation</code> defaulting to an empty string is used to add a documenting text to each entry which will be printed as a comment when this class is asked to write out all declarations to a stream using the <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters()</a> function.</p>
<p>The parameter <code>has_to_be_set</code> can be used in order to declare this parameter as a parameter whose default value has to be overwritten by one of the methods provided by this class. Whether a parameter has been set successfully can be queried by the functions <a class="el" href="classParameterHandler.html#aa5a299c29da8a837a1b8441039d0fa79">get_entries_wrongly_not_set()</a> and <a class="el" href="classParameterHandler.html#af441ab90c4d310c1c7d12c5f0050024f">assert_that_entries_have_been_set()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>An entry can be declared more than once without generating an error, for example to override an earlier default value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00796">796</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a59f3996003757093fb0e050a6729e81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f3996003757093fb0e050a6729e81b">&#9670;&nbsp;</a></span>add_action()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::add_action </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const std::string &amp;value)&gt; &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attach an action to the parameter with name <code>entry</code> in the current section. The action needs to be a function-like object that takes the value of the parameter as a (string) argument. See the general documentation of this class for a longer description of actions, as well as examples.</p>
<p>The action is executed in three different circumstances:</p><ul>
<li>With the default value of the parameter with name <code>name</code>, at the end of the current function. This is useful because it allows for the action to execute whatever it needs to do at least once for each parameter, even those that are not actually specified in the input file (and thus remain at their default values).</li>
<li>Within the <a class="el" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">ParameterHandler::set()</a> functions that explicitly set a value for a parameter.</li>
<li>Within the <a class="el" href="classMultipleParameterLoop.html#a978e161aae61a62c27a7dec2d7fd527b">parse_input()</a> function and similar functions such as <a class="el" href="classParameterHandler.html#a79bb8b2735fb7e9980ec73ff7b489f7f">parse_input_from_string()</a>. Here, the action is executed whenever the parameter with which it is associated is read from the input, after it has been established that the value so read matches the pattern that corresponds to this parameter, and before the value is actually saved.</li>
</ul>
<p>It is valid to add multiple actions to the same parameter. They will in that case be executed in the same order in which they were added.</p>
<dl class="section note"><dt>Note</dt><dd>Actions may modify all sorts of variables in their scope. The only thing an action should not modify is the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object it is attached to. In other words, it is not allowed to enter or leave sections of the current <a class="el" href="classParameterHandler.html">ParameterHandler</a> object. It is, in principle, acceptable to call <a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">ParameterHandler::get()</a> and related functions on other parameters in the current section, but since there is no guarantee about the order in which they will be read from an input file, you will not want to rely on the values these functions would return.</dd>
<dd>
Throwing an exception in an action is generally not a good idea, but yields fundamentally the same result as if one tries to read a parameter from a file for which the value does not satisfy the pattern associated with the parameter. In other words, the value just read is discarded, and <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> stops to read any further content from the file. See <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00842">842</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a04b75c02037d19fd7fd781785fcefc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b75c02037d19fd7fd781785fcefc79">&#9670;&nbsp;</a></span>add_parameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ParameterType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::add_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParameterType &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>documentation</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em> = <code>*<a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a>&lt;ParameterType&gt;::to_pattern()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>has_to_be_set</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare a new entry name <code>entry</code>, set its default value to the content of the variable <code>parameter</code>, and create an action that will fill <code>parameter</code> with updated values when a file is parsed, or the entry is set to a new value.</p>
<p>By default, the pattern to use is obtained by calling the function <a class="el" href="structPatterns_1_1Tools_1_1Convert.html#a3fb901bae7fe2de5dc27da09e989ad2c">Patterns::Tools::Convert&lt;T&gt;::to_pattern()</a>, but a custom one can be used.</p>
<p>The parameter <code>has_to_be_set</code> can be used in order to declare this parameter as a parameter whose default value has to be overwritten by one of the methods provided by this class. Whether a parameter has been set successfully can be queried by the functions <a class="el" href="classParameterHandler.html#aa5a299c29da8a837a1b8441039d0fa79">get_entries_wrongly_not_set()</a> and <a class="el" href="classParameterHandler.html#af441ab90c4d310c1c7d12c5f0050024f">assert_that_entries_have_been_set()</a>. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02315">2315</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aecb847561585089c4c7fcf51eddece16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb847561585089c4c7fcf51eddece16">&#9670;&nbsp;</a></span>declare_alias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::declare_alias </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>existing_entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alias_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>alias_is_deprecated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an alias for an existing entry. This provides a way to refer to a parameter in the input file using an alternate name. The alias will be in the current section, and the referenced entry needs to be an existing entry in the current section.</p>
<p>The primary purpose of this function is to allow for a backward compatible way of changing names in input files of applications for which backward compatibility is important. This can be achieved by changing the name of the parameter in the call to <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a>, and then creating an alias that maps the old name to the new name. This way, old input files can continue to refer to parameters under the old name, and they will automatically be mapped to the new parameter name.</p>
<p>It is valid to set the same parameter multiple times in an input file. The value that will ultimately be chosen in such cases is simply the last value set. This rule also applies to aliases, where the final value of a parameter is the last value set either through the current name of the parameter or through any of its possible multiple aliases. For example, if you have an input file that looks like </p><div class="fragment"><div class="line"><span class="keyword">set</span> parm1       = 1</div><div class="line"><span class="keyword">set</span> parm1_alias = 2</div></div><!-- fragment --><p> where <code>parm1_alias</code> is an alias declared via </p><div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#aecb847561585089c4c7fcf51eddece16">declare_alias</a> (<span class="stringliteral">&quot;parm1&quot;</span>, <span class="stringliteral">&quot;parm1_alias&quot;</span>);</div></div><!-- fragment --><p> then the final value for the parameter called <code>parm1</code> will be 2, not 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">existing_entry_name</td><td>The name of an existing parameter in the current section that the alias should refer to. </td></tr>
    <tr><td class="paramname">alias_name</td><td>An alternate name for the parameter referenced by the first argument. </td></tr>
    <tr><td class="paramname">alias_is_deprecated</td><td>If true, mark the alias as deprecated. This will then be listed in the description of the alias if you call <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters()</a>, and you will get a warning on the screen when reading an input file that contains this deprecated alias. The purpose of this argument is to be able to allow the use of an old name for a parameter (see above) but make it clear that this old name will eventually be removed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00878">878</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af29c20cde6d44186806d559beb468696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29c20cde6d44186806d559beb468696">&#9670;&nbsp;</a></span>enter_subsection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::enter_subsection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subsection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enter a subsection. If it does not yet exist, create it. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00939">939</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a599462cacd492e2f712bf7369507dcff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599462cacd492e2f712bf7369507dcff">&#9670;&nbsp;</a></span>leave_subsection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::leave_subsection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Leave present subsection. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00953">953</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae6142462087d1cd62d294eccb1f58867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6142462087d1cd62d294eccb1f58867">&#9670;&nbsp;</a></span>subsection_path_exists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::subsection_path_exists </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether a subsection or a subsection path exists in current tree. The input parameter <code>sub_path</code> is assumed to be relative to the currently selected path. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00966">966</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a91cfbaca954f444047302446a4e87125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cfbaca954f444047302446a4e87125">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_string</code>. If the entry was changed, then the changed value is returned, otherwise the default value. If the value of an undeclared entry is required, an <code>Assert</code> will fail. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00987">987</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa08ccf6fbd95de45a35b53ba0c09f49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08ccf6fbd95de45a35b53ba0c09f49f">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_string</code>. If the entry was changed, then the changed value is returned, otherwise the default value. If the value of an undeclared entry is required, an <code>Assert</code> will fail. If <code>entry_subsection_path</code> is non-empty, the value will be gotten from the subsection represented by that path instead of the current subsection. The first string in <code>entry_subsection_path</code> must be the name of a subsection of the current section, and each next string must be the name of a subsection of the one before it. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01004">1004</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a61fa98fdc0c52980a5b1de0ee1fc5bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fa98fdc0c52980a5b1de0ee1fc5bb2">&#9670;&nbsp;</a></span>get_integer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classint.html">int</a> ParameterHandler::get_integer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_string</code> as <code>long int</code>. (A long int is chosen so that even very large unsigned values can be returned by this function). </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01025">1025</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a421a09eb0548f1fb3783d97d3e85fd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421a09eb0548f1fb3783d97d3e85fd5c">&#9670;&nbsp;</a></span>get_integer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classint.html">int</a> ParameterHandler::get_integer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_string</code> as <code>long int</code>. (A long int is chosen so that even very large unsigned values can be returned by this function). If <code>entry_subsection_path</code> is non-empty, the value will be gotten from the subsection represented by that path instead of the current subsection. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01044">1044</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aeaf3c7846747695b1f327677e3716ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf3c7846747695b1f327677e3716ec5">&#9670;&nbsp;</a></span>get_double() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> ParameterHandler::get_double </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_name</code> as <code>double</code>. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01068">1068</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a913289695be07bd949bf94aa5cd5ad54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913289695be07bd949bf94aa5cd5ad54">&#9670;&nbsp;</a></span>get_double() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> ParameterHandler::get_double </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_name</code> as <code>double</code>. If <code>entry_subsection_path</code> is non-empty, the value will be gotten from the subsection represented by that path instead of the current subsection. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01088">1088</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a6bb45dc67787e3fab7882461929b5fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb45dc67787e3fab7882461929b5fbe">&#9670;&nbsp;</a></span>get_bool() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::get_bool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_name</code> as <code>bool</code>. The entry may be "true" or "yes" for <code>true</code>, "false" or "no" for <code>false</code> respectively. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01113">1113</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a209f365b60c5b0a76080b86693baa36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209f365b60c5b0a76080b86693baa36b">&#9670;&nbsp;</a></span>get_bool() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::get_bool </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return value of entry <code>entry_name</code> as <code>bool</code>. The entry may be "true" or "yes" for <code>true</code>, "false" or "no" for <code>false</code> respectively. If <code>entry_subsection_path</code> is non-empty, the value will be gotten from the subsection represented by that path instead of the current subsection. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01130">1130</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa6418ea655b1b550b9dcf63513030196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6418ea655b1b550b9dcf63513030196">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01152">1152</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af288e1fe38ac1a1baf1cef3058b63ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af288e1fe38ac1a1baf1cef3058b63ce1">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but an overload where the second argument is a character pointer. This is necessary, since otherwise the call to <code>set("abc","def")</code> will be mapped to the function taking one string and a bool as arguments, which is certainly not what is most often intended.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01205">1205</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa89180ba36c54e207286a3545f8371b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89180ba36c54e207286a3545f8371b4">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01227">1227</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ad46b9dd6387d7e48ddca4add8baad2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46b9dd6387d7e48ddca4add8baad2aa">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>For internal purposes, the new value needs to be converted to a string. This is done using 16 digits of accuracy, so the set value and the one you can get back out using <a class="el" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double()</a> may differ in the 16th digit.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01213">1213</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae417f9634872a427765365cd5ee9b160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae417f9634872a427765365cd5ee9b160">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the value presently stored for <code>entry_name</code> to the one given in the second argument.</p>
<p>The parameter must already exist in the present subsection.</p>
<p>The function throws an exception of type ExcValueDoesNotMatchPattern if the new value does not conform to the pattern for this entry. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01240">1240</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a4ac3a8b19ade16e96e8ea25906daf23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac3a8b19ade16e96e8ea25906daf23a">&#9670;&nbsp;</a></span>print_parameters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; ParameterHandler::print_parameters </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print all parameters with the given <code>style</code> to <code>out</code>.</p>
<p>Before printing, all current parameters and subsections are sorted alphabetically by default. This behavior can be disabled setting the optional parameter <code>style</code> to <code>KeepDeclarationOrder</code>: in this case entries are printed in the same order as they have been declared.</p>
<p>In <code>PRM</code>, <code>XML</code>, and <code>JSON</code> format, the output is formatted in such a way that it is possible to use it for later input again. This is most useful to record the parameters for a specific run, since if you output the parameters using this function into a log file, you can always recover the results by simply copying the output to your input file.</p>
<p>Besides the name and value of each entry, the output also contains the default value of entries if it is different from the actual value, as well as the documenting string given to the <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> function if available.</p>
<p>By using the flag <code>Short</code> in combination with <code>PRM</code>, <code>XML</code>, <code>JSON</code>, or <code>LaTeX</code> (or by using the shortcuts <code>ShortPRM</code>, <code>ShortXML</code>, <code>ShortJSON</code>, or <code>ShortLaTeX</code>), a reduced output can be generated, only containing the values and skipping the documentation.</p>
<p>In <code>XML</code> format, the output starts with one root element <code><a class="el" href="classParameterHandler.html">ParameterHandler</a></code> in order to get a valid XML document and all subsections under it.</p>
<p>In <code>LaTeX</code> format, the output contains the same information but in a format so that the resulting file can be input into a latex document such as a manual for the code for which this object handles run-time parameters. The various sections of parameters are then represented by latex section and subsection commands as well as by nested enumerations.</p>
<p>You can reference specific parameter sections and individual parameters by the labels that are generated automatically for each entry. The labels have the format <code>parameters:section1/subsection1</code> and <code>parameters:section1/subsection1/someentry</code>. Because special characters can appear in the section and entry names, these will be "mangled". Here, all characters except <code>[a-zA-Z0-9]</code> are replaced by <code>_XX</code>, where <code>XX</code> is the two-digit ascii code of the character in hexadecimal encoding (so a space becomes <code>_20</code> for example).</p>
<p>While this function escapes special LaTeX-specific characters (backslash, underscore, etc.) in most of the output (names, default values, etc.), the documentation string is passed as-is. This means you can use math environments and other formatting in the description, but you need to escape quotes, backslashes, underscores, etc. yourself.</p>
<p>In addition, all parameter names are listed with <code>\index</code> statements in two indices called <code>prmindex</code> (where the name of each parameter is listed in the index) and <code>prmindexfull</code> where parameter names are listed sorted by the section in which they exist. By default, the LaTeX program ignores these <code>\index</code> commands, but they can be used to generate an index by using the following commands in the preamble of the latex file : </p><div class="fragment"><div class="line">\usepackage{imakeidx}</div><div class="line">\makeindex[name=prmindex, title=Index of <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>-time parameter <a class="code" href="classParameterHandler.html#ae3c753f43844f2c1196d4ef939048bb0">entries</a>]</div><div class="line">\makeindex[name=prmindexfull,</div><div class="line">           title=Index of <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>-time parameters with section names]</div></div><!-- fragment --><p> and at the end of the file this: </p><div class="fragment"><div class="line">\printindex[prmindex]</div><div class="line">\printindex[prmindexfull]</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01250">1250</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a17fde9ad56e01eed0648e56106e6bf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17fde9ad56e01eed0648e56106e6bf1e">&#9670;&nbsp;</a></span>print_parameters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::print_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em> = <code><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print all parameters to the file given by <code>filename</code> with the given output style <code>style</code>.</p>
<p>This function deduces the output format from the extension of the specified filename. Supported extensions are <code>prm</code>, <code>xml</code>, <code>tex</code>, and <code>json</code>. Hence, it is not necessary to specify an output format via the <code>style</code> argument as long as one of these extensions is added to the filename. If an output format is specified in the <code>style</code> parameter nevertheless, the output format has to be consistent with the filename extension.</p>
<p>If no extension is specified or the extension is not supported, the output format is deduced from the <code>style</code> argument.</p>
<p>If neither the extension is supported, nor does the <code>style</code> parameter contain a format specification, an assertion is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The output file name. </td></tr>
    <tr><td class="paramname">style</td><td>The style with which output is produced. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01354">1354</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa900e3460a10639fc4d8703ef09a7c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa900e3460a10639fc4d8703ef09a7c0a">&#9670;&nbsp;</a></span>log_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::log_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLogStream.html">LogStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em> = <code><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print parameters to a logstream. This function allows to print all parameters into a log-file. Sections will be indented in the usual log- file style.</p>
<p>All current parameters and subsections are sorted alphabetically by default. This behavior can be disabled setting the optional parameter <code>style</code> to <code>KeepDeclarationOrder</code>: in this case entries are printed in the same order as they have been declared.</p>
<dl class="section note"><dt>Note</dt><dd>All style settings in <code>style</code> not related to the ordering are ignored. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01757">1757</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae15f2618f3b24c04eead226c5271be1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15f2618f3b24c04eead226c5271be1a">&#9670;&nbsp;</a></span>log_parameters_section()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::log_parameters_section </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLogStream.html">LogStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em> = <code><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Log parameters in the present subsection. The subsection is determined by the <code>subsection_path</code> member variable. This variable is controlled by entering and leaving subsections through the <a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection()</a> and <a class="el" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection()</a> functions.</p>
<p>All current parameters and subsections are sorted alphabetically by default. This behavior can be disabled setting the optional parameter <code>style</code> to <code>KeepDeclarationOrder</code>: in this case entries are printed in the same order as they have been declared.</p>
<dl class="section note"><dt>Note</dt><dd>All style settings in <code>style</code> not related to the ordering are ignored.</dd></dl>
<p>In most cases, you will not want to use this function directly, but have it called recursively by the previous function. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01768">1768</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a5df38ff67c1c8352e04de490e0c0a39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df38ff67c1c8352e04de490e0c0a39e">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02277">2277</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="a09fd2ee6d01b78079f894893aacd6c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fd2ee6d01b78079f894893aacd6c4c">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02296">2296</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aac896adce1ec1db3f525f57811764879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac896adce1ec1db3f525f57811764879">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="aede1a749bba8ee11876fd114a16c4f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede1a749bba8ee11876fd114a16c4f3e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test for equality. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02018">2018</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa5a299c29da8a837a1b8441039d0fa79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a299c29da8a837a1b8441039d0fa79">&#9670;&nbsp;</a></span>get_entries_wrongly_not_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; ParameterHandler::get_entries_wrongly_not_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a set of parameter names (including subsection names) corresponding to those entries of the parameter handler that have not been set by one of the functions parsing parameters from an input file or by an explicit call to one of the <a class="el" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set()</a> functions, but that have been declared as mandatory parameters that must be set (through the last argument of the <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> function or <a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">add_parameter()</a> function). </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02043">2043</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af441ab90c4d310c1c7d12c5f0050024f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af441ab90c4d310c1c7d12c5f0050024f">&#9670;&nbsp;</a></span>assert_that_entries_have_been_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::assert_that_entries_have_been_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asserts that those entries of the parameter handler with flag <code>has_to_be_set = true</code> have been set. An exception is invoked if at least one of these parameters has not been set. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02057">2057</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acf494a63b63e0f0a52ddcd7cd3ba60b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf494a63b63e0f0a52ddcd7cd3ba60b9">&#9670;&nbsp;</a></span>multiple_choices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classMultipleParameterLoop_1_1Entry.html">Entry</a>&gt; MultipleParameterLoop::multiple_choices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of variant entry values. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02243">2243</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="a7165818f5c82fed1026e6bb489c004a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7165818f5c82fed1026e6bb489c004a8">&#9670;&nbsp;</a></span>n_branches</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> MultipleParameterLoop::n_branches</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of branches constructed from the different combinations of the variants. This obviously equals the number of runs to be performed. </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l02249">2249</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a></li>
<li>source/base/<a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
