<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classMultipleParameterLoop.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MultipleParameterLoop Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classMultipleParameterLoop-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MultipleParameterLoop Class Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__input.html">Input</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="parameter__handler_8h_source.html">deal.II/base/parameter_handler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MultipleParameterLoop:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classMultipleParameterLoop__inherit__graph.svg" width="183" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop_1_1Entry.html">Entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop_1_1UserClass.html">UserClass</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8364dda711b93753c6809eefe2a8e827"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> { <br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a> = 0x0000, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f">Short</a> = 0x0001, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a50ae66aa378db81bb360ce7cdf96e3e1">KeepDeclarationOrder</a> = 0x0002, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a9b48379ffc293bc0a49b7aa342dbc9bf">PRM</a> = 0x0010, 
<br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">Text</a> = PRM, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3b5d289d79f36e819a7bd0d81a52ee37">LaTeX</a> = 0x0020, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a5ed7026d01b66b89ee3c1aef3efbfd4a">Description</a> = 0x0040, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510">XML</a> = 0x0080, 
<br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a456d0f94d7d72f33234d02a8b2e9030c">JSON</a> = 0x0100, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aadc1ef9748b3bb19e21e097bfe4f70b1">ShortPRM</a> = PRM | Short, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a6d91eaf8deb52a5d3cba991a9bb23ac7">ShortText</a> = ShortPRM, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aadab70cda4e49776ec93690fd9e1bbd1">ShortXML</a> = XML | Short, 
<br />
&#160;&#160;<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a26b405ba447d5fcbeb3c178076c4580f">ShortJSON</a> = JSON | Short, 
<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a0fbe0a13822fbc6b4e28fd6b416eb9ca">ShortLaTeX</a> = LaTeX | Short
<br />
 }</td></tr>
<tr class="separator:a8364dda711b93753c6809eefe2a8e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8f9975e29e77c65dfde69a389a03377"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa8f9975e29e77c65dfde69a389a03377">ExcInvalidEntryForPatternXML</a> = <a class="el" href="group__Exceptions.html#ga8b16bc7be372c9270121d278858a672f">ExcValueDoesNotMatchPattern</a></td></tr>
<tr class="separator:gaa8f9975e29e77c65dfde69a389a03377"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a90c2eea8e17afb645733c45d9bc5d562"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#a90c2eea8e17afb645733c45d9bc5d562">MultipleParameterLoop</a> ()</td></tr>
<tr class="separator:a90c2eea8e17afb645733c45d9bc5d562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b2ae95204b6d02958b55cdebcb7816"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#ac0b2ae95204b6d02958b55cdebcb7816">~MultipleParameterLoop</a> () override=default</td></tr>
<tr class="separator:ac0b2ae95204b6d02958b55cdebcb7816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978e161aae61a62c27a7dec2d7fd527b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#a978e161aae61a62c27a7dec2d7fd527b">parse_input</a> (std::istream &amp;input, const std::string &amp;filename=&quot;input file&quot;, const std::string &amp;last_line=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> skip_undefined=false) override</td></tr>
<tr class="separator:a978e161aae61a62c27a7dec2d7fd527b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd380d8bca1546e2c29fe9a33d047241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#acd380d8bca1546e2c29fe9a33d047241">loop</a> (<a class="el" href="classMultipleParameterLoop_1_1UserClass.html">UserClass</a> &amp;uc)</td></tr>
<tr class="separator:acd380d8bca1546e2c29fe9a33d047241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76c74f48e073e6ff96fa9d788d2b0bd"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#aa76c74f48e073e6ff96fa9d788d2b0bd">memory_consumption</a> () const</td></tr>
<tr class="separator:aa76c74f48e073e6ff96fa9d788d2b0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647461d59c5de46d345d56e0f856d581"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a647461d59c5de46d345d56e0f856d581">parse_input</a> (const std::string &amp;filename, const std::string &amp;last_line=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> skip_undefined=false, const <a class="el" href="classbool.html">bool</a> assert_mandatory_entries_are_found=false)</td></tr>
<tr class="separator:a647461d59c5de46d345d56e0f856d581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bb8b2735fb7e9980ec73ff7b489f7f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a79bb8b2735fb7e9980ec73ff7b489f7f">parse_input_from_string</a> (const std::string &amp;s, const std::string &amp;last_line=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> skip_undefined=false)</td></tr>
<tr class="separator:a79bb8b2735fb7e9980ec73ff7b489f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e7edb2a86419b76f4a1b69dfdd873a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a12e7edb2a86419b76f4a1b69dfdd873a">parse_input_from_xml</a> (std::istream &amp;input, const <a class="el" href="classbool.html">bool</a> skip_undefined=false)</td></tr>
<tr class="separator:a12e7edb2a86419b76f4a1b69dfdd873a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4afb8f5cc2451fb16be1fff32b4380"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#afb4afb8f5cc2451fb16be1fff32b4380">parse_input_from_json</a> (std::istream &amp;input, const <a class="el" href="classbool.html">bool</a> skip_undefined=false)</td></tr>
<tr class="separator:afb4afb8f5cc2451fb16be1fff32b4380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6184baed4eba575e422161dc86ed12e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6184baed4eba575e422161dc86ed12e3">clear</a> ()</td></tr>
<tr class="separator:a6184baed4eba575e422161dc86ed12e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d65f458be69e23a348221cb67fc411d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a> (const std::string &amp;entry, const std::string &amp;default_value, const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;pattern=<a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(), const std::string &amp;documentation=&quot;&quot;, const <a class="el" href="classbool.html">bool</a> has_to_be_set=false)</td></tr>
<tr class="separator:a6d65f458be69e23a348221cb67fc411d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f3996003757093fb0e050a6729e81b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a59f3996003757093fb0e050a6729e81b">add_action</a> (const std::string &amp;entry, const std::function&lt; void(const std::string &amp;value)&gt; &amp;action)</td></tr>
<tr class="separator:a59f3996003757093fb0e050a6729e81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b75c02037d19fd7fd781785fcefc79"><td class="memTemplParams" colspan="2">template&lt;class ParameterType &gt; </td></tr>
<tr class="memitem:a04b75c02037d19fd7fd781785fcefc79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">add_parameter</a> (const std::string &amp;entry, ParameterType &amp;parameter, const std::string &amp;documentation=&quot;&quot;, const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;pattern= *<a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a>&lt; ParameterType &gt;::to_pattern(), const <a class="el" href="classbool.html">bool</a> has_to_be_set=false)</td></tr>
<tr class="separator:a04b75c02037d19fd7fd781785fcefc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb847561585089c4c7fcf51eddece16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aecb847561585089c4c7fcf51eddece16">declare_alias</a> (const std::string &amp;existing_entry_name, const std::string &amp;alias_name, const <a class="el" href="classbool.html">bool</a> alias_is_deprecated=false)</td></tr>
<tr class="separator:aecb847561585089c4c7fcf51eddece16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29c20cde6d44186806d559beb468696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a> (const std::string &amp;subsection)</td></tr>
<tr class="separator:af29c20cde6d44186806d559beb468696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599462cacd492e2f712bf7369507dcff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a> ()</td></tr>
<tr class="separator:a599462cacd492e2f712bf7369507dcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6142462087d1cd62d294eccb1f58867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae6142462087d1cd62d294eccb1f58867">subsection_path_exists</a> (const std::vector&lt; std::string &gt; &amp;sub_path) const</td></tr>
<tr class="separator:ae6142462087d1cd62d294eccb1f58867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cfbaca954f444047302446a4e87125"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a> (const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a91cfbaca954f444047302446a4e87125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08ccf6fbd95de45a35b53ba0c09f49f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa08ccf6fbd95de45a35b53ba0c09f49f">get</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:aa08ccf6fbd95de45a35b53ba0c09f49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fa98fdc0c52980a5b1de0ee1fc5bb2"><td class="memItemLeft" align="right" valign="top">long <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a> (const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a61fa98fdc0c52980a5b1de0ee1fc5bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421a09eb0548f1fb3783d97d3e85fd5c"><td class="memItemLeft" align="right" valign="top">long <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a421a09eb0548f1fb3783d97d3e85fd5c">get_integer</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a421a09eb0548f1fb3783d97d3e85fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf3c7846747695b1f327677e3716ec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a> (const std::string &amp;entry_name) const</td></tr>
<tr class="separator:aeaf3c7846747695b1f327677e3716ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913289695be07bd949bf94aa5cd5ad54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a913289695be07bd949bf94aa5cd5ad54">get_double</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a913289695be07bd949bf94aa5cd5ad54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb45dc67787e3fab7882461929b5fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a> (const std::string &amp;entry_name) const</td></tr>
<tr class="separator:a6bb45dc67787e3fab7882461929b5fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209f365b60c5b0a76080b86693baa36b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a209f365b60c5b0a76080b86693baa36b">get_bool</a> (const std::vector&lt; std::string &gt; &amp;entry_subsection_path, const std::string &amp;entry_string) const</td></tr>
<tr class="separator:a209f365b60c5b0a76080b86693baa36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6418ea655b1b550b9dcf63513030196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a> (const std::string &amp;entry_name, const std::string &amp;new_value)</td></tr>
<tr class="separator:aa6418ea655b1b550b9dcf63513030196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af288e1fe38ac1a1baf1cef3058b63ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af288e1fe38ac1a1baf1cef3058b63ce1">set</a> (const std::string &amp;entry_name, const char *new_value)</td></tr>
<tr class="separator:af288e1fe38ac1a1baf1cef3058b63ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89180ba36c54e207286a3545f8371b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa89180ba36c54e207286a3545f8371b4">set</a> (const std::string &amp;entry_name, const long <a class="el" href="classint.html">int</a> new_value)</td></tr>
<tr class="separator:aa89180ba36c54e207286a3545f8371b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46b9dd6387d7e48ddca4add8baad2aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ad46b9dd6387d7e48ddca4add8baad2aa">set</a> (const std::string &amp;entry_name, const <a class="el" href="classdouble.html">double</a> new_value)</td></tr>
<tr class="separator:ad46b9dd6387d7e48ddca4add8baad2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae417f9634872a427765365cd5ee9b160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae417f9634872a427765365cd5ee9b160">set</a> (const std::string &amp;entry_name, const <a class="el" href="classbool.html">bool</a> new_value)</td></tr>
<tr class="separator:ae417f9634872a427765365cd5ee9b160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac3a8b19ade16e96e8ea25906daf23a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a> (std::ostream &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style) const</td></tr>
<tr class="separator:a4ac3a8b19ade16e96e8ea25906daf23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fde9ad56e01eed0648e56106e6bf1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a17fde9ad56e01eed0648e56106e6bf1e">print_parameters</a> (const std::string &amp;filename, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style=<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a>) const</td></tr>
<tr class="separator:a17fde9ad56e01eed0648e56106e6bf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa900e3460a10639fc4d8703ef09a7c0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa900e3460a10639fc4d8703ef09a7c0a">log_parameters</a> (<a class="el" href="classLogStream.html">LogStream</a> &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style=<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a>)</td></tr>
<tr class="separator:aa900e3460a10639fc4d8703ef09a7c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15f2618f3b24c04eead226c5271be1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#ae15f2618f3b24c04eead226c5271be1a">log_parameters_section</a> (<a class="el" href="classLogStream.html">LogStream</a> &amp;out, const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a> style=<a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a>)</td></tr>
<tr class="separator:ae15f2618f3b24c04eead226c5271be1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df38ff67c1c8352e04de490e0c0a39e"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a5df38ff67c1c8352e04de490e0c0a39e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a5df38ff67c1c8352e04de490e0c0a39e">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:a5df38ff67c1c8352e04de490e0c0a39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#a09fd2ee6d01b78079f894893aacd6c4c">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a09fd2ee6d01b78079f894893aacd6c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac896adce1ec1db3f525f57811764879"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:aac896adce1ec1db3f525f57811764879"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aac896adce1ec1db3f525f57811764879">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:aac896adce1ec1db3f525f57811764879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede1a749bba8ee11876fd114a16c4f3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aede1a749bba8ee11876fd114a16c4f3e">operator==</a> (const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm2) const</td></tr>
<tr class="separator:aede1a749bba8ee11876fd114a16c4f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a299c29da8a837a1b8441039d0fa79"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#aa5a299c29da8a837a1b8441039d0fa79">get_entries_wrongly_not_set</a> () const</td></tr>
<tr class="separator:aa5a299c29da8a837a1b8441039d0fa79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af441ab90c4d310c1c7d12c5f0050024f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParameterHandler.html#af441ab90c4d310c1c7d12c5f0050024f">assert_that_entries_have_been_set</a> () const</td></tr>
<tr class="separator:af441ab90c4d310c1c7d12c5f0050024f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga55b48a9b5ced390a0c292e8103afdf91"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga55b48a9b5ced390a0c292e8103afdf91">ExcEntryAlreadyExists</a> (std::string arg1)</td></tr>
<tr class="separator:ga55b48a9b5ced390a0c292e8103afdf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b16bc7be372c9270121d278858a672f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8b16bc7be372c9270121d278858a672f">ExcValueDoesNotMatchPattern</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga8b16bc7be372c9270121d278858a672f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9213c9ff33bbb3d167b67fa890a6d9ce"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9213c9ff33bbb3d167b67fa890a6d9ce">ExcAlreadyAtTopLevel</a> ()</td></tr>
<tr class="separator:ga9213c9ff33bbb3d167b67fa890a6d9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab8cc9a7fa6a9c6114a207b795007d5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga2ab8cc9a7fa6a9c6114a207b795007d5">ExcEntryUndeclared</a> (std::string arg1)</td></tr>
<tr class="separator:ga2ab8cc9a7fa6a9c6114a207b795007d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a05434eefbd2de0314b0a483247d96d"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0a05434eefbd2de0314b0a483247d96d">ExcUnbalancedSubsections</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga0a05434eefbd2de0314b0a483247d96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8136031b245c5a29ddac3940090f0ac"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad8136031b245c5a29ddac3940090f0ac">ExcNoSubsection</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gad8136031b245c5a29ddac3940090f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa620e44b3aa3cf356feaa424a516086e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa620e44b3aa3cf356feaa424a516086e">ExcCannotParseLine</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gaa620e44b3aa3cf356feaa424a516086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3cb505bbdd65d21ef66e3ef7e383bab"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad3cb505bbdd65d21ef66e3ef7e383bab">ExcInvalidEntryForPattern</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3, std::string arg4, std::string arg5)</td></tr>
<tr class="separator:gad3cb505bbdd65d21ef66e3ef7e383bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43bb6588e469c2e12a430fb7ea316da1"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga43bb6588e469c2e12a430fb7ea316da1">ExcInvalidXMLParameterFile</a> ()</td></tr>
<tr class="separator:ga43bb6588e469c2e12a430fb7ea316da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2febc2a5dd0328f971093085bf9b4fa"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac2febc2a5dd0328f971093085bf9b4fa">ExcCannotOpenIncludeStatementFile</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac2febc2a5dd0328f971093085bf9b4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2a4d4877a5f67766a8a375de6f4cb17a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#a2a4d4877a5f67766a8a375de6f4cb17a">init_branches</a> ()</td></tr>
<tr class="separator:a2a4d4877a5f67766a8a375de6f4cb17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e01c261219f65af82c3f6c5ab28a68d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#a0e01c261219f65af82c3f6c5ab28a68d">init_branches_current_section</a> ()</td></tr>
<tr class="separator:a0e01c261219f65af82c3f6c5ab28a68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58138c82fb4fb1d75f5444baf26f4aed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#a58138c82fb4fb1d75f5444baf26f4aed">fill_entry_values</a> (const unsigned <a class="el" href="classint.html">int</a> run_no)</td></tr>
<tr class="separator:a58138c82fb4fb1d75f5444baf26f4aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:acf494a63b63e0f0a52ddcd7cd3ba60b9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classMultipleParameterLoop_1_1Entry.html">Entry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#acf494a63b63e0f0a52ddcd7cd3ba60b9">multiple_choices</a></td></tr>
<tr class="separator:acf494a63b63e0f0a52ddcd7cd3ba60b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7165818f5c82fed1026e6bb489c004a8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMultipleParameterLoop.html#a7165818f5c82fed1026e6bb489c004a8">n_branches</a></td></tr>
<tr class="separator:a7165818f5c82fed1026e6bb489c004a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>多参数循环（MultipleParameterLoop）类提供了一种简单的可能性，可以在程序的一次运行中测试多个参数集。为此，它使用ParameterHandler类以标准化的形式读入数据，搜索变量入口值并对所有的参数组合进行循环。 变体条目值是这样给出的。 </p><pre class="fragment">*   set Time step size = { 0.1 | 0.2 | 0.3 }
* </pre><p> 循环将进行三次程序运行，对<code>时间步长</code>的每个值进行一次运行，而所有其他参数都按指定值或默认值运行。如果在输入中存在几个变体条目值，则对每个变体值的组合进行一次循环。 </p><pre class="fragment">*   set Time step size = { 0.1 | 0.2 }
*   set Solver         = { CG  | GMRES }
* </pre><p> 将导致程序的四次运行，两个求解器的时间步长分别为0.1和0.2。 除了变体条目，这个类还支持<em>array entries</em>，看起来像这样。 </p><pre class="fragment">*   set Output file = ofile.{{ 1 | 2 | 3 | 4 }}
* </pre><p> 这表明如果有变体条目产生了总共四个不同的运行，那么我们将把它们的结果分别写入文件<code>ofile.1</code>、<code>ofile.2</code>、<code>ofile.3</code>和<code>ofile.4</code>。数组条目本身不产生主循环的多次运行，但是如果有变体条目，那么在主循环的<em>n</em>次运行中，也会返回数组的<em>n</em>次值。 由于不同的变体是按照声明的顺序构建的，而不是按照变体条目在输入文件中出现的顺序，所以可能很难猜测不同的变体和数组中适当的条目之间的映射。你将不得不检查声明的顺序，或者只使用一个变体条目。 保证只有在声明一个条目时给出的正则表达式（模式）相匹配的选择才会被反馈给程序。如果一个变量的值与正则表达式不匹配，就会存储默认值并发出错误。在循环的第一次运行之前，所有可能的值都会被检查是否符合，因此错误会在程序的一开始就发出。</p>
<h3>Usage</h3>
<p>这个类的用法与ParameterHandler类相似。首先必须声明条目和分节，然后进行循环，在循环中设置不同的参数集，创建一个新的用户类的实例，然后调用。以ParameterHandler类的例子为例，扩展后的程序会是这样的。 </p><div class="fragment"><div class="line"><span class="keyword">class </span>HelperClass : <span class="keyword">public</span> <a class="code" href="classMultipleParameterLoop_1_1UserClass.html">MultipleParameterLoop::UserClass</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  HelperClass ();</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> create_new (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> run_no);</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a> (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::unique_ptr&lt;Problem&gt; p;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">HelperClass::HelperClass () : p(0) {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> HelperClass::create_new (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> run_no)</div><div class="line">{</div><div class="line">  p = std::make_unique&lt;Problem&gt;());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> HelperClass::declare_parameters (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  Problem::declare_parameters (prm);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">HelperClass::run</a> (<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  p-&gt;get_parameters (prm);</div><div class="line">  p-&gt;do_useful_work ();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <span class="keyword">class </span><a class="code" href="classMultipleParameterLoop.html">MultipleParameterLoop</a> prm;</div><div class="line">  HelperClass h;</div><div class="line">  HelperClass::declare_parameters (prm);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a> (<span class="stringliteral">&quot;prmtest.prm&quot;</span>);</div><div class="line">  prm.loop (h);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>可以看出，首先必须建立一个新的辅助类。这必须包含一个问题类的虚拟构造函数。你也可以从 <a class="el" href="classMultipleParameterLoop_1_1UserClass.html">MultipleParameterLoop::UserClass</a> 中派生出你的问题类，并让<code>create_new</code>清除所有成员变量。如果你能以某种方式访问所有继承的成员变量，这就是推荐的程序。第三种可能性是使用多重继承，从 <a class="el" href="classMultipleParameterLoop_1_1UserClass.html">MultipleParameterLoop::UserClass</a> 和问题类中派生出一个辅助类。在任何情况下，<code>create_new</code>都必须提供一个干净的问题对象，这是第二和第三种可能性的问题。 派生类还必须提供声明条目和运行程序的成员函数。运行程序包括从ParameterHandler对象中获取参数。 在定义了这个辅助类的对象和多参数循环类的对象后，必须以与ParameterHandler类相同的方式声明条目。然后要读取输入。最后，循环被调用。这将执行以下步骤。 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (each combination)</div><div class="line">  {</div><div class="line">    UserObject.create_new (run_no);</div><div class="line"></div><div class="line">    <span class="comment">// set parameters for this run</span></div><div class="line"></div><div class="line">    UserObject.run (*<span class="keyword">this</span>);</div><div class="line">  }</div></div><!-- fragment --><p> <code>UserObject</code>是<code>loop</code>函数的参数。<code>create_new</code>被赋予运行的编号（从1开始），以使每次运行的输出文件的命名不同。</p>
<h3>Syntax for variant and array entry values</h3>
<p>变量值的指定与<code>prefix{ v1 | v2 | v3 | ... }postfix</code>。开头括号<code>{</code>右边的空白会被忽略，而结尾括号<code>}</code>左边的空白也不会被忽略。中间符号<code>|</code>周围的空白也会被忽略。空的选择<code>prefix{ v1 | }postfix</code>也是允许的，并产生字符串<code>prefixv1postfix</code>和<code>prefixpostfix</code>。 除了双括号之外，数组值的语法是相同的。<code>prefix{{ v1 | v2 | v3 }}postfix</code>。</p>
<h3>Worked example</h3>
<p>给出上述对ParameterHandler示例程序的扩展和以下输入文件 </p><pre class="fragment">*   set Equation 1 = Poisson
*   set Equation 2 = Navier-Stokes
*   set Output file= results.{{ 1 | 2 | 3 | 4 | 5 | 6 }}
*
*   subsection Equation 1
*     set Matrix type = Sparse
*     subsection Linear solver
*       set Solver                       = CG
*       set Maximum number of iterations = { 10 | 20 | 30 }
*     end
*   end
*
*   subsection Equation 2
*     set Matrix type = Full
*     subsection Linear solver
*       set Solver                       = { BiCGStab | GMRES }
*       set Maximum number of iterations = 100
*     end
*   end
* </pre><p> 这就是输出结果。 </p><pre class="fragment">*   LinEq: Method=CG, MaxIterations=10
*   LinEq: Method=BiCGStab, MaxIterations=100
*   Problem: outfile=results.1
*            eq1=Poisson, eq2=Navier-Stokes
*            Matrix1=Sparse, Matrix2=Full
*   LinEq: Method=CG, MaxIterations=20
*   LinEq: Method=BiCGStab, MaxIterations=100
*   Problem: outfile=results.2
*            eq1=Poisson, eq2=Navier-Stokes
*            Matrix1=Sparse, Matrix2=Full
*   LinEq: Method=CG, MaxIterations=30
*   LinEq: Method=BiCGStab, MaxIterations=100
*   Problem: outfile=results.3
*            eq1=Poisson, eq2=Navier-Stokes
*            Matrix1=Sparse, Matrix2=Full
*   LinEq: Method=CG, MaxIterations=10
*   LinEq: Method=GMRES, MaxIterations=100
*   Problem: outfile=results.4
*            eq1=Poisson, eq2=Navier-Stokes
*            Matrix1=Sparse, Matrix2=Full
*   LinEq: Method=CG, MaxIterations=20
*   LinEq: Method=GMRES, MaxIterations=100
*   Problem: outfile=results.5
*            eq1=Poisson, eq2=Navier-Stokes
*            Matrix1=Sparse, Matrix2=Full
*   LinEq: Method=CG, MaxIterations=30
*   LinEq: Method=GMRES, MaxIterations=100
*   Problem: outfile=results.6
*            eq1=Poisson, eq2=Navier-Stokes
*            Matrix1=Sparse, Matrix2=Full
* </pre><p> 由于<code>create_new</code>得到了运行的编号，所以也可以输出运行的编号。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01750">1750</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a8364dda711b93753c6809eefe2a8e827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8364dda711b93753c6809eefe2a8e827">&#9670;&nbsp;</a></span>OutputStyle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用于 <a class="el" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">ParameterHandler::print_parameters()</a>. 等函数的可能输出格式列表 选项可分为两组。</p>
<ul>
<li>格式选项。PRM, LaTeX, Description, XML, JSON</li>
<li>文体选项。Short, KeepDeclarationOrder 每次只能指定一个格式选项。任何接受OutputStyle作为选项的函数，如果你指定了一个以上的选项，就会抛出。 我们提供了一些常用选项组合的快捷方式。 例如，ShortPRM以PRM格式打印参数，同时跳过文档。 </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48"></a>DefaultStyle&#160;</td><td class="fielddoc"><p>默认文体风格：打印文档，并按字母顺序排列所有参数。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f"></a>Short&#160;</td><td class="fielddoc"><p>为ParameterHandler写输入，没有注释或改变默认值。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a50ae66aa378db81bb360ce7cdf96e3e1"></a>KeepDeclarationOrder&#160;</td><td class="fielddoc"><p>保持参数的顺序，因为它们已经被声明了。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a9b48379ffc293bc0a49b7aa342dbc9bf"></a>PRM&#160;</td><td class="fielddoc"><p>编写适合由 <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> 再次读取的人类可读输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365"></a>Text&#160;</td><td class="fielddoc"><p>写出适合由 <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> 再次读取的人类可读输出。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>使用<code>PRM</code>而不是<code>Text</code>。</dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a3b5d289d79f36e819a7bd0d81a52ee37"></a>LaTeX&#160;</td><td class="fielddoc"><p>将参数写成LaTeX表格。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a5ed7026d01b66b89ee3c1aef3efbfd4a"></a>Description&#160;</td><td class="fielddoc"><p>写出声明的参数与描述和可能的值。 </p><dl class="section note"><dt>Note</dt><dd>这种格式不适合再读回来。 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a2b5a2007249d810f05d23dc837c47510"></a>XML&#160;</td><td class="fielddoc"><p>将所有内容写成一个<a href="http://en.wikipedia.org/wiki/XML">XML</a>的文件，适合由 <a class="el" href="classParameterHandler.html#a12e7edb2a86419b76f4a1b69dfdd873a">ParameterHandler::parse_input_from_xml()</a> 再次读取。 关于输出的例子，请看这个类的一般文档。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a456d0f94d7d72f33234d02a8b2e9030c"></a>JSON&#160;</td><td class="fielddoc"><p>把所有的东西都写成一个<a href="http://en.wikipedia.org/wiki/JSON">JSON</a>文件，适合由 <a class="el" href="classParameterHandler.html#afb4afb8f5cc2451fb16be1fff32b4380">ParameterHandler::parse_input_from_json()</a> 再次读取。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827aadc1ef9748b3bb19e21e097bfe4f70b1"></a>ShortPRM&#160;</td><td class="fielddoc"><p>写出ParameterHandler的内容，没有注释或改变默认值。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a6d91eaf8deb52a5d3cba991a9bb23ac7"></a>ShortText&#160;</td><td class="fielddoc"><p>写下ParameterHandler的内容，不加评论或改变默认值。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>使用<code>ShortPRM</code>而不是<code>ShortText</code>。</dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827aadab70cda4e49776ec93690fd9e1bbd1"></a>ShortXML&#160;</td><td class="fielddoc"><p>把ParameterHandler的内容写成XML文件，不加注释或改变默认值。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a26b405ba447d5fcbeb3c178076c4580f"></a>ShortJSON&#160;</td><td class="fielddoc"><p>把ParameterHandler的内容写成JSON文件，不加注释或改变默认值。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a8364dda711b93753c6809eefe2a8e827a0fbe0a13822fbc6b4e28fd6b416eb9ca"></a>ShortLaTeX&#160;</td><td class="fielddoc"><p>把ParameterHandler的内容写成LaTeX文件，不加注释或改变默认值。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l00734">734</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a90c2eea8e17afb645733c45d9bc5d562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c2eea8e17afb645733c45d9bc5d562">&#9670;&nbsp;</a></span>MultipleParameterLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MultipleParameterLoop::MultipleParameterLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02083">2083</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ac0b2ae95204b6d02958b55cdebcb7816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b2ae95204b6d02958b55cdebcb7816">&#9670;&nbsp;</a></span>~MultipleParameterLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual MultipleParameterLoop::~MultipleParameterLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解构器。声明这个只是为了有一个虚拟的析构器，这更安全，因为我们有虚拟函数。它实际上没有什么了不起的作用。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a978e161aae61a62c27a7dec2d7fd527b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978e161aae61a62c27a7dec2d7fd527b">&#9670;&nbsp;</a></span>parse_input() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultipleParameterLoop::parse_input </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;input&#160;file&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一个流中读取输入，直到该流返回<code>eof</code>条件或错误。第二个参数可以用来表示我们正在读取的文件的名称（如果那是输入流所代表的）；这只在为错误信息创建输出时使用。 如果提供了非空的 <code>last_line</code> ，ParameterHandler对象将在遇到 <code>last_line</code> 后停止解析行。 这在添加应被手动解析的额外数据时很方便。 如果 <code>skip_undefined</code> 是 <code>true</code> ，参数处理程序将跳过未定义的部分和条目。这对于部分解析参数文件非常有用，例如，只获得问题的空间维度。默认情况下，所有条目和子节都应该被声明。 </p><dl class="section note"><dt>Note</dt><dd>这是ParameterHandler实现的三个<code>parse_input</code>函数中唯一的重载，这个类用新的行为重写了这个函数。这是因为其他两个<code>parse_input</code>函数只是重新格式化它们的输入，然后调用这个版本。 </dd></dl>

<p>Reimplemented from <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler</a>.</p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02090">2090</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="acd380d8bca1546e2c29fe9a33d047241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd380d8bca1546e2c29fe9a33d047241">&#9670;&nbsp;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MultipleParameterLoop::loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMultipleParameterLoop_1_1UserClass.html">MultipleParameterLoop::UserClass</a> &amp;&#160;</td>
          <td class="paramname"><em>uc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>运行中心循环。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02107">2107</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa76c74f48e073e6ff96fa9d788d2b0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76c74f48e073e6ff96fa9d788d2b0bd">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MultipleParameterLoop::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>确定这个对象的内存消耗（以字节为单位）的估计值。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02241">2241</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a2a4d4877a5f67766a8a375de6f4cb17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4d4877a5f67766a8a375de6f4cb17a">&#9670;&nbsp;</a></span>init_branches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultipleParameterLoop::init_branches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>初始化不同的分支，即构建组合。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02121">2121</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a0e01c261219f65af82c3f6c5ab28a68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e01c261219f65af82c3f6c5ab28a68d">&#9670;&nbsp;</a></span>init_branches_current_section()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultipleParameterLoop::init_branches_current_section </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>遍历当前由enter_subsection()/leave_subsection()设置的部分，看看哪些条目是变体或数组条目。然后用这些信息填充multiple_choices变量。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02162">2162</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a58138c82fb4fb1d75f5444baf26f4aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58138c82fb4fb1d75f5444baf26f4aed">&#9670;&nbsp;</a></span>fill_entry_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultipleParameterLoop::fill_entry_values </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>run_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一次运行的条目值转移到条目树上。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02193">2193</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a647461d59c5de46d345d56e0f856d581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647461d59c5de46d345d56e0f856d581">&#9670;&nbsp;</a></span>parse_input() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>assert_mandatory_entries_are_found</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解析来自指定参数文件的输入 <code>filename</code> ，与正在使用的输入文件类型（prm、xml、json）无关。这个函数选择的代码路径是从文件名的结尾处提取的，所以用户必须确保输入文件的内容与文件名一致。 参数 <code>last_line</code> 将只用于.prm类型的参数文件。 参见其他parse_input函数的文档。 用户可以指定输入文件中未加入参数处理程序的参数是否会被 <code>skip_undefined</code> 跳过（启用部分解析），以及代码是否会断言所有用标志<code>has_to_be_set=true</code>声明的参数处理程序的参数确实在输入文件中找到。 如果函数是以<code>skip_undefined=true</code>调用的，建议同时设置<code>assert_mandatory_entries_are_found=true</code>。例如，这可以确保在输入文件中有错别字的参数不会被跳过，而这种错误在其他情况下仍然无法被识别。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00532">532</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a79bb8b2735fb7e9980ec73ff7b489f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bb8b2735fb7e9980ec73ff7b489f7f">&#9670;&nbsp;</a></span>parse_input_from_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input_from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>last_line</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一个字符串中解析输入，以填充已知的参数字段。字符串中的各行必须用<code> \n</code> 字符分开。 该函数实质上是将整个文件读入一个流，然后用该流调用其他的parse_input()函数。更多信息见那里。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00560">560</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a12e7edb2a86419b76f4a1b69dfdd873a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e7edb2a86419b76f4a1b69dfdd873a">&#9670;&nbsp;</a></span>parse_input_from_xml()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input_from_xml </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一个XML流中解析输入，以填充已知的参数字段。这可能来自一个最初由print_parameters()函数使用XML输出风格编写的文件，然后根据需要手工修改，或者来自一个使用该方法编写的文件，然后由图形化参数GUI修改（见该类的一般文档）。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00700">700</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="afb4afb8f5cc2451fb16be1fff32b4380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4afb8f5cc2451fb16be1fff32b4380">&#9670;&nbsp;</a></span>parse_input_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::parse_input_from_json </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>skip_undefined</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解析来自JSON流的输入，以填充已知的参数字段。这可能来自于最初由print_parameters()函数使用JSON输出风格编写的文件，然后根据需要手工修改，或者来自一个知道如何为ParameterHandler输入编写JSON格式的单独程序。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00756">756</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a6184baed4eba575e422161dc86ed12e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6184baed4eba575e422161dc86ed12e3">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>清除所有内容。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00787">787</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a6d65f458be69e23a348221cb67fc411d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d65f458be69e23a348221cb67fc411d">&#9670;&nbsp;</a></span>declare_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::declare_entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em> = <code><a class="el" href="classPatterns_1_1Anything.html">Patterns::Anything</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>documentation</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>has_to_be_set</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>声明一个新的条目，名称为<code>entry</code>，默认为任何输入都必须与<code>pattern</code>相匹配（默认：任何模式）。 如果默认值与给定的模式不匹配，该函数会产生一个ExcValueDoesNotMatchPattern类型的异常，使用C++的抛出机制。然而，这个异常只在条目被创建时产生<em>after</em>；如果你的代码中不可能有合理的参数默认值，那么你可以捕捉并忽略这个异常。 参数 <code>documentation</code> 默认为一个空字符串，用于为每个条目添加记录文本，当这个类被要求使用print_parameters()函数将所有声明写到一个流中时，该文本将被打印出来作为注释。 可以使用参数 <code>has_to_be_set</code> 来声明这个参数，这个参数的默认值必须被这个类所提供的一个方法所覆盖。一个参数是否被成功设置，可以通过函数get_entries_wrongly_not_set()和assert_that_entries_have_been_set()进行查询。 </p><dl class="section note"><dt>Note</dt><dd>一个条目可以被声明多次而不产生错误，例如，为了覆盖一个早期的默认值。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00796">796</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a59f3996003757093fb0e050a6729e81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f3996003757093fb0e050a6729e81b">&#9670;&nbsp;</a></span>add_action()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::add_action </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const std::string &amp;value)&gt; &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在当前章节中为名称为 <code>entry</code> 的参数附加一个动作。这个动作需要是一个类似于函数的对象，把参数的值作为一个（字符串）参数。关于动作的更多描述，请参见这个类的一般文档，以及例子。 该动作在三种不同的情况下被执行。</p>
<ul>
<li>在当前函数的末尾加上名称为 <code>name</code>, 的参数的默认值。这很有用，因为它允许动作对每个参数至少执行一次它需要做的事情，即使是那些实际上没有在输入文件中指定的参数（因此保持其默认值）。</li>
<li>在 <a class="el" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">ParameterHandler::set()</a> 函数中，明确地为一个参数设置一个值。</li>
<li>在parse_input()函数和类似的函数中，例如parse_input_from_string()。在这里，只要从输入中读取与之相关的参数，在确定所读取的值与该参数所对应的模式相匹配后，在实际保存该值之前，就会执行该动作。 为同一个参数添加多个动作是有效的。在这种情况下，它们将按照添加的顺序被执行。 <dl class="section note"><dt>Note</dt><dd>动作可以修改其范围内的所有种类的变量。一个动作唯一不应该修改的是它所连接的ParameterHandler对象。换句话说，它不允许进入或离开当前ParameterHandler对象的部分。原则上，在当前部分的其他参数上调用 <a class="el" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">ParameterHandler::get()</a> 和相关函数是可以接受的，但由于不能保证它们从输入文件中读取的顺序，你将不希望依赖这些函数将返回的值。 </dd>
<dd>
在一个动作中抛出一个异常通常不是一个好主意，但产生的结果与试图从一个文件中读取一个参数的结果基本相同，因为该参数的值不符合与该参数相关的模式。换句话说，刚刚读取的值被丢弃， <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> 停止从文件中读取任何进一步的内容。更多信息见 <a class="el" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">ParameterHandler::parse_input()</a> 。 </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00842">842</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a04b75c02037d19fd7fd781785fcefc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b75c02037d19fd7fd781785fcefc79">&#9670;&nbsp;</a></span>add_parameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ParameterType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::add_parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParameterType &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>documentation</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPatterns_1_1PatternBase.html">Patterns::PatternBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em> = <code>*<a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a>&lt;ParameterType&gt;::to_pattern()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>has_to_be_set</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>声明一个新的条目名称 <code>entry</code>, 将其默认值设置为变量 <code>parameter</code>, 的内容，并创建一个动作，当文件被解析，或条目被设置为新值时，将用更新的值填充 <code>参数。</code> 默认情况下，要使用的模式是通过调用函数 <a class="el" href="structPatterns_1_1Tools_1_1Convert.html#a3fb901bae7fe2de5dc27da09e989ad2c">Patterns::Tools::Convert&lt;T&gt;::to_pattern()</a>, 获得的，但也可以使用一个自定义的模式。 可以使用参数 <code>has_to_be_set</code> 来声明这个参数，其默认值必须被这个类提供的一个方法所覆盖。一个参数是否被成功设置，可以通过函数get_entries_wrongly_not_set()和assert_that_entries_have_been_set()进行查询。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01998">1998</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aecb847561585089c4c7fcf51eddece16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb847561585089c4c7fcf51eddece16">&#9670;&nbsp;</a></span>declare_alias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::declare_alias </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>existing_entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>alias_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>alias_is_deprecated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为一个现有条目创建一个别名。这提供了一种方法，可以用另一个名字来引用输入文件中的一个参数。该别名将在当前部分，而被引用的条目需要是当前部分的一个现有条目。 这个函数的主要目的是允许用一种向后兼容的方式来改变应用程序输入文件中的名称，因为向后兼容很重要。这可以通过在调用 <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> 时改变参数的名称，然后创建一个别名将旧名称映射到新名称来实现。这样，旧的输入文件可以继续引用旧名称下的参数，它们将自动被映射到新的参数名称。 在一个输入文件中多次设置同一个参数是有效的。 在这种情况下，最终选择的值仅仅是最后设置的值。这个规则也适用于别名，参数的最终值是通过参数的当前名称或通过其可能的多个别名设置的最后一个值。例如，如果你有一个输入文件，看起来像 </p><div class="fragment"><div class="line"><span class="keyword">set</span> parm1       = 1</div><div class="line"><span class="keyword">set</span> parm1_alias = 2</div></div><!-- fragment --><p> 其中 <code>parm1_alias</code> 是一个通过以下方式声明的别名 </p><div class="fragment"><div class="line">prm.<a class="code" href="classParameterHandler.html#aecb847561585089c4c7fcf51eddece16">declare_alias</a> (<span class="stringliteral">&quot;parm1&quot;</span>, <span class="stringliteral">&quot;parm1_alias&quot;</span>);</div></div><!-- fragment --><p> 那么名为 <code>parm1</code> 的参数的最终值将是2，而不是1。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">existing_entry_name</td><td>在当前章节中的一个现有参数的名称，该别名应该指的是这个。 </td></tr>
    <tr><td class="paramname">alias_name</td><td>第一个参数所引用的参数的另一个名称。 </td></tr>
    <tr><td class="paramname">alias_is_deprecated</td><td>如果为真，将该别名标记为已废弃。如果你调用print_parameters()，这将被列在别名的描述中，并且在读取包含这个已废弃的别名的输入文件时，你将在屏幕上得到一个警告。这个参数的目的是能够允许使用一个旧的参数名称（见上文），但是要明确这个旧名称最终会被删除。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00878">878</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af29c20cde6d44186806d559beb468696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29c20cde6d44186806d559beb468696">&#9670;&nbsp;</a></span>enter_subsection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::enter_subsection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subsection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>输入一个分节。如果它还不存在，就创建它。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00939">939</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a599462cacd492e2f712bf7369507dcff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599462cacd492e2f712bf7369507dcff">&#9670;&nbsp;</a></span>leave_subsection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::leave_subsection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>离开目前的分节。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00953">953</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae6142462087d1cd62d294eccb1f58867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6142462087d1cd62d294eccb1f58867">&#9670;&nbsp;</a></span>subsection_path_exists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::subsection_path_exists </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>检查当前树中是否存在一个分节或分节路径。 输入参数 <code>sub_path</code> 被认为是相对于当前选择的路径。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00966">966</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a91cfbaca954f444047302446a4e87125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cfbaca954f444047302446a4e87125">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>入口的返回值 <code>entry_string</code>. 如果入口被改变，则返回改变后的值，否则返回默认值。如果需要一个未声明的条目的值， <code>Assert</code> 将失败。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l00987">987</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa08ccf6fbd95de45a35b53ba0c09f49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08ccf6fbd95de45a35b53ba0c09f49f">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ParameterHandler::get </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>条目 <code>entry_string</code>. 的返回值 如果条目被改变，那么返回改变后的值，否则返回默认值。如果需要一个未声明的条目的值， <code>Assert</code> 将失败。 如果 <code>entry_subsection_path</code> 是非空的，那么将从该路径所代表的分节中获取数值，而不是当前分节。 <code>entry_subsection_path</code> 中的第一个字符串必须是当前分节的名称，接下来的每个字符串必须是前面一个分节的名称。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01004">1004</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a61fa98fdc0c52980a5b1de0ee1fc5bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fa98fdc0c52980a5b1de0ee1fc5bb2">&#9670;&nbsp;</a></span>get_integer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classint.html">int</a> ParameterHandler::get_integer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回条目 <code>entry_string</code> 的值为 <code>long int</code> 。（选择一个长的int，这样即使是非常大的无符号值也可以由这个函数返回）。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01025">1025</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a421a09eb0548f1fb3783d97d3e85fd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421a09eb0548f1fb3783d97d3e85fd5c">&#9670;&nbsp;</a></span>get_integer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classint.html">int</a> ParameterHandler::get_integer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>条目 <code>entry_string</code> 的返回值为 <code>long int</code> 。（选择一个长的int，这样即使是非常大的无符号值也能被这个函数返回）。 如果 <code>entry_subsection_path</code> 是非空的，那么该值将从该路径所代表的分节而不是当前分节中得到。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01044">1044</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aeaf3c7846747695b1f327677e3716ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf3c7846747695b1f327677e3716ec5">&#9670;&nbsp;</a></span>get_double() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> ParameterHandler::get_double </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回条目 <code>entry_name</code> 的值为 <code>double</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01068">1068</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a913289695be07bd949bf94aa5cd5ad54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913289695be07bd949bf94aa5cd5ad54">&#9670;&nbsp;</a></span>get_double() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> ParameterHandler::get_double </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果 <code>entry_subsection_path</code> 不是空的，将从该路径所代表的分节而不是当前分节中获取数值。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01088">1088</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a6bb45dc67787e3fab7882461929b5fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb45dc67787e3fab7882461929b5fbe">&#9670;&nbsp;</a></span>get_bool() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::get_bool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>条目 <code>entry_name</code> 的返回值为 <code>bool</code>. ，该条目对 <code>true</code>, 可以是 "真 "或 "是"，对 <code>false</code> 可以是 "假 "或 "否"。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01113">1113</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a209f365b60c5b0a76080b86693baa36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209f365b60c5b0a76080b86693baa36b">&#9670;&nbsp;</a></span>get_bool() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::get_bool </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>entry_subsection_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>条目 <code>entry_name</code> 的返回值为 <code>bool</code>. 该条目对于 <code>true</code>, 可以分别为 "真 "或 "是"，对于 <code>false</code> 可以为 "假 "或 "否"。 如果 <code>entry_subsection_path</code> 不为空，则将从该路径所代表的分节中获取数值，而不是当前分节。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01130">1130</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa6418ea655b1b550b9dcf63513030196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6418ea655b1b550b9dcf63513030196">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将当前存储的<code>entry_name</code>的值改为第二个参数中给出的值。 该参数必须已经存在于当前分节中。 如果新值不符合该条目的模式，该函数会抛出一个ExcValueDoesNotMatchPattern类型的异常。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01152">1152</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af288e1fe38ac1a1baf1cef3058b63ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af288e1fe38ac1a1baf1cef3058b63ce1">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>和上面一样，但有一个重载，第二个参数是一个字符指针。这是必要的，因为否则对 <code>set("abc","def")</code> 的调用将被映射为该函数以一个字符串和一个bool作为参数，这当然不是最常见的目的。 如果新值不符合这个条目的模式，该函数会抛出一个ExcValueDoesNotMatchPattern类型的异常。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01205">1205</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa89180ba36c54e207286a3545f8371b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89180ba36c54e207286a3545f8371b4">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将目前为<code>entry_name</code>存储的值改为第二个参数中给出的值。 该参数必须已经存在于本小节中。 如果新值不符合该条目的模式，该函数会抛出一个ExcValueDoesNotMatchPattern类型的异常。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01227">1227</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ad46b9dd6387d7e48ddca4add8baad2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46b9dd6387d7e48ddca4add8baad2aa">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将目前为<code>entry_name</code>存储的值改为第二个参数中给出的值。 该参数必须已经存在于本分节中。 为了内部的目的，新的值需要转换为一个字符串。 这是用16位数的精度完成的，所以设定的值和你用get_double()得到的值可能在第16位数上有所不同。 如果新值不符合这个条目的模式，该函数会抛出一个ExcValueDoesNotMatchPattern类型的异常。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01213">1213</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae417f9634872a427765365cd5ee9b160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae417f9634872a427765365cd5ee9b160">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将目前为<code>entry_name</code>存储的值改为第二个参数中给出的值。 该参数必须已经存在于本小节中。 如果新值不符合该条目的模式，该函数会抛出一个ExcValueDoesNotMatchPattern类型的异常。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01240">1240</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a4ac3a8b19ade16e96e8ea25906daf23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac3a8b19ade16e96e8ea25906daf23a">&#9670;&nbsp;</a></span>print_parameters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; ParameterHandler::print_parameters </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>打印所有具有给定 <code>style</code> 至 <code>out</code>. 的参数 在打印之前，所有当前参数和子部分默认按字母顺序排序。 这种行为可以通过设置可选的参数 <code>style</code> 来禁用<code>KeepDeclarationOrder</code>：在这种情况下，条目的打印顺序与它们被声明的顺序相同。 在<code>PRM</code>、<code>XML</code>和<code>JSON</code>格式中，输出的格式是可以用于以后再次输入。这对于记录特定运行的参数是最有用的，因为如果你用这个函数把参数输出到一个日志文件中，你总是可以通过简单地把输出复制到输入文件来恢复结果。 除了每个条目的名称和值之外，输出还包括条目的默认值（如果它与实际值不同），以及给 <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> 函数的记录字符串（如果有）。 通过使用标志<code>Short</code>与<code>PRM</code>、<code>XML</code>、<code>JSON</code>或<code>LaTeX</code>相结合（或通过使用快捷键<code>ShortPRM</code>。<code>ShortXML</code>, <code>ShortJSON</code>, 或 <code>ShortLaTeX</code>），可以生成一个缩小的输出，只包含数值，跳过文档。 在<code>XML</code>格式中，输出从一个根元素<code><a class="el" href="classParameterHandler.html">ParameterHandler</a></code>开始，以便得到一个有效的XML文档和它下面的所有子节。 在<code>LaTeX</code>格式中，输出包含同样的信息，但其格式是这样的：所产生的文件可以输入到一个latex文档中，例如这个对象处理运行时参数的代码的手册。然后，参数的各个部分由latex章节和分节命令以及嵌套的枚举来表示。 你可以通过为每个条目自动生成的标签来引用特定的参数部分和单个参数。标签的格式为 <code>parameters:section1/subsection1</code> 和 <code>parameters:section1/subsection1/someentry</code> 。由于特殊字符可能出现在章节和条目名称中，这些字符将被 "混杂"。在这里，除了 <code>[a-zA-Z0-9]</code> 以外的所有字符都被 <code>_XX</code>, where <code>XX</code> 所取代，该字符在十六进制编码中的两位数ascii代码（因此，例如，一个空格变成 <code>_20</code> ）。 虽然这个函数在大多数输出中（名称、默认值等）都转义了LaTeX特有的字符（反斜杠、下划线等），但文档字符串是按原样传递的。这意味着你可以在描述中使用数学环境和其他格式，但你需要自己转义引号、反斜线、下划线等。 此外，所有的参数名称都用 <code>\index</code> 语句列在两个索引中，称为 <code>prmindex</code> （每个参数的名称都列在索引中）和 <code>prmindexfull</code> ，参数名称按其存在的章节排序。默认情况下，LaTeX程序会忽略这些 <code>\index</code> 命令，但它们可以通过在latex文件的序言中使用以下命令来生成索引。 </p><div class="fragment"><div class="line">\usepackage{imakeidx}</div><div class="line">\makeindex[name=prmindex, title=Index of <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>-time parameter <a class="code" href="classParameterHandler.html#ae3c753f43844f2c1196d4ef939048bb0">entries</a>]</div><div class="line">\makeindex[name=prmindexfull,</div><div class="line">         title=Index of <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>-time parameters with section names]</div></div><!-- fragment --><p> 并在文件的结尾这样做。 </p><div class="fragment"><div class="line">\printindex[prmindex]</div><div class="line">\printindex[prmindexfull]</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01250">1250</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a17fde9ad56e01eed0648e56106e6bf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17fde9ad56e01eed0648e56106e6bf1e">&#9670;&nbsp;</a></span>print_parameters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::print_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em> = <code><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>打印所有参数到 <code>filename</code> 给定的文件中，并使用给定的输出样式 <code>style</code>. 这个函数从指定文件名的扩展名推断出输出格式。支持的扩展名是`prm', `xml', `tex', 和 `json'。因此，只要在文件名中加入这些扩展名之一，就没有必要通过 <code>style</code> 参数指定输出格式。不过，如果在 <code>style</code> 参数中指定了输出格式，输出格式必须与文件名的扩展名一致。 如果没有指定扩展名或不支持扩展名，输出格式将从 <code>style</code> 参数中推断出来。 如果既不支持扩展名，也不支持 <code>style</code> 参数中的格式规范，则会抛出一个断言。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>输出文件名。 </td></tr>
    <tr><td class="paramname">style</td><td>产生输出的样式。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01354">1354</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa900e3460a10639fc4d8703ef09a7c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa900e3460a10639fc4d8703ef09a7c0a">&#9670;&nbsp;</a></span>log_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::log_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLogStream.html">LogStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em> = <code><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>打印参数到一个日志流。这个函数允许将所有参数打印到一个日志文件中。各部分将以通常的日志文件风格缩进。 默认情况下，所有当前的参数和子部分都是按字母顺序排列的。 这种行为可以通过设置可选的参数 <code>style</code> 来禁用<code>KeepDeclarationOrder</code>：在这种情况下，条目的打印顺序与它们被声明的顺序相同。 </p><dl class="section note"><dt>Note</dt><dd><code>style</code> 中所有与排序无关的样式设置都被忽略了。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01757">1757</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="ae15f2618f3b24c04eead226c5271be1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15f2618f3b24c04eead226c5271be1a">&#9670;&nbsp;</a></span>log_parameters_section()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::log_parameters_section </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLogStream.html">LogStream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">OutputStyle</a>&#160;</td>
          <td class="paramname"><em>style</em> = <code><a class="el" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827aea377cb78fede823d8857c58bca5fd48">DefaultStyle</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>本分节中的日志参数。该分节由<code>subsection_path</code>成员变量决定。这个变量通过enter_subsection()和leave_subsection()函数进入和离开子段来控制。 所有当前的参数和子段默认是按字母顺序排序的。 这种行为可以通过设置可选的参数 <code>style</code> 来禁用<code>KeepDeclarationOrder</code>：在这种情况下，条目的打印顺序与它们被声明的顺序相同。 </p><dl class="section note"><dt>Note</dt><dd><code>style</code> 中所有与排序无关的样式设置都被忽略了。 在大多数情况下，你不会想直接使用这个函数，而是让它被前面的函数递归调用。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l01768">1768</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a5df38ff67c1c8352e04de490e0c0a39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df38ff67c1c8352e04de490e0c0a39e">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>将此对象的数据写入一个流中，以便进行序列化。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01960">1960</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="a09fd2ee6d01b78079f894893aacd6c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fd2ee6d01b78079f894893aacd6c4c">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>从一个流中读取此对象的数据，以达到序列化的目的。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01979">1979</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="aac896adce1ec1db3f525f57811764879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac896adce1ec1db3f525f57811764879">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>从流中写入和读取此对象的数据，以达到序列化的目的。 </p>

</div>
</div>
<a id="aede1a749bba8ee11876fd114a16c4f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede1a749bba8ee11876fd114a16c4f3e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> ParameterHandler::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>检验是否相等。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02018">2018</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="aa5a299c29da8a837a1b8441039d0fa79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a299c29da8a837a1b8441039d0fa79">&#9670;&nbsp;</a></span>get_entries_wrongly_not_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; ParameterHandler::get_entries_wrongly_not_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一组参数名称（包括分段名称），对应于参数处理程序的那些条目，这些条目没有被一个从输入文件解析参数的函数或明确调用set()函数之一来设置，但已被声明为必须设置的强制性参数（通过 <a class="el" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry()</a> 函数或 <a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">add_parameter()</a> 函数的最后参数）。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02043">2043</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="af441ab90c4d310c1c7d12c5f0050024f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af441ab90c4d310c1c7d12c5f0050024f">&#9670;&nbsp;</a></span>assert_that_entries_have_been_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ParameterHandler::assert_that_entries_have_been_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>断言参数处理程序中那些标记为<code>has_to_be_set = true</code>的条目已经被设置。如果这些参数中至少有一个没有被设置，就会出现异常。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8cc_source.html#l02057">2057</a> of file <a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acf494a63b63e0f0a52ddcd7cd3ba60b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf494a63b63e0f0a52ddcd7cd3ba60b9">&#9670;&nbsp;</a></span>multiple_choices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classMultipleParameterLoop_1_1Entry.html">Entry</a>&gt; MultipleParameterLoop::multiple_choices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>变体条目值的列表。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01926">1926</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<a id="a7165818f5c82fed1026e6bb489c004a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7165818f5c82fed1026e6bb489c004a8">&#9670;&nbsp;</a></span>n_branches</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> MultipleParameterLoop::n_branches</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从变体的不同组合中构建的分支数量。这显然等于要执行的运行次数。 </p>

<p class="definition">Definition at line <a class="el" href="parameter__handler_8h_source.html#l01932">1932</a> of file <a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="parameter__handler_8h_source.html">parameter_handler.h</a></li>
<li>source/base/<a class="el" href="parameter__handler_8cc_source.html">parameter_handler.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
