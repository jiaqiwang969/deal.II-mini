<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSUNDIALS_1_1KINSOL.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SUNDIALS::KINSOL&lt; VectorType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a></li><li class="navelem"><a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSUNDIALS_1_1KINSOL-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SUNDIALS::KINSOL&lt; VectorType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="kinsol_8h_source.html">deal.II/sundials/kinsol.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">AdditionalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2f027f7121367e503cd8f090da1d3196"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a2f027f7121367e503cd8f090da1d3196">KINSOL</a> (const <a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">AdditionalData</a> &amp;<a class="el" href="classSUNDIALS_1_1KINSOL.html#acdf27e966cc3118636052bf047af1b21">data</a>=<a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">AdditionalData</a>(), const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_comm=MPI_COMM_WORLD)</td></tr>
<tr class="separator:a2f027f7121367e503cd8f090da1d3196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40c93d7c9737289e7723c8992176380"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#ae40c93d7c9737289e7723c8992176380">~KINSOL</a> ()</td></tr>
<tr class="separator:ae40c93d7c9737289e7723c8992176380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b68ab01a5e74ecfd08e37ab4dc3e454"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a4b68ab01a5e74ecfd08e37ab4dc3e454">solve</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;initial_guess_and_solution)</td></tr>
<tr class="separator:a4b68ab01a5e74ecfd08e37ab4dc3e454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3267c6a16d4fb4dc2252a90d9e68606e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a3267c6a16d4fb4dc2252a90d9e68606e">DeclException1</a> (ExcKINSOLError, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;One of the SUNDIALS <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> internal functions &quot;&lt;&lt; &quot;returned a negative error code: &quot;&lt;&lt; arg1&lt;&lt; &quot;. Please consult SUNDIALS manual.&quot;)</td></tr>
<tr class="separator:a3267c6a16d4fb4dc2252a90d9e68606e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:abdccb7a76e27cd9948048fdd03949380"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classVectorType.html">VectorType</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#abdccb7a76e27cd9948048fdd03949380">reinit_vector</a></td></tr>
<tr class="separator:abdccb7a76e27cd9948048fdd03949380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa791c6b63d41c8e7b12ec227e224c72a"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;src, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#aa791c6b63d41c8e7b12ec227e224c72a">residual</a></td></tr>
<tr class="separator:aa791c6b63d41c8e7b12ec227e224c72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e9bd8d5777b0b254201b8c3241c110"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;src, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#ad4e9bd8d5777b0b254201b8c3241c110">iteration_function</a></td></tr>
<tr class="separator:ad4e9bd8d5777b0b254201b8c3241c110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199363bcae2f185e8b6c120fa9152aad"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;current_u, const <a class="el" href="classVectorType.html">VectorType</a> &amp;current_f)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian</a></td></tr>
<tr class="separator:a199363bcae2f185e8b6c120fa9152aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388cbc77068ac53927b0b8b3e055a423"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;ycur, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fcur, const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a388cbc77068ac53927b0b8b3e055a423">solve_jacobian_system</a></td></tr>
<tr class="separator:a388cbc77068ac53927b0b8b3e055a423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1924e602d00f1be169e1d958666e5bc9"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classdouble.html">double</a> tolerance)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a1924e602d00f1be169e1d958666e5bc9">solve_with_jacobian</a></td></tr>
<tr class="separator:a1924e602d00f1be169e1d958666e5bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166289e621e9bc6e60298796af7bdb29"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classVectorType.html">VectorType</a> &amp;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a166289e621e9bc6e60298796af7bdb29">get_solution_scaling</a></td></tr>
<tr class="separator:a166289e621e9bc6e60298796af7bdb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae9907f344445e416fd2673efa7b36e"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classVectorType.html">VectorType</a> &amp;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#abae9907f344445e416fd2673efa7b36e">get_function_scaling</a></td></tr>
<tr class="separator:abae9907f344445e416fd2673efa7b36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8758cc946c8dc07b314ea2e73e99f838"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a8758cc946c8dc07b314ea2e73e99f838">DeclException1</a> (ExcFunctionNotProvided, std::string,&lt;&lt; &quot;Please provide an implementation for the function &lt;&lt; arg1&lt;&lt; &quot;\&quot;)</td></tr>
<tr class="separator:a8758cc946c8dc07b314ea2e73e99f838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0629ce8aba07659cdc5068b3704969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a2d0629ce8aba07659cdc5068b3704969">set_functions_to_trigger_an_assert</a> ()</td></tr>
<tr class="separator:a2d0629ce8aba07659cdc5068b3704969"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:acdf27e966cc3118636052bf047af1b21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">AdditionalData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#acdf27e966cc3118636052bf047af1b21">data</a></td></tr>
<tr class="separator:acdf27e966cc3118636052bf047af1b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60479a46e6972eea3bd9381be07787b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#af60479a46e6972eea3bd9381be07787b">kinsol_mem</a></td></tr>
<tr class="separator:af60479a46e6972eea3bd9381be07787b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ab8129560b235c632d274bc477c44a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a77ab8129560b235c632d274bc477c44a">mem</a></td></tr>
<tr class="separator:a77ab8129560b235c632d274bc477c44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename VectorType = Vector&lt;double&gt;&gt;<br />
class SUNDIALS::KINSOL&lt; VectorType &gt;</h3>

<p>SUNDIALS的非线性求解器（KINSOL）的接口。 KINSOL是一个用于残差形式 \(F(u) = 0\) 或定点形式 \(G(u) = u\) 的非线性代数系统的求解器，其中 \(u\) 是一个向量，我们将假设它在 \({\mathbb R}^n\) 或 \({\mathbb C}^n\) 中，但它也可能有一个块结构，可以分布在并行计算中；函数 \(F\) 和 \(G\) 满足 \(F,G:{\mathbb R}^N \to{\mathbb R}^N\) 或 \(F,G:{\mathbb C}^N \to{\mathbb C}^N\) 。它包括牛顿-克雷洛夫求解器以及皮卡德和定点求解器，这两种求解器都可以用安德森加速器进行加速。KINSOL是基于Brown和Saad以前的Fortran软件包NKSOL。一个使用KINSOL的例子可以在 <a class="el" href="step_77.html">step-77</a> 的教程程序中找到。 KINSOL的牛顿求解器采用了不精确的牛顿方法。由于这个求解器主要用于大型系统，用户需要提供他们自己的求解器函数。 在最高级别，KINSOL实现了以下迭代方案。</p>
<ul>
<li>设置 \(u_0\) =一个初始猜测</li>
<li>对于 \(n = 0, 1, 2, \ldots\) 直到收敛做。</li>
<li>解决 \(J(u_n)\delta_n = -F(u_n)\)</li>
<li>设置 \(u_{n+1} = u_n + \lambda \delta_n, 0 &lt; \lambda \leq 1\)</li>
<li>检验收敛性 这里， \(u_n\) 是 \(n\) 到 \(u\) 的第1次迭代，而 \(J(u) = \nabla_u F(u)\) 是系统的雅各布系数。在迭代过程的每个阶段，步骤 \(\delta_n\) 的标量倍数被添加到 \(u_n\) ，以产生一个新的迭代， \(u_{n+1}\) 。在继续迭代之前，要进行收敛测试。 除非用户另有规定，否则KINSOL会尽可能少地更新雅各布信息，以平衡矩阵操作的高成本和其他成本。具体来说，这些更新在以下情况下发生。</li>
<li>问题被初始化了。</li>
<li>\(\|\lambda \delta_{n-1} \|_{D_u,\infty} \geq 1.5\) （仅有不确切的牛顿，见下文对 \(\| \cdot \|_{D_u,\infty}\) 的定义）。</li>
<li>自上次更新以来，已经过了指定数量的非线性迭代。</li>
<li>线性求解器在过期的雅各布信息下失败，可以恢复。</li>
<li>全局策略因过期的雅各布信息而失败，或</li>
<li>\(\|\lambda \delta_{n} \|_{D_u,\infty} \leq \) 容忍*与过时的雅各布信息。 KINSOL允许通过可选的求解器输入来改变上述策略。用户可以禁用初始雅各布信息评估，或者改变强制更新雅各布信息的非线性迭代次数的默认值。 为了解决条件不良的非线性系统的情况，KINSOL允许为解向量和残差向量规定比例系数。为了使用缩放，用户可以提供函数get_solution_scaling()，该函数返回值 \(D_u\) ，它是缩放矩阵的对角线元素，当 \(u_n\) 接近解时， \(D_u u_n\) 的所有分量都大致相同。 ] 接近于一个解决方案，而get_function_scaling()，提供的值 \(D_F\) ，是缩放矩阵的对角线元素，当 \(u_n\) 不*太接近于一个解决方案时， \(D_F F\) 的所有分量大致相同。 当为解向量提供缩放值时，如果用户没有通过solve_jacobian_system()函数提供雅各布信息的默认差分商数近似值，这些值将自动并入计算的扰动。 有两种将计算的步骤 \(\delta_n\) 应用于先前计算的解向量的方法被实现。第一种也是最简单的是标准的牛顿策略，它以常数 \(\lambda\) 始终设置为1来应用更新。另一种方法是全局策略，它试图以最有效的方式使用 \(\delta_n\) 所暗示的方向来促进非线性问题的收敛。这种技术在第二个策略中实现，称为Linesearch。这个方案同时采用了J.E.Dennis和R.B.B.Dennis所给出的Goldstein-Armijo linesearch算法的 \(\alpha\) 和 \(\beta\) 的条件。E. Dennis和R. B. Schnabel。"Numerical Methods for Unconstrained Optimization and Nonlinear Equations."。SIAM, Philadelphia, 1996.*，其中 \(\lambda\) 的选择是为了保证 \(F\) 相对于步长的充分下降，以及相对于 \(F\) 的初始下降率的最小步长。该算法的一个特性是，牛顿全步趋向于在接近解的地方进行。 在KINSOL中实现的基本定点迭代方案是这样的：。</li>
<li>设置 \(u_0 =\) 一个初始猜测</li>
<li>对于 \(n = 0, 1, 2, \dots\) 直到收敛做。</li>
<li>设置 \(u_{n+1} = G(u_n)\)</li>
<li>收敛性测试 在迭代过程的每个阶段，函数 \(G\) 被应用于当前迭代，产生一个新的迭代， \(u_{n+1}\) 。在继续迭代之前要进行收敛性测试。 对于KINSOL中实现的Picard迭代，我们考虑非线性函数 \(F\) 的特殊形式，如 \(F(u) = Lu - N(u)\) ，其中 \(L\) 是一个常数非辛格矩阵， \(N\) 是（一般）非线性的。 那么固定点函数 \(G\) 定义为 \(G(u) = u - L^{-1}F(u)\) 。 在每个迭代中，Picard步骤被计算出来，然后加入到 \(u_n\) 中，产生新的迭代。接下来，非线性残差函数在新迭代处被评估，并检查收敛性。使用安德森的方法可以大大加快Picard和固定点方法的速度。 用户必须提供以下内容的实现 std::functions: 。</li>
<li>reinit_vector；并且只有一个</li>
<li>剩余的；或</li>
<li>iteration_function; 指定residual()允许用户使用牛顿和皮卡德策略（即 \(F(u)=0\) 将被解决），而指定iteration_function()，将使用固定点迭代（即 \(G(u)=u\) 将被解决）。 如果希望使用牛顿或皮卡德方法，那么用户还应该提供</li>
<li>solve_jacobian_system 或 solve_with_jacobian；和可选的</li>
<li>setup_jacobian; 固定点迭代不需要解决任何线性系统。 另外，以下函数也可以改写，以便在收敛检查时为解和残差评估提供额外的缩放因子。</li>
<li>get_solution_scaling;</li>
<li>get_function_scaling; </li>
</ul>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00197">197</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2f027f7121367e503cd8f090da1d3196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f027f7121367e503cd8f090da1d3196">&#9670;&nbsp;</a></span>KINSOL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::<a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em> = <code><a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">AdditionalData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造器。通过传递一个设置所有求解器参数的AdditionalData()对象，可以对SUNDIALS KINSOL求解器进行微调。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>KINSOL配置数据 </td></tr>
    <tr><td class="paramname">mpi_comm</td><td>MPI通信器 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kinsol_8cc_source.html#l00309">309</a> of file <a class="el" href="kinsol_8cc_source.html">kinsol.cc</a>.</p>

</div>
</div>
<a id="ae40c93d7c9737289e7723c8992176380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40c93d7c9737289e7723c8992176380">&#9670;&nbsp;</a></span>~KINSOL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::~<a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>解构器。 </p>

<p class="definition">Definition at line <a class="el" href="kinsol_8cc_source.html#l00319">319</a> of file <a class="el" href="kinsol_8cc_source.html">kinsol.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4b68ab01a5e74ecfd08e37ab4dc3e454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b68ab01a5e74ecfd08e37ab4dc3e454">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>initial_guess_and_solution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>解决非线性系统。返回为收敛而采取的非线性步骤的数量。KINSOL使用<code>initial_guess_and_solution</code>的内容作为初始猜测，并将最终解存储在同一个向量中。 </p>

<p class="definition">Definition at line <a class="el" href="kinsol_8cc_source.html#l00329">329</a> of file <a class="el" href="kinsol_8cc_source.html">kinsol.cc</a>.</p>

</div>
</div>
<a id="a3267c6a16d4fb4dc2252a90d9e68606e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3267c6a16d4fb4dc2252a90d9e68606e">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcKINSOLError&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;One of the SUNDIALS <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; internal functions &quot;&lt;&lt; &quot;returned a negative error code: &quot;&lt;&lt; arg1&lt;&lt; &quot;. Please consult SUNDIALS manual.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>处理KINSOL异常。 </p>

</div>
</div>
<a id="a8758cc946c8dc07b314ea2e73e99f838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8758cc946c8dc07b314ea2e73e99f838">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcFunctionNotProvided&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Please provide an implementation for the function \ arg1&lt;&lt; &quot;\&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>当一个具有给定名称的函数没有实现时，抛出一个异常。 </p>

</div>
</div>
<a id="a2d0629ce8aba07659cdc5068b3704969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0629ce8aba07659cdc5068b3704969">&#9670;&nbsp;</a></span>set_functions_to_trigger_an_assert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::set_functions_to_trigger_an_assert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数在构造时被执行，以设置上面的 std::function ，如果它们没有被实现，则触发一个断言。 </p>

<p class="definition">Definition at line <a class="el" href="kinsol_8cc_source.html#l00535">535</a> of file <a class="el" href="kinsol_8cc_source.html">kinsol.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abdccb7a76e27cd9948048fdd03949380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdccb7a76e27cd9948048fdd03949380">&#9670;&nbsp;</a></span>reinit_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(<a class="el" href="classVectorType.html">VectorType</a> &amp;)&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::reinit_vector</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个用户需要提供的函数对象，其目的是将给定的向量重新itize为正确的大小、块结构（如果使用块向量）和MPI通信器（如果向量使用MPI分布在多个处理器上），以及任何其他必要的属性。 </p>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00391">391</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="aa791c6b63d41c8e7b12ec227e224c72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa791c6b63d41c8e7b12ec227e224c72a">&#9670;&nbsp;</a></span>residual</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;src, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst)&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::residual</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个用户应该提供的函数对象，其目的是计算残差<code>dst = F(src)</code>。该函数仅在选择了 SolutionStrategy::newton 或 SolutionStrategy::linesearch 策略时使用。 这个函数应该返回。</p>
<ul>
<li>0: 成功</li>
<li>&gt;0: 可恢复的错误（KINSOL将尝试改变其内部参数并尝试一个新的解决步骤</li>
<li>&lt;0: 无法恢复的错误，计算将被中止，并抛出一个断言。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00417">417</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="ad4e9bd8d5777b0b254201b8c3241c110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e9bd8d5777b0b254201b8c3241c110">&#9670;&nbsp;</a></span>iteration_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;src, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst)&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::iteration_function</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个用户应该提供的函数对象，其目的是为了计算固定点和Picard迭代的迭代函数 \(G(u)\) 。该函数仅在选择 SolutionStrategy::fixed_point 或 SolutionStrategy::picard 策略时使用。 这个函数应该返回。</p>
<ul>
<li>0: 成功</li>
<li>&gt;0: 可恢复的错误（KINSOL将尝试改变其内部参数并尝试一个新的解决步骤</li>
<li>&lt;0: 无法恢复的错误；计算将被中止，并抛出一个断言。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00444">444</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="a199363bcae2f185e8b6c120fa9152aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199363bcae2f185e8b6c120fa9152aad">&#9670;&nbsp;</a></span>setup_jacobian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;current_u, const <a class="el" href="classVectorType.html">VectorType</a> &amp;current_f)&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::setup_jacobian</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个用户可以提供的函数对象，其目的是为后续调用solve_jacobian_system()准备线性求解器。 <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian()</a>的工作是为后续调用solve_jacobian_system()准备线性求解器，在解决线性系统 \(Ax = b\) 。这个系统的确切性质取决于已经选择的SolutionStrategy。 在strategy = SolutionStrategy::newton 或 SolutionStrategy::linesearch, 的情况下 \(A\) 是雅各布 \(J = \partial F/\partial u\) 。如果策略= SolutionStrategy::picard, \(A\) 是近似的雅各布矩阵 \(L\) 。如果策略= SolutionStrategy::fixed_point, ，则不会出现线性系统，这个函数也不会被调用。 <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian()</a>函数可以调用一个用户提供的函数，或者线性求解器模块中的一个函数，以计算线性求解器所需要的雅各布相关数据。它还可以根据solve_jacobian_system()的需要对这些数据进行预处理，这可能涉及到调用一个通用函数（比如用于LU因子化），或者更普遍的是，从组装的雅各布式建立预处理程序。在任何情况下，这样生成的数据都可以在解决线性系统的时候被使用。 这个函数的意义在于，setup_jacobian()函数不是在每次牛顿迭代时都被调用，而是在求解器确定适合执行设置任务时才被调用。这样，由setup_jacobian()函数生成的雅各布相关数据有望在若干次牛顿迭代中被使用。KINSOL自己决定何时重新生成雅各布系数和相关信息（比如为雅各布系数计算的预处理程序）是有益的，从而尽可能地节省重新生成雅各布系数矩阵和其预处理程序的努力。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_u</td><td>\(u\) </td></tr>
    <tr><td class="paramname">current_f</td><td>\(F(u)\) 或 \(G(u)\) 的当前值 这个函数应该返回。</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>0: 成功</li>
<li>&gt;0: 可恢复的错误（KINSOL将尝试改变其内部参数并尝试一个新的解决步骤</li>
<li>&lt;0: 无法恢复的错误，计算将被中止，并抛出一个断言。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00482">482</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="a388cbc77068ac53927b0b8b3e055a423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388cbc77068ac53927b0b8b3e055a423">&#9670;&nbsp;</a></span>solve_jacobian_system</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;ycur, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fcur, const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp; dst)&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve_jacobian_system</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000095">Deprecated:</a></b></dt><dd>4.0之后的SUNDIALS版本不再提供这个回调的所有必要信息（见下文）。使用下面描述的<code>solve_with_jacobian</code>回调。 一个用户可以提供的函数对象，其目的是用雅各布矩阵来解决一个线性系统。这个函数将在setup_jacobian()被调用至少一次后被KINSOL调用（可能是多次）。KINSOL试图尽最大努力调用setup_jacobian()最少的次数。如果不更新雅各布式就能达到收敛，那么KINSOL就不会再次调用setup_jacobian()。相反，如果KINSOL内部收敛测试失败，那么KINSOL就会用更新的向量和系数再次调用setup_jacobian()，以便连续调用solve_jacobian_systems()导致牛顿过程中更好的收敛。 如果你没有指定<code>solve_jacobian_system</code>或<code>solve_with_jacobian</code>函数，那么只能使用固定点迭代策略。注意，这可能不会收敛，或者收敛得很慢。 对这个函数的调用应该在<code>dst</code>中存储 \(J^{-1}\) 应用于<code>rhs</code>的结果，即，<code>J*dst = rhs</code>。用户有责任在这个函数中（或在上面的<code>setup_jacobian</code>回调中）设置适当的求解器和预处理器。 该函数的参数是。</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ycur</td><td>当前KINSOL内部步骤的 \(y\) 向量。在上面的文档中，这个 \(y\) 向量一般用 \(u\) 表示。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fcur</td><td><code>ycur</code>处隐含的右手边的当前值， \(f_I (t_n, ypred)\) 。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>要解决的系统右手边 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>\(J^{-1} src\) 的解决方案 这个函数应该返回。</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>0: 成功</li>
<li>&gt;0: 可恢复的错误（KINSOL将尝试改变其内部参数并尝试一个新的解决步骤</li>
<li>&lt;0: 无法恢复的错误，计算将被中止，并抛出一个断言。 <dl class="section warning"><dt>Warning</dt><dd>从SUNDIALS 4.1开始，SUNDIALS不再提供<code>ycur'和</code>fcur'变量。</dd></dl>
</li>
<li>只提供<code>rhs</code>，并且需要返回<code>dst</code>。因此在这种情况下，前两个参数将是空的向量。在实践中，这意味着我们不能再在这个函数中计算当前迭代的雅各布矩阵。相反，这必须发生在上面的<code>setup_jacobian</code>函数中，该函数接收这些信息。 如果雅各布矩阵与当前*迭代对应是很重要的（而不是一个重复的迭代）。 迭代（而不是重新使用在之前的迭代中计算过的雅各布矩阵，因此对应于之前的*迭代），那么你还必须将 <a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html#a0dfb5ad9895dc47e31b6e4b304f00240">AdditionalData::maximum_newton_step</a> 变量设置为1，表示雅各布矩阵应该在每次迭代中重新计算。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00526">526</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="a1924e602d00f1be169e1d958666e5bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1924e602d00f1be169e1d958666e5bc9">&#9670;&nbsp;</a></span>solve_with_jacobian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classdouble.html">double</a> tolerance)&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve_with_jacobian</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个用户可以提供的函数对象，其目的是用雅各布矩阵求解一个线性系统。这个函数将在setup_jacobian()被调用至少一次之后被KINSOL调用（可能是多次）。KINSOL试图尽最大努力调用setup_jacobian()最少的次数。如果不更新雅各布式就能达到收敛，那么KINSOL就不会再次调用setup_jacobian()。相反，如果KINSOL内部收敛测试失败，那么KINSOL就会用更新的向量和系数再次调用setup_jacobian()，以便连续调用solve_jacobian_systems()导致牛顿过程中更好的收敛。 如果你没有指定<code>solve_with_jacobian</code>函数，那么只能使用固定点迭代策略。注意，这可能不会收敛，或者收敛得很慢。 对这个函数的调用应该在<code>dst</code>中存储 \(J^{-1}\) 应用于<code>rhs</code>的结果，即，<code>J*dst = rhs</code>。用户有责任在这个函数中（或在上面的<code>setup_jacobian</code>回调中）设置适当的求解器和预处理器。附在这个回调上的函数还提供了对线性求解器的容忍度，表明不需要用雅各布矩阵精确地求解线性系统，而只需要达到KINSOL将随着时间推移而适应的容忍度。 该函数的参数是。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>要解决的系统右侧。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>\(J^{-1} src\) 的解。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>用来解决线性方程组的公差。 这个函数应该返回。</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>0: 成功</li>
<li>&gt;0: 可恢复的错误（KINSOL将尝试改变其内部参数并尝试一个新的解决步骤</li>
<li>&lt;0: 无法恢复的错误，计算将被中止，并抛出一个断言。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00560">560</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="a166289e621e9bc6e60298796af7bdb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166289e621e9bc6e60298796af7bdb29">&#9670;&nbsp;</a></span>get_solution_scaling</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classVectorType.html">VectorType</a> &amp;()&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::get_solution_scaling</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个用户可以提供的函数对象，目的是返回一个向量，其组成部分是KINSOL用来计算解决方案的向量规范的权重。这个函数的实现是可选的，只有在实现时才会使用。 这个比例因子的目的是为了解决解的不同成分在数值上有很大差异的问题。</p>
<ul>
<li>通常是因为它们有不同的物理单位和代表不同的东西。例如，如果要解决一个非线性斯托克斯问题，解的向量有对应于速度的成分和对应于压力的其他成分。这些都有不同的物理单位，根据人们选择的单位，它们可能有大致可比的数字大小，也可能没有。仅举一个例子，在模拟地球内部的流动时，速度可能是每年10厘米，压力大约是100GPa。如果用国际单位来表示，这相当于大约 \(0.000,000,003=3 \times 10^{-9}\) 米/秒的速度，和大约 \(10^9 \text{kg}/\text{m}/\text{s}^2\) 的压力，也就是说，差别很大。在这种情况下，计算解决方案类型向量的 \(l_2\) 准则（例如，前一个解决方案和当前解决方案之间的差异）是没有意义的，因为准则将被速度分量或压力分量所支配。该函数返回的缩放向量旨在为解的每个分量提供一个缩放因子，该因子通常被选为 "典型速度 "或 "典型压力 "的倒数，这样，当一个向量分量乘以相应的缩放向量分量时，可以得到一个数量级为1的数字（即典型速度/压力的1倍的合理小数）。KINSOL手册中对此有如下说明。"用户应提供数值 @f$D_u@f$ ，这些数值是缩放矩阵的对角线元素，当 @f$U@f$ 接近解时， @f$D_u U@f$ 的所有分量的大小大致相同"。 如果没有向KINSOL对象提供任何函数，那么这将被解释为隐含地表示所有这些缩放因子都应被视为一个。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00569">569</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="abae9907f344445e416fd2673efa7b36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae9907f344445e416fd2673efa7b36e">&#9670;&nbsp;</a></span>get_function_scaling</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classVectorType.html">VectorType</a> &amp;()&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::get_function_scaling</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个用户可以提供的函数对象，其目的是返回一个向量，其组成部分是KINSOL用来计算远离解的函数评估的向量规范的权重。这个函数的实现是可选的，只有在实现时才会使用。 这个函数的要点和它返回的缩放向量与上面讨论的`get_solution_scaling'相似，只是在计算规范时，它是对函数 \(F(U)\) 的分量进行缩放，而不是 \(U\) 的分量。如上所述，如果没有提供函数，那么这就相当于使用一个缩放向量，其分量都等于1。 </p>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00578">578</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="acdf27e966cc3118636052bf047af1b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf27e966cc3118636052bf047af1b21">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">AdditionalData</a> <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>KINSOL配置数据。 </p>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00613">613</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="af60479a46e6972eea3bd9381be07787b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60479a46e6972eea3bd9381be07787b">&#9670;&nbsp;</a></span>kinsol_mem</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::kinsol_mem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>KINSOL内存对象。 </p>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00619">619</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="a77ab8129560b235c632d274bc477c44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ab8129560b235c632d274bc477c44a">&#9670;&nbsp;</a></span>mem</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a>&lt;<a class="el" href="classVectorType.html">VectorType</a>&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::mem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>向量的内存池。 </p>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00625">625</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/sundials/<a class="el" href="kinsol_8h_source.html">kinsol.h</a></li>
<li>source/sundials/<a class="el" href="kinsol_8cc_source.html">kinsol.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
