<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSUNDIALS_1_1KINSOL.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SUNDIALS::KINSOL&lt; VectorType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a></li><li class="navelem"><a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSUNDIALS_1_1KINSOL-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SUNDIALS::KINSOL&lt; VectorType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="kinsol_8h_source.html">deal.II/sundials/kinsol.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">AdditionalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2f027f7121367e503cd8f090da1d3196"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a2f027f7121367e503cd8f090da1d3196">KINSOL</a> (const <a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">AdditionalData</a> &amp;<a class="el" href="classSUNDIALS_1_1KINSOL.html#acdf27e966cc3118636052bf047af1b21">data</a>=<a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">AdditionalData</a>(), const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_comm=MPI_COMM_WORLD)</td></tr>
<tr class="separator:a2f027f7121367e503cd8f090da1d3196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40c93d7c9737289e7723c8992176380"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#ae40c93d7c9737289e7723c8992176380">~KINSOL</a> ()</td></tr>
<tr class="separator:ae40c93d7c9737289e7723c8992176380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b68ab01a5e74ecfd08e37ab4dc3e454"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a4b68ab01a5e74ecfd08e37ab4dc3e454">solve</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;initial_guess_and_solution)</td></tr>
<tr class="separator:a4b68ab01a5e74ecfd08e37ab4dc3e454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3267c6a16d4fb4dc2252a90d9e68606e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a3267c6a16d4fb4dc2252a90d9e68606e">DeclException1</a> (ExcKINSOLError, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;One of the SUNDIALS <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> internal functions &quot;&lt;&lt; &quot;returned a negative error code: &quot;&lt;&lt; arg1&lt;&lt; &quot;. Please consult SUNDIALS manual.&quot;)</td></tr>
<tr class="separator:a3267c6a16d4fb4dc2252a90d9e68606e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:abdccb7a76e27cd9948048fdd03949380"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classVectorType.html">VectorType</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#abdccb7a76e27cd9948048fdd03949380">reinit_vector</a></td></tr>
<tr class="separator:abdccb7a76e27cd9948048fdd03949380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa791c6b63d41c8e7b12ec227e224c72a"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;src, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#aa791c6b63d41c8e7b12ec227e224c72a">residual</a></td></tr>
<tr class="separator:aa791c6b63d41c8e7b12ec227e224c72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e9bd8d5777b0b254201b8c3241c110"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;src, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#ad4e9bd8d5777b0b254201b8c3241c110">iteration_function</a></td></tr>
<tr class="separator:ad4e9bd8d5777b0b254201b8c3241c110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199363bcae2f185e8b6c120fa9152aad"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;current_u, const <a class="el" href="classVectorType.html">VectorType</a> &amp;current_f)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian</a></td></tr>
<tr class="separator:a199363bcae2f185e8b6c120fa9152aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388cbc77068ac53927b0b8b3e055a423"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;ycur, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fcur, const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a388cbc77068ac53927b0b8b3e055a423">solve_jacobian_system</a></td></tr>
<tr class="separator:a388cbc77068ac53927b0b8b3e055a423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1924e602d00f1be169e1d958666e5bc9"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classdouble.html">double</a> tolerance)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a1924e602d00f1be169e1d958666e5bc9">solve_with_jacobian</a></td></tr>
<tr class="separator:a1924e602d00f1be169e1d958666e5bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166289e621e9bc6e60298796af7bdb29"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classVectorType.html">VectorType</a> &amp;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a166289e621e9bc6e60298796af7bdb29">get_solution_scaling</a></td></tr>
<tr class="separator:a166289e621e9bc6e60298796af7bdb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae9907f344445e416fd2673efa7b36e"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classVectorType.html">VectorType</a> &amp;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#abae9907f344445e416fd2673efa7b36e">get_function_scaling</a></td></tr>
<tr class="separator:abae9907f344445e416fd2673efa7b36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8758cc946c8dc07b314ea2e73e99f838"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a8758cc946c8dc07b314ea2e73e99f838">DeclException1</a> (ExcFunctionNotProvided, std::string,&lt;&lt; &quot;Please provide an implementation for the function &lt;&lt; arg1&lt;&lt; &quot;\&quot;)</td></tr>
<tr class="separator:a8758cc946c8dc07b314ea2e73e99f838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0629ce8aba07659cdc5068b3704969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a2d0629ce8aba07659cdc5068b3704969">set_functions_to_trigger_an_assert</a> ()</td></tr>
<tr class="separator:a2d0629ce8aba07659cdc5068b3704969"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:acdf27e966cc3118636052bf047af1b21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">AdditionalData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#acdf27e966cc3118636052bf047af1b21">data</a></td></tr>
<tr class="separator:acdf27e966cc3118636052bf047af1b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60479a46e6972eea3bd9381be07787b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#af60479a46e6972eea3bd9381be07787b">kinsol_mem</a></td></tr>
<tr class="separator:af60479a46e6972eea3bd9381be07787b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ab8129560b235c632d274bc477c44a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1KINSOL.html#a77ab8129560b235c632d274bc477c44a">mem</a></td></tr>
<tr class="separator:a77ab8129560b235c632d274bc477c44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename VectorType = Vector&lt;double&gt;&gt;<br />
class SUNDIALS::KINSOL&lt; VectorType &gt;</h3>

<p>Interface to <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a>' nonlinear solver (<a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a>).</p>
<p><a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> is a solver for nonlinear algebraic systems in residual form \(F(u) = 0\) or fixed point form \(G(u) = u\), where \(u\) is a vector which we will assume to be in \({\mathbb R}^n\) or \({\mathbb C}^n\), but that may also have a block structure and may be distributed in parallel computations; the functions \(F\) and \(G\) satisfy \(F,G:{\mathbb R}^N \to{\mathbb R}^N\) or \(F,G:{\mathbb C}^N \to{\mathbb C}^N\). It includes a Newton-Krylov solver as well as Picard and fixed point solvers, both of which can be accelerated with Anderson acceleration. <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> is based on the previous Fortran package NKSOL of Brown and Saad. An example of using <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> can be found in the step-77 tutorial program.</p>
<p><a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a>'s Newton solver employs the inexact Newton method. As this solver is intended mainly for large systems, the user is required to provide their own solver function.</p>
<p>At the highest level, <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> implements the following iteration scheme:</p><ul>
<li>set \(u_0\) = an initial guess</li>
<li>For \(n = 0, 1, 2, \ldots\) until convergence do:<ul>
<li>Solve \(J(u_n)\delta_n = -F(u_n)\)</li>
<li>Set \(u_{n+1} = u_n + \lambda \delta_n, 0 &lt; \lambda \leq 1\)</li>
<li>Test for convergence</li>
</ul>
</li>
</ul>
<p>Here, \(u_n\) is the \(n\)-th iterate to \(u\), and \(J(u) = \nabla_u F(u)\) is the system Jacobian. At each stage in the iteration process, a scalar multiple of the step \(\delta_n\), is added to \(u_n\) to produce a new iterate, \(u_{n+1}\). A test for convergence is made before the iteration continues.</p>
<p>Unless specified otherwise by the user, <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> strives to update Jacobian information as infrequently as possible to balance the high costs of matrix operations against other costs. Specifically, these updates occur when:</p><ul>
<li>the problem is initialized,</li>
<li>\(\|\lambda \delta_{n-1} \|_{D_u,\infty} \geq 1.5\) (inexact Newton only, see below for a definition of \(\| \cdot \|_{D_u,\infty}\))</li>
<li>a specified number of nonlinear iterations have passed since the last update,</li>
<li>the linear solver failed recoverably with outdated Jacobian information,</li>
<li>the global strategy failed with outdated Jacobian information, or</li>
<li>\(\|\lambda \delta_{n} \|_{D_u,\infty} \leq \) <em>tolerance</em> with outdated Jacobian information.</li>
</ul>
<p><a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> allows changes to the above strategy through optional solver inputs. The user can disable the initial Jacobian information evaluation or change the default value of the number of nonlinear iterations after which a Jacobian information update is enforced.</p>
<p>To address the case of ill-conditioned nonlinear systems, <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> allows prescribing scaling factors both for the solution vector and for the residual vector. For scaling to be used, the user may supply the function <a class="el" href="classSUNDIALS_1_1KINSOL.html#a166289e621e9bc6e60298796af7bdb29">get_solution_scaling()</a>, that returns values \(D_u\), which are diagonal elements of the scaling matrix such that \(D_u u_n\) has all components roughly the same magnitude when \(u_n\) is close to a solution, and <a class="el" href="classSUNDIALS_1_1KINSOL.html#abae9907f344445e416fd2673efa7b36e">get_function_scaling()</a>, that supply values \(D_F\), which are diagonal scaling matrix elements such that \(D_F F\) has all components roughly the same magnitude when \(u_n\) is <em>not</em> too close to a solution.</p>
<p>When scaling values are provided for the solution vector, these values are automatically incorporated into the calculation of the perturbations used for the default difference quotient approximations for Jacobian information if the user does not supply a Jacobian solver through the <a class="el" href="classSUNDIALS_1_1KINSOL.html#a388cbc77068ac53927b0b8b3e055a423">solve_jacobian_system()</a> function.</p>
<p>Two methods of applying a computed step \(\delta_n\) to the previously computed solution vector are implemented. The first and simplest is the standard Newton strategy which applies the update with a constant \(\lambda\) always set to 1. The other method is a global strategy, which attempts to use the direction implied by \(\delta_n\) in the most efficient way for furthering convergence of the nonlinear problem. This technique is implemented in the second strategy, called Linesearch. This option employs both the \(\alpha\) and \(\beta\) conditions of the Goldstein-Armijo linesearch algorithm given in <em>J. E. Dennis and R. B. Schnabel. "Numerical
Methods for Unconstrained Optimization and Nonlinear Equations." SIAM, Philadelphia, 1996.</em>, where \(\lambda\) is chosen to guarantee a sufficient decrease in \(F\) relative to the step length as well as a minimum step length relative to the initial rate of decrease of \(F\). One property of the algorithm is that the full Newton step tends to be taken close to the solution.</p>
<p>The basic fixed-point iteration scheme implemented in <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> is given by:</p><ul>
<li>Set \(u_0 =\) an initial guess</li>
<li>For \(n = 0, 1, 2, \dots\) until convergence do:<ul>
<li>Set \(u_{n+1} = G(u_n)\)</li>
<li>Test for convergence</li>
</ul>
</li>
</ul>
<p>At each stage in the iteration process, function \(G\) is applied to the current iterate to produce a new iterate, \(u_{n+1}\). A test for convergence is made before the iteration continues.</p>
<p>For Picard iteration, as implemented in <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a>, we consider a special form of the nonlinear function \(F\), such that \(F(u) = Lu - N(u)\), where \(L\) is a constant nonsingular matrix and \(N\) is (in general) nonlinear.</p>
<p>Then the fixed-point function \(G\) is defined as \(G(u) = u - L^{-1}F(u)\). Within each iteration, the Picard step is computed then added to \(u_n\) to produce the new iterate. Next, the nonlinear residual function is evaluated at the new iterate, and convergence is checked. The Picard and fixed point methods can be significantly accelerated using Anderson's method.</p>
<p>The user has to provide the implementation of the following std::functions:</p><ul>
<li>reinit_vector; and only one of</li>
<li>residual; or</li>
<li>iteration_function;</li>
</ul>
<p>Specifying <a class="el" href="classSUNDIALS_1_1KINSOL.html#aa791c6b63d41c8e7b12ec227e224c72a">residual()</a> allows the user to use Newton and Picard strategies (i.e., \(F(u)=0\) will be solved), while specifying <a class="el" href="classSUNDIALS_1_1KINSOL.html#ad4e9bd8d5777b0b254201b8c3241c110">iteration_function()</a>, a fixed point iteration will be used (i.e., \(G(u)=u\) will be solved).</p>
<p>If the use of a Newton or Picard method is desired, then the user should also supply</p><ul>
<li>solve_jacobian_system or solve_with_jacobian; and optionally</li>
<li>setup_jacobian;</li>
</ul>
<p>Fixed point iteration does not require the solution of any linear system.</p>
<p>Also the following functions could be rewritten, to provide additional scaling factors for both the solution and the residual evaluation during convergence checks:</p><ul>
<li>get_solution_scaling;</li>
<li>get_function_scaling; </li>
</ul>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00183">183</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2f027f7121367e503cd8f090da1d3196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f027f7121367e503cd8f090da1d3196">&#9670;&nbsp;</a></span>KINSOL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::<a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em> = <code><a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">AdditionalData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. It is possible to fine tune the <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> solver by passing an AdditionalData() object that sets all of the solver parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td><a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> configuration data </td></tr>
    <tr><td class="paramname">mpi_comm</td><td>MPI communicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae40c93d7c9737289e7723c8992176380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40c93d7c9737289e7723c8992176380">&#9670;&nbsp;</a></span>~KINSOL()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::~<a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4b68ab01a5e74ecfd08e37ab4dc3e454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b68ab01a5e74ecfd08e37ab4dc3e454">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>initial_guess_and_solution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the non linear system. Return the number of nonlinear steps taken to converge. <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> uses the content of <code>initial_guess_and_solution</code> as initial guess, and stores the final solution in the same vector. </p>

</div>
</div>
<a id="a3267c6a16d4fb4dc2252a90d9e68606e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3267c6a16d4fb4dc2252a90d9e68606e">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcKINSOLError&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;One of the SUNDIALS <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; internal functions &quot;&lt;&lt; &quot;returned a negative error code: &quot;&lt;&lt; arg1&lt;&lt; &quot;. Please consult SUNDIALS manual.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> exceptions. </p>

</div>
</div>
<a id="a8758cc946c8dc07b314ea2e73e99f838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8758cc946c8dc07b314ea2e73e99f838">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcFunctionNotProvided&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Please provide an implementation for the function \ arg1&lt;&lt; &quot;\&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Throw an exception when a function with the given name is not implemented. </p>

</div>
</div>
<a id="a2d0629ce8aba07659cdc5068b3704969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0629ce8aba07659cdc5068b3704969">&#9670;&nbsp;</a></span>set_functions_to_trigger_an_assert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::set_functions_to_trigger_an_assert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is executed at construction time to set the std::function above to trigger an assert if they are not implemented. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abdccb7a76e27cd9948048fdd03949380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdccb7a76e27cd9948048fdd03949380">&#9670;&nbsp;</a></span>reinit_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(<a class="el" href="classVectorType.html">VectorType</a> &amp;)&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::reinit_vector</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users need to supply and that is intended to reinitize the given vector to its correct size, block structure (if block vectors are used), and MPI communicator (if the vector is distributed across multiple processors using MPI), along with any other properties necessary. </p>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00409">409</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="aa791c6b63d41c8e7b12ec227e224c72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa791c6b63d41c8e7b12ec227e224c72a">&#9670;&nbsp;</a></span>residual</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;src, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst)&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::residual</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users should supply and that is intended to compute the residual <code>dst = F(src)</code>. This function is only used if the SolutionStrategy::newton or SolutionStrategy::linesearch strategies were selected.</p>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error (<a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> will try to change its internal parameters and attempt a new solution step)</li>
<li>&lt;0: Unrecoverable error the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00424">424</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="ad4e9bd8d5777b0b254201b8c3241c110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e9bd8d5777b0b254201b8c3241c110">&#9670;&nbsp;</a></span>iteration_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;src, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst)&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::iteration_function</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users should supply and that is intended to compute the iteration function \(G(u)\) for the fixed point and Picard iteration. This function is only used if the SolutionStrategy::fixed_point or SolutionStrategy::picard strategies were selected.</p>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error (<a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> will try to change its internal parameters and attempt a new solution step)</li>
<li>&lt;0: Unrecoverable error; the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00441">441</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="a199363bcae2f185e8b6c120fa9152aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199363bcae2f185e8b6c120fa9152aad">&#9670;&nbsp;</a></span>setup_jacobian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;current_u, const <a class="el" href="classVectorType.html">VectorType</a> &amp;current_f)&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::setup_jacobian</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to prepare the linear solver for subsequent calls to <a class="el" href="classSUNDIALS_1_1KINSOL.html#a388cbc77068ac53927b0b8b3e055a423">solve_jacobian_system()</a>.</p>
<p>The job of <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian()</a> is to prepare the linear solver for subsequent calls to <a class="el" href="classSUNDIALS_1_1KINSOL.html#a388cbc77068ac53927b0b8b3e055a423">solve_jacobian_system()</a>, in the solution of linear systems \(Ax = b\). The exact nature of this system depends on the SolutionStrategy that has been selected.</p>
<p>In the cases strategy = SolutionStrategy::newton or SolutionStrategy::linesearch, \(A\) is the Jacobian \(J = \partial F/\partial u\). If strategy = SolutionStrategy::picard, \(A\) is the approximate Jacobian matrix \(L\). If strategy = SolutionStrategy::fixed_point, then linear systems do not arise, and this function is never called.</p>
<p>The <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian()</a> function may call a user-supplied function, or a function within the linear solver module, to compute Jacobian-related data that is required by the linear solver. It may also preprocess that data as needed for <a class="el" href="classSUNDIALS_1_1KINSOL.html#a388cbc77068ac53927b0b8b3e055a423">solve_jacobian_system()</a>, which may involve calling a generic function (such as for LU factorization) or, more generally, build preconditioners from the assembled Jacobian. In any case, the data so generated may then be used whenever a linear system is solved.</p>
<p>The point of this function is that <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian()</a> function is not called at every Newton iteration, but only as frequently as the solver determines that it is appropriate to perform the setup task. In this way, Jacobian-related data generated by <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian()</a> is expected to be used over a number of Newton iterations. <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> determines itself when it is beneficial to regenerate the Jacobian and associated information (such as preconditioners computed for the Jacobian), thereby saving the effort to regenerate the Jacobian matrix and a preconditioner for it whenever possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_u</td><td>Current value of \(u\) </td></tr>
    <tr><td class="paramname">current_f</td><td>Current value of \(F(u)\) or \(G(u)\)</td></tr>
  </table>
  </dd>
</dl>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error (<a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> will try to change its internal parameters and attempt a new solution step)</li>
<li>&lt;0: Unrecoverable error the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00489">489</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="a388cbc77068ac53927b0b8b3e055a423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388cbc77068ac53927b0b8b3e055a423">&#9670;&nbsp;</a></span>solve_jacobian_system</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;ycur, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fcur, const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp; dst)&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve_jacobian_system</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000098">Deprecated:</a></b></dt><dd>Versions of <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> after 4.0 no longer provide all of the information necessary for this callback (see below). Use the <code>solve_with_jacobian</code> callback described below.</dd></dl>
<p>A function object that users may supply and that is intended to solve a linear system with the Jacobian matrix. This function will be called by <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> (possibly several times) after <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian()</a> has been called at least once. <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> tries to do its best to call <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian()</a> the minimum number of times. If convergence can be achieved without updating the Jacobian, then <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> does not call <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian()</a> again. If, on the contrary, internal <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> convergence tests fail, then <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> calls <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian()</a> again with updated vectors and coefficients so that successive calls to solve_jacobian_systems() lead to better convergence in the Newton process.</p>
<p>If you do not specify a <code>solve_jacobian_system</code> or <code>solve_with_jacobian</code> function, then only a fixed point iteration strategy can be used. Notice that this may not converge, or may converge very slowly.</p>
<p>A call to this function should store in <code>dst</code> the result of \(J^{-1}\) applied to <code>rhs</code>, i.e., <code>J*dst = rhs</code>. It is the user's responsibility to set up proper solvers and preconditioners inside this function (or in the <code>setup_jacobian</code> callback above).</p>
<p>Arguments to the function are:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ycur</td><td>The current \(y\) vector for the current <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> internal step. In the documentation above, this \(y\) vector is generally denoted by \(u\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fcur</td><td>The current value of the implicit right-hand side at <code>ycur</code>, \(f_I (t_n, ypred)\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The system right hand side to solve for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>The solution of \(J^{-1} * src\)</td></tr>
  </table>
  </dd>
</dl>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error (<a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> will try to change its internal parameters and attempt a new solution step)</li>
<li>&lt;0: Unrecoverable error the computation will be aborted and an assertion will be thrown.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Starting with <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> 4.1, <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> no longer provides the <code>ycur</code> and <code>fcur</code> variables &ndash; only <code>rhs</code> is provided and <code>dst</code> needs to be returned. The first two arguments will therefore be empty vectors in that case. In practice, that means that one can no longer compute a Jacobian matrix for the current iterate within this function. Rather, this has to happen inside the <code>setup_jacobian</code> function above that receives this information. If it is important that the Jacobian corresponds to the <em>current</em> iterate (rather than a re-used Jacobian matrix that had been computed in a previous iteration and that therefore corresponds to a <em>previous</em> iterate), then you will also have to set the <a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html#a0dfb5ad9895dc47e31b6e4b304f00240">AdditionalData::maximum_newton_step</a> variable to one, indicating that the Jacobian should be re-computed in every iteration. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00553">553</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="a1924e602d00f1be169e1d958666e5bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1924e602d00f1be169e1d958666e5bc9">&#9670;&nbsp;</a></span>solve_with_jacobian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classdouble.html">double</a> tolerance)&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve_with_jacobian</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to solve a linear system with the Jacobian matrix. This function will be called by <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> (possibly several times) after <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian()</a> has been called at least once. <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> tries to do its best to call <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian()</a> the minimum number of times. If convergence can be achieved without updating the Jacobian, then <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> does not call <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian()</a> again. If, on the contrary, internal <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> convergence tests fail, then <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> calls <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">setup_jacobian()</a> again with updated vectors and coefficients so that successive calls to solve_jacobian_systems() lead to better convergence in the Newton process.</p>
<p>If you do not specify a <code>solve_with_jacobian</code> function, then only a fixed point iteration strategy can be used. Notice that this may not converge, or may converge very slowly.</p>
<p>A call to this function should store in <code>dst</code> the result of \(J^{-1}\) applied to <code>rhs</code>, i.e., <code>J*dst = rhs</code>. It is the user's responsibility to set up proper solvers and preconditioners inside this function (or in the <code>setup_jacobian</code> callback above). The function attached to this callback is also provided with a tolerance to the linear solver, indicating that it is not necessary to solve the linear system with the Jacobian matrix exactly, but only to a tolerance that <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> will adapt over time.</p>
<p>Arguments to the function are:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The system right hand side to solve for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>The solution of \(J^{-1} * src\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>The tolerance with which to solve the linear system of equations.</td></tr>
  </table>
  </dd>
</dl>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error (<a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> will try to change its internal parameters and attempt a new solution step)</li>
<li>&lt;0: Unrecoverable error the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00596">596</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="a166289e621e9bc6e60298796af7bdb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166289e621e9bc6e60298796af7bdb29">&#9670;&nbsp;</a></span>get_solution_scaling</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classVectorType.html">VectorType</a> &amp;()&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::get_solution_scaling</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to return a vector whose components are the weights used by <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> to compute the vector norm of the solution. The implementation of this function is optional, and it is used only if implemented.</p>
<p>The intent for this scaling factor is for problems in which the different components of a solution have vastly different numerical magnitudes &ndash; typically because they have different physical units and represent different things. For example, if one were to solve a nonlinear Stokes problem, the solution vector has components that correspond to velocities and other components that correspond to pressures. These have different physical units and depending on which units one chooses, they may have roughly comparable numerical sizes or maybe they don't. To give just one example, in simulations of flow in the Earth's interior, one has velocities on the order of maybe ten centimeters per year, and pressures up to around 100 GPa. If one expresses this in SI units, this corresponds to velocities of around \(0.000,000,003=3 \times 10^{-9}\) m/s, and pressures around \(10^9 \text{kg}/\text{m}/\text{s}^2\), i.e., vastly different. In such cases, computing the \(l_2\) norm of a solution-type vector (e.g., the difference between the previous and the current solution) makes no sense because the norm will either be dominated by the velocity components or the pressure components. The scaling vector this function returns is intended to provide each component of the solution with a scaling factor that is generally chosen as as the inverse of a "typical velocity" or "typical pressure" so that upon multiplication of a vector component by the corresponding scaling vector component, one obtains a number that is of order of magnitude of one (i.e., a reasonably small multiple of one times the typical velocity/pressure). The <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> manual states this as follows: "The user should supply values \(D_u\), which are diagonal elements of the scaling matrix such that \(D_u U\) has all components roughly the same magnitude when \(U\) is close to a solution".</p>
<p>If no function is provided to a <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> object, then this is interpreted as implicitly saying that all of these scaling factors should be considered as one. </p>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00636">636</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="abae9907f344445e416fd2673efa7b36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae9907f344445e416fd2673efa7b36e">&#9670;&nbsp;</a></span>get_function_scaling</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classVectorType.html">VectorType</a> &amp;()&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::get_function_scaling</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function object that users may supply and that is intended to return a vector whose components are the weights used by <a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> to compute the vector norm of the function evaluation away from the solution. The implementation of this function is optional, and it is used only if implemented.</p>
<p>The point of this function and the scaling vector it returns is similar to the one discussed above for <code>get_solution_scaling</code>, except that it is for a vector that scales the components of the function \(F(U)\), rather than the components of \(U\), when computing norms. As above, if no function is provided, then this is equivalent to using a scaling vector whose components are all equal to one. </p>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00652">652</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="acdf27e966cc3118636052bf047af1b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf27e966cc3118636052bf047af1b21">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">AdditionalData</a> <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> configuration data. </p>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00685">685</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="af60479a46e6972eea3bd9381be07787b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60479a46e6972eea3bd9381be07787b">&#9670;&nbsp;</a></span>kinsol_mem</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::kinsol_mem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSUNDIALS_1_1KINSOL.html">KINSOL</a> memory object. </p>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00690">690</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<a id="a77ab8129560b235c632d274bc477c44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ab8129560b235c632d274bc477c44a">&#9670;&nbsp;</a></span>mem</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a>&lt;<a class="el" href="classVectorType.html">VectorType</a>&gt; <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::mem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Memory pool of vectors. </p>

<p class="definition">Definition at line <a class="el" href="kinsol_8h_source.html#l00695">695</a> of file <a class="el" href="kinsol_8h_source.html">kinsol.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/sundials/<a class="el" href="kinsol_8h_source.html">kinsol.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
