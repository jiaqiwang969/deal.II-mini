<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classParticles_1_1ParticleHandler.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Particles::ParticleHandler&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceParticles.html">Particles</a></li><li class="navelem"><a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classParticles_1_1ParticleHandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Particles::ParticleHandler&lt; dim, spacedim &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="particles_2data__out_8h_source.html">deal.II/particles/data_out.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Particles::ParticleHandler&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classParticles_1_1ParticleHandler__inherit__graph.svg" width="182" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParticles_1_1ParticleHandler_1_1Signals.html">Signals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a70366eefa102c06eea770e53412b0a52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> = <a class="el" href="classParticles_1_1ParticleIterator.html">ParticleIterator</a>&lt; dim, spacedim &gt;</td></tr>
<tr class="separator:a70366eefa102c06eea770e53412b0a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655ae2bdfe026f1ed172a2ec4c6c3d60"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a655ae2bdfe026f1ed172a2ec4c6c3d60">particle_iterator_range</a> = boost::iterator_range&lt; <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &gt;</td></tr>
<tr class="separator:a655ae2bdfe026f1ed172a2ec4c6c3d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802a7c4ebe4e57aedd31a47fe2b2c74a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a802a7c4ebe4e57aedd31a47fe2b2c74a">particle_container</a> = std::vector&lt; std::vector&lt; typename <a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt; dim, spacedim &gt;::Handle &gt; &gt;</td></tr>
<tr class="separator:a802a7c4ebe4e57aedd31a47fe2b2c74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2154bc9eb8f28a1f81bc50f242d88cdc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a2154bc9eb8f28a1f81bc50f242d88cdc">ParticleHandler</a> ()</td></tr>
<tr class="separator:a2154bc9eb8f28a1f81bc50f242d88cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab838d96b65a0d7c30270ac300f67d086"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#ab838d96b65a0d7c30270ac300f67d086">ParticleHandler</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classParticles_1_1ParticleHandler.html#aed73d58005f8ccfafa56cf2bcb4ab4c1">mapping</a>, const unsigned <a class="el" href="classint.html">int</a> n_properties=0)</td></tr>
<tr class="separator:ab838d96b65a0d7c30270ac300f67d086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9e46faa39070489a83e12ee555e92d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a3b9e46faa39070489a83e12ee555e92d">~ParticleHandler</a> ()</td></tr>
<tr class="separator:a3b9e46faa39070489a83e12ee555e92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80faedd016dc8f8ea444385bad5ba3ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a80faedd016dc8f8ea444385bad5ba3ec">initialize</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classParticles_1_1ParticleHandler.html#aed73d58005f8ccfafa56cf2bcb4ab4c1">mapping</a>, const unsigned <a class="el" href="classint.html">int</a> n_properties=0)</td></tr>
<tr class="separator:a80faedd016dc8f8ea444385bad5ba3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb95eec30eed4444c9bc77e6681c257d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#aeb95eec30eed4444c9bc77e6681c257d">copy_from</a> (const <a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>&lt; dim, spacedim &gt; &amp;particle_handler)</td></tr>
<tr class="separator:aeb95eec30eed4444c9bc77e6681c257d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75aa243f94d48d176b7024b6c65bc3d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a75aa243f94d48d176b7024b6c65bc3d9">clear</a> ()</td></tr>
<tr class="separator:a75aa243f94d48d176b7024b6c65bc3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4792e590e18ad8a4c427e82da98f7c2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a4792e590e18ad8a4c427e82da98f7c2e">clear_particles</a> ()</td></tr>
<tr class="separator:a4792e590e18ad8a4c427e82da98f7c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5011a0a3814c205d05a1dcd69930f3f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a5011a0a3814c205d05a1dcd69930f3f6">update_cached_numbers</a> ()</td></tr>
<tr class="separator:a5011a0a3814c205d05a1dcd69930f3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958a15b3aa325db82b4876cdb9feb527"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a958a15b3aa325db82b4876cdb9feb527">begin</a> () const</td></tr>
<tr class="separator:a958a15b3aa325db82b4876cdb9feb527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7577ec9642ac23c74d98506559af665b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a7577ec9642ac23c74d98506559af665b">begin</a> ()</td></tr>
<tr class="separator:a7577ec9642ac23c74d98506559af665b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f542a397843198eb82d8537602daf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#ab5f542a397843198eb82d8537602daf3">end</a> () const</td></tr>
<tr class="separator:ab5f542a397843198eb82d8537602daf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdc20dd339efffd016ca5f2de2d648f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a9fdc20dd339efffd016ca5f2de2d648f">end</a> ()</td></tr>
<tr class="separator:a9fdc20dd339efffd016ca5f2de2d648f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3dd2c6bb5c8f3745931c75a2b04153"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a7d3dd2c6bb5c8f3745931c75a2b04153">begin_ghost</a> () const</td></tr>
<tr class="separator:a7d3dd2c6bb5c8f3745931c75a2b04153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cceebf117c4325cc08595e20968408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#ad6cceebf117c4325cc08595e20968408">begin_ghost</a> ()</td></tr>
<tr class="separator:ad6cceebf117c4325cc08595e20968408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bd8520f383556411ab78df7dd563b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a19bd8520f383556411ab78df7dd563b6">end_ghost</a> () const</td></tr>
<tr class="separator:a19bd8520f383556411ab78df7dd563b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290f2201824c3b7acc3d9812ea59c60f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a290f2201824c3b7acc3d9812ea59c60f">end_ghost</a> ()</td></tr>
<tr class="separator:a290f2201824c3b7acc3d9812ea59c60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac043a4ea224ed50a03b8e9c3d3b98aec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#ac043a4ea224ed50a03b8e9c3d3b98aec">n_particles_in_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell) const</td></tr>
<tr class="separator:ac043a4ea224ed50a03b8e9c3d3b98aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7faa76fe7bdcf2a3e4957e3da2cf46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1ParticleHandler.html#a655ae2bdfe026f1ed172a2ec4c6c3d60">particle_iterator_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a2f7faa76fe7bdcf2a3e4957e3da2cf46">particles_in_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell)</td></tr>
<tr class="separator:a2f7faa76fe7bdcf2a3e4957e3da2cf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae893b3181f2de5df6d565282ad4dbc54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1ParticleHandler.html#a655ae2bdfe026f1ed172a2ec4c6c3d60">particle_iterator_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#ae893b3181f2de5df6d565282ad4dbc54">particles_in_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell) const</td></tr>
<tr class="separator:ae893b3181f2de5df6d565282ad4dbc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d9da9f7d53d0e7ffb58543d99234a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#ab8d9da9f7d53d0e7ffb58543d99234a2">remove_particle</a> (const <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &amp;particle)</td></tr>
<tr class="separator:ab8d9da9f7d53d0e7ffb58543d99234a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3695c2b85931d51f81b0209841e7eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#adb3695c2b85931d51f81b0209841e7eb">remove_particles</a> (const std::vector&lt; <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &gt; &amp;<a class="el" href="classParticles_1_1ParticleHandler.html#af71b7ac43cac8e6050676b058ff20d4f">particles</a>)</td></tr>
<tr class="separator:adb3695c2b85931d51f81b0209841e7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3a123356cfc3f1be5623d8fe1fdf2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a6d3a123356cfc3f1be5623d8fe1fdf2a">insert_particle</a> (const <a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt; &amp;particle, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell)</td></tr>
<tr class="separator:a6d3a123356cfc3f1be5623d8fe1fdf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27a829c48f1abb15399d4b561040034"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#ae27a829c48f1abb15399d4b561040034">insert_particles</a> (const std::multimap&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt;&gt; &amp;<a class="el" href="classParticles_1_1ParticleHandler.html#af71b7ac43cac8e6050676b058ff20d4f">particles</a>)</td></tr>
<tr class="separator:ae27a829c48f1abb15399d4b561040034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f50d7fb4d3b0679462eb8355633b1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a18f50d7fb4d3b0679462eb8355633b1c">insert_particles</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;positions)</td></tr>
<tr class="separator:a18f50d7fb4d3b0679462eb8355633b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f5ee2de4878d33900e399dae278264"><td class="memItemLeft" align="right" valign="top">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classIndexSet.html">IndexSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#ab5f5ee2de4878d33900e399dae278264">insert_global_particles</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;positions, const std::vector&lt; std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt;&gt; &amp;global_bounding_boxes, const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;properties={}, const std::vector&lt; <a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a> &gt; &amp;ids={})</td></tr>
<tr class="separator:ab5f5ee2de4878d33900e399dae278264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4095d645555387f0f257014aaaef259f"><td class="memItemLeft" align="right" valign="top">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classIndexSet.html">IndexSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a4095d645555387f0f257014aaaef259f">insert_global_particles</a> (const std::vector&lt; <a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt;&gt; &amp;<a class="el" href="classParticles_1_1ParticleHandler.html#af71b7ac43cac8e6050676b058ff20d4f">particles</a>, const std::vector&lt; std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt;&gt; &amp;global_bounding_boxes)</td></tr>
<tr class="separator:a4095d645555387f0f257014aaaef259f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68fb42de1cfabbef5b486626f04b564"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:af68fb42de1cfabbef5b486626f04b564"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; <a class="el" href="classVectorType.html">VectorType</a> *, <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; * &gt;::value==false &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#af68fb42de1cfabbef5b486626f04b564">set_particle_positions</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;input_vector, const <a class="el" href="classbool.html">bool</a> displace_particles=true)</td></tr>
<tr class="separator:af68fb42de1cfabbef5b486626f04b564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2912dec4f536ca688bf87c47d08c2141"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a2912dec4f536ca688bf87c47d08c2141">set_particle_positions</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;new_positions, const <a class="el" href="classbool.html">bool</a> displace_particles=true)</td></tr>
<tr class="separator:a2912dec4f536ca688bf87c47d08c2141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0998416b93c56c4335f78e8ac2cfbd8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a0998416b93c56c4335f78e8ac2cfbd8a">set_particle_positions</a> (const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;function, const <a class="el" href="classbool.html">bool</a> displace_particles=true)</td></tr>
<tr class="separator:a0998416b93c56c4335f78e8ac2cfbd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b3495884a94db511cd04ac888fddef"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a41b3495884a94db511cd04ac888fddef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a41b3495884a94db511cd04ac888fddef">get_particle_positions</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;output_vector, const <a class="el" href="classbool.html">bool</a> add_to_output_vector=false)</td></tr>
<tr class="separator:a41b3495884a94db511cd04ac888fddef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8092724bc4430506e019d567f720484c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a8092724bc4430506e019d567f720484c">get_particle_positions</a> (std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;positions, const <a class="el" href="classbool.html">bool</a> add_to_output_vector=false)</td></tr>
<tr class="separator:a8092724bc4430506e019d567f720484c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0748cc2d1c552871f99d7c3be39be744"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a0748cc2d1c552871f99d7c3be39be744">register_additional_store_load_functions</a> (const std::function&lt; std::size_t()&gt; &amp;<a class="el" href="classParticles_1_1ParticleHandler.html#a9b8d2e28beef0e67127fe10fb76c4591">size_callback</a>, const std::function&lt; void *(const <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &amp;, void *)&gt; &amp;<a class="el" href="classParticles_1_1ParticleHandler.html#a068770808c9cb389504fd34c41d0733d">store_callback</a>, const std::function&lt; const void *(const <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &amp;, const void *)&gt; &amp;<a class="el" href="classParticles_1_1ParticleHandler.html#aecb0305ed8558a67f72d44184b36e3eb">load_callback</a>)</td></tr>
<tr class="separator:a0748cc2d1c552871f99d7c3be39be744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a0beaff35d1541936ffa8d4724aab1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a11a0beaff35d1541936ffa8d4724aab1">n_global_particles</a> () const</td></tr>
<tr class="separator:a11a0beaff35d1541936ffa8d4724aab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5e803af074c2c55cf5a19c3228059d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#adf5e803af074c2c55cf5a19c3228059d">n_global_max_particles_per_cell</a> () const</td></tr>
<tr class="separator:adf5e803af074c2c55cf5a19c3228059d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafee65f03660b3adf80a40e52bfc7e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#abafee65f03660b3adf80a40e52bfc7e4">n_locally_owned_particles</a> () const</td></tr>
<tr class="separator:abafee65f03660b3adf80a40e52bfc7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c8a7d07ec85780875197ac1edd9140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#af6c8a7d07ec85780875197ac1edd9140">get_next_free_particle_index</a> () const</td></tr>
<tr class="separator:af6c8a7d07ec85780875197ac1edd9140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae52dca45437abc8ceba776a2537bfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a2ae52dca45437abc8ceba776a2537bfd">locally_relevant_ids</a> () const</td></tr>
<tr class="separator:a2ae52dca45437abc8ceba776a2537bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff72d8b28b3ce456715338102c529f15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#aff72d8b28b3ce456715338102c529f15">locally_owned_particle_ids</a> () const</td></tr>
<tr class="separator:aff72d8b28b3ce456715338102c529f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d680b964c34e5ccfa22c920a7cd02a3"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a2d680b964c34e5ccfa22c920a7cd02a3">n_properties_per_particle</a> () const</td></tr>
<tr class="separator:a2d680b964c34e5ccfa22c920a7cd02a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41adb90b9849e8e6c385d8e2ec77ac4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a41adb90b9849e8e6c385d8e2ec77ac4e">get_property_pool</a> () const</td></tr>
<tr class="separator:a41adb90b9849e8e6c385d8e2ec77ac4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad817e16828f2355b0cad6fef8db7df81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#ad817e16828f2355b0cad6fef8db7df81">sort_particles_into_subdomains_and_cells</a> ()</td></tr>
<tr class="separator:ad817e16828f2355b0cad6fef8db7df81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc49fc12351c51875cdadfcc5ef6ad9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a0dc49fc12351c51875cdadfcc5ef6ad9">exchange_ghost_particles</a> (const <a class="el" href="classbool.html">bool</a> enable_ghost_cache=false)</td></tr>
<tr class="separator:a0dc49fc12351c51875cdadfcc5ef6ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67e8522ddf712ace1547b997a9caa65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#ac67e8522ddf712ace1547b997a9caa65">update_ghost_particles</a> ()</td></tr>
<tr class="separator:ac67e8522ddf712ace1547b997a9caa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f132c97c49f31a3b4392a80e58f808"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a57f132c97c49f31a3b4392a80e58f808">prepare_for_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:a57f132c97c49f31a3b4392a80e58f808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24de503d9bfb2e11f0924be6083b0af7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a24de503d9bfb2e11f0924be6083b0af7">unpack_after_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:a24de503d9bfb2e11f0924be6083b0af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296b16801f3d611bcf646ea76421b59a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a296b16801f3d611bcf646ea76421b59a">prepare_for_serialization</a> ()</td></tr>
<tr class="separator:a296b16801f3d611bcf646ea76421b59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf6f4465d2840b0811a95bbdb12f77a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#aebf6f4465d2840b0811a95bbdb12f77a">deserialize</a> ()</td></tr>
<tr class="separator:aebf6f4465d2840b0811a95bbdb12f77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0c30b19d0dd7590a9f869ffb90bb84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8h.html#a8ce3607a2c3e9ba0f1d553bff4a3b588">DEAL_II_DEPRECATED_EARLY</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a1c0c30b19d0dd7590a9f869ffb90bb84">register_store_callback_function</a> ()</td></tr>
<tr class="separator:a1c0c30b19d0dd7590a9f869ffb90bb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e041e6c5232d9ef43e1023986dd9e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8h.html#a8ce3607a2c3e9ba0f1d553bff4a3b588">DEAL_II_DEPRECATED_EARLY</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a90e041e6c5232d9ef43e1023986dd9e4">register_load_callback_function</a> (const <a class="el" href="classbool.html">bool</a> serialization)</td></tr>
<tr class="separator:a90e041e6c5232d9ef43e1023986dd9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877e1aac8ef0ad6fa85ed400bf71eb1c"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a877e1aac8ef0ad6fa85ed400bf71eb1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a877e1aac8ef0ad6fa85ed400bf71eb1c">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a877e1aac8ef0ad6fa85ed400bf71eb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ace9086a5193f019312f962b0de892296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structParticles_1_1ParticleHandler_1_1Signals.html">Signals</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#ace9086a5193f019312f962b0de892296">signals</a></td></tr>
<tr class="separator:ace9086a5193f019312f962b0de892296"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:acc0f3a178feb749c98b77e3cc31a7453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#acc0f3a178feb749c98b77e3cc31a7453">insert_particle</a> (const void *&amp;data, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell)</td></tr>
<tr class="separator:acc0f3a178feb749c98b77e3cc31a7453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0903c26dd9c9ffe23e202fcf8a134776"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a0903c26dd9c9ffe23e202fcf8a134776">insert_particle</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;position, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;reference_position, const <a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a> particle_index, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;properties={})</td></tr>
<tr class="separator:a0903c26dd9c9ffe23e202fcf8a134776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b0e23c7059e8d5fbfafc01e3a286fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#aa9b0e23c7059e8d5fbfafc01e3a286fc">send_recv_particles</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>, std::vector&lt; <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &gt;&gt; &amp;particles_to_send, <a class="el" href="classParticles_1_1ParticleHandler.html#a802a7c4ebe4e57aedd31a47fe2b2c74a">particle_container</a> &amp;received_particles, const std::map&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>, std::vector&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt;&gt; &amp;new_cells_for_particles=std::map&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>, std::vector&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt;&gt;(), const <a class="el" href="classbool.html">bool</a> enable_cache=false)</td></tr>
<tr class="separator:aa9b0e23c7059e8d5fbfafc01e3a286fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4329873ef050b946e6378af7599810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#ace4329873ef050b946e6378af7599810">send_recv_particles_properties_and_location</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>, std::vector&lt; <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &gt;&gt; &amp;particles_to_send, <a class="el" href="classParticles_1_1ParticleHandler.html#a802a7c4ebe4e57aedd31a47fe2b2c74a">particle_container</a> &amp;received_particles)</td></tr>
<tr class="separator:ace4329873ef050b946e6378af7599810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0ef7355c362d519390b017782c4910"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a9a0ef7355c362d519390b017782c4910">connect_to_triangulation_signals</a> ()</td></tr>
<tr class="separator:a9a0ef7355c362d519390b017782c4910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab9c83c79e98634532343418e567d24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a6ab9c83c79e98634532343418e567d24">post_mesh_change_action</a> ()</td></tr>
<tr class="separator:a6ab9c83c79e98634532343418e567d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26756110d4de6f32e6d36ec0a64c7e07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a26756110d4de6f32e6d36ec0a64c7e07">register_data_attach</a> ()</td></tr>
<tr class="separator:a26756110d4de6f32e6d36ec0a64c7e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9979aabc576388ab0835d7c96bc37e7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a9979aabc576388ab0835d7c96bc37e7c">notify_ready_to_unpack</a> (const <a class="el" href="classbool.html">bool</a> serialization)</td></tr>
<tr class="separator:a9979aabc576388ab0835d7c96bc37e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c61772bc9f6280813f0fe6e9a047cd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#ad7c61772bc9f6280813f0fe6e9a047cd">pack_callback</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::CellStatus status) const</td></tr>
<tr class="separator:ad7c61772bc9f6280813f0fe6e9a047cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6bcebd8e08ab15ea04820273490f24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#aaf6bcebd8e08ab15ea04820273490f24">unpack_callback</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::CellStatus status, const boost::iterator_range&lt; std::vector&lt; char &gt;::const_iterator &gt; &amp;data_range)</td></tr>
<tr class="separator:aaf6bcebd8e08ab15ea04820273490f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad1469d144554b97c1923b89b41ed9861"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;, <a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#ad1469d144554b97c1923b89b41ed9861">triangulation</a></td></tr>
<tr class="separator:ad1469d144554b97c1923b89b41ed9861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed73d58005f8ccfafa56cf2bcb4ab4c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;, <a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#aed73d58005f8ccfafa56cf2bcb4ab4c1">mapping</a></td></tr>
<tr class="separator:aed73d58005f8ccfafa56cf2bcb4ab4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1e3a6c49a29635e5d4b8919a1bd5d7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a8b1e3a6c49a29635e5d4b8919a1bd5d7">property_pool</a></td></tr>
<tr class="separator:a8b1e3a6c49a29635e5d4b8919a1bd5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71b7ac43cac8e6050676b058ff20d4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1ParticleHandler.html#a802a7c4ebe4e57aedd31a47fe2b2c74a">particle_container</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#af71b7ac43cac8e6050676b058ff20d4f">particles</a></td></tr>
<tr class="separator:af71b7ac43cac8e6050676b058ff20d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e997cb226a001b8607a90f9e714eec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a39e997cb226a001b8607a90f9e714eec">global_number_of_particles</a></td></tr>
<tr class="separator:a39e997cb226a001b8607a90f9e714eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf50ad8857cb4c72f33e53a948c4794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a7cf50ad8857cb4c72f33e53a948c4794">number_of_locally_owned_particles</a></td></tr>
<tr class="separator:a7cf50ad8857cb4c72f33e53a948c4794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a86590b151cf93fa8545dbf656219b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a20a86590b151cf93fa8545dbf656219b">global_max_particles_per_cell</a></td></tr>
<tr class="separator:a20a86590b151cf93fa8545dbf656219b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa863c080d1a642649cadd0bdb2649c40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#aa863c080d1a642649cadd0bdb2649c40">next_free_particle_index</a></td></tr>
<tr class="separator:aa863c080d1a642649cadd0bdb2649c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8d2e28beef0e67127fe10fb76c4591"><td class="memItemLeft" align="right" valign="top">std::function&lt; std::size_t()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a9b8d2e28beef0e67127fe10fb76c4591">size_callback</a></td></tr>
<tr class="separator:a9b8d2e28beef0e67127fe10fb76c4591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068770808c9cb389504fd34c41d0733d"><td class="memItemLeft" align="right" valign="top">std::function&lt; void *(const <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &amp;, void *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a068770808c9cb389504fd34c41d0733d">store_callback</a></td></tr>
<tr class="separator:a068770808c9cb389504fd34c41d0733d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb0305ed8558a67f72d44184b36e3eb"><td class="memItemLeft" align="right" valign="top">std::function&lt; const void *(const <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &amp;, const void *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#aecb0305ed8558a67f72d44184b36e3eb">load_callback</a></td></tr>
<tr class="separator:aecb0305ed8558a67f72d44184b36e3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ee6e39b789ef90435b2d7e536410a2"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#ae3ee6e39b789ef90435b2d7e536410a2">handle</a></td></tr>
<tr class="separator:ae3ee6e39b789ef90435b2d7e536410a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b2af0279aef18dfec85f1cb2a0ef72"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#af4b2af0279aef18dfec85f1cb2a0ef72">triangulation_cache</a></td></tr>
<tr class="separator:af4b2af0279aef18dfec85f1cb2a0ef72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f6b566977ebd3725cf46570305dd38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structParticles_1_1internal_1_1GhostParticlePartitioner.html">internal::GhostParticlePartitioner</a>&lt; dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#a27f6b566977ebd3725cf46570305dd38">ghost_particles_cache</a></td></tr>
<tr class="separator:a27f6b566977ebd3725cf46570305dd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfacbe32357e12bc77bc2dec277fbffc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::signals2::connection &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1ParticleHandler.html#adfacbe32357e12bc77bc2dec277fbffc">tria_listeners</a></td></tr>
<tr class="separator:adfacbe32357e12bc77bc2dec277fbffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class Particles::ParticleHandler&lt; dim, spacedim &gt;</h3>

<p>This class manages the storage and handling of particles. It provides the data structures necessary to store particles efficiently, accessor functions to iterate over particles and find particles, and algorithms to distribute particles in parallel domains. Note that the class is designed in a similar way as the triangulation class. In particular, we call particles in the domain of the local process local particles, and particles that belong to neighbor processes and live in the ghost cells around the locally owned domain "ghost particles". The class also includes functionality that is similar to the <a class="el" href="classDoFHandler.html">DoFHandler</a> class (it knows which particles live on which cells) and the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class (it knows how to transfer particles between cells and subdomains).</p>
<p>For examples on how to use this class to track particles, store properties on particles, and let the properties on the particles influence the finite-element solution see step-19, step-68, and step-70. </p>

<p class="definition">Definition at line <a class="el" href="particles_2data__out_8h_source.html#l00032">32</a> of file <a class="el" href="particles_2data__out_8h_source.html">data_out.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a70366eefa102c06eea770e53412b0a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70366eefa102c06eea770e53412b0a52">&#9670;&nbsp;</a></span>particle_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> =  <a class="el" href="classParticles_1_1ParticleIterator.html">ParticleIterator</a>&lt;dim, spacedim&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A type that can be used to iterate over all particles in the domain. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00072">72</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a655ae2bdfe026f1ed172a2ec4c6c3d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655ae2bdfe026f1ed172a2ec4c6c3d60">&#9670;&nbsp;</a></span>particle_iterator_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1ParticleHandler.html#a655ae2bdfe026f1ed172a2ec4c6c3d60">particle_iterator_range</a> =  boost::iterator_range&lt;<a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A type that represents a range of particles. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00077">77</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a802a7c4ebe4e57aedd31a47fe2b2c74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802a7c4ebe4e57aedd31a47fe2b2c74a">&#9670;&nbsp;</a></span>particle_container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1ParticleHandler.html#a802a7c4ebe4e57aedd31a47fe2b2c74a">particle_container</a> =  std::vector&lt;std::vector&lt;typename <a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt;dim, spacedim&gt;::Handle&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A type for the storage container for particles. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00083">83</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2154bc9eb8f28a1f81bc50f242d88cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2154bc9eb8f28a1f81bc50f242d88cdc">&#9670;&nbsp;</a></span>ParticleHandler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. </p>

</div>
</div>
<a id="ab838d96b65a0d7c30270ac300f67d086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab838d96b65a0d7c30270ac300f67d086">&#9670;&nbsp;</a></span>ParticleHandler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_properties</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that initializes the particle handler with a given triangulation and mapping. Since particles are stored with respect to their surrounding cells this information is necessary to correctly organize the particle collection. This constructor is equivalent to calling the default constructor and the initialize function. </p>

</div>
</div>
<a id="a3b9e46faa39070489a83e12ee555e92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9e46faa39070489a83e12ee555e92d">&#9670;&nbsp;</a></span>~ParticleHandler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::~<a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a80faedd016dc8f8ea444385bad5ba3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80faedd016dc8f8ea444385bad5ba3ec">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_properties</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the particle handler. This function clears the internal data structures, and sets the triangulation and the mapping to be used. </p>

</div>
</div>
<a id="aeb95eec30eed4444c9bc77e6681c257d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb95eec30eed4444c9bc77e6681c257d">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>particle_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the state of particle handler <code>particle_handler</code> into the current object. This will copy all particles and properties and leave this object as an identical copy of <code>particle_handler</code>. Existing particles in this object are deleted. Be aware that this does not copy functions that are connected to the signals of <code>particle_handler</code>, nor does it connect the current object's member functions to triangulation signals, which must be done by the caller if necessary, that is if the <code>particle_handler</code> had connected functions.</p>
<p>This function is expensive as it has to duplicate all data in <code>particle_handler</code>, and insert it into this object, which may be a significant amount of data. However, it can be useful to save the state of a particle collection at a certain point in time and reset this state later under certain conditions, for example if a timestep has to be undone and repeated. </p>

</div>
</div>
<a id="a75aa243f94d48d176b7024b6c65bc3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75aa243f94d48d176b7024b6c65bc3d9">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all particle related data but keep the handler initialized. </p>

</div>
</div>
<a id="a4792e590e18ad8a4c427e82da98f7c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4792e590e18ad8a4c427e82da98f7c2e">&#9670;&nbsp;</a></span>clear_particles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::clear_particles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Only clear particle data, but keep cache information about number of particles. This is useful during reorganization of particle data between processes. </p>

</div>
</div>
<a id="a5011a0a3814c205d05a1dcd69930f3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5011a0a3814c205d05a1dcd69930f3f6">&#9670;&nbsp;</a></span>update_cached_numbers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::update_cached_numbers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update all internally cached numbers. Note that all functions that modify internal data structures and act on multiple particles will call this function automatically (e.g. insert_particles), while functions that act on single particles will not call this function (e.g. insert_particle). This is done because the update is expensive compared to single operations. </p>

</div>
</div>
<a id="a958a15b3aa325db82b4876cdb9feb527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958a15b3aa325db82b4876cdb9feb527">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator to the first locally owned particle. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l01126">1126</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a7577ec9642ac23c74d98506559af665b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7577ec9642ac23c74d98506559af665b">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator to the first locally owned particle. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l01135">1135</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="ab5f542a397843198eb82d8537602daf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f542a397843198eb82d8537602daf3">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator past the end of the particles. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l01152">1152</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a9fdc20dd339efffd016ca5f2de2d648f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fdc20dd339efffd016ca5f2de2d648f">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator past the end of the particles. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l01161">1161</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a7d3dd2c6bb5c8f3745931c75a2b04153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3dd2c6bb5c8f3745931c75a2b04153">&#9670;&nbsp;</a></span>begin_ghost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::begin_ghost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator to the first ghost particle. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l01173">1173</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="ad6cceebf117c4325cc08595e20968408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cceebf117c4325cc08595e20968408">&#9670;&nbsp;</a></span>begin_ghost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::begin_ghost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator to the first ghost particle. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l01182">1182</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a19bd8520f383556411ab78df7dd563b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bd8520f383556411ab78df7dd563b6">&#9670;&nbsp;</a></span>end_ghost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::end_ghost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator past the end of the ghost particles. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l01199">1199</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a290f2201824c3b7acc3d9812ea59c60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290f2201824c3b7acc3d9812ea59c60f">&#9670;&nbsp;</a></span>end_ghost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::end_ghost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator past the end of the ghost particles. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l01208">1208</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="ac043a4ea224ed50a03b8e9c3d3b98aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac043a4ea224ed50a03b8e9c3d3b98aec">&#9670;&nbsp;</a></span>n_particles_in_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::n_particles_in_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of particles that live on the given cell. </p>

</div>
</div>
<a id="a2f7faa76fe7bdcf2a3e4957e3da2cf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7faa76fe7bdcf2a3e4957e3da2cf46">&#9670;&nbsp;</a></span>particles_in_cell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html#a655ae2bdfe026f1ed172a2ec4c6c3d60">particle_iterator_range</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::particles_in_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pair of particle iterators that mark the begin and end of the particles in a particular cell. The last iterator is the first particle that is no longer in the cell.</p>
<p>The number of elements in the returned range equals what the <a class="el" href="classParticles_1_1ParticleHandler.html#ac043a4ea224ed50a03b8e9c3d3b98aec">n_particles_in_cell()</a> function returns. </p>

</div>
</div>
<a id="ae893b3181f2de5df6d565282ad4dbc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae893b3181f2de5df6d565282ad4dbc54">&#9670;&nbsp;</a></span>particles_in_cell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html#a655ae2bdfe026f1ed172a2ec4c6c3d60">particle_iterator_range</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::particles_in_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pair of particle iterators that mark the begin and end of the particles in a particular cell. The last iterator is the first particle that is no longer in the cell.</p>
<p>The number of elements in the returned range equals what the <a class="el" href="classParticles_1_1ParticleHandler.html#ac043a4ea224ed50a03b8e9c3d3b98aec">n_particles_in_cell()</a> function returns. </p>

</div>
</div>
<a id="ab8d9da9f7d53d0e7ffb58543d99234a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d9da9f7d53d0e7ffb58543d99234a2">&#9670;&nbsp;</a></span>remove_particle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::remove_particle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>particle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a particle pointed to by the iterator. Note that <code>particle</code> and all iterators that point to other particles in the same cell as <code>particle</code> will be invalidated during this call. </p>

</div>
</div>
<a id="adb3695c2b85931d51f81b0209841e7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3695c2b85931d51f81b0209841e7eb">&#9670;&nbsp;</a></span>remove_particles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::remove_particles </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>particles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a vector of particles indicated by the particle iterators. The iterators and all other particle iterators are invalidated during the function call. </p>

</div>
</div>
<a id="a6d3a123356cfc3f1be5623d8fe1fdf2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3a123356cfc3f1be5623d8fe1fdf2a">&#9670;&nbsp;</a></span>insert_particle() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::insert_particle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>particle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a particle into the collection of particles. Return an iterator to the new position of the particle. This function involves a copy of the particle and its properties. Note that this function is of \(O(N \log N)\) complexity for \(N\) particles. </p>

</div>
</div>
<a id="ae27a829c48f1abb15399d4b561040034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27a829c48f1abb15399d4b561040034">&#9670;&nbsp;</a></span>insert_particles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::insert_particles </td>
          <td>(</td>
          <td class="paramtype">const std::multimap&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>particles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a number of particles into the collection of particles. This function involves a copy of the particles and their properties. Note that this function is of O(n_existing_particles + n_particles) complexity. </p>

</div>
</div>
<a id="a18f50d7fb4d3b0679462eb8355633b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f50d7fb4d3b0679462eb8355633b1c">&#9670;&nbsp;</a></span>insert_particles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::insert_particles </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create and insert a number of particles into the collection of particles. This function takes a list of positions and creates a set of particles at these positions, which are then added to the local particle collection. Note that this function currently uses <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations()</a>, which assumes all positions are within the local part of the triangulation. If one of them is not in the local domain this function will throw an exception. </p>

</div>
</div>
<a id="ab5f5ee2de4878d33900e399dae278264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f5ee2de4878d33900e399dae278264">&#9670;&nbsp;</a></span>insert_global_particles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classIndexSet.html">IndexSet</a>&gt; <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::insert_global_particles </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>global_bounding_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>properties</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create and insert a number of particles into the collection of particles. This function takes a list of positions and creates a set of particles at these positions, which are then distributed and added to the local particle collection of a processor. Note that this function uses <a class="el" href="namespaceGridTools.html#afe6eff31d194dd4beafc9eb6a22c5e27">GridTools::distributed_compute_point_locations()</a>. Consequently, it can require intense communications between the processors. This function is used in step-70.</p>
<p>This function figures out what mpi process owns the points that do not fall within the locally owned part of the triangulation, it sends to that process the points passed to this function on this process, and receives the points that fall within the locally owned cells of the triangulation from whoever received them as input.</p>
<p>In order to keep track of what mpi process received what points, a map from mpi process to <a class="el" href="classIndexSet.html">IndexSet</a> is returned by the function. This <a class="el" href="classIndexSet.html">IndexSet</a> contains the local indices of the points that were passed to this function on the calling mpi process, and that falls within the part of triangulation owned by this mpi process.</p>
<p>The ids of the resulting particles are assigned from the optional argument <code>ids</code>. If the vector of <code>ids</code> is empty, then the ids are computed automatically from the <a class="el" href="classParticles_1_1ParticleHandler.html#af6c8a7d07ec85780875197ac1edd9140">get_next_free_particle_index()</a> onward. For example, if the method <a class="el" href="classParticles_1_1ParticleHandler.html#af6c8a7d07ec85780875197ac1edd9140">get_next_free_particle_index()</a> returns n0, calling this function with two MPI processes each adding n1 and n2 particles will result in the n1 particles added by process zero having ids equal to <code>[n0,n0+n1)</code>, and the n2 particles added by process one having ids <code>[n0+n1, n0+n1+n2)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">positions</td><td>A vector of points that do not need to be on the local processor, but have to be in the triangulation that is associated with this <a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a> object.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">global_bounding_boxes</td><td>A vector of vectors of bounding boxes. The bounding boxes <code>global_bboxes[rk]</code> describe which part of the mesh is locally owned by the mpi process with rank <code>rk</code>. The local description can be obtained from <a class="el" href="namespaceGridTools.html#ab6ed37fb4458b7a7c782afdb9d0d2664">GridTools::compute_mesh_predicate_bounding_box()</a>, and the global one can be obtained by passing the local ones to <a class="el" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">properties</td><td>(Optional) A vector of vector of properties associated with each local point. The size of the vector should be either zero (no properties will be transferred nor attached to the generated particles) or it should be a vector of <code>positions.size()</code> vectors of size <code><a class="el" href="classParticles_1_1ParticleHandler.html#a2d680b964c34e5ccfa22c920a7cd02a3">n_properties_per_particle()</a></code>. Notice that this function call will transfer the properties from the local mpi process to the final mpi process that will own each of the particles, and it may therefore be communication intensive.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ids</td><td>(Optional) A vector of ids to associate to each particle. If the vector is empty, the ids are assigned as a continuous range from the first available index, as documented above. If the vector is not empty, then its size must match the size of the <code>positions</code> vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map from owner to <a class="el" href="classIndexSet.html">IndexSet</a>, that contains the local indices of the points that were passed to this function on the calling mpi process, and that falls within the part of triangulation owned by this mpi process. </dd></dl>

</div>
</div>
<a id="a4095d645555387f0f257014aaaef259f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4095d645555387f0f257014aaaef259f">&#9670;&nbsp;</a></span>insert_global_particles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classIndexSet.html">IndexSet</a>&gt; <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::insert_global_particles </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>global_bounding_boxes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a number of particles into the collection of particles. This function takes a list of particles for which we don't know the associated cell iterator, and distributes them to the correct local particle collection of a processor, by unpacking the locations, figuring out where to send the particles by calling <a class="el" href="namespaceGridTools.html#afe6eff31d194dd4beafc9eb6a22c5e27">GridTools::distributed_compute_point_locations()</a>, and sending the particles to the corresponding process.</p>
<p>In order to keep track of what mpi process received what particles, a map from mpi process to <a class="el" href="classIndexSet.html">IndexSet</a> is returned by the function. This <a class="el" href="classIndexSet.html">IndexSet</a> contains the local indices of the particles that were passed to this function on the calling mpi process, and that falls within the part of the triangulation owned by this mpi process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particles</td><td>A vector of particles that do not need to be on the local processor.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">global_bounding_boxes</td><td>A vector of vectors of bounding boxes. The bounding boxes <code>global_bboxes[rk]</code> describe which part of the mesh is locally owned by the mpi process with rank <code>rk</code>. The local description can be obtained from <a class="el" href="namespaceGridTools.html#ab6ed37fb4458b7a7c782afdb9d0d2664">GridTools::compute_mesh_predicate_bounding_box()</a>, and the global one can be obtained by passing the local ones to <a class="el" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map from owner to <a class="el" href="classIndexSet.html">IndexSet</a>, that contains the local indices of the points that were passed to this function on the calling mpi process, and that falls within the part of triangulation owned by this mpi process. </dd></dl>

</div>
</div>
<a id="af68fb42de1cfabbef5b486626f04b564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68fb42de1cfabbef5b486626f04b564">&#9670;&nbsp;</a></span>set_particle_positions() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_convertible&lt; <a class="el" href="classVectorType.html">VectorType</a> *, <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; * &gt;::value==false &gt;::type <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::set_particle_positions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>input_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>displace_particles</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the position of the particles by using the values contained in the vector <code>input_vector</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorType</td><td>Any of the parallel distributed vectors supported by the library.</td></tr>
  </table>
  </dd>
</dl>
<p>The vector <code>input_vector</code> should have read access to the indices created by extracting the locally relevant ids with <a class="el" href="classParticles_1_1ParticleHandler.html#aff72d8b28b3ce456715338102c529f15">locally_owned_particle_ids()</a>, and taking its tensor product with the index set representing the range <code>[0, spacedim)</code>, i.e.: </p><div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> ids = particle_handler.locally_owned_particle_ids().</div><div class="line"> tensor_product(<a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div></div><!-- fragment --><p>The position of the particle with global index <code>id</code> is read from spacedim consecutive entries starting from <code>input_vector[id*spacedim]</code>.</p>
<p>Notice that it is not necessary that the <code>input_vector</code> <em>owns</em> those indices, however it has to have read access to them (i.e., it can be a distributed vector with ghost entries).</p>
<p>If the argument <code>displace_particles</code> is set to false, then the new position taken from the values contained in <code>input_vector</code>, replacing the previously stored particle position. By default, the particles are displaced by the amount contained in the <code>input_vector</code>, i.e., the contents of the vector are considered <em>offsets</em> that are added to the previous position.</p>
<p>After setting the new position, this function calls internally the method <a class="el" href="classParticles_1_1ParticleHandler.html#ad817e16828f2355b0cad6fef8db7df81">sort_particles_into_subdomains_and_cells()</a>. You should make sure you satisfy the requirements of that function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_vector</td><td>A parallel distributed vector containing the displacement to apply to each particle, or their new absolute position.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">displace_particles</td><td>Control if the <code>input_vector</code> should be interpreted as a displacement vector, or a vector of absolute positions. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l01239">1239</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a2912dec4f536ca688bf87c47d08c2141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2912dec4f536ca688bf87c47d08c2141">&#9670;&nbsp;</a></span>set_particle_positions() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::set_particle_positions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>new_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>displace_particles</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the position of the particles within the particle handler using a vector of points. The new set of point defined by the vector has to be sufficiently close to the original one to ensure that the <a class="el" href="classParticles_1_1ParticleHandler.html#ad817e16828f2355b0cad6fef8db7df81">sort_particles_into_subdomains_and_cells()</a> function manages to find the new cells in which the particles belong.</p>
<p>Points are numbered in the same way they are traversed locally by the <a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>. A typical way to use this method, is to first call the <a class="el" href="classParticles_1_1ParticleHandler.html#a41b3495884a94db511cd04ac888fddef">get_particle_positions()</a> function, and then modify the resulting vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_positions</td><td>A vector of points of dimension particle_handler.n_locally_owned_particles()</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">displace_particles</td><td>When true, this function adds the value of the vector of points to the current position of the particle, thus displacing them by the amount given by the function. When false, the position of the particle is replaced by the value in the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0998416b93c56c4335f78e8ac2cfbd8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0998416b93c56c4335f78e8ac2cfbd8a">&#9670;&nbsp;</a></span>set_particle_positions() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::set_particle_positions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>displace_particles</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the position of the particles within the particle handler using a function with spacedim components. The new set of point defined by the function has to be sufficiently close to the original one to ensure that the sort_particles_into_subdomains_and_cells algorithm manages to find the new cells in which the particles belong.</p>
<p>The function is evaluated at the current location of the particles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>A function that has n_components==spacedim that describes either the displacement or the new position of the particles as a function of the current location of the particle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">displace_particles</td><td>When true, this function adds the results of the function to the current position of the particle, thus displacing them by the amount given by the function. When false, the position of the particle is replaced by the value of the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41b3495884a94db511cd04ac888fddef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b3495884a94db511cd04ac888fddef">&#9670;&nbsp;</a></span>get_particle_positions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::get_particle_positions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>output_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>add_to_output_vector</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the position of the particles and store them into the distributed vector <code>output_vector</code>. By default the <code>output_vector</code> is overwritten by this operation, but you can add to its entries by setting <code>add_to_output_vector</code> to <code>true</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorType</td><td>Any of the parallel distributed vectors supported by the library.</td></tr>
  </table>
  </dd>
</dl>
<p>This is the reverse operation of the <a class="el" href="classParticles_1_1ParticleHandler.html#af68fb42de1cfabbef5b486626f04b564">set_particle_positions()</a> function. The position of the particle with global index <code>id</code> is written to spacedim consecutive entries starting from <code>output_vector[id*spacedim]</code>.</p>
<p>Notice that, if you use a distributed vector type, it is not necessary for the <code>output_vector</code> to own the entries corresponding to the indices that will be written. However you should keep in mind that this requires a global communication to distribute the entries above to their respective owners.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output_vector</td><td>A parallel distributed vector containing the positions of the particles, or updated with the positions of the particles.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add_to_output_vector</td><td>Control if the function should set the entries of the <code>output_vector</code> or if should add to them. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l01262">1262</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a8092724bc4430506e019d567f720484c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8092724bc4430506e019d567f720484c">&#9670;&nbsp;</a></span>get_particle_positions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::get_particle_positions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>add_to_output_vector</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gather the position of the particles within the particle handler in a vector of points. The order of the points is the same on would obtain by iterating over all (local) particles, and querying their locations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">positions</td><td>A vector preallocated at size <code>particle_handler.n_locally_owned_articles</code> and whose points will become the positions of the locally owned particles</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add_to_output_vector</td><td>When true, the value of the point of the particles is added to the positions vector. When false, the value of the points in the positions vector are replaced by the position of the particles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0748cc2d1c552871f99d7c3be39be744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0748cc2d1c552871f99d7c3be39be744">&#9670;&nbsp;</a></span>register_additional_store_load_functions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::register_additional_store_load_functions </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::size_t()&gt; &amp;&#160;</td>
          <td class="paramname"><em>size_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void *(const <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &amp;, void *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>store_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; const void *(const <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &amp;, const void *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>load_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function allows to register three additional functions that are called every time a particle is transferred to another process (i.e. during sorting into cells, during ghost particle transfer, or during serialization of all particles).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size_callback</td><td>A function that is called when serializing particle data. The function gets no arguments and is expected to return the size of the additional data that is serialized per particle. Note that this currently implies the data size has to be the same for every particle. </td></tr>
    <tr><td class="paramname">store_callback</td><td>A function that is called once per particle when serializing particle data. Arguments to the function are a particle iterator that identifies the current particle and a void pointer that points to a data block of size <a class="el" href="classParticles_1_1ParticleHandler.html#a9b8d2e28beef0e67127fe10fb76c4591">size_callback()</a> in which the function can store additional data. The function is expected to return a void pointer pointing to a position right after its data block. </td></tr>
    <tr><td class="paramname">load_callback</td><td>A function that is called once per particle when deserializing particle data. Arguments to the function are a particle iterator that identifies the current particle and a void pointer that points to a data block of size <a class="el" href="classParticles_1_1ParticleHandler.html#a9b8d2e28beef0e67127fe10fb76c4591">size_callback()</a> in which additional data was stored by the store_callback function. The function is expected to return a void pointer pointing to a position right after its data block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11a0beaff35d1541936ffa8d4724aab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a0beaff35d1541936ffa8d4724aab1">&#9670;&nbsp;</a></span>n_global_particles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::n_global_particles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of particles that were managed by this class the last time the <a class="el" href="classParticles_1_1ParticleHandler.html#a5011a0a3814c205d05a1dcd69930f3f6">update_cached_numbers()</a> function was called. The actual number of particles may have changed since then if particles have been added or removed.</p>
<dl class="section return"><dt>Returns</dt><dd>Total number of particles in simulation. </dd></dl>

</div>
</div>
<a id="adf5e803af074c2c55cf5a19c3228059d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5e803af074c2c55cf5a19c3228059d">&#9670;&nbsp;</a></span>n_global_max_particles_per_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::n_global_max_particles_per_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximum number of particles per cell the last time the <a class="el" href="classParticles_1_1ParticleHandler.html#a5011a0a3814c205d05a1dcd69930f3f6">update_cached_numbers()</a> function was called.</p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of particles in one cell in simulation. </dd></dl>

</div>
</div>
<a id="abafee65f03660b3adf80a40e52bfc7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafee65f03660b3adf80a40e52bfc7e4">&#9670;&nbsp;</a></span>n_locally_owned_particles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::n_locally_owned_particles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of particles in the local part of the triangulation. </p>

</div>
</div>
<a id="af6c8a7d07ec85780875197ac1edd9140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c8a7d07ec85780875197ac1edd9140">&#9670;&nbsp;</a></span>get_next_free_particle_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::get_next_free_particle_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the next free particle index in the global set of particles the last time the <a class="el" href="classParticles_1_1ParticleHandler.html#a5011a0a3814c205d05a1dcd69930f3f6">update_cached_numbers()</a> function was called. </p>

</div>
</div>
<a id="a2ae52dca45437abc8ceba776a2537bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae52dca45437abc8ceba776a2537bfd">&#9670;&nbsp;</a></span>locally_relevant_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::locally_relevant_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract an <a class="el" href="classIndexSet.html">IndexSet</a> with global dimensions equal to <a class="el" href="classParticles_1_1ParticleHandler.html#af6c8a7d07ec85780875197ac1edd9140">get_next_free_particle_index()</a>, containing the locally owned particle indices.</p>
<p>This function can be used to construct distributed vectors and matrices to manipulate particles using linear algebra operations.</p>
<p>Notice that it is the user's responsibility to guarantee that particle indices are unique, and no check is performed to verify that this is the case, nor that the union of all <a class="el" href="classIndexSet.html">IndexSet</a> objects on each mpi process is complete.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classIndexSet.html">IndexSet</a> of size <a class="el" href="classParticles_1_1ParticleHandler.html#af6c8a7d07ec85780875197ac1edd9140">get_next_free_particle_index()</a>, containing n_locally_owned_particle() indices.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000094">Deprecated:</a></b></dt><dd>Use <a class="el" href="classParticles_1_1ParticleHandler.html#aff72d8b28b3ce456715338102c529f15">locally_owned_particle_ids()</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l01289">1289</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="aff72d8b28b3ce456715338102c529f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff72d8b28b3ce456715338102c529f15">&#9670;&nbsp;</a></span>locally_owned_particle_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::locally_owned_particle_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract an <a class="el" href="classIndexSet.html">IndexSet</a> with global dimensions equal to <a class="el" href="classParticles_1_1ParticleHandler.html#af6c8a7d07ec85780875197ac1edd9140">get_next_free_particle_index()</a>, containing the locally owned particle indices.</p>
<p>This function can be used to construct distributed vectors and matrices to manipulate particles using linear algebra operations.</p>
<p>Notice that it is the user's responsibility to guarantee that particle indices are unique, and no check is performed to verify that this is the case, nor that the union of all <a class="el" href="classIndexSet.html">IndexSet</a> objects on each mpi process is complete.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classIndexSet.html">IndexSet</a> of size <a class="el" href="classParticles_1_1ParticleHandler.html#af6c8a7d07ec85780875197ac1edd9140">get_next_free_particle_index()</a>, containing n_locally_owned_particle() indices. </dd></dl>

</div>
</div>
<a id="a2d680b964c34e5ccfa22c920a7cd02a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d680b964c34e5ccfa22c920a7cd02a3">&#9670;&nbsp;</a></span>n_properties_per_particle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::n_properties_per_particle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of properties each particle has. </p>

</div>
</div>
<a id="a41adb90b9849e8e6c385d8e2ec77ac4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41adb90b9849e8e6c385d8e2ec77ac4e">&#9670;&nbsp;</a></span>get_property_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::get_property_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the property pool that owns all particle properties, and organizes them physically. </p>

</div>
</div>
<a id="ad817e16828f2355b0cad6fef8db7df81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad817e16828f2355b0cad6fef8db7df81">&#9670;&nbsp;</a></span>sort_particles_into_subdomains_and_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::sort_particles_into_subdomains_and_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and update the cells containing each particle for all locally owned particles. If particles moved out of the local subdomain they will be sent to their new process and inserted there. After this function call every particle is either on its current process and in its current cell, or deleted (if it could not find its new process or cell).</p>
<p>The user may attach a function to the signal <a class="el" href="structParticles_1_1ParticleHandler_1_1Signals.html#a8d374d0243baf75c2667f2fe6823cc16">Particles::ParticleHandler::Signals::particle_lost()</a>. The signal is triggered whenever a particle is deleted, and the connected functions are called passing an iterator to the particle in question, and its last known cell association. </p>

</div>
</div>
<a id="a0dc49fc12351c51875cdadfcc5ef6ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc49fc12351c51875cdadfcc5ef6ad9">&#9670;&nbsp;</a></span>exchange_ghost_particles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::exchange_ghost_particles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enable_ghost_cache</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exchange all particles that live in cells that are ghost cells to other processes. Clears and re-populates the ghost_neighbors member variable. </p>

</div>
</div>
<a id="ac67e8522ddf712ace1547b997a9caa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67e8522ddf712ace1547b997a9caa65">&#9670;&nbsp;</a></span>update_ghost_particles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::update_ghost_particles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update all particles that live in cells that are ghost cells to other processes. In this context, update means to update the location and the properties of the ghost particles assuming that the ghost particles have not changed cells. Consequently, this will not update the reference location of the particles. </p>

</div>
</div>
<a id="a57f132c97c49f31a3b4392a80e58f808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f132c97c49f31a3b4392a80e58f808">&#9670;&nbsp;</a></span>prepare_for_coarsening_and_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::prepare_for_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function prepares the particle handler for a coarsening and refinement cycle, by storing the necessary information to transfer particles to their new cells. The implementation depends on the triangulation type that is connected to the particle handler and differs between shared and distributed triangulations. This function should be used like the corresponding function with the same name in the <a class="el" href="namespaceLegacy_1_1parallel_1_1distributed.html#ac1d4c80a4169516a20e61b4517aec56e">SolutionTransfer()</a> class. </p>

</div>
</div>
<a id="a24de503d9bfb2e11f0924be6083b0af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24de503d9bfb2e11f0924be6083b0af7">&#9670;&nbsp;</a></span>unpack_after_coarsening_and_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::unpack_after_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function unpacks the particle data after a coarsening and refinement cycle, by reading the necessary information to transfer particles to their new cells. This function should be used like the <a class="el" href="classSolutionTransfer.html#a1171abf820e35e02304017ef3daeeaa5">SolutionTransfer::interpolate()</a> function after mesh refinement has finished. Note that this function requires a working mapping, i.e. if you use a mapping class that requires setup after a mesh refinement (e.g. <a class="el" href="classMappingQCache.html">MappingQCache()</a>, or MappingEulerian()), the mapping has to be ready before you can call this function.</p>
<dl class="section note"><dt>Note</dt><dd>It is important to note, that if you do not call this function after a refinement/coarsening operation (and a repartitioning operation in a distributed triangulation) and the particle handler contained particles before, the particle handler will not be usable any more. Not calling this function after refinement would be similar to trying to access a solution vector after mesh refinement without first using a <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class to transfer the vector to the new mesh. </dd></dl>

</div>
</div>
<a id="a296b16801f3d611bcf646ea76421b59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296b16801f3d611bcf646ea76421b59a">&#9670;&nbsp;</a></span>prepare_for_serialization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::prepare_for_serialization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function prepares the particle handler for serialization. This needs to be done before calling <a class="el" href="classTriangulation.html#a2f0c10f7a8cd32d961e9367173685047">Triangulation::save()</a>. This function should be used like the corresponding function with the same name in the <a class="el" href="namespaceLegacy_1_1parallel_1_1distributed.html#ac1d4c80a4169516a20e61b4517aec56e">SolutionTransfer()</a> class.</p>
<dl class="section note"><dt>Note</dt><dd>It is important to note, that if you do not call this function before a serialization operation in a distributed triangulation, the particles will not be serialized, and therefore will disappear after deserialization. </dd></dl>

</div>
</div>
<a id="aebf6f4465d2840b0811a95bbdb12f77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf6f4465d2840b0811a95bbdb12f77a">&#9670;&nbsp;</a></span>deserialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::deserialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute the deserialization of the particle data. This needs to be done after calling <a class="el" href="classTriangulation.html#ae2f72d5fbb277ec65dbe0382ae72a929">Triangulation::load()</a>. The data must have been stored before the serialization of the triangulation using the <a class="el" href="classParticles_1_1ParticleHandler.html#a296b16801f3d611bcf646ea76421b59a">prepare_for_serialization()</a> function. This function should be used like the corresponding function with the same name in the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class. </p>

</div>
</div>
<a id="a1c0c30b19d0dd7590a9f869ffb90bb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0c30b19d0dd7590a9f869ffb90bb84">&#9670;&nbsp;</a></span>register_store_callback_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8h.html#a8ce3607a2c3e9ba0f1d553bff4a3b588">DEAL_II_DEPRECATED_EARLY</a> void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::register_store_callback_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function that should be called before every refinement and when writing checkpoints. This function is used to register <a class="el" href="classParticles_1_1ParticleHandler.html#ad7c61772bc9f6280813f0fe6e9a047cd">pack_callback()</a> with the triangulation. This function is used in step-70.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000095">Deprecated:</a></b></dt><dd>Please use <a class="el" href="classParticles_1_1ParticleHandler.html#a57f132c97c49f31a3b4392a80e58f808">prepare_for_coarsening_and_refinement()</a> or <a class="el" href="classParticles_1_1ParticleHandler.html#a296b16801f3d611bcf646ea76421b59a">prepare_for_serialization()</a> instead. See there for further information about the purpose of this function. </dd></dl>

</div>
</div>
<a id="a90e041e6c5232d9ef43e1023986dd9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e041e6c5232d9ef43e1023986dd9e4">&#9670;&nbsp;</a></span>register_load_callback_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8h.html#a8ce3607a2c3e9ba0f1d553bff4a3b588">DEAL_II_DEPRECATED_EARLY</a> void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::register_load_callback_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>serialization</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function that should be called after every refinement and after resuming from a checkpoint. This function is used to register <a class="el" href="classParticles_1_1ParticleHandler.html#aaf6bcebd8e08ab15ea04820273490f24">unpack_callback()</a> with the triangulation. This function is used in step-70.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000096">Deprecated:</a></b></dt><dd>Please use <a class="el" href="classParticles_1_1ParticleHandler.html#a24de503d9bfb2e11f0924be6083b0af7">unpack_after_coarsening_and_refinement()</a> or <a class="el" href="classParticles_1_1ParticleHandler.html#aebf6f4465d2840b0811a95bbdb12f77a">deserialize()</a> instead. See there for further information about the purpose of this function. </dd></dl>

</div>
</div>
<a id="a877e1aac8ef0ad6fa85ed400bf71eb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877e1aac8ef0ad6fa85ed400bf71eb1c">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Serialize the contents of this class using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l01221">1221</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="acc0f3a178feb749c98b77e3cc31a7453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0f3a178feb749c98b77e3cc31a7453">&#9670;&nbsp;</a></span>insert_particle() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::insert_particle </td>
          <td>(</td>
          <td class="paramtype">const void *&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert a particle into the collection of particles from a raw data pointer. This function is used for shipping particles during serialization and refinement and not intended for use outside of this class. Return an iterator to the new position of the particle. </p>

</div>
</div>
<a id="a0903c26dd9c9ffe23e202fcf8a134776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0903c26dd9c9ffe23e202fcf8a134776">&#9670;&nbsp;</a></span>insert_particle() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::insert_particle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>reference_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a>&#160;</td>
          <td class="paramname"><em>particle_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>properties</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert a particle into the collection of particles given all the properties necessary for a particle. This function is used internally to efficiently generate particles without the detour through a <a class="el" href="classParticles_1_1Particle.html">Particle</a> object. </p>

</div>
</div>
<a id="aa9b0e23c7059e8d5fbfafc01e3a286fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b0e23c7059e8d5fbfafc01e3a286fc">&#9670;&nbsp;</a></span>send_recv_particles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::send_recv_particles </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>, std::vector&lt; <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>particles_to_send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticles_1_1ParticleHandler.html#a802a7c4ebe4e57aedd31a47fe2b2c74a">particle_container</a> &amp;&#160;</td>
          <td class="paramname"><em>received_particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>, std::vector&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>new_cells_for_particles</em> = <code>std::map&lt;&#160;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>,&#160;std::vector&lt;&#160;typename&#160;<a class="el" href="classTriangulation.html">Triangulation</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;::active_cell_iterator&#160;&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enable_cache</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transfer particles that have crossed subdomain boundaries to other processors. All received particles and their new cells will be appended to the <code>received_particles</code> vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particles_to_send</td><td>All particles that should be sent and their new subdomain_ids are in this map.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">received_particles</td><td><a class="el" href="classParticles_1_1Particle.html">Particle</a> container that stores all received particles. Note that it is not required nor checked that the container is empty, received particles are simply inserted into the container.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_cells_for_particles</td><td>Optional vector of cell iterators with the same structure as <code>particles_to_send</code>. If this parameter is given it should contain the cell iterator for every particle to be send in which the particle belongs. This parameter is necessary if the cell information of the particle iterator is outdated (e.g. after particle movement).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_cache</td><td>Optional bool that enables updating the ghost particles without rebuilding them from scratch by building a cache of type GhostParticlePartitioner, which stores the necessary information to update the ghost particles. Once this cache is built, the ghost particles can be updated by a call to <a class="el" href="classParticles_1_1ParticleHandler.html#ace4329873ef050b946e6378af7599810">send_recv_particles_properties_and_location()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace4329873ef050b946e6378af7599810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4329873ef050b946e6378af7599810">&#9670;&nbsp;</a></span>send_recv_particles_properties_and_location()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::send_recv_particles_properties_and_location </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>, std::vector&lt; <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>particles_to_send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticles_1_1ParticleHandler.html#a802a7c4ebe4e57aedd31a47fe2b2c74a">particle_container</a> &amp;&#160;</td>
          <td class="paramname"><em>received_particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transfer ghost particles' position and properties assuming that the particles have not changed cells. This routine uses the GhostParticlePartitioner as a caching structure to know which particles are ghost to other processes, and where they need to be sent. It inherently assumes that particles cannot have changed cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particles_to_send</td><td>All particles for which information should be sent and their new subdomain_ids are in this map.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">received_particles</td><td>A map with all received particles. Note that it is not required nor checked that the container is empty, received particles are simply inserted into the container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a0ef7355c362d519390b017782c4910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0ef7355c362d519390b017782c4910">&#9670;&nbsp;</a></span>connect_to_triangulation_signals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::connect_to_triangulation_signals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Connect the particle handler to the relevant triangulation signals to appropriately react to changes in the underlying triangulation. </p>

</div>
</div>
<a id="a6ab9c83c79e98634532343418e567d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab9c83c79e98634532343418e567d24">&#9670;&nbsp;</a></span>post_mesh_change_action()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::post_mesh_change_action </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classFunction.html">Function</a> that gets called by the triangulation signals if the structure of the mesh has changed. This function is responsible for resizing the particle container if no particles are stored, i.e. if the usual call to prepare_for_..., and transfer_particles_after_... functions is not necessary. </p>

</div>
</div>
<a id="a26756110d4de6f32e6d36ec0a64c7e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26756110d4de6f32e6d36ec0a64c7e07">&#9670;&nbsp;</a></span>register_data_attach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::register_data_attach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classFunction.html">Function</a> that should be called before every refinement and when writing checkpoints. This function is used to register <a class="el" href="classParticles_1_1ParticleHandler.html#ad7c61772bc9f6280813f0fe6e9a047cd">pack_callback()</a> with the triangulation. </p>

</div>
</div>
<a id="a9979aabc576388ab0835d7c96bc37e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9979aabc576388ab0835d7c96bc37e7c">&#9670;&nbsp;</a></span>notify_ready_to_unpack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::notify_ready_to_unpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>serialization</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Callback function that should be called after every refinement and after resuming from a checkpoint. This function is used to call the <a class="el" href="classParticles_1_1ParticleHandler.html#a9979aabc576388ab0835d7c96bc37e7c">notify_ready_to_unpack()</a> function of the triangulation and hand over the <a class="el" href="classParticles_1_1ParticleHandler.html#aaf6bcebd8e08ab15ea04820273490f24">unpack_callback()</a> function, which will unpack the particle data for each cell. </p>

</div>
</div>
<a id="ad7c61772bc9f6280813f0fe6e9a047cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c61772bc9f6280813f0fe6e9a047cd">&#9670;&nbsp;</a></span>pack_callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;char&gt; <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::pack_callback </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::CellStatus&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called by listener functions from <a class="el" href="classTriangulation.html">Triangulation</a> for every cell before a refinement step. All particles have to be attached to their cell to be sent around to the new cell and owning process. </p>

</div>
</div>
<a id="aaf6bcebd8e08ab15ea04820273490f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6bcebd8e08ab15ea04820273490f24">&#9670;&nbsp;</a></span>unpack_callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::unpack_callback </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::CellStatus&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::iterator_range&lt; std::vector&lt; char &gt;::const_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called by listener functions after a refinement step for each cell to unpack the particle data and transfer it to the local container. </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ace9086a5193f019312f962b0de892296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9086a5193f019312f962b0de892296">&#9670;&nbsp;</a></span>signals</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structParticles_1_1ParticleHandler_1_1Signals.html">Signals</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::signals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="structParticles_1_1ParticleHandler_1_1Signals.html">Signals</a> for the events that a particle handler can notify the calling application about. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00837">837</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="ad1469d144554b97c1923b89b41ed9861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1469d144554b97c1923b89b41ed9861">&#9670;&nbsp;</a></span>triangulation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;, <a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::triangulation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Address of the triangulation to work on. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00870">870</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="aed73d58005f8ccfafa56cf2bcb4ab4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed73d58005f8ccfafa56cf2bcb4ab4c1">&#9670;&nbsp;</a></span>mapping</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classMapping.html">Mapping</a>&lt;dim, spacedim&gt;, <a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::mapping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Address of the mapping to work on. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00876">876</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a8b1e3a6c49a29635e5d4b8919a1bd5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1e3a6c49a29635e5d4b8919a1bd5d7">&#9670;&nbsp;</a></span>property_pool</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::property_pool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This object owns and organizes the memory for all particle properties. Since particles reference the property pool, the latter has to be destroyed <em>after</em> the particles are destroyed. This is achieved by making sure the <code>property_pool</code> member variable precedes the declaration of the <code>particles</code> member variable. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00886">886</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="af71b7ac43cac8e6050676b058ff20d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71b7ac43cac8e6050676b058ff20d4f">&#9670;&nbsp;</a></span>particles</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1ParticleHandler.html#a802a7c4ebe4e57aedd31a47fe2b2c74a">particle_container</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::particles</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set of particles currently living in the local domain including ghost cells, organized by the active cell index of the cell they are in. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00892">892</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a39e997cb226a001b8607a90f9e714eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e997cb226a001b8607a90f9e714eec">&#9670;&nbsp;</a></span>global_number_of_particles</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::global_number_of_particles</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This variable stores how many particles are stored globally. It is calculated by <a class="el" href="classParticles_1_1ParticleHandler.html#a5011a0a3814c205d05a1dcd69930f3f6">update_cached_numbers()</a>. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00898">898</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a7cf50ad8857cb4c72f33e53a948c4794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf50ad8857cb4c72f33e53a948c4794">&#9670;&nbsp;</a></span>number_of_locally_owned_particles</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::number_of_locally_owned_particles</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This variable stores how many particles are locally owned. It is calculated by <a class="el" href="classParticles_1_1ParticleHandler.html#a5011a0a3814c205d05a1dcd69930f3f6">update_cached_numbers()</a>. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00904">904</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a20a86590b151cf93fa8545dbf656219b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a86590b151cf93fa8545dbf656219b">&#9670;&nbsp;</a></span>global_max_particles_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::global_max_particles_per_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum number of particles per cell in the global domain. This variable is important to store and load particle data during repartition and serialization of the solution. Note that the variable is only updated when it is needed, e.g. after particle movement, before/after mesh refinement, before creating a checkpoint and after resuming from a checkpoint. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00914">914</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="aa863c080d1a642649cadd0bdb2649c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa863c080d1a642649cadd0bdb2649c40">&#9670;&nbsp;</a></span>next_free_particle_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::next_free_particle_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This variable stores the next free particle index that is available globally in case new particles need to be generated. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00920">920</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a9b8d2e28beef0e67127fe10fb76c4591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8d2e28beef0e67127fe10fb76c4591">&#9670;&nbsp;</a></span>size_callback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;std::size_t()&gt; <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::size_callback</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that can be registered by calling register_additional_store_load_functions. It is called when serializing particle data. The function gets no arguments and is expected to return the size of the additional data that is serialized per particle. Note that this currently implies the data size has to be the same for every particle, but it does not have to be the same for every serialization process (e.g. a serialization during particle movement might include temporary data, while a serialization after movement was finished does not need to transfer this data). </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00933">933</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a068770808c9cb389504fd34c41d0733d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068770808c9cb389504fd34c41d0733d">&#9670;&nbsp;</a></span>store_callback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void *(const <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &amp;, void *)&gt; <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::store_callback</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that can be registered by calling register_additional_store_load_functions. It is called once per particle when serializing particle data. Arguments to the function are a particle iterator that identifies the current particle and a void pointer that points to a data block of size <a class="el" href="classParticles_1_1ParticleHandler.html#a9b8d2e28beef0e67127fe10fb76c4591">size_callback()</a> in which the function can store additional data. The function is expected to return a void pointer pointing to a position right after its data block. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00945">945</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="aecb0305ed8558a67f72d44184b36e3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb0305ed8558a67f72d44184b36e3eb">&#9670;&nbsp;</a></span>load_callback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;const void *(const <a class="el" href="classParticles_1_1ParticleHandler.html#a70366eefa102c06eea770e53412b0a52">particle_iterator</a> &amp;, const void *)&gt; <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::load_callback</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that is called once per particle when deserializing particle data. Arguments to the function are a particle iterator that identifies the current particle and a void pointer that points to a data block of size <a class="el" href="classParticles_1_1ParticleHandler.html#a9b8d2e28beef0e67127fe10fb76c4591">size_callback()</a> from which the function can load additional data. This block was filled by the store_callback function during serialization. This function is expected to return a void pointer pointing to a position right after its data block. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00958">958</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="ae3ee6e39b789ef90435b2d7e536410a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ee6e39b789ef90435b2d7e536410a2">&#9670;&nbsp;</a></span>handle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::handle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This variable is set by the <a class="el" href="classParticles_1_1ParticleHandler.html#a26756110d4de6f32e6d36ec0a64c7e07">register_data_attach()</a> function and used by the <a class="el" href="classParticles_1_1ParticleHandler.html#a9979aabc576388ab0835d7c96bc37e7c">notify_ready_to_unpack()</a> function to check where the particle data was registered in the corresponding triangulation object. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00966">966</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="af4b2af0279aef18dfec85f1cb2a0ef72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b2af0279aef18dfec85f1cb2a0ef72">&#9670;&nbsp;</a></span>triangulation_cache</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::triangulation_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> is used to store the information about the vertex_to_cells set and the vertex_to_cell_centers vectors to prevent recomputing them every time we sort_into_subdomain_and_cells(). This cache is automatically updated when the triangulation has changed. This cache is stored within a unique pointer because the particle handler has a constructor that enables it to be constructed without a triangulation. The cache does not have such a constructor. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l00977">977</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="a27f6b566977ebd3725cf46570305dd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f6b566977ebd3725cf46570305dd38">&#9670;&nbsp;</a></span>ghost_particles_cache</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structParticles_1_1internal_1_1GhostParticlePartitioner.html">internal::GhostParticlePartitioner</a>&lt;dim, spacedim&gt; <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::ghost_particles_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cache structure used to store the elements which are required to exchange the particle information (location and properties) across processors in order to update the ghost particles. This structure is only used to update the ghost particles. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l01053">1053</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<a id="adfacbe32357e12bc77bc2dec277fbffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfacbe32357e12bc77bc2dec277fbffc">&#9670;&nbsp;</a></span>tria_listeners</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;boost::signals2::connection&gt; <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a>&lt; dim, spacedim &gt;::tria_listeners</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of connections with which this object connects to the triangulation to get information about when the triangulation changes. </p>

<p class="definition">Definition at line <a class="el" href="particle__handler_8h_source.html#l01066">1066</a> of file <a class="el" href="particle__handler_8h_source.html">particle_handler.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/particles/<a class="el" href="particles_2data__out_8h_source.html">data_out.h</a></li>
<li>include/deal.II/particles/<a class="el" href="particle__handler_8h_source.html">particle_handler.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
