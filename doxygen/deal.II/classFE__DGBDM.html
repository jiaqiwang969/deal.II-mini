<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFE__DGBDM.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FE_DGBDM&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classFE__DGBDM-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FE_DGBDM&lt; dim, spacedim &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a> &raquo; <a class="el" href="group__fe.html">Finite element space descriptions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fe__dg__vector_8h_source.html">deal.II/fe/fe_dg_vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FE_DGBDM&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFE__DGBDM__inherit__graph.svg" width="387" height="519"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0cd5f34c3ab828fac31004f3b52921a1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a> { <br />
&#160;&#160;<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1afbb5ba93aed087d17dd0224e65a1bddc">unknown</a> = 0x00, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a349c581c3d0e392c33cc41d917eb038c">L2</a> = 0x01, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a0787dd9aa05e57e4e6009dd73cb1d229">Hcurl</a> = 0x02, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a11a375871bcf4978f67ff6d7435f81ee">Hdiv</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a0e986c9c300b61774d25c92ae2a9d054">H1</a> = Hcurl | Hdiv, 
<a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1a916ecb570449b2ad08281d708b39bae2">H2</a> = 0x0e
<br />
 }</td></tr>
<tr class="separator:a0cd5f34c3ab828fac31004f3b52921a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afa294f4c49161d9db8e5301c5e3e1458"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__DGBDM.html#afa294f4c49161d9db8e5301c5e3e1458">FE_DGBDM</a> (const unsigned <a class="el" href="classint.html">int</a> p)</td></tr>
<tr class="separator:afa294f4c49161d9db8e5301c5e3e1458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cdb625c5bc57ffff2dc98f04137fb8"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__DGBDM.html#a78cdb625c5bc57ffff2dc98f04137fb8">get_name</a> () const override</td></tr>
<tr class="separator:a78cdb625c5bc57ffff2dc98f04137fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e25f164fd98df828a00b9e488c37cb6"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__DGVector.html#a3e25f164fd98df828a00b9e488c37cb6">clone</a> () const override</td></tr>
<tr class="separator:a3e25f164fd98df828a00b9e488c37cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9f11c1bb7778b0384867a3b1ca4d19"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__DGVector.html#a1c9f11c1bb7778b0384867a3b1ca4d19">has_support_on_face</a> (const unsigned <a class="el" href="classint.html">int</a> shape_index, const unsigned <a class="el" href="classint.html">int</a> face_index) const override</td></tr>
<tr class="separator:a1c9f11c1bb7778b0384867a3b1ca4d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdf31566f4c83b3910e5323f0a40dd9"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__DGVector.html#afcdf31566f4c83b3910e5323f0a40dd9">memory_consumption</a> () const override</td></tr>
<tr class="separator:afcdf31566f4c83b3910e5323f0a40dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d612e33a3521245d3622bf086975e8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#ae4d612e33a3521245d3622bf086975e8">requires_update_flags</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags) const override</td></tr>
<tr class="separator:ae4d612e33a3521245d3622bf086975e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5c7a79b81e77b1e78b99e548318370"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a8b5c7a79b81e77b1e78b99e548318370">shape_value</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a8b5c7a79b81e77b1e78b99e548318370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bd508748b8aa53dcb079604b438f85"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#af8bd508748b8aa53dcb079604b438f85">shape_value_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:af8bd508748b8aa53dcb079604b438f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928b72c168c5cdf1c0b9095160459999"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a928b72c168c5cdf1c0b9095160459999">shape_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a928b72c168c5cdf1c0b9095160459999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077b899f9ed0cd4d0b51f7f2e2d85f2c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a077b899f9ed0cd4d0b51f7f2e2d85f2c">shape_grad_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:a077b899f9ed0cd4d0b51f7f2e2d85f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c753175396d250d063f035eb3ec19e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#ac2c753175396d250d063f035eb3ec19e">shape_grad_grad</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:ac2c753175396d250d063f035eb3ec19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74023d8ecb4c4757a86a8448f016dac"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#ac74023d8ecb4c4757a86a8448f016dac">shape_grad_grad_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const override</td></tr>
<tr class="separator:ac74023d8ecb4c4757a86a8448f016dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0833eb3ee7cbff916b3d8f3e7558501"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aa0833eb3ee7cbff916b3d8f3e7558501">operator^</a> (const unsigned <a class="el" href="classint.html">int</a> multiplicity) const</td></tr>
<tr class="separator:aa0833eb3ee7cbff916b3d8f3e7558501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623b0c5a085bc13c826f3d78459a407f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a623b0c5a085bc13c826f3d78459a407f">operator[]</a> (const unsigned <a class="el" href="classint.html">int</a> fe_index) const</td></tr>
<tr class="separator:a623b0c5a085bc13c826f3d78459a407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8eac071595214d0252b359c48ed11d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0e8eac071595214d0252b359c48ed11d">operator==</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe) const</td></tr>
<tr class="separator:a0e8eac071595214d0252b359c48ed11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439857c3106a765203a354723dfc7cac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a439857c3106a765203a354723dfc7cac">operator==</a> (const <a class="el" href="classFiniteElementData.html">FiniteElementData</a> &amp;) const</td></tr>
<tr class="separator:a439857c3106a765203a354723dfc7cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443a348f7c568cb05b3ec3f18c788f75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a443a348f7c568cb05b3ec3f18c788f75">operator!=</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;) const</td></tr>
<tr class="separator:a443a348f7c568cb05b3ec3f18c788f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga663d09822c597afdf3252fd2ee228484"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga663d09822c597afdf3252fd2ee228484">DeclException1</a> (ExcShapeFunctionNotPrimitive, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The shape function with index &quot;&lt;&lt; arg1&lt;&lt; &quot; is not primitive, i.e. it is vector-valued and &quot;&lt;&lt; &quot;has more than one non-zero vector component. This &quot;&lt;&lt; &quot;function cannot be called for these shape functions. &quot;&lt;&lt; &quot;Maybe you want to use the same function with the &quot;&lt;&lt; &quot;_component suffix?&quot;)</td></tr>
<tr class="separator:ga663d09822c597afdf3252fd2ee228484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ec1b9715ae5de8ea67d626df81074e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga6ec1b9715ae5de8ea67d626df81074e1">DeclException0</a> (ExcFENotPrimitive)</td></tr>
<tr class="separator:ga6ec1b9715ae5de8ea67d626df81074e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37396684147b41d9ffe6dfdd4210b1ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga37396684147b41d9ffe6dfdd4210b1ce">DeclException0</a> (ExcInterpolationNotImplemented)</td></tr>
<tr class="separator:ga37396684147b41d9ffe6dfdd4210b1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed68da6b4b3bc08dfbf59630124f2875"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaed68da6b4b3bc08dfbf59630124f2875">DeclExceptionMsg</a> (ExcUnitShapeValuesDoNotExist, &quot;You are trying to access the values or derivatives of shape functions &quot; &quot;on the reference cell of an element that does not define its shape &quot; &quot;functions through mapping from the reference cell. Consequently, &quot; &quot;you cannot ask for shape function values or derivatives on the &quot; &quot;reference cell.&quot;)</td></tr>
<tr class="separator:gaed68da6b4b3bc08dfbf59630124f2875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d7ad6a5f56547799f047a79fb049af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga84d7ad6a5f56547799f047a79fb049af">DeclExceptionMsg</a> (ExcFEHasNoSupportPoints, &quot;You are trying to access the support points of a finite &quot; &quot;element that either has no support points at all, or for &quot; &quot;which the corresponding tables have not been implemented.&quot;)</td></tr>
<tr class="separator:ga84d7ad6a5f56547799f047a79fb049af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d4217c6d67c320694015d7e5e59269f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3d4217c6d67c320694015d7e5e59269f">DeclExceptionMsg</a> (ExcEmbeddingVoid, &quot;You are trying to access the matrices that describe how &quot; &quot;to embed a finite element function on one cell into the &quot; &quot;finite element space on one of its children (i.e., the &quot; &quot;'embedding' or '<a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a>' matrices). However, the &quot; &quot;current finite element can either not define this sort of &quot; &quot;operation, or it has not yet been implemented.&quot;)</td></tr>
<tr class="separator:ga3d4217c6d67c320694015d7e5e59269f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04d11552badfaba74bd005e26054bbaa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga04d11552badfaba74bd005e26054bbaa">DeclExceptionMsg</a> (ExcProjectionVoid, &quot;You are trying to access the matrices that describe how &quot; &quot;to restrict a finite element function from the children &quot; &quot;of one cell to the finite element space defined on their &quot; &quot;parent (i.e., the '<a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">restriction</a>' or 'projection' matrices). &quot; &quot;However, the current finite element can either not define &quot; &quot;this sort of operation, or it has not yet been &quot; &quot;implemented.&quot;)</td></tr>
<tr class="separator:ga04d11552badfaba74bd005e26054bbaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7259b58625401341a88c342ea942ee40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7259b58625401341a88c342ea942ee40">DeclException2</a> (ExcWrongInterfaceMatrixSize, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The interface matrix has a size of &quot;&lt;&lt; arg1&lt;&lt; &quot;x&quot;&lt;&lt; arg2&lt;&lt; &quot;, which is not reasonable for the current element &quot; &quot;in the present dimension.&quot;)</td></tr>
<tr class="separator:ga7259b58625401341a88c342ea942ee40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60aed438915b7d8d37b2a45c902e6bfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classReferenceCell.html">ReferenceCell</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a60aed438915b7d8d37b2a45c902e6bfe">reference_cell</a> () const</td></tr>
<tr class="separator:a60aed438915b7d8d37b2a45c902e6bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfd4619615520b8446ac853826a7d4c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a5cfd4619615520b8446ac853826a7d4c">n_unique_quads</a> () const</td></tr>
<tr class="separator:a5cfd4619615520b8446ac853826a7d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6081492e85d34bbfbd334423e31ce42"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ad6081492e85d34bbfbd334423e31ce42">n_unique_faces</a> () const</td></tr>
<tr class="separator:ad6081492e85d34bbfbd334423e31ce42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1f06778f87a7606cc2e0d5338b41ab"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a0d1f06778f87a7606cc2e0d5338b41ab">n_dofs_per_vertex</a> () const</td></tr>
<tr class="separator:a0d1f06778f87a7606cc2e0d5338b41ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384464e3b59fe91485f603dc32db7dd1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a384464e3b59fe91485f603dc32db7dd1">n_dofs_per_line</a> () const</td></tr>
<tr class="separator:a384464e3b59fe91485f603dc32db7dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8259242b27dc19222cde2016a99dba2"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ad8259242b27dc19222cde2016a99dba2">n_dofs_per_quad</a> (unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:ad8259242b27dc19222cde2016a99dba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32508c87a3850e94e59193f14c52d6f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aa32508c87a3850e94e59193f14c52d6f">max_dofs_per_quad</a> () const</td></tr>
<tr class="separator:aa32508c87a3850e94e59193f14c52d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb7465f62a849481ae0bf5edc78ec7d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aecb7465f62a849481ae0bf5edc78ec7d">n_dofs_per_hex</a> () const</td></tr>
<tr class="separator:aecb7465f62a849481ae0bf5edc78ec7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5f5b1fc401af61dafc61d083f5ae7b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a4a5f5b1fc401af61dafc61d083f5ae7b">n_dofs_per_face</a> (unsigned <a class="el" href="classint.html">int</a> face_no=0, unsigned <a class="el" href="classint.html">int</a> child=0) const</td></tr>
<tr class="separator:a4a5f5b1fc401af61dafc61d083f5ae7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54eef7c23041e6750f0a71c2ca3028bd"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a54eef7c23041e6750f0a71c2ca3028bd">max_dofs_per_face</a> () const</td></tr>
<tr class="separator:a54eef7c23041e6750f0a71c2ca3028bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b522422da89e5c080e7405ad49d7c7"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a> () const</td></tr>
<tr class="separator:a33b522422da89e5c080e7405ad49d7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc6a1e69b9c6594f6f08338d11ceb43"><td class="memTemplParams" colspan="2">template&lt;int structdim&gt; </td></tr>
<tr class="memitem:a6dc6a1e69b9c6594f6f08338d11ceb43"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a6dc6a1e69b9c6594f6f08338d11ceb43">n_dofs_per_object</a> (const unsigned <a class="el" href="classint.html">int</a> i=0) const</td></tr>
<tr class="separator:a6dc6a1e69b9c6594f6f08338d11ceb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a698695065333035e493294ce92820e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">n_components</a> () const</td></tr>
<tr class="separator:a5a698695065333035e493294ce92820e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1c4ca934f26ff463caf35a574e9f14"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a4c1c4ca934f26ff463caf35a574e9f14">n_blocks</a> () const</td></tr>
<tr class="separator:a4c1c4ca934f26ff463caf35a574e9f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b11a9d43bf383bb38953fd50dba34b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ab6b11a9d43bf383bb38953fd50dba34b">block_indices</a> () const</td></tr>
<tr class="separator:ab6b11a9d43bf383bb38953fd50dba34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584a56a1611a86a04c8b9a26d0eb9f27"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a584a56a1611a86a04c8b9a26d0eb9f27">tensor_degree</a> () const</td></tr>
<tr class="separator:a584a56a1611a86a04c8b9a26d0eb9f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e928460be93a004559b841f35ad698"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a18e928460be93a004559b841f35ad698">conforms</a> (const <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a>) const</td></tr>
<tr class="separator:a18e928460be93a004559b841f35ad698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078fb199880f2b29fc72d9c01d317bd0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a078fb199880f2b29fc72d9c01d317bd0">get_first_line_index</a> () const</td></tr>
<tr class="separator:a078fb199880f2b29fc72d9c01d317bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1b484c2e7afda2efaa11e7e31b5bbf"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a3a1b484c2e7afda2efaa11e7e31b5bbf">get_first_quad_index</a> (const unsigned <a class="el" href="classint.html">int</a> quad_no=0) const</td></tr>
<tr class="separator:a3a1b484c2e7afda2efaa11e7e31b5bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4361f6bf7db70f4961e67ddf97ebf8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aff4361f6bf7db70f4961e67ddf97ebf8">get_first_hex_index</a> () const</td></tr>
<tr class="separator:aff4361f6bf7db70f4961e67ddf97ebf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859d429b3a7a847713c6d2528c3f2e97"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a859d429b3a7a847713c6d2528c3f2e97">get_first_face_line_index</a> (const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:a859d429b3a7a847713c6d2528c3f2e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2166738fc6fda9ef70988179d8d569"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a9f2166738fc6fda9ef70988179d8d569">get_first_face_quad_index</a> (const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:a9f2166738fc6fda9ef70988179d8d569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">形状函数访问</div></td></tr>
<tr class="memitem:af9716de0908601e453e0b56935280eb3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#af9716de0908601e453e0b56935280eb3">shape_3rd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:af9716de0908601e453e0b56935280eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc9c5e6fff74957e68a7dc40ce9001c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4bc9c5e6fff74957e68a7dc40ce9001c">shape_3rd_derivative_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:a4bc9c5e6fff74957e68a7dc40ce9001c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca1cc51c17eefe7ae1b22d40739bb5b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#afca1cc51c17eefe7ae1b22d40739bb5b">shape_4th_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:afca1cc51c17eefe7ae1b22d40739bb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25664d01bbe39b68056379410dd916ab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a25664d01bbe39b68056379410dd916ab">shape_4th_derivative_component</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:a25664d01bbe39b68056379410dd916ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">转移和约束矩阵 @{</div></td></tr>
<tr class="memitem:a9fbcedd86a33fd947de495e7bf6923dd"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9fbcedd86a33fd947de495e7bf6923dd">get_restriction_matrix</a> (const unsigned <a class="el" href="classint.html">int</a> child, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const</td></tr>
<tr class="separator:a9fbcedd86a33fd947de495e7bf6923dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4671144d9976b133c4f79c9aefdd7c"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a3a4671144d9976b133c4f79c9aefdd7c">get_prolongation_matrix</a> (const unsigned <a class="el" href="classint.html">int</a> child, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const</td></tr>
<tr class="separator:a3a4671144d9976b133c4f79c9aefdd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ead2dba2770c63493a139bec677ccdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a1ead2dba2770c63493a139bec677ccdb">prolongation_is_implemented</a> () const</td></tr>
<tr class="separator:a1ead2dba2770c63493a139bec677ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0849d6c4188612816934d5468ecf9e6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0849d6c4188612816934d5468ecf9e6b">isotropic_prolongation_is_implemented</a> () const</td></tr>
<tr class="separator:a0849d6c4188612816934d5468ecf9e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8539eac73f0305ba91e612ad5519250"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab8539eac73f0305ba91e612ad5519250">restriction_is_implemented</a> () const</td></tr>
<tr class="separator:ab8539eac73f0305ba91e612ad5519250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645ff401ff38407d67a0785163939f87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a645ff401ff38407d67a0785163939f87">isotropic_restriction_is_implemented</a> () const</td></tr>
<tr class="separator:a645ff401ff38407d67a0785163939f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa81cef78859c726852a1ee1ef37210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a6aa81cef78859c726852a1ee1ef37210">restriction_is_additive</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:a6aa81cef78859c726852a1ee1ef37210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da3f9ca1fa6be8fa5afcb34d56028a3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9da3f9ca1fa6be8fa5afcb34d56028a3">constraints</a> (const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;subface_case=::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt;::case_isotropic) const</td></tr>
<tr class="separator:a9da3f9ca1fa6be8fa5afcb34d56028a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f5b5d1700cf820f8989f35418efbfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a01f5b5d1700cf820f8989f35418efbfc">constraints_are_implemented</a> (const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;subface_case=::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt;::case_isotropic) const</td></tr>
<tr class="separator:a01f5b5d1700cf820f8989f35418efbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d64f4a56fb9fefc55a68fb7ac5e71a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae5d64f4a56fb9fefc55a68fb7ac5e71a">hp_constraints_are_implemented</a> () const</td></tr>
<tr class="separator:ae5d64f4a56fb9fefc55a68fb7ac5e71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d590413e360eb10dbe4f9e247cb2bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a46d590413e360eb10dbe4f9e247cb2bb">get_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix) const</td></tr>
<tr class="separator:a46d590413e360eb10dbe4f9e247cb2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">支持hp的函数</div></td></tr>
<tr class="memitem:a704fd4e8da3219ba0f71a17b5effdf55"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a704fd4e8da3219ba0f71a17b5effdf55">get_face_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:a704fd4e8da3219ba0f71a17b5effdf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49db74688a0ac8a839fb5aca9b7febde"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a49db74688a0ac8a839fb5aca9b7febde">get_subface_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;source, const unsigned <a class="el" href="classint.html">int</a> subface, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:a49db74688a0ac8a839fb5aca9b7febde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">支持HP的函数-</div></td></tr>
<tr class="memitem:a18c920830fe94b08cdf8754b6533e805"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a18c920830fe94b08cdf8754b6533e805">hp_vertex_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const</td></tr>
<tr class="separator:a18c920830fe94b08cdf8754b6533e805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0580b57287997a3aaa682d993bc952c1"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0580b57287997a3aaa682d993bc952c1">hp_line_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other) const</td></tr>
<tr class="separator:a0580b57287997a3aaa682d993bc952c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34df541fc9614840c6c428cbe9ffa68e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a34df541fc9614840c6c428cbe9ffa68e">hp_quad_dof_identities</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:a34df541fc9614840c6c428cbe9ffa68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1719468736ca8342cf3927564e57ed66"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a1719468736ca8342cf3927564e57ed66">compare_for_domination</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe_other, const unsigned <a class="el" href="classint.html">int</a> codim=0) const</td></tr>
<tr class="separator:a1719468736ca8342cf3927564e57ed66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">索引计算 @{</div></td></tr>
<tr class="memitem:a86644fe67824373cd51e9ff7fca94f8c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">system_to_component_index</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:a86644fe67824373cd51e9ff7fca94f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ea16b60a6fc644a9bc7097703a53e8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae2ea16b60a6fc644a9bc7097703a53e8">component_to_system_index</a> (const unsigned <a class="el" href="classint.html">int</a> component, const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:ae2ea16b60a6fc644a9bc7097703a53e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb73242a6dca33f8da1bb44a5f00d61"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aecb73242a6dca33f8da1bb44a5f00d61">face_system_to_component_index</a> (const unsigned <a class="el" href="classint.html">int</a> index, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:aecb73242a6dca33f8da1bb44a5f00d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54657bc9ca9484522e7e6e3ca2499bc"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae54657bc9ca9484522e7e6e3ca2499bc">adjust_quad_dof_index_for_face_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> index, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classbool.html">bool</a> face_orientation, const <a class="el" href="classbool.html">bool</a> face_flip, const <a class="el" href="classbool.html">bool</a> face_rotation) const</td></tr>
<tr class="separator:ae54657bc9ca9484522e7e6e3ca2499bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d22a08e0e3136f181d6098db19f8b93"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a8d22a08e0e3136f181d6098db19f8b93">face_to_cell_index</a> (const unsigned <a class="el" href="classint.html">int</a> face_dof_index, const unsigned <a class="el" href="classint.html">int</a> face, const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false) const</td></tr>
<tr class="separator:a8d22a08e0e3136f181d6098db19f8b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5859e4b85feaa0406c4aa571fc4dfa4f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a5859e4b85feaa0406c4aa571fc4dfa4f">adjust_line_dof_index_for_line_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> index, const <a class="el" href="classbool.html">bool</a> line_orientation) const</td></tr>
<tr class="separator:a5859e4b85feaa0406c4aa571fc4dfa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12aa649db6e1460a8d30b067af952fc4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a12aa649db6e1460a8d30b067af952fc4">get_nonzero_components</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a12aa649db6e1460a8d30b067af952fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac228df752c9c2462aabf284e862402d0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac228df752c9c2462aabf284e862402d0">n_nonzero_components</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ac228df752c9c2462aabf284e862402d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626abd282a25193db7f61b4ec53e7385"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a626abd282a25193db7f61b4ec53e7385">is_primitive</a> () const</td></tr>
<tr class="separator:a626abd282a25193db7f61b4ec53e7385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38241991825f67d635d53d25cb5a2fda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a38241991825f67d635d53d25cb5a2fda">is_primitive</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a38241991825f67d635d53d25cb5a2fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12fbcc708737aa60fa272d4d3e22aea"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ad12fbcc708737aa60fa272d4d3e22aea">n_base_elements</a> () const</td></tr>
<tr class="separator:ad12fbcc708737aa60fa272d4d3e22aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c2ecc833033772889878116bd8a740"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a40c2ecc833033772889878116bd8a740">base_element</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:a40c2ecc833033772889878116bd8a740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa009769e662e34081f60ff16327db1b1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aa009769e662e34081f60ff16327db1b1">element_multiplicity</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:aa009769e662e34081f60ff16327db1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e43718bc2c42814fb3513478f25db42"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a6e43718bc2c42814fb3513478f25db42">get_sub_fe</a> (const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask) const</td></tr>
<tr class="separator:a6e43718bc2c42814fb3513478f25db42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91c784287a963d36c05fed227b4c973"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ad91c784287a963d36c05fed227b4c973">get_sub_fe</a> (const unsigned <a class="el" href="classint.html">int</a> first_component, const unsigned <a class="el" href="classint.html">int</a> n_selected_components) const</td></tr>
<tr class="separator:ad91c784287a963d36c05fed227b4c973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ac75dfc5b9f4e01c34d5865b4ca5a2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">system_to_base_index</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:a95ac75dfc5b9f4e01c34d5865b4ca5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4647e72a2670c17849701a6357eb87"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9c4647e72a2670c17849701a6357eb87">face_system_to_base_index</a> (const unsigned <a class="el" href="classint.html">int</a> index, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:a9c4647e72a2670c17849701a6357eb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc49f8114f396b20b9a7fe9a3c058568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#afc49f8114f396b20b9a7fe9a3c058568">first_block_of_base</a> (const unsigned <a class="el" href="classint.html">int</a> b) const</td></tr>
<tr class="separator:afc49f8114f396b20b9a7fe9a3c058568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1ca2e63382a8fd20910ae0303f4f6c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a2e1ca2e63382a8fd20910ae0303f4f6c">component_to_base_index</a> (const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:a2e1ca2e63382a8fd20910ae0303f4f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656f95e7c9144846758b804a41405cd3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a656f95e7c9144846758b804a41405cd3">block_to_base_index</a> (const unsigned <a class="el" href="classint.html">int</a> block) const</td></tr>
<tr class="separator:a656f95e7c9144846758b804a41405cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0763dd6212313f0ff69f04c735b2a147"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0763dd6212313f0ff69f04c735b2a147">system_to_block_index</a> (const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:a0763dd6212313f0ff69f04c735b2a147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3dd1574cabab93b67e3fe47a103b6a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7b3dd1574cabab93b67e3fe47a103b6a">component_to_block_index</a> (const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:a7b3dd1574cabab93b67e3fe47a103b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">分量和块状矩阵</div></td></tr>
<tr class="memitem:a4409f54175f279ac24cc982cfcfcbd2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const</td></tr>
<tr class="separator:a4409f54175f279ac24cc982cfcfcbd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d11c23f6db2eca49ba470defb873c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a46d11c23f6db2eca49ba470defb873c0">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const</td></tr>
<tr class="separator:a46d11c23f6db2eca49ba470defb873c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0dcc1e76885ec0ddcaae340dcdcd62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a2c0dcc1e76885ec0ddcaae340dcdcd62">component_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;sym_tensor) const</td></tr>
<tr class="separator:a2c0dcc1e76885ec0ddcaae340dcdcd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d2a54a95f43f0db77e74b1bfab21d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a24d2a54a95f43f0db77e74b1bfab21d2">component_mask</a> (const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;<a class="el" href="classFiniteElement.html#a7cc5ed75cad6792b8b21a3ac635a8860">block_mask</a>) const</td></tr>
<tr class="separator:a24d2a54a95f43f0db77e74b1bfab21d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc5ed75cad6792b8b21a3ac635a8860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7cc5ed75cad6792b8b21a3ac635a8860">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const</td></tr>
<tr class="separator:a7cc5ed75cad6792b8b21a3ac635a8860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9294bf84eec96ac31f29808a5aa87551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9294bf84eec96ac31f29808a5aa87551">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const</td></tr>
<tr class="separator:a9294bf84eec96ac31f29808a5aa87551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace95b8ef3a342bbb8f82cb17113be612"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ace95b8ef3a342bbb8f82cb17113be612">block_mask</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;sym_tensor) const</td></tr>
<tr class="separator:ace95b8ef3a342bbb8f82cb17113be612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931d71caa9f14212b8dd89337e155fc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMask.html">BlockMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a931d71caa9f14212b8dd89337e155fc1">block_mask</a> (const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;<a class="el" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>) const</td></tr>
<tr class="separator:a931d71caa9f14212b8dd89337e155fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3584deb698371e24c78dcd27f962ede8"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt;, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a3584deb698371e24c78dcd27f962ede8">get_constant_modes</a> () const</td></tr>
<tr class="separator:a3584deb698371e24c78dcd27f962ede8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">支持点和插值</div></td></tr>
<tr class="memitem:a5b35a290aa7dd7562911a92a13b11fee"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">get_unit_support_points</a> () const</td></tr>
<tr class="separator:a5b35a290aa7dd7562911a92a13b11fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f25ecdd4c356032bd44e3e6571d983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a47f25ecdd4c356032bd44e3e6571d983">has_support_points</a> () const</td></tr>
<tr class="separator:a47f25ecdd4c356032bd44e3e6571d983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240719f4c467b178c7dea32040f8015e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a240719f4c467b178c7dea32040f8015e">unit_support_point</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:a240719f4c467b178c7dea32040f8015e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ccbc59eb1eed98078b686568227c98"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a62ccbc59eb1eed98078b686568227c98">get_unit_face_support_points</a> (const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:a62ccbc59eb1eed98078b686568227c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e0ebd1082fd37318aac7c5b69c99ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a40e0ebd1082fd37318aac7c5b69c99ba">has_face_support_points</a> (const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:a40e0ebd1082fd37318aac7c5b69c99ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a38445c29e48889bcca49674f3be92"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a76a38445c29e48889bcca49674f3be92">unit_face_support_point</a> (const unsigned <a class="el" href="classint.html">int</a> index, const unsigned <a class="el" href="classint.html">int</a> face_no=0) const</td></tr>
<tr class="separator:a76a38445c29e48889bcca49674f3be92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7d4db3494e48ce40d49da6f2c7d4b2"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#acd7d4db3494e48ce40d49da6f2c7d4b2">get_generalized_support_points</a> () const</td></tr>
<tr class="separator:acd7d4db3494e48ce40d49da6f2c7d4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7a3e41b44869ce600ae0b3a98b5b4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4d7a3e41b44869ce600ae0b3a98b5b4e">has_generalized_support_points</a> () const</td></tr>
<tr class="separator:a4d7a3e41b44869ce600ae0b3a98b5b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ea3780c7d2e6140141a9afcbc421f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGeometryPrimitive.html">GeometryPrimitive</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae0ea3780c7d2e6140141a9afcbc421f4">get_associated_geometry_primitive</a> (const unsigned <a class="el" href="classint.html">int</a> cell_dof_index) const</td></tr>
<tr class="separator:ae0ea3780c7d2e6140141a9afcbc421f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e71a320cf0c2bcb0d0d9d8447aaa34"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a97e71a320cf0c2bcb0d0d9d8447aaa34">convert_generalized_support_point_values_to_dof_values</a> (const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;support_point_values, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;nodal_values) const</td></tr>
<tr class="separator:a97e71a320cf0c2bcb0d0d9d8447aaa34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad82fdeb0955b7d59f32d5371adaaadbc"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ad82fdeb0955b7d59f32d5371adaaadbc">dofs_per_vertex</a></td></tr>
<tr class="separator:ad82fdeb0955b7d59f32d5371adaaadbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490e2ded19c0a8cad0846e07e57e3e76"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a490e2ded19c0a8cad0846e07e57e3e76">dofs_per_line</a></td></tr>
<tr class="separator:a490e2ded19c0a8cad0846e07e57e3e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ab27b2dfa5520f2aa56f9bb8223878"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a00ab27b2dfa5520f2aa56f9bb8223878">dofs_per_quad</a></td></tr>
<tr class="separator:a00ab27b2dfa5520f2aa56f9bb8223878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9014d27be7564a42c962848db0d2fd75"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a9014d27be7564a42c962848db0d2fd75">dofs_per_hex</a></td></tr>
<tr class="separator:a9014d27be7564a42c962848db0d2fd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c172e26b87c60b3f7e5e3ebf155b62e"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a8c172e26b87c60b3f7e5e3ebf155b62e">first_line_index</a></td></tr>
<tr class="separator:a8c172e26b87c60b3f7e5e3ebf155b62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9fc2a37fc1aa814ac73e93baca4bea"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aca9fc2a37fc1aa814ac73e93baca4bea">first_quad_index</a></td></tr>
<tr class="separator:aca9fc2a37fc1aa814ac73e93baca4bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649a135f376e3fba63ecf08c2b17cc64"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a649a135f376e3fba63ecf08c2b17cc64">first_hex_index</a></td></tr>
<tr class="separator:a649a135f376e3fba63ecf08c2b17cc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cf27d2dabe49e0c1f57954d7d08500"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a70cf27d2dabe49e0c1f57954d7d08500">first_face_line_index</a></td></tr>
<tr class="separator:a70cf27d2dabe49e0c1f57954d7d08500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f85f3eae2daee423441fce5e87fa2e6"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a0f85f3eae2daee423441fce5e87fa2e6">first_face_quad_index</a></td></tr>
<tr class="separator:a0f85f3eae2daee423441fce5e87fa2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358bffed1fba59ef4df715469473fd36"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></td></tr>
<tr class="separator:a358bffed1fba59ef4df715469473fd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fa3b8d578ba488b4f37061bb0278bb"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a></td></tr>
<tr class="separator:ae2fa3b8d578ba488b4f37061bb0278bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccdb4fd2c40a3e3cd92cb0361cddaf8"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a1ccdb4fd2c40a3e3cd92cb0361cddaf8">components</a></td></tr>
<tr class="separator:a1ccdb4fd2c40a3e3cd92cb0361cddaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbf5ad6b464871261dbd054bced18a8"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a></td></tr>
<tr class="separator:a2cbf5ad6b464871261dbd054bced18a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca702ba3af0ed17eaffcfbbccf82067f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#aca702ba3af0ed17eaffcfbbccf82067f">conforming_space</a></td></tr>
<tr class="separator:aca702ba3af0ed17eaffcfbbccf82067f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9346e3aae3032545c8a94b78a365ffcb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#a9346e3aae3032545c8a94b78a365ffcb">block_indices_data</a></td></tr>
<tr class="separator:a9346e3aae3032545c8a94b78a365ffcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a577195e2fad97018b5dccb837952dad7"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a577195e2fad97018b5dccb837952dad7">space_dimension</a> = spacedim</td></tr>
<tr class="separator:a577195e2fad97018b5dccb837952dad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40fa679812dc4fcc76496aa9a139050"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElementData.html#af40fa679812dc4fcc76496aa9a139050">dimension</a> = dim</td></tr>
<tr class="separator:af40fa679812dc4fcc76496aa9a139050"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adbafd47e79bfff9a4d6992cd407b9357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#adbafd47e79bfff9a4d6992cd407b9357">single_mapping_kind</a> () const</td></tr>
<tr class="separator:adbafd47e79bfff9a4d6992cd407b9357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02356fe38fd14f9a169ae99ade355b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#ab02356fe38fd14f9a169ae99ade355b5">adjust_quad_dof_sign_for_face_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> index, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classbool.html">bool</a> face_orientation, const <a class="el" href="classbool.html">bool</a> face_flip, const <a class="el" href="classbool.html">bool</a> face_rotation) const</td></tr>
<tr class="separator:ab02356fe38fd14f9a169ae99ade355b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea9b13e048ed08291ba5a7e948c16a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#acea9b13e048ed08291ba5a7e948c16a8">get_mapping_kind</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:acea9b13e048ed08291ba5a7e948c16a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3120826089c7acfa86648238856fbfe0"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a3120826089c7acfa86648238856fbfe0">get_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a3120826089c7acfa86648238856fbfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39b9d1f49e11622d0adf74d48ebb7a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#ab39b9d1f49e11622d0adf74d48ebb7a7">fill_fe_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:ab39b9d1f49e11622d0adf74d48ebb7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76218870e645f59e07c7ab650cf31a79"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">fill_fe_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const =0</td></tr>
<tr class="separator:a76218870e645f59e07c7ab650cf31a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aae2c752c1773929a57032589040fa5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a7aae2c752c1773929a57032589040fa5">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a7aae2c752c1773929a57032589040fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5fd937dc322e6028f60c30fc65f185"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7c5fd937dc322e6028f60c30fc65f185">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a7c5fd937dc322e6028f60c30fc65f185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd572e784ad8c26c2c41c9fc3ce86ed6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#abd572e784ad8c26c2c41c9fc3ce86ed6">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:abd572e784ad8c26c2c41c9fc3ce86ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0a259d87fb0df0b817c9d0195d8e07"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#ada0a259d87fb0df0b817c9d0195d8e07">fill_fe_subface_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> sub_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:ada0a259d87fb0df0b817c9d0195d8e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7af117168f8d0fdb4bbdd516373625"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ace7af117168f8d0fdb4bbdd516373625">fill_fe_subface_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> sub_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;mapping_internal, const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;mapping_data, const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;fe_internal, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const =0</td></tr>
<tr class="separator:ace7af117168f8d0fdb4bbdd516373625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62838f7428ee56e34c4081ca6d03bc26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a62838f7428ee56e34c4081ca6d03bc26">reinit_restriction_and_prolongation_matrices</a> (const <a class="el" href="classbool.html">bool</a> isotropic_restriction_only=false, const <a class="el" href="classbool.html">bool</a> isotropic_prolongation_only=false)</td></tr>
<tr class="separator:a62838f7428ee56e34c4081ca6d03bc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d72dc54ae8d760b3c9c4e5ce0f96c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableIndices.html">TableIndices</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab1d72dc54ae8d760b3c9c4e5ce0f96c4">interface_constraints_size</a> () const</td></tr>
<tr class="separator:ab1d72dc54ae8d760b3c9c4e5ce0f96c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7236d243e42448327e719a9ea66a81"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0d7236d243e42448327e719a9ea66a81">get_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a0d7236d243e42448327e719a9ea66a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2f79f305092a89472245fb9ee4cdf7"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a7e2f79f305092a89472245fb9ee4cdf7">get_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a7e2f79f305092a89472245fb9ee4cdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d025c0e209ea71e8247eadb5f78b38"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#af8d025c0e209ea71e8247eadb5f78b38">get_subface_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:af8d025c0e209ea71e8247eadb5f78b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ac7b5101c0c081760e5402767aed14c0c"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac7b5101c0c081760e5402767aed14c0c">compute_n_nonzero_components</a> (const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; &amp;<a class="el" href="classFiniteElement.html#ae6fe073d1e3ce59791b142067482bd5b">nonzero_components</a>)</td></tr>
<tr class="separator:ac7b5101c0c081760e5402767aed14c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abeecf4df065ca5f5701ba1190a190631"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#abeecf4df065ca5f5701ba1190a190631">mapping_kind</a></td></tr>
<tr class="separator:abeecf4df065ca5f5701ba1190a190631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20234bd8b6c97e450bb3c0efcd836198"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a20234bd8b6c97e450bb3c0efcd836198">adjust_quad_dof_sign_for_face_orientation_table</a></td></tr>
<tr class="separator:a20234bd8b6c97e450bb3c0efcd836198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45a96809bedb741904aebe616a32ba2"><td class="memItemLeft" align="right" valign="top">const std::unique_ptr&lt; const <a class="el" href="classTensorPolynomialsBase.html">TensorPolynomialsBase</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#ae45a96809bedb741904aebe616a32ba2">poly_space</a></td></tr>
<tr class="separator:ae45a96809bedb741904aebe616a32ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c73bd10d9b2b3c8d11e390c23b1b7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a38c73bd10d9b2b3c8d11e390c23b1b7e">inverse_node_matrix</a></td></tr>
<tr class="separator:a38c73bd10d9b2b3c8d11e390c23b1b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188e364c278533b4b319f702390322fd"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a188e364c278533b4b319f702390322fd">cache_mutex</a></td></tr>
<tr class="separator:a188e364c278533b4b319f702390322fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3728ea2a8d8d8744ebe14bdf6cbb31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a6f3728ea2a8d8d8744ebe14bdf6cbb31">cached_point</a></td></tr>
<tr class="separator:a6f3728ea2a8d8d8744ebe14bdf6cbb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb75d35170b98b1ba99090e566f6c5cd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#adb75d35170b98b1ba99090e566f6c5cd">cached_values</a></td></tr>
<tr class="separator:adb75d35170b98b1ba99090e566f6c5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306eab3ba19d1b62dd82b4126f466d55"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#a306eab3ba19d1b62dd82b4126f466d55">cached_grads</a></td></tr>
<tr class="separator:a306eab3ba19d1b62dd82b4126f466d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14cdfca59390a4e648da7a0c7bee0b7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PolyTensor.html#af14cdfca59390a4e648da7a0c7bee0b7">cached_grad_grads</a></td></tr>
<tr class="separator:af14cdfca59390a4e648da7a0c7bee0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4993707a4ec342560ff74e5d22401794"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">restriction</a></td></tr>
<tr class="separator:a4993707a4ec342560ff74e5d22401794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc42f850096c429fd39cfcbde1b6b56"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">prolongation</a></td></tr>
<tr class="separator:afbc42f850096c429fd39cfcbde1b6b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d4cd5afce6a401892aeb5a40ccfa2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ac8d4cd5afce6a401892aeb5a40ccfa2f">interface_constraints</a></td></tr>
<tr class="separator:ac8d4cd5afce6a401892aeb5a40ccfa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f6e0c83686b918fbb92716ead92313"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab4f6e0c83686b918fbb92716ead92313">unit_support_points</a></td></tr>
<tr class="separator:ab4f6e0c83686b918fbb92716ead92313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cab5fe59b82da1fc25e1454b12c4fa9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a1cab5fe59b82da1fc25e1454b12c4fa9">unit_face_support_points</a></td></tr>
<tr class="separator:a1cab5fe59b82da1fc25e1454b12c4fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2531d00b5c9e77e1e64981864c3b8cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae2531d00b5c9e77e1e64981864c3b8cc">generalized_support_points</a></td></tr>
<tr class="separator:ae2531d00b5c9e77e1e64981864c3b8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646b0f9a97e1df8fc14f9305149ed525"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a646b0f9a97e1df8fc14f9305149ed525">generalized_face_support_points</a></td></tr>
<tr class="separator:a646b0f9a97e1df8fc14f9305149ed525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5592f17f6c16d325de2d30f1cc051eeb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a5592f17f6c16d325de2d30f1cc051eeb">adjust_quad_dof_index_for_face_orientation_table</a></td></tr>
<tr class="separator:a5592f17f6c16d325de2d30f1cc051eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6659bb0dccc62e2d680c964e5035daf6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a6659bb0dccc62e2d680c964e5035daf6">adjust_line_dof_index_for_line_orientation_table</a></td></tr>
<tr class="separator:a6659bb0dccc62e2d680c964e5035daf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af218ae93821b61054de7e88e1734aa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a9af218ae93821b61054de7e88e1734aa">system_to_component_table</a></td></tr>
<tr class="separator:a9af218ae93821b61054de7e88e1734aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc61022ae105ef061458aa5f2d573055"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#abc61022ae105ef061458aa5f2d573055">face_system_to_component_table</a></td></tr>
<tr class="separator:abc61022ae105ef061458aa5f2d573055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870f688170ad210708077eed94642d73"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a870f688170ad210708077eed94642d73">system_to_base_table</a></td></tr>
<tr class="separator:a870f688170ad210708077eed94642d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e6a76c64f925c81561745fd6bc12c3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ab4e6a76c64f925c81561745fd6bc12c3">face_system_to_base_table</a></td></tr>
<tr class="separator:ab4e6a76c64f925c81561745fd6bc12c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f62f39ded99d6525f1c33f4227ee8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a61f62f39ded99d6525f1c33f4227ee8d">base_to_block_indices</a></td></tr>
<tr class="separator:a61f62f39ded99d6525f1c33f4227ee8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2c44f3a207e0e11880820a29ac37a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aaf2c44f3a207e0e11880820a29ac37a8">component_to_base_table</a></td></tr>
<tr class="separator:aaf2c44f3a207e0e11880820a29ac37a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f4833a318127b42d2dc806bffe1c2c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#aa8f4833a318127b42d2dc806bffe1c2c">restriction_is_additive_flags</a></td></tr>
<tr class="separator:aa8f4833a318127b42d2dc806bffe1c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fe073d1e3ce59791b142067482bd5b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#ae6fe073d1e3ce59791b142067482bd5b">nonzero_components</a></td></tr>
<tr class="separator:ae6fe073d1e3ce59791b142067482bd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7cb6ef5342900727931ef983636502"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a0b7cb6ef5342900727931ef983636502">n_nonzero_components_table</a></td></tr>
<tr class="separator:a0b7cb6ef5342900727931ef983636502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4124079b6443590608046d8f150574f6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiniteElement.html#a4124079b6443590608046d8f150574f6">cached_primitivity</a></td></tr>
<tr class="separator:a4124079b6443590608046d8f150574f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class FE_DGBDM&lt; dim, spacedim &gt;</h3>

<p>一个基于FE_BDM的多项式空间的矢量值DG元素。该类实现了一个 "破碎的
"有限元空间，在单元之间是不连续的，在每个单元上的形状函数与BDM元素相同。 相关的类FE_DGRT用于 <a class="el" href="step_61.html">step-61</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="fe__dg__vector_8h_source.html#l00196">196</a> of file <a class="el" href="fe__dg__vector_8h_source.html">fe_dg_vector.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a0cd5f34c3ab828fac31004f3b52921a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd5f34c3ab828fac31004f3b52921a1">&#9670;&nbsp;</a></span>Conformity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">FiniteElementData::Conformity</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个有限元可能具有的不同类型的连续性的枚举器。连续性是由包含构建的有限元空间的Sobolev空间来衡量的，也这样称呼。 请注意，某些连续性可能意味着其他连续性。例如，<em>H<sup>1</sup></em>中的函数在<em>H<sup>curl</sup></em>和<em>H<sup>div</sup></em>中也是如此。 如果你对经典意义上的连续性感兴趣，那么以下关系是成立的。 </p><ol>
<li>
<em>H<sup>1</sup></em>意味着该函数在单元格边界上是连续的。 </li>
<li>
<em>H<sup>2</sup></em>意味着该函数在单元格边界上是连续可微的。 </li>
<li>
<em>L<sup>2</sup></em> 表示该元素是不连续的。 由于不连续元素在网格单元之间没有拓扑耦合，代码实际上可能取决于这一属性，<em>L<sup>2</sup></em>符合性以特殊方式处理，即它是<b>not</b>由任何更高符合性所暗示的。 </li>
</ol>
<p>为了测试一个有限元是否符合某个空间，使用 <a class="el" href="classFiniteElementData.html#a18e928460be93a004559b841f35ad698">FiniteElementData&lt;dim&gt;::conforms()</a>. 。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0cd5f34c3ab828fac31004f3b52921a1afbb5ba93aed087d17dd0224e65a1bddc"></a>unknown&#160;</td><td class="fielddoc"><p>表示一个系统的不兼容的连续性。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a0cd5f34c3ab828fac31004f3b52921a1a349c581c3d0e392c33cc41d917eb038c"></a>L2&#160;</td><td class="fielddoc"><p>不连续的元素。见上文! </p>
</td></tr>
<tr><td class="fieldname"><a id="a0cd5f34c3ab828fac31004f3b52921a1a0787dd9aa05e57e4e6009dd73cb1d229"></a>Hcurl&#160;</td><td class="fielddoc"><p>与空间的一致性 <em>H<sup>curl</sup></em>（矢量场的连续切向分量）。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a0cd5f34c3ab828fac31004f3b52921a1a11a375871bcf4978f67ff6d7435f81ee"></a>Hdiv&#160;</td><td class="fielddoc"><p>与空间<em>H<sup>div</sup></em>（矢量场的连续法向分量）的符合性 </p>
</td></tr>
<tr><td class="fieldname"><a id="a0cd5f34c3ab828fac31004f3b52921a1a0e986c9c300b61774d25c92ae2a9d054"></a>H1&#160;</td><td class="fielddoc"><p>与空间<em>H<sup>1</sup></em>的符合性（连续）。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a0cd5f34c3ab828fac31004f3b52921a1a916ecb570449b2ad08281d708b39bae2"></a>H2&#160;</td><td class="fielddoc"><p>与空间<em>H<sup>2</sup></em>的符合性（连续可微）。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00175">175</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afa294f4c49161d9db8e5301c5e3e1458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa294f4c49161d9db8e5301c5e3e1458">&#9670;&nbsp;</a></span>FE_DGBDM()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFE__DGBDM.html">FE_DGBDM</a>&lt; dim, spacedim &gt;::<a class="el" href="classFE__DGBDM.html">FE_DGBDM</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>度的不连续BDM元素的构造函数 <code>p</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="fe__dg__vector_8cc_source.html#l00080">80</a> of file <a class="el" href="fe__dg__vector_8cc_source.html">fe_dg_vector.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a78cdb625c5bc57ffff2dc98f04137fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78cdb625c5bc57ffff2dc98f04137fb8">&#9670;&nbsp;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classFE__DGBDM.html">FE_DGBDM</a>&lt; dim, spacedim &gt;::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个唯一标识有限元的字符串。该类返回<code>FE_DGBDM&lt;dim&gt;(degree)</code>，其中 <code>dim</code> 和 <code>degree</code> 由适当的值代替。 </p>

<p>Reimplemented from <a class="el" href="classFE__DGVector.html#a14525444fb5700986552bae390345880">FE_DGVector&lt; PolynomialsBDM&lt; dim &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe__dg__vector_8cc_source.html#l00087">87</a> of file <a class="el" href="fe__dg__vector_8cc_source.html">fe_dg_vector.cc</a>.</p>

</div>
</div>
<a id="a3e25f164fd98df828a00b9e488c37cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e25f164fd98df828a00b9e488c37cb6">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classFE__DGVector.html">FE_DGVector</a>&lt; <a class="el" href="classPolynomialsBDM.html">PolynomialsBDM</a>&lt; dim &gt; , dim, spacedim &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一种虚拟的拷贝构造函数，该函数返回有限元对象的拷贝。派生类需要在这个基类中覆盖这里的函数，并返回一个与派生类相同类型的对象。 库中的一些地方，例如FESystem以及 <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> 类的构造函数，需要在不知道其确切类型的情况下对有限元进行复制。他们通过这个函数来做。 </p>

<p>Implements <a class="el" href="classFiniteElement.html#a63dfa09878be59ca47a2fc33206a53c6">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a1c9f11c1bb7778b0384867a3b1ca4d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9f11c1bb7778b0384867a3b1ca4d19">&#9670;&nbsp;</a></span>has_support_on_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classFE__DGVector.html">FE_DGVector</a>&lt; <a class="el" href="classPolynomialsBDM.html">PolynomialsBDM</a>&lt; dim &gt; , dim, spacedim &gt;::has_support_on_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>shape_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果形状函数 <code>shape_index</code> 在面的某处有非零函数值，这个函数就会返回 <code>true</code>, 对于这个元素，我们总是返回 <code>true</code>. 。 </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="afcdf31566f4c83b3910e5323f0a40dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdf31566f4c83b3910e5323f0a40dd9">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classFE__DGVector.html">FE_DGVector</a>&lt; <a class="el" href="classPolynomialsBDM.html">PolynomialsBDM</a>&lt; dim &gt; , dim, spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>确定这个对象的内存消耗（以字节为单位）的估计值。 这个函数是虚拟的，因为有限元对象通常是通过指向其基类的指针来访问的，而不是类本身。 </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#a5d91517978ab8b107c6951cc4c63c10f">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ae4d612e33a3521245d3622bf086975e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d612e33a3521245d3622bf086975e8">&#9670;&nbsp;</a></span>requires_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::requires_update_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定一组更新标志，计算哪些其他数量<em>also</em>需要被计算以满足给定标志的请求。 然后返回原始标志集和刚刚计算的标志的组合。 例如，如果 <code>update_flags</code> 包含update_gradients，一个有限元类通常需要计算雅各布矩阵的逆值，以便将参考单元上的形状函数的梯度旋转到实际单元上。然后，它不仅会返回update_gradients，还会返回update_covariant_transformation，这个标志使映射类产生雅各布矩阵的逆。 关于这个函数和FEValues之间互动的广泛讨论可以在 <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and</a> 文档模块中找到。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> </dd></dl>

<p>Implements <a class="el" href="classFiniteElement.html#a7ee9f47da3fcdfc8c1ca7c7a0feb1929">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8cc_source.html#l02402">2402</a> of file <a class="el" href="fe__poly__tensor_8cc_source.html">fe_poly_tensor.cc</a>.</p>

</div>
</div>
<a id="a8b5c7a79b81e77b1e78b99e548318370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5c7a79b81e77b1e78b99e548318370">&#9670;&nbsp;</a></span>shape_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::shape_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算形状函数 <code>i</code> 在给定正交点 <code>p</code>. 的（标量）值。 </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#a9889833bef170393b1281a1418596d70">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8cc_source.html#l00279">279</a> of file <a class="el" href="fe__poly__tensor_8cc_source.html">fe_poly_tensor.cc</a>.</p>

</div>
</div>
<a id="af8bd508748b8aa53dcb079604b438f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bd508748b8aa53dcb079604b438f85">&#9670;&nbsp;</a></span>shape_value_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::shape_value_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>就像shape_value()一样，但是当形状函数有一个以上的非零向量分量时，这个函数将被调用。在这种情况下，这个函数应该返回 <code>component-th</code> 形状函数在 <code>p</code>. 点的 <code>ith</code> 向量分量的值。 </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#a247fccbd72723a07fc8c17ac093d3156">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8cc_source.html#l00291">291</a> of file <a class="el" href="fe__poly__tensor_8cc_source.html">fe_poly_tensor.cc</a>.</p>

</div>
</div>
<a id="a928b72c168c5cdf1c0b9095160459999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928b72c168c5cdf1c0b9095160459999">&#9670;&nbsp;</a></span>shape_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::shape_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算（标量）形状函数 <code>i</code> 在给定正交点的梯度 <code>p</code>. 由于该类代表的元素是矢量值，没有这样的标量值，因此该函数抛出了一个异常。 </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#aaaafefdf45fc2a5e7db18acb64063f5d">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8cc_source.html#l00325">325</a> of file <a class="el" href="fe__poly__tensor_8cc_source.html">fe_poly_tensor.cc</a>.</p>

</div>
</div>
<a id="a077b899f9ed0cd4d0b51f7f2e2d85f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077b899f9ed0cd4d0b51f7f2e2d85f2c">&#9670;&nbsp;</a></span>shape_grad_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::shape_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>就像shape_grad()一样，但是当形状函数有一个以上的非零向量分量时，这个函数将被调用。在这种情况下，这个函数应该返回 <code>component-th</code> 形状函数的 <code>ith</code> 向量分量在 <code>p</code>. 点的梯度。 </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#a7f026ed19fcc589476f11d69de4a3419">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8cc_source.html#l00336">336</a> of file <a class="el" href="fe__poly__tensor_8cc_source.html">fe_poly_tensor.cc</a>.</p>

</div>
</div>
<a id="ac2c753175396d250d063f035eb3ec19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c753175396d250d063f035eb3ec19e">&#9670;&nbsp;</a></span>shape_grad_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::shape_grad_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算（标量）形状函数 <code>i</code> 在给定正交点的Hessian <code>p</code>. 由于该类所代表的元素是矢量值，没有这样的标量值，因此该函数抛出一个异常。 </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#af9735ea35b55b66b069cece0d5c55e9d">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8cc_source.html#l00371">371</a> of file <a class="el" href="fe__poly__tensor_8cc_source.html">fe_poly_tensor.cc</a>.</p>

</div>
</div>
<a id="ac74023d8ecb4c4757a86a8448f016dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74023d8ecb4c4757a86a8448f016dac">&#9670;&nbsp;</a></span>shape_grad_grad_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::shape_grad_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>就像shape_grad_grad()一样，但是当形状函数有一个以上的非零向量分量时，这个函数将被调用。在这种情况下，这个函数应该返回 <code>component-th</code> 形状函数的 <code>ith</code> 向量分量在 <code>p</code>. 点的梯度。 </p>

<p>Reimplemented from <a class="el" href="classFiniteElement.html#a78d74d669ee2e15eedea95d75889b9e3">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8cc_source.html#l00382">382</a> of file <a class="el" href="fe__poly__tensor_8cc_source.html">fe_poly_tensor.cc</a>.</p>

</div>
</div>
<a id="adbafd47e79bfff9a4d6992cd407b9357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbafd47e79bfff9a4d6992cd407b9357">&#9670;&nbsp;</a></span>single_mapping_kind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::single_mapping_kind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个布尔值，当有限元使用单一映射时为真，当有限元使用多个映射时为假。 </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8cc_source.html#l00222">222</a> of file <a class="el" href="fe__poly__tensor_8cc_source.html">fe_poly_tensor.cc</a>.</p>

</div>
</div>
<a id="ab02356fe38fd14f9a169ae99ade355b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02356fe38fd14f9a169ae99ade355b5">&#9670;&nbsp;</a></span>adjust_quad_dof_sign_for_face_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::adjust_quad_dof_sign_for_face_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于三维中非标准面的方向，面（四边形）上的道夫必须被置换，以便与正确的形状函数相结合，另外还可以改变符号。给定一个四边形上的局部dof <code>index</code> ，如果该面有非标准的面朝向、面朝上或面朝下的旋转，则返回经过处理的形状函数的符号。在二维和一维中，没有必要进行包络，因此在这种情况下它没有任何作用。 permutation本身由界面类FiniteElement&lt;dim&gt;中实现的adjust_quad_dof_index_for_face_orientation返回。 </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8cc_source.html#l00230">230</a> of file <a class="el" href="fe__poly__tensor_8cc_source.html">fe_poly_tensor.cc</a>.</p>

</div>
</div>
<a id="acea9b13e048ed08291ba5a7e948c16a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea9b13e048ed08291ba5a7e948c16a8">&#9670;&nbsp;</a></span>get_mapping_kind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::get_mapping_kind </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回有限元的MappingKind <code>i</code> 。 </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8cc_source.html#l00266">266</a> of file <a class="el" href="fe__poly__tensor_8cc_source.html">fe_poly_tensor.cc</a>.</p>

</div>
</div>
<a id="a3120826089c7acfa86648238856fbfe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3120826089c7acfa86648238856fbfe0">&#9670;&nbsp;</a></span>get_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::get_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建一个内部数据对象，并返回一个指针，然后该函数的调用者将拥有该指针的所有权。然后，每次在具体单元上评估有限元形状函数及其导数时，这个对象将被传递给 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> 。因此，这里创建的对象被派生类用作评估形状函数时的抓取对象，以及存储可以预先计算一次并在每个单元上重复使用的信息（例如，在参考单元上评估形状函数的值和梯度，以便以后在将这些值转换到具体单元时重复使用）。 在为给定的映射和有限元对象初始化FEValues对象的过程中，这个函数是第一个被调用的。返回的对象随后将被传递给 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> 的具体单元，它本身将把其输出放到 <a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>. 类型的对象中。由于可能有数据已经可以在参考单元上以其<em>final</em>的形式计算，这个函数也接收对 <a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a> 对象的引用作为其最后参数。当与该函数返回的InternalDataBase对象一起使用时，这个输出参数保证总是同一个参数。换句话说，在返回的对象和 <code>output_data</code> 对象中，从头数据和最终数据的细分是如下的。如果数据可以在参考单元上以以后在具体单元上需要的确切形式预先计算出来，那么这个函数应该已经把它放到了 <code>output_data</code> 对象中。一个例子是通常拉格朗日元素的正交点的形状函数值，它在具体单元上与参考单元上的相同。另一方面，如果某些数据可以预先计算，以便在具体单元上进行计算<em>cheaper</em>，那么它应该被放入返回的对象中，以便以后在派生类的实现中重新使用 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a>. ] 一个例子是拉格朗日元素的形状函数在参考单元上的梯度：为了计算形状函数在具体单元上的梯度，我们必须将参考单元上的梯度乘以映射的雅各布反值；因此，我们不能在调用当前函数时已经计算出具体单元上的梯度，但我们至少可以预先计算出参考单元上的梯度，并将其保存在返回的对象中。 关于这个函数和 <a class="el" href="classFEValues.html">FEValues</a> 之间的互动的广泛讨论可以在 <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and</a> 文档模块中找到。也请参见InternalDataBase类的文档。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">update_flags</td><td>一组UpdateFlags值，描述FEValues对象要求有限元计算哪种信息。这组标志也可以包括有限元不能计算的信息，例如，与映射产生的数据有关的标志。这个函数的实现需要在返回的对象中设置所有的数据字段，这些字段是产生这些标志所指定的有限元相关数据所必需的，并且可能已经预先计算了这些信息的一部分，如上文所述。元素可能希望在 <a class="el" href="classFiniteElement_1_1InternalDataBase.html#a99c4ead335ec713b3f9b3cdc8b5a1f40">InternalDataBase::update_each</a> 中存储这些更新标志（或这些标志的子集），以便在 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> 被调用时知道他们应该计算什么 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">映射</td><td>对用于计算形状函数值和导数的映射的引用。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">正交</td><td>对描述形状函数应被评估的对象的引用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>对对象的引用，FEValues将与这里返回的对象一起使用， <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> 的实现将在这里放置所需的信息。 这允许当前函数已经预先计算了可以在参考单元上计算的信息，如上所述。FEValues保证这个输出对象和当前函数返回的对象将总是一起使用。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个指向从InternalDataBase派生的类型的对象的指针，派生类可以用它来存储可以预先计算的抓取数据，或者用于抓取数组，然后只需要分配一次。 调用网站承担这个对象的所有权，并在不再需要时将其删除。 </dd></dl>

<p>Implements <a class="el" href="classFiniteElement.html#a83c2e3851e02752d6b241fd402cc0bcd">FiniteElement&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00214">214</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="ab39b9d1f49e11622d0adf74d48ebb7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39b9d1f49e11622d0adf74d48ebb7a7">&#9670;&nbsp;</a></span>fill_fe_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8cc_source.html#l00420">420</a> of file <a class="el" href="fe__poly__tensor_8cc_source.html">fe_poly_tensor.cc</a>.</p>

</div>
</div>
<a id="a76218870e645f59e07c7ab650cf31a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76218870e645f59e07c7ab650cf31a79">&#9670;&nbsp;</a></span>fill_fe_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算由第一个参数表示的单元上的形状函数信息。派生类将不得不根据它们所代表的元素种类来实现这个函数。它是由 <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a>. 调用的。从概念上讲，这个函数在由这个函数的正交参数所描述的那些正交点的映射位置上评估形状函数及其导数。在许多情况下，计算形状函数的导数（在某些情况下也计算形状函数的值）需要利用从参考单元到实际单元的映射；这一信息可以从调用此函数之前为当前单元填充的 <code>mapping_data</code> 对象中获取，或者通过调用与当前单元对应的 <code>mapping_internal</code> 对象的Mapping对象的成员函数。 这个函数计算出来的信息被用来填充这个函数的输出参数的各种成员变量。该结构中的哪些成员变量应该被填充，由存储在传递给该函数的对象的 <a class="el" href="classFiniteElement_1_1InternalDataBase.html#a99c4ead335ec713b3f9b3cdc8b5a1f40">FiniteElement::InternalDataBase::update_each</a> 字段中的更新标志决定。这些标志通常由 <a class="el" href="classFiniteElement.html#a83c2e3851e02752d6b241fd402cc0bcd">FiniteElement::get_data()</a>, FiniteElement::get_face_date() 和 <a class="el" href="classFiniteElement.html#af8d025c0e209ea71e8247eadb5f78b38">FiniteElement::get_subface_data()</a> （或者更具体地说，这些函数在派生类中的实现）设置。 关于这个函数和FEValues之间的互动的广泛讨论可以在 <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and</a> 文档模块中找到。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>三角形中的单元格，该函数要计算从参考单元格到三角形的映射。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_similarity</td><td>作为第一个参数的单元格是否是最近一次调用此函数的单元格的简单翻译、旋转等。这个信息是通过匹配前一个单元和当前单元之间的顶点（由三角结构存储）简单计算出来的。这里传递的值可能被这个函数的实现所修改，然后应该被返回（见关于这个函数的返回值的讨论）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>对当前评估中使用的正交公式的引用。这个正交对象与创建 <code>internal_data</code> 对象时使用的对象相同。然后，当前对象负责在此对象所代表的正交点的映射位置评估形状函数。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>对用于从参考单元映射到当前单元的映射对象的引用。在调用当前函数之前，这个对象被用来计算 <code>mapping_data</code> 对象中的信息。它也是通过 <a class="el" href="classMapping.html#a2fdce92a1ba733f9652de666d3475a34">Mapping::get_data()</a>. 创建 <code>mapping_internal对象的映射对象。你最需要对这个映射对象的引用来调用</code> <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping::transform()</a> ，将梯度和高导数从参考单元转换到当前单元。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_internal</td><td>一个特定于映射对象的对象。 映射选择在其中存储的内容与当前函数无关，但你可能必须将这个对象的引用传递给映射类的某些函数（例如，如果你需要从当前函数中调用它们，那么 <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping::transform()</a>) 。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_data</td><td><a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a> 函数将对应于当前单元格的映射信息写入的输出对象。这包括，例如，可能与当前函数相关的映射的Jacobian，以及 <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> 从映射中要求的其他信息。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_internal</td><td>一个对先前由get_data()创建的对象的引用，可用于存储映射在参考单元上可以计算的一次信息。参见 <a class="el" href="classFiniteElement_1_1InternalDataBase.html">FiniteElement::InternalDataBase</a> 类的文档，以了解对这些对象的用途的广泛描述。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>对成员变量应被计算的对象的引用。并非所有这个参数的成员都需要被填充；哪些成员需要被填充是由存储在 <code>fe_internal</code> 对象中的更新标志决定的。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>FEValues确保这个函数总是用同一对 <code>fe_internal</code> 和 <code>output_data</code> 对象调用。换句话说，如果这个函数的实现知道它在之前的调用中已经把一个数据写入了输出参数，那么在以后的调用中，如果实现知道这是同一个值，就没有必要再把它复制到那里。 </dd></dl>

</div>
</div>
<a id="a7aae2c752c1773929a57032589040fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aae2c752c1773929a57032589040fa5">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8cc_source.html#l01043">1043</a> of file <a class="el" href="fe__poly__tensor_8cc_source.html">fe_poly_tensor.cc</a>.</p>

</div>
</div>
<a id="a7c5fd937dc322e6028f60c30fc65f185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5fd937dc322e6028f60c30fc65f185">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数等同于 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a>, ，但用于单元格的面。关于其目的的广泛讨论见那里。 它被 <a class="el" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">FEFaceValues::reinit()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">单元格所调用，该函数要计算从参考单元格到的映射的三角形单元格。</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>我们当前考虑的面的编号，在前一个参数所指定的单元格的面中索引。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>对当前评估中使用的正交公式的引用。这个正交对象与创建 <code>internal_data</code> 对象时使用的对象相同。然后，当前对象负责在此对象所代表的正交点的映射位置评估形状函数。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>对用于从参考单元映射到当前单元的映射对象的引用。在调用当前函数之前，该对象被用来计算 <code>mapping_data</code> 对象中的信息。它也是通过 <a class="el" href="classMapping.html#a2fdce92a1ba733f9652de666d3475a34">Mapping::get_data()</a>. 创建 <code>mapping_internal对象的映射对象。你最需要对这个映射对象的引用来调用</code> <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping::transform()</a> ，将梯度和高导数从参考单元转换到当前单元。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_internal</td><td>一个特定于映射对象的对象。 映射选择在其中存储什么与当前函数无关，但你可能必须将这个对象的引用传递给映射类的某些函数（例如， <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping::transform()</a>) 如果你需要从当前函数中调用它们。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_data</td><td><a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a> 函数将对应于当前单元的映射信息写入的输出对象。这包括，例如，可能与当前函数相关的映射的雅各布，以及 <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> 从映射中要求的其他信息。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_internal</td><td>一个对先前由get_data()创建的对象的引用，可用于存储映射在参考单元上可以计算的信息。参见 <a class="el" href="classFiniteElement_1_1InternalDataBase.html">FiniteElement::InternalDataBase</a> 类的文档，了解这些对象的用途的广泛描述。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>对成员变量应被计算的对象的引用。并非所有这个参数的成员都需要被填充；哪些成员需要被填充是由存储在 <code>fe_internal</code> 对象内的更新标志决定的。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd572e784ad8c26c2c41c9fc3ce86ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd572e784ad8c26c2c41c9fc3ce86ed6">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>使用带有 <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> 参数的版本。</dd></dl>

</div>
</div>
<a id="ada0a259d87fb0df0b817c9d0195d8e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0a259d87fb0df0b817c9d0195d8e07">&#9670;&nbsp;</a></span>fill_fe_subface_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>sub_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8cc_source.html#l01728">1728</a> of file <a class="el" href="fe__poly__tensor_8cc_source.html">fe_poly_tensor.cc</a>.</p>

</div>
</div>
<a id="ace7af117168f8d0fdb4bbdd516373625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7af117168f8d0fdb4bbdd516373625">&#9670;&nbsp;</a></span>fill_fe_subface_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>sub_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数等同于 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a>, ，但用于单元格面的子代。关于其目的的广泛讨论见那里。它被 <a class="el" href="classFESubfaceValues.html#a341778d1291f936d5192a39f2531472a">FESubfaceValues::reinit()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">单元格所调用，该函数要为其计算从参考单元格到的映射。</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>我们当前考虑的面的编号，在前一个参数所指定的单元格的面中索引。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_no</td><td>我们当前考虑的子面的编号，即一个面的子的编号，在前面参数指定的面的子中索引。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>对当前评估中使用的正交公式的引用。这个正交对象与创建 <code>internal_data</code> 对象时使用的对象相同。然后，当前对象负责在此对象所代表的正交点的映射位置评估形状函数。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>对用于从参考单元映射到当前单元的映射对象的引用。在调用当前函数之前，这个对象被用来计算 <code>mapping_data</code> 对象中的信息。它也是通过 <a class="el" href="classMapping.html#a2fdce92a1ba733f9652de666d3475a34">Mapping::get_data()</a>. 创建 <code>mapping_internal对象的映射对象。你最需要这个映射对象的引用来调用</code> <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping::transform()</a> ，将梯度和高导数从参考单元转换到当前单元。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_internal</td><td>一个特定于映射对象的对象。 映射选择在其中存储什么与当前函数无关，但你可能必须将这个对象的引用传递给映射类的某些函数（例如， <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping::transform()</a>) 如果你需要从当前函数中调用它们。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_data</td><td><a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a> 函数将对应于当前单元格的映射信息写入的输出对象。这包括，例如，可能与当前函数相关的映射的Jacobians，以及 <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> 从映射中要求的其他信息。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_internal</td><td>一个对先前由get_data()创建的对象的引用，可用于存储映射在参考单元上可以计算的一次信息。参见 <a class="el" href="classFiniteElement_1_1InternalDataBase.html">FiniteElement::InternalDataBase</a> 类的文档，了解这些对象的用途的广泛描述。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>对成员变量应被计算的对象的引用。并非所有这个参数的成员都需要被填充；哪些成员需要被填充是由存储在 <code>fe_internal</code> 对象内的更新标志决定的。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0833eb3ee7cbff916b3d8f3e7558501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0833eb3ee7cbff916b3d8f3e7558501">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::operator^ </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>multiplicity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建以该类为基础元素的FESystem的信息，并且具有多重性 <code>multiplicity</code>. 特别是，这个函数的返回类型可以用于FESystem对象的构造函数中。 这个函数调用clone()，因此创建了一个当前对象的副本。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00177">177</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a623b0c5a085bc13c826f3d78459a407f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623b0c5a085bc13c826f3d78459a407f">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果给定的参数等于零，该操作符返回对当前对象的引用。虽然这看起来不是特别有用，但在编写与::DoFHandler和hp-版本 <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a>, 一起工作的代码时，它是有帮助的，因为这样就可以写出这样的代码。 </p><div class="fragment"><div class="line"><a class="code" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a> =</div><div class="line">dof_handler-&gt;get_fe()[cell-&gt;active_fe_index()].n_dofs_per_cell();</div></div><!-- fragment --><p> 这段代码在这两种情况下都不能用，因为 <a class="el" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">DoFHandler::get_fe()</a> 返回一个有限元，而 hp::DoFHandler::get_fe() 返回一个有限元的集合，不提供 <code>dofs_per_cell</code> 成员变量：人们首先要选择对哪个有限元进行处理，这是用操作符[]来完成。幸运的是， <code>cell-&gt;active_fe_index()</code> 也适用于非hp类，在这种情况下只需返回0。本操作符[]接受这个零参数，返回其集合中索引为零的有限元（当然，无论如何，它只由本有限元组成）。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>随着 DoFHandler::get_fe(int) 和 <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> 类的废弃，这个操作符不再有任何用途。</dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02484">2484</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="af9716de0908601e453e0b56935280eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9716de0908601e453e0b56935280eb3">&#9670;&nbsp;</a></span>shape_3rd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 <code>ith</code> 形状函数在单元格上 <code>p</code> 点的三阶导数的张量。该导数是单元格上相对于单元格坐标的导数。如果有限元是矢量值的，那么返回这个形状函数的矢量值的唯一非零分量的值。如果形状函数有一个以上的非零分量（我们用非基元一词来指代），那么实现这个函数的派生类应该抛出一个ExcShapeFunctionNotPrimitive类型的异常。在这种情况下，请使用 <a class="el" href="classFiniteElement.html#a4bc9c5e6fff74957e68a7dc40ce9001c">shape_3rd_derivative_component()</a> 函数。 如果所考虑的FiniteElement的形状函数取决于实空间中的单元的形状，也就是说，如果形状函数不是通过从参考单元的映射来定义的，那么这个函数的实现应该抛出一个ExcUnitShapeValuesDoNotExist类型的异常。一些不符合要求的元素就是这样定义的，FE_DGPNonparametric类就是如此，这只是一个例子。 这个虚拟函数的默认实现正是这样做的，也就是说，它只是抛出一个ExcUnitShapeValuesDoNotExist类型的异常。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#ad795407bb8ed6a584a63102e5c415060">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#aa59119ad4067e65e27c7889266dd43a6">FE_Poly&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#aa59119ad4067e65e27c7889266dd43a6">FE_Poly&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00256">256</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a4bc9c5e6fff74957e68a7dc40ce9001c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc9c5e6fff74957e68a7dc40ce9001c">&#9670;&nbsp;</a></span>shape_3rd_derivative_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_3rd_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>就像shape_3rd_derivative()一样，但这个函数将在形状函数有一个以上的非零矢量分量时被调用。在这种情况下，这个函数应该返回 <code>component-</code> 形状函数的第 <code>ith</code> 个向量分量在点 <code>p</code>. 的梯度。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#af4259713fa38075409d422d0080d16f9">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#aa258a0a78360027cf8bddea4ceb3cbd1">FE_Poly&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#aa258a0a78360027cf8bddea4ceb3cbd1">FE_Poly&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00267">267</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="afca1cc51c17eefe7ae1b22d40739bb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca1cc51c17eefe7ae1b22d40739bb5b">&#9670;&nbsp;</a></span>shape_4th_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_4th_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 <code>ith</code> 形状函数在单元格上 <code>p</code> 点的第四导数的张量。该导数是单元格上相对于单元格坐标的导数。如果有限元是矢量值的，那么返回这个形状函数的矢量值的唯一非零分量的值。如果形状函数有一个以上的非零分量（我们用非基元一词来指代），那么实现这个函数的派生类应该抛出一个ExcShapeFunctionNotPrimitive类型的异常。在这种情况下，请使用 <a class="el" href="classFiniteElement.html#a25664d01bbe39b68056379410dd916ab">shape_4th_derivative_component()</a> 函数。 如果所考虑的FiniteElement的形状函数取决于实空间中的单元的形状，也就是说，如果形状函数不是通过从参考单元的映射来定义的，那么这个函数的实现应该抛出一个ExcUnitShapeValuesDoNotExist类型的异常。一些不符合要求的元素就是这样定义的，FE_DGPNonparametric类就是如此，这只是一个例子。 这个虚拟函数的默认实现正是这样做的，也就是说，它只是抛出一个ExcUnitShapeValuesDoNotExist类型的异常。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a50b440758f45da4842b77a81a56e4b3d">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#aa4d2a9a7e2db3544f8f78b6815ab6f63">FE_Poly&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#aa4d2a9a7e2db3544f8f78b6815ab6f63">FE_Poly&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00280">280</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a25664d01bbe39b68056379410dd916ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25664d01bbe39b68056379410dd916ab">&#9670;&nbsp;</a></span>shape_4th_derivative_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 4, dim &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::shape_4th_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>就像shape_4th_derivative()一样，但这个函数将在形状函数有一个以上的非零向量分量时被调用。在这种情况下，这个函数应该返回 <code>component-</code> 形状函数的第 <code>ith</code> 个向量分量在 <code>p</code>. 点的梯度。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#aa1483d485cefac01d5346d3025954360">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Poly.html#a00f27b44c9f21097d7549931d4442ec4">FE_Poly&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Poly.html#a00f27b44c9f21097d7549931d4442ec4">FE_Poly&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00291">291</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a9fbcedd86a33fd947de495e7bf6923dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbcedd86a33fd947de495e7bf6923dd">&#9670;&nbsp;</a></span>get_restriction_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_restriction_matrix </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回描述从给定的 <code>child</code> （由给定的 <code>refinement_case</code>) 获得的有限元场到父单元的限制矩阵。返回的矩阵的解释取决于limittion_is_additive()为每个形状函数返回的内容。 行和列指数分别与粗网格和细网格空间相关，与相关运算符的定义一致。 如果投影矩阵没有在派生的有限元类中实现，这个函数会以 FiniteElement::ExcProjectionVoid. 类型的异常中止，你可以通过首先调用restriction_is_implemented()或isotropic_restriction_is_implemented()函数检查是否会发生这种情况。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a28477b6f49b26d5bc6a289e814211840">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#aad3fd5f26f00c29b8affb348336c684f">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a835e06ba03fbb0ddf048e9f0c2d5a2cf">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#a885b0af32db948d130e5655d4559feef">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#a2a96ec920c314042dbc78dee1bb7678c">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a47a74b08383c427f424c3b19a8d083ea">FE_Q_Base&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexPoly.html#a4bab884675ccc2e4bed4a34b324a6db6">FE_SimplexPoly&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Bernstein.html#ad881d4e04f5e699e4a8bda5b4e9f5265">FE_Bernstein&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00335">335</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a3a4671144d9976b133c4f79c9aefdd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4671144d9976b133c4f79c9aefdd7c">&#9670;&nbsp;</a></span>get_prolongation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_prolongation_matrix </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>网格间的延长/嵌入矩阵。 从粗网格空间到细网格空间（这两个空间都被识别为定义在父单元和子单元上的函数）的身份运算符与一个矩阵 <code>P</code> 相关联，该矩阵以其节点值映射这些函数的相应表示。这里返回该矩阵 <code>P_i</code> 对单个子单元的限制。 矩阵 <code>P</code> 是串联的，而不是单元格矩阵 <code>P_i的总和。也就是说，如果同一个非零条目<code>j</code>,k</code>存在于两个不同的子矩阵 <code>P_i</code>, 中，该值在两个矩阵中应该是相同的，它只被复制到矩阵 <code>P</code> 一次。 行和列指数分别与细格和粗格空间相关，与相关运算符的定义一致。 这些矩阵被组装多层次方法的延长矩阵的程序所使用。 在使用这个矩阵阵列组装单元间的转移矩阵时，延长矩阵中的零元素被丢弃，不会填满转移矩阵。 如果延长矩阵没有在派生的有限元类中实现，这个函数将以 FiniteElement::ExcEmbeddingVoid. 类型的异常中止。你可以通过首先调用prolongation_is_implemented()或isotropic_prolongation_is_implemented()函数检查是否会发生这种情况。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#ac7802b1354590cdb8990bc0b417d47e9">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#a7f4b356836dd26f801296b9545c5f290">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__Enriched.html#acf745000f9e0d92e41b496f4a7832d5b">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#aa9d90557ae62df3f54a6cced64548c7b">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#ad54e4d53abe7fb9e34701cc356faf001">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#af8c966792cf559b9cdc5e5f91e2c6ed6">FE_Q_Base&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#a6da12c1f660079a9682c8a65b4512be0">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#a8f8b3e2cc54212c9973da2341dadae59">FE_Bernstein&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__SimplexPoly.html#aaa6699485cd7233aff7f6e1e3e1c14a6">FE_SimplexPoly&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00358">358</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a1ead2dba2770c63493a139bec677ccdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ead2dba2770c63493a139bec677ccdb">&#9670;&nbsp;</a></span>prolongation_is_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::prolongation_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个元素是否实现了它的延长矩阵。该返回值还表明调用get_prolongation_matrix()函数是否会产生错误。 请注意，只有在各向同性和所有各向异性的细化情况下，该函数才会返回 <code>true</code> 的延长矩阵。如果你只对各向同性细化的延长矩阵感兴趣，请使用 isotropic_prolongation_is_implemented 函数来代替。 这个函数在这里主要是为了让我们编写更有效的测试程序，我们在各种奇怪的元素上运行，对于这些测试，我们只需要排除某些测试，以防某些东西没有实现。在一般情况下，它在应用中可能不会有很大的帮助，因为如果需要这些功能而它们没有被实现，那就没有什么办法了。这个函数可以用来检查对<code><a class="el" href="classFiniteElement.html#a3a4671144d9976b133c4f79c9aefdd7c">get_prolongation_matrix()</a></code>的调用是否会成功；然而，人们仍然需要应对这个函数所表达的信息的缺乏。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00725">725</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a0849d6c4188612816934d5468ecf9e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0849d6c4188612816934d5468ecf9e6b">&#9670;&nbsp;</a></span>isotropic_prolongation_is_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::isotropic_prolongation_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个元素是否为各向同性的孩子实现了其延长矩阵。该返回值也表明调用 <code>get_prolongation_matrix</code> 函数是否会产生错误。 这个函数在这里主要是为了让我们编写更有效的测试程序，我们在各种奇怪的元素上运行，对于这些元素，我们只需要排除某些测试，以防某些东西没有实现。在一般情况下，它在应用中可能不会有很大的帮助，因为如果需要这些功能而它们没有被实现，那就没有什么办法了。这个函数可以用来检查对<code><a class="el" href="classFiniteElement.html#a3a4671144d9976b133c4f79c9aefdd7c">get_prolongation_matrix()</a></code>的调用是否会成功；然而，人们仍然需要应对这个函数所表达的信息的缺乏。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00781">781</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ab8539eac73f0305ba91e612ad5519250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8539eac73f0305ba91e612ad5519250">&#9670;&nbsp;</a></span>restriction_is_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个元素是否实现了它的限制矩阵。该返回值也表明调用get_restriction_matrix()函数是否会产生错误。 注意，只有在各向同性和所有各向异性细化情况下的限制矩阵被实现时，该函数才会返回 <code>true</code> 。如果你只对各向同性细化的限制矩阵感兴趣，请使用 <a class="el" href="classFiniteElement.html#a645ff401ff38407d67a0785163939f87">isotropic_restriction_is_implemented()</a> 函数来代替。 这个函数在这里主要是为了让我们编写更有效的测试程序，我们在各种奇怪的元素上运行，对于这些测试，我们只需要排除某些测试，以防某些东西没有被实现。在一般情况下，它在应用中可能不会有很大的帮助，因为如果需要这些功能而它们没有被实现，那就没有什么办法了。这个函数可以用来检查对<code><a class="el" href="classFiniteElement.html#a9fbcedd86a33fd947de495e7bf6923dd">get_restriction_matrix()</a></code>的调用是否会成功；然而，人们仍然需要应对这个函数所表达的信息的缺乏。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00753">753</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a645ff401ff38407d67a0785163939f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645ff401ff38407d67a0785163939f87">&#9670;&nbsp;</a></span>isotropic_restriction_is_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::isotropic_restriction_is_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个元素是否实现了其各向同性的子女的限制矩阵。该返回值还表明调用get_restriction_matrix()函数是否会产生错误。 这个函数在这里主要是为了让我们编写更有效的测试程序，我们在各种奇怪的元素上运行，对于这些元素，我们只需要排除某些测试，以防某些东西没有实现。在一般情况下，它在应用中可能不会有很大的帮助，因为如果需要这些功能而它们没有被实现，那就没有什么办法了。这个函数可以用来检查对<code><a class="el" href="classFiniteElement.html#a9fbcedd86a33fd947de495e7bf6923dd">get_restriction_matrix()</a></code>的调用是否会成功；然而，人们仍然需要应对这个函数所表达的信息的缺乏。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00809">809</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a6aa81cef78859c726852a1ee1ef37210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa81cef78859c726852a1ee1ef37210">&#9670;&nbsp;</a></span>restriction_is_additive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction_is_additive </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>访问::restriction_is_additive_flags字段。更多信息请参见一般类文档中关于限制矩阵的讨论。 索引必须在零和这个元素的形状函数的数量之间。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02667">2667</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a9da3f9ca1fa6be8fa5afcb34d56028a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da3f9ca1fa6be8fa5afcb34d56028a3">&#9670;&nbsp;</a></span>constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::constraints </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subface_case</em> = <code>::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt;dim&gt;::case_isotropic</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对矩阵的只读引用，该矩阵描述了精炼单元和非精炼单元之间界面上的约束。 一些有限元不（还）实现悬挂节点约束。如果是这种情况，那么这个函数将产生一个异常，因为不能产生有用的返回值。如果你应该有办法接受这种情况，那么你可能想使用constraints_are_implemented()函数来预先检查这个函数是否会成功或产生异常。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00865">865</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a01f5b5d1700cf820f8989f35418efbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f5b5d1700cf820f8989f35418efbfc">&#9670;&nbsp;</a></span>constraints_are_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::constraints_are_implemented </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>subface_case</em> = <code>::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt;dim&gt;::case_isotropic</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个元素是否实现了它的悬挂节点约束。该返回值也表明对约束()函数的调用是否会产生一个错误。 这个函数在这里主要是为了让我们编写更有效的测试程序，我们运行在各种奇怪的元素上，对于这些元素，我们只需要排除某些测试，以防悬挂节点约束没有实现。一般来说，它在应用中可能不会有很大的帮助，因为如果需要悬挂节点约束而它们没有被实现的话，就没有什么可以做的。这个函数可以用来检查对<code><a class="el" href="classFiniteElement.html#a9da3f9ca1fa6be8fa5afcb34d56028a3">constraints()</a></code>的调用是否会成功；然而，人们仍然需要应对这个函数所表达的信息的缺乏。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00837">837</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ae5d64f4a56fb9fefc55a68fb7ac5e71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d64f4a56fb9fefc55a68fb7ac5e71a">&#9670;&nbsp;</a></span>hp_constraints_are_implemented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_constraints_are_implemented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个元素是否以新的方式实现了它的悬挂节点约束，这必须用于使元素 "hp-compatible"。 这意味着，该元素正确实现了get_face_interpolation_matrix和get_subface_interpolation_matrix方法。因此，返回值也表明对get_face_interpolation_matrix()方法和get_subface_interpolation_matrix()方法的调用是否会产生一个错误。 目前这个函数的主要目的是让make_hanging_node_constraints方法决定是否可以使用新的程序，这些程序应该在hp-framework中工作，或者是否应该使用旧的经过充分验证但不具备hp能力的函数。 一旦过渡到计算接口约束的新方案，这个函数将是多余的，可能会消失。 派生类应该相应地实现这个函数。默认的假设是有限元不提供具有hp能力的面插值，因此默认的实现会返回 <code>false</code>. 。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#ab5d083777a26e139e566a666e0091e7e">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#aea2a8648f7576fd483dbd1dda7945117">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__FaceP.html#a34bd94b51956b7060544ae723a4f1e98">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a752ab095e3724fe3f379427f175f3e2d">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a6ae5e77df08a40e80a2e4e15bcab8e67">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#af4b80e5fdf5a47cbf5ecfa0757d577ba">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPMonomial.html#ac346899d214522ecbbc9d851c92afd95">FE_DGPMonomial&lt; dim &gt;</a>, <a class="el" href="classFE__RaviartThomasNodal.html#a94291d112c8d7fe2735c4b059c154d6a">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFE__FaceQ_3_011_00_01spacedim_01_4.html#a60322d0a56da843a64a51dac02f4b76f">FE_FaceQ&lt; 1, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#ad64a12bd02cd54ff914641859f0080b1">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#ad64a12bd02cd54ff914641859f0080b1">FE_Nothing&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#a16d3698bfa4a47c2e4c45a5d2802c5ea">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a8b49bdcf6165c2fbda8936e1f7ef5eff">FE_Q_Base&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#afba8ff945c78c1ab6563e1c571d33bbd">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#a6c768591bf1ffc08d0102686595564d1">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a2e41211f3aace7e620c887da08fd6e4e">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__SimplexPoly.html#a5690b0959afe1c9cba6c5e33e631d02f">FE_SimplexPoly&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__TraceQ.html#a537ec3fb24b2bbc3fb54306613abc68a">FE_TraceQ&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00856">856</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a46d590413e360eb10dbe4f9e247cb2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d590413e360eb10dbe4f9e247cb2bb">&#9670;&nbsp;</a></span>get_interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回从给定的有限元到现在的有限元的内插矩阵。矩阵的大小是::dofs_per_cell乘以&lt;tt&gt;source.<a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">dofs_per_cell</a>。 衍生元素将不得不实现这个函数。他们可能只为某些源有限元提供插值矩阵，例如那些来自同一家族的有限元。如果他们不实现给定元素的插值，那么他们必须抛出一个ExcInterpolationNotImplemented类型的异常。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a117566232430f89edbf198ef9d5ae1a9">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#a1600028cce7854d1bef41c3df793765e">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#ab5a729e6430ea7b24750faefcaf1f156">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#a1fdd96a59291888c3f333683e59d3548">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#affbcfd81664c27a931abdfbe51000d4d">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#abbac44586e679f8a1b6647ab0539402b">FE_Bernstein&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#a07aae97288d3b0c84d5f4ad56d4d06e4">FE_Q_Base&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00927">927</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a704fd4e8da3219ba0f71a17b5effdf55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704fd4e8da3219ba0f71a17b5effdf55">&#9670;&nbsp;</a></span>get_face_interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_face_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回从一个元素的面插值到相邻元素的面的矩阵。 矩阵的大小是<code>source.<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code>乘以<code>this-&gt;<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code>。 衍生元素将不得不实现这个函数。他们可能只为某些源有限元提供插值矩阵，例如那些来自同一家族的有限元。如果他们不实现给定元素的插值，那么他们必须抛出一个ExcInterpolationNotImplemented类型的异常。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a60a4d4886f54ebe3c3169b26b82e0858">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#afa30d21396cae365249a149643e7ed04">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#ad9aea970150a9f35df999dc08a9bf595">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#ade09182d4129046521281ab3f12e26c0">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a7bc7dfb5db24437cbb2f04c736d57913">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a615691992f02e2bc217548992d01acd0">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a955abe1aff4c1b1a311a84a07b3ec2b8">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__TraceQ.html#acf410b648f6842ebc73a2f2e4f742420">FE_TraceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#ae912cb443621cbfc3b523980c1a68ebb">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexPoly.html#afab3ae394382930183d0323eea98af17">FE_SimplexPoly&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#a4cbb20ef6d8a2148701d4685ee01531d">FE_FaceQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#ad14c932a54076ac67cf8b10197e3d264">FE_Q_Base&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00943">943</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a49db74688a0ac8a839fb5aca9b7febde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49db74688a0ac8a839fb5aca9b7febde">&#9670;&nbsp;</a></span>get_subface_interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_subface_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回从一个元素的面内插到邻近元素的子面的矩阵。 矩阵的大小是<code>source.<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code>乘以<code>this-&gt;<a class="el" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a></code>。 衍生元素将不得不实现这个函数。他们可能只为某些源有限元提供插值矩阵，例如那些来自同一家族的有限元。如果他们不实现给定元素的插值，那么他们必须抛出一个ExcInterpolationNotImplemented类型的异常。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#abc5031867f79f76ae1065bbf6427e692">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#a8c498b8f5f8fe4a3796608b0cdebc01a">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#aef2fd8e7e43199340fe3f5e3b2388f4b">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a869122172b27fe97f7a77c02559dff7a">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a3542d0fdcc731227a87a68a8a7d9b3c5">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a39e147d7510e02fad281dafe8f9b4c96">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#ada86e010d0d60a606f64d8ef5169847c">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__TraceQ.html#a6cb6da09e53476c05e0c4735ca4cf034">FE_TraceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#ae603c1d9acbb1e507aab8d7d97423995">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexPoly.html#a45c30c34277f222736405ac1b5e16e46">FE_SimplexPoly&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#ac6cfc37b99a337be617bab4055a00076">FE_FaceQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#a070253b3d7f817efd523f20ce8f890b8">FE_Q_Base&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00960">960</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a18c920830fe94b08cdf8754b6533e805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c920830fe94b08cdf8754b6533e805">&#9670;&nbsp;</a></span>hp_vertex_dof_identities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_vertex_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果在一个顶点上，有几个有限元处于活动状态，hp代码首先为这些FEs的每个自由度分配不同的全局索引。然后调用这个函数来找出其中哪些应该得到相同的值，从而可以得到相同的全局自由度指数。 因此，该函数返回当前有限元对象的自由度与 <code>fe_other</code>, 的自由度之间的相同性列表，后者是对代表在该特定顶点上活动的其他有限元之一的有限元对象的引用。该函数计算两个有限元对象的哪些自由度是相等的，这两个自由度的编号都在零和两个有限元的n_dofs_per_vertex()的相应值之间。每一对的第一个索引表示本元素的一个顶点自由度，而第二个是另一个有限元素的相应索引。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#ad99ac38fdabea78d1b2eb15cc413d14f">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a7cf0cae49c6a3e64aa071ac3d661f0b1">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#acaf49df985a8909336e8062131bf435d">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a6937c42e4dd88f4d4f808559d6b49890">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexDGP.html#a433b40c2bab352c9a5cad9aa770ac6df">FE_SimplexDGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a76cd8a7c5ee17026aafd494ba280e573">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a2e70087285c8a0189eaf347b91439ac8">FE_Q_Base&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#aab33a2ac3dd777ae00f00fd7f4b18cb7">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexP.html#a9a0ba37154492fae13d526cba4936d66">FE_SimplexP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#a737367715c3ac1c2569c614149925dee">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#ada1b43d4fa44fda363c7a79b4bd819af">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PyramidP.html#aace3dc6359f20277149614974aa2f764">FE_PyramidP&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__WedgeP.html#aaaeba89a2d9e7a310d579847620bda02">FE_WedgeP&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00978">978</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a0580b57287997a3aaa682d993bc952c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0580b57287997a3aaa682d993bc952c1">&#9670;&nbsp;</a></span>hp_line_dof_identities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_line_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与hp_vertex_dof_indices()相同，只是该函数处理线上自由度。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a50bc69e0a928673d093743af96ecb8ce">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#aa3b40d46ca7cd6630c4ece7775b8e6ca">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#aa08e051322dca4feaf5f4d02cc614b08">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a016184923f178608fc6461680bf4b29a">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexDGP.html#a2fcf5ef8bb27b2eddc278ae52e476a02">FE_SimplexDGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#a087307bdae6234335b1ae17a31bf8483">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a64b3c4555c329686ec227391af73eb11">FE_Q_Base&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#ab9ced0e9992ab065e4e165bb08ca01a1">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexP.html#a75ad1e5b118b05426ef99ec02665d848">FE_SimplexP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#afce52c8fd8f94362cbed8b8c5e24be83">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#a620aee4cace68de92511ec801691f28a">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PyramidP.html#a613cf5f8378c9df000c94628ea88d371">FE_PyramidP&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__WedgeP.html#ac2f52a554010b62420aae62510f03aac">FE_WedgeP&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00989">989</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a34df541fc9614840c6c428cbe9ffa68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34df541fc9614840c6c428cbe9ffa68e">&#9670;&nbsp;</a></span>hp_quad_dof_identities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::hp_quad_dof_identities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与hp_vertex_dof_indices()相同，只是该函数处理四边形上的自由度。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a23d39d3c9635f9e2ac013d3a12136c5d">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a209ffb6e028c73a1445e33a44ff5020e">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a75aedd580bac6d0cf3dc738e9943b3a0">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#aefc97c77f65fac1e64a777d8050acf1f">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#afce4d6f5eaa675699267dd839917c0c4">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a7bec9993624e79d8a7c01f908dde8f04">FE_Q_Base&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a7191ca9e75734ddc3c98f372a427faf9">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#a4fde340aa3a425e2833f4f225a07bbf3">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#ade75fae0f41295d254ae18faeb6387cb">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PyramidP.html#ac40eaaf61da2e5934beae18c11469cf6">FE_PyramidP&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__WedgeP.html#a3dafe070bd259f5d67bb4f2c8258e364">FE_WedgeP&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01000">1000</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a1719468736ca8342cf3927564e57ed66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1719468736ca8342cf3927564e57ed66">&#9670;&nbsp;</a></span>compare_for_domination()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::compare_for_domination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>codim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个元素是否支配另一个作为参数的元素 <code>fe_other</code>, 是否相反，是否两者都不支配，或者是否两者都可以支配。 <code>codim</code> 参数描述了被调查的子空间的二维度，并指定其受此比较。例如，如果<code>codim==0</code>，那么这个函数就会比较哪个元素在细胞水平上占优势。如果<code>codim==1</code>，那么元素在面进行比较，也就是说，比较发生在限制在面的两个有限元素的函数空间之间。较大的`codim'值也相应地起作用。 关于支配的定义，见 <a class="el" href="namespaceFiniteElementDomination.html#a65fdbe0cca5954df89a7af4f36769bf9">FiniteElementDomination::Domination</a> ，特别是 <a class="el" href="DEALGlossary.html#hp_paper">hp-论文</a> 。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#abc005a9584d52b4a1e42d8f62840b8df">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q.html#ad496bc25467a4b54950f632ff90ad76c">FE_Q&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceP.html#a472b433e9a14f775f60250733ded637c">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a464443089288286e5c63225b4e4a5d5e">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGPNonparametric.html#a7d221adc2e5f87f33e59856063192f90">FE_DGPNonparametric&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#acc39c310b7d0861b99c58bb6cc7c1590">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#af2193761f38afb2a652b4eddbf300c4b">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexDGP.html#a0061240a4a03b33f83528620d9f14ab5">FE_SimplexDGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a97ba20a01a35a3e96658b5c73791bac9">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nothing.html#ab629f287fe1a1feeed2e61a1b4773488">FE_Nothing&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__SimplexP.html#a7782c9d9917e45bd1a7dc94f7e982e8c">FE_SimplexP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ.html#a2100bbca84401863a3d0ff884d029429">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Bernstein.html#a48237f7b472fc49126bd5dc17eddeadd">FE_Bernstein&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#a37a853bf18f58d35aef29e060cd35ed2">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__TraceQ.html#a5524715045fb491b741f8cc97a3bff65">FE_TraceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__iso__Q1.html#a067adf37b830b1c24826df387aca57f0">FE_Q_iso_Q1&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PyramidP.html#aec8e80a12b0d54d4e346d64b82dddfcd">FE_PyramidP&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__WedgeP.html#ac371eb89e8a6bb7942c25df2b5ce66bd">FE_WedgeP&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01012">1012</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a0e8eac071595214d0252b359c48ed11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8eac071595214d0252b359c48ed11d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>比较运算符。 在当前类中的实现是检查当前对象和作为参数给定的对象之间的以下信息是否相等，按照这个顺序。</p>
<ul>
<li>当前对象和给定对象的动态类型（即最派生类的类型）。</li>
<li>由get_name()返回的名称。</li>
<li>如同FiniteElementData中的所有字段。</li>
<li>约束矩阵。 这涵盖了大多数元素可以不同的情况，但也有派生元素不同的情况，对于这些情况，当前函数仍然返回 <code>true</code>. 对于这些情况，派生类应该重载这个函数。 <dl class="section note"><dt>Note</dt><dd>这个操作符特别不检查当前类的下列成员变量。</dd></dl>
</li>
<li>限制矩阵。</li>
<li>此对象和参数的延长矩阵。 这是因为这些成员变量可能只在派生类的要求下被初始化，而不是立即可用。 因此，比较这些成员不仅成本高，因为这些一般都是大数组，而且其计算也可能很昂贵。另一方面，派生类的这些数组对于两个对象来说可能是不同的，即使上面的列表比较起来是相等的，也可能想要实现自己的operator==()。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01025">1025</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a439857c3106a765203a354723dfc7cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439857c3106a765203a354723dfc7cac">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>比较运算符。 </p>

<p class="definition">Definition at line <a class="el" href="fe__data_8cc_source.html#l00180">180</a> of file <a class="el" href="fe__data_8cc_source.html">fe_data.cc</a>.</p>

</div>
</div>
<a id="a443a348f7c568cb05b3ec3f18c788f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443a348f7c568cb05b3ec3f18c788f75">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>非等价比较运算符。以平等比较运算符的方式定义。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01040">1040</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a86644fe67824373cd51e9ff7fca94f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86644fe67824373cd51e9ff7fca94f8c">&#9670;&nbsp;</a></span>system_to_component_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_component_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从这个有限元内的形状函数的索引中计算出这个形状函数对应的向量分量和索引。 如果元素是标量，那么分量总是零，这个分量内的索引等于总索引。 如果引用的形状函数有一个以上的非零分量，那么它不能与一个矢量分量相关联，并且将引发一个ExcShapeFunctionNotPrimitive类型的异常。 注意，如果元素是由其他（基）元素组成的，并且一个基元素有一个以上的分量，但是它的所有形状函数都是原始的（即在只有一个分量中是非零的），那么这个映射包含有效的信息。然而，这个元素的形状函数在一个分量中的索引（即这个数组中各自条目的第二个数字）并不表示各自的形状函数在基数元素中的索引（因为它有一个以上的向量分量）。关于这个信息，请参考::system_to_base_table字段和system_to_base_index()函数。 关于这个函数的典型使用方法，见上面的类描述。 在 <a class="el" href="step_8.html">step-8</a> 和 <a class="el" href="step_20.html">step_20 </a>step-20" " 教程程序以及 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> 模块中，对该函数的使用进行了广泛的解释。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02496">2496</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ae2ea16b60a6fc644a9bc7097703a53e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ea16b60a6fc644a9bc7097703a53e8">&#9670;&nbsp;</a></span>component_to_system_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_system_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算给定矢量元件和索引的形状函数。 如果该元素是标量，那么该分量必须为零，并且该分量内的索引等于总索引。 这是与system_to_component_index()函数相反的操作。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02529">2529</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="aecb73242a6dca33f8da1bb44a5f00d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb73242a6dca33f8da1bb44a5f00d61">&#9670;&nbsp;</a></span>face_system_to_component_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_component_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与system_to_component_index()函数相同，但对形状函数和它们在面上的索引进行操作。因此允许的索引范围是0...#dofs_per_face。 你在应用程序中很少需要这个函数，因为几乎所有的应用程序代码都只需要处理单元格的索引，而不是面的索引。这个函数主要是为了在库内使用。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02556">2556</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ae54657bc9ca9484522e7e6e3ca2499bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54657bc9ca9484522e7e6e3ca2499bc">&#9670;&nbsp;</a></span>adjust_quad_dof_index_for_face_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_quad_dof_index_for_face_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于在3D中具有非标准面孔方向的面孔，面孔（四边形）上的道夫必须被移位，以便与正确的形状函数相结合。给出一个四边形上的局部dof <code>index</code> ，如果该面具有非标准的面朝向、面朝上或面朝下的旋转，则返回局部索引。在二维和一维中，不需要 permutation，因此会抛出一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00657">657</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a8d22a08e0e3136f181d6098db19f8b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d22a08e0e3136f181d6098db19f8b93">&#9670;&nbsp;</a></span>face_to_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_to_cell_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定一个面的指数的自然排序，返回单元格上相同自由度的指数。 为了解释这个概念，考虑这样的情况：我们想知道一个面的自由度，例如作为FESystem元素的一部分，是否是原始的。不幸的是，FiniteElement类中的is_primitive()函数需要一个单元格索引，所以我们需要找到对应于当前面的索引的形状函数的单元格索引。 这个函数就是这样做的。 实现这一点的代码将看起来像这样。 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="classFiniteElementData.html#a358bffed1fba59ef4df715469473fd36">dofs_per_face</a>; ++i)</div><div class="line"><span class="keywordflow">if</span> (fe.is_primitive(fe.face_to_cell_index(i, some_face_no)))</div><div class="line">... <span class="keywordflow">do</span> whatever</div></div><!-- fragment --><p> 这个函数需要额外的参数，这些参数考虑到实际的面可以是相对于所考虑的单元格的标准排序，或者可以是翻转的，定向的，等等。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face_dof_index</td><td>一个面的自由度的索引。这个指数必须在零和每个面的自由度之间。 </td></tr>
    <tr><td class="paramname">face</td><td>这个自由度所在的面的编号。这个数字必须在零和 <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">GeometryInfo::faces_per_cell</a>. 之间 </td></tr>
    <tr><td class="paramname">face_orientation</td><td>描述面的方向的一部分。见 <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a> 。 </td></tr>
    <tr><td class="paramname">face_flip</td><td>对脸部方向的描述的一部分。参见 <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a> 。 </td></tr>
    <tr><td class="paramname">face_rotation</td><td>描述脸部方向的一部分。参见 <a class="el" href="DEALGlossary.html#GlossFaceOrientation">GlossFaceOrientation</a> 。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>这个自由度在整个单元上的自由度集合中的索引。返回值将介于0和dofs_per_cell之间。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>这个函数存在于这个类中，因为这是它首次实现的地方。然而，在不知道我们有什么元素的情况下，它不能真正在最一般的情况下工作。原因是当一个面被翻转或旋转时，我们还需要知道我们是否需要交换这个面上的自由度，或者它们是否可以免于这样。 对于这一点，请考虑2d中 \(Q_3\) 元素的情况。如果face_flip是真的，那么我们就需要以相反的顺序考虑边缘上的两个自由度。另一方面，如果这个元素是 \(Q_1^2\) ，那么由于这个边上的两个自由度属于不同的向量分量，它们不应该被反向考虑。所有这些表明，如果每条线或四边有一个以上的自由度，这个函数就不能工作，在这些情况下，函数会抛出一个异常，指出这个功能需要由一个知道自由度实际代表的派生类提供。 </dd></dl>

<p>Reimplemented in <a class="el" href="classFESystem.html#a2ad92aed11c564b6e09129c8c6e11688">FESystem&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Q__Base.html#a22a24f018babdf5a517bda0b6daa3034">FE_Q_Base&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00568">568</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a5859e4b85feaa0406c4aa571fc4dfa4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5859e4b85feaa0406c4aa571fc4dfa4f">&#9670;&nbsp;</a></span>adjust_line_dof_index_for_line_orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_line_dof_index_for_line_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>line_orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于在三维中具有非标准线方向的线条，线条上的自由度必须被替换，以便与正确的形状函数相结合。给出一条线上的局部道夫 <code>index</code> ，如果该线有非标准的线方向，则返回局部索引。在二维和一维中，不需要进行置换，所以直接返回给定的索引。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00700">700</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a12aa649db6e1460a8d30b067af952fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12aa649db6e1460a8d30b067af952fc4">&#9670;&nbsp;</a></span>get_nonzero_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回该有限元的哪些向量分量中 <code>第i个形状函数是非零的。返回数组的长度等于这个元素的向量分量的数量。</code> 对于大多数有限元空间，这个函数的结果将是一个恰好有一个元素是 <code>true</code>, 的向量，因为对于大多数空间，各个向量分量是独立的。在这种情况下，带有单个0的分量也是system_to_component_index()返回的第一个元素。 只有对于那些耦合分量的空间，例如为了使形状函数无发散，才会有一个以上的 <code>true</code> 条目。 这种情况下的元素被称为非原始元素（见 <a class="el" href="DEALGlossary.html#GlossPrimitive">GlossPrimitive</a> ）。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02678">2678</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ac228df752c9c2462aabf284e862402d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac228df752c9c2462aabf284e862402d0">&#9670;&nbsp;</a></span>n_nonzero_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::n_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 <code>ith</code> 形状函数在多少个向量分量中是非零的。这个值等于get_nonzero_components()函数结果中等于 <code>true</code> 的条目数量。 对于大多数有限元空间来说，该结果将等于1。只有对于那些矢量值形状函数将各个分量结合在一起的解析空间，例如，为了使其无发散，它才不等于1。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02688">2688</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a626abd282a25193db7f61b4ec53e7385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626abd282a25193db7f61b4ec53e7385">&#9670;&nbsp;</a></span>is_primitive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::is_primitive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回整个有限元是否是原始的，即其所有形状函数都是原始的。如果有限元是标量的，那么情况总是这样的。 由于这是一个极其常见的操作，其结果被缓存并由该函数返回。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02698">2698</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a38241991825f67d635d53d25cb5a2fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38241991825f67d635d53d25cb5a2fda">&#9670;&nbsp;</a></span>is_primitive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::is_primitive </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 <code>ith</code> 形状函数是否是原始的，即形状函数只在一个向量分量中非零。那么，非原始的形状函数将是那些无发散的Ansatz空间的形状函数，其中各个向量分量是耦合的。 当且仅当<code>n_nonzero_components(i)</code>的结果等于1时，该函数的结果为 <code>true</code> 。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02707">2707</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ad12fbcc708737aa60fa272d4d3e22aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12fbcc708737aa60fa272d4d3e22aea">&#9670;&nbsp;</a></span>n_base_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::n_base_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>混合离散化中的基元数量。 请注意，即使是矢量值的有限元，组件的数量也不需要与基元的数量相一致，因为它们可能被重复使用。例如，如果你通过使用接受一个有限元和一个倍数的构造函数来创建一个具有三个相同的有限元类的FES系统，那么基元的数量仍然是一个，尽管有限元的分量数量等于倍数。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02510">2510</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a40c2ecc833033772889878116bd8a740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c2ecc833033772889878116bd8a740">&#9670;&nbsp;</a></span>base_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::base_element </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对基元对象的访问。如果元素是原子性的，那么 <code>base_element(0)</code> 就是 <code>this</code>. 。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a2a870396630e54769b1e2adbdf4f55fc">FESystem&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__Enriched.html#a9f1d3ed19393f5e5c5aa6eb10ad0960e">FE_Enriched&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01402">1402</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="aa009769e662e34081f60ff16327db1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa009769e662e34081f60ff16327db1b1">&#9670;&nbsp;</a></span>element_multiplicity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::element_multiplicity </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个索引表示基础元素 <code>index</code> 在一个组成元素中使用的频率。如果该元素是原子性的，那么结果总是等于1。更多细节见n_base_elements()函数的文档。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02519">2519</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a6e43718bc2c42814fb3513478f25db42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e43718bc2c42814fb3513478f25db42">&#9670;&nbsp;</a></span>get_sub_fe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_sub_fe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个包含的有限元素的引用，该元素与给定的ComponentMask所选择的组件相匹配 <code>mask</code>. 对于一个任意嵌套的FESystem，该函数返回与给定掩码相匹配的最内层的FiniteElement。如果 <code>mask</code> 不完全匹配其中一个包含的有限元，则该方法失败。如果当前对象是一个FESystem，该方法是最有用的，因为在所有其他情况下，返回值只能是 <code>this</code> 。 请注意，如果掩码与之匹配，但不与任何包含的对象匹配，则返回的对象可以是一个FESystem。 让我们用一个有7个组件的FESystem <code>fe</code> 来说明这个函数。 </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;2&gt;</a> fe_velocity(<a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>(2), 2);</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> fe_pressure(1);</div><div class="line"><a class="code" href="classFE__DGP.html">FE_DGP&lt;2&gt;</a> fe_dg(0);</div><div class="line"><a class="code" href="classFE__BDM.html">FE_BDM&lt;2&gt;</a> fe_nonprim(1);</div><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;2&gt;</a> fe(fe_velocity, 1, fe_pressure, 1, fe_dg, 2, fe_nonprim, 1);</div></div><!-- fragment --><p> 下表列出了你可以使用的所有可能的组件掩码。 </p><table class="doxtable">
<tr>
<th><a class="el" href="classComponentMask.html">ComponentMask</a> </th><th>Result </th><th>Description  </th></tr>
<tr>
<td><code>[true,true,true,true,true,true,true]</code> </td><td><code>FESystem&lt;2&gt;[FESystem&lt;2&gt;[FE_Q&lt;2&gt;(2)^2]-FE_Q&lt;2&gt;(1)-FE_DGP&lt;2&gt;(0)^2-FE_BDM&lt;2&gt;(1)]</code> </td><td><code>fe</code> itself, the whole <code><a class="el" href="classFESystem.html">FESystem</a></code>   </td></tr>
<tr>
<td><code>[true,true,false,false,false,false,false]</code> </td><td><code>FESystem&lt;2&gt;[FE_Q&lt;2&gt;(2)^2]</code> </td><td>just the <code>fe_velocity</code>   </td></tr>
<tr>
<td><code>[true,false,false,false,false,false,false]</code> </td><td><code>FE_Q&lt;2&gt;(2)</code> </td><td>The first component in <code>fe_velocity</code>   </td></tr>
<tr>
<td><code>[false,true,false,false,false,false,false]</code> </td><td><code>FE_Q&lt;2&gt;(2)</code> </td><td>The second component in <code>fe_velocity</code>   </td></tr>
<tr>
<td><code>[false,false,true,false,false,false,false]</code> </td><td><code>FE_Q&lt;2&gt;(1)</code> </td><td><code>fe_pressure</code>   </td></tr>
<tr>
<td><code>[false,false,false,true,false,false,false]</code> </td><td><code>FE_DGP&lt;2&gt;(0)</code> </td><td>first copy of <code>fe_dg</code>   </td></tr>
<tr>
<td><code>[false,false,false,false,true,false,false]</code> </td><td><code>FE_DGP&lt;2&gt;(0)</code> </td><td>second copy of <code>fe_dg</code>   </td></tr>
<tr>
<td><code>[false,false,false,false,false,true,true]</code> </td><td><code>FE_BDM&lt;2&gt;(1)</code> </td><td>both components of <code>fe_nonprim</code>   </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01164">1164</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ad91c784287a963d36c05fed227b4c973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91c784287a963d36c05fed227b4c973">&#9670;&nbsp;</a></span>get_sub_fe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_sub_fe </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_selected_components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个与组件 <code>n_selected_components</code> 相匹配的所含有限元的引用，该组件从索引为 <code>first_component</code>. 的组件开始。更多细节见上面的其他get_sub_fe()函数。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a8e4f1afff1380d9f81f6ee1cf63a1a81">FESystem&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01197">1197</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a95ac75dfc5b9f4e01c34d5865b4ca5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ac75dfc5b9f4e01c34d5865b4ca5a2">&#9670;&nbsp;</a></span>system_to_base_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为形状函数 <code>index</code> 返回它所属的基本元素，这个基本元素的副本数量（介于0和这个元素的倍数之间），以及这个形状函数在这个基本元素中的索引。 如果该元素不是由其他元素组成的，那么基数和实例总是零，而索引等于形状函数的编号。 如果元素是由其他元素的单个实例组成的（即所有的倍数都是1），这些实例都是标量的，那么这个元素中的基值和dof索引就等于::system_to_component_table。只有在该元素由其他元素组成，并且其中至少有一个元素本身是矢量值的情况下，它才会有所不同。 关于这个函数的典型使用方法，请看上面的类文件中的一个例子。 与system_to_component_index()函数相比，这个函数在矢量值（即非原始）形状函数的情况下也能返回有效值。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02591">2591</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a9c4647e72a2670c17849701a6357eb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4647e72a2670c17849701a6357eb87">&#9670;&nbsp;</a></span>face_system_to_base_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与system_to_base_index()函数相同，但是针对位于面的自由度。因此允许的指数范围是0...#dofs_per_face。 你在应用程序中很少需要这个函数，因为几乎所有的应用程序代码都只需要处理单元格的索引，而不是面的索引。这个函数主要是在库内使用的。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02602">2602</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="afc49f8114f396b20b9a7fe9a3c058568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc49f8114f396b20b9a7fe9a3c058568">&#9670;&nbsp;</a></span>first_block_of_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::first_block_of_base </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定一个基本元素数，返回它将生成的BlockVector的第一个块。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02618">2618</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a2e1ca2e63382a8fd20910ae0303f4f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1ca2e63382a8fd20910ae0303f4f6c">&#9670;&nbsp;</a></span>component_to_base_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于每个向量组件，返回哪个基元实现了这个组件以及这个基元中的哪个向量组件。这个信息只对由几个子元素组成的矢量值有限元素有意义。在这种情况下，人们可能想获得关于实现某个矢量分量的元素的信息，这可以用这个函数和 <a class="el" href="classFESystem.html#a2a870396630e54769b1e2adbdf4f55fc">FESystem::base_element()</a> 函数来完成。 如果这是一个标量有限元，那么返回值总是等于一对零。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02628">2628</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a656f95e7c9144846758b804a41405cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656f95e7c9144846758b804a41405cd3">&#9670;&nbsp;</a></span>block_to_base_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_to_base_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回此块的基元和基元的副本数量。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02640">2640</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a0763dd6212313f0ff69f04c735b2a147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0763dd6212313f0ff69f04c735b2a147">&#9670;&nbsp;</a></span>system_to_block_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_block_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个形状函数的向量块和块内的索引。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02650">2650</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a7b3dd1574cabab93b67e3fe47a103b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3dd1574cabab93b67e3fe47a103b6a">&#9670;&nbsp;</a></span>component_to_block_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_block_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个组件的向量块。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00384">384</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a4409f54175f279ac24cc982cfcfcbd2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4409f54175f279ac24cc982cfcfcbd2f">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个分量掩码，其元素数量与此对象的向量分量相同，并且其中正好有一个与给定参数相对应的分量是真的。更多信息见 <a class="el" href="DEALGlossary.html#GlossComponentMask">术语表</a> 。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">标量</td><td>一个代表该有限元的单一标量向量分量的对象。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个分量掩码，在所有分量中都是假的，除了与参数相对应的那一个。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00396">396</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a46d11c23f6db2eca49ba470defb873c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d11c23f6db2eca49ba470defb873c0">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个分量掩码，其元素数量与此对象的向量分量相同，并且其中与给定参数对应的 <code>dim</code> 分量为真。更多信息见 <a class="el" href="DEALGlossary.html#GlossComponentMask">术语表</a> 。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">矢量</td><td>一个表示该有限元的暗淡矢量分量的对象。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个分量掩码，在所有分量中都是假的，除了与参数相对应的分量。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00414">414</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a2c0dcc1e76885ec0ddcaae340dcdcd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0dcc1e76885ec0ddcaae340dcdcd62">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sym_tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个分量掩码，其元素数与此对象的向量分量相同，其中与给定参数对应的 <code>dim*(dim+1)/2</code> 分量为真。更多信息见 <a class="el" href="DEALGlossary.html#GlossComponentMask">术语表</a> 。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym_tensor</td><td>一个表示该有限元的dim*(dim+1)/2分量的对象，这些分量共同被解释为形成一个对称张量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个分量掩码，在所有分量中都是假的，除了与参数相对应的那些。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00436">436</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a24d2a54a95f43f0db77e74b1bfab21d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d2a54a95f43f0db77e74b1bfab21d2">&#9670;&nbsp;</a></span>component_mask() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>block_mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00461">461</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a7cc5ed75cad6792b8b21a3ac635a8860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc5ed75cad6792b8b21a3ac635a8860">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个块掩码，其元素数与此对象的块数相同，并且其中正好有一个与给定参数相对应的成分是真的。更多信息见 <a class="el" href="DEALGlossary.html#GlossBlockMask">术语表</a> 。 </p><dl class="section note"><dt>Note</dt><dd>这个函数只有在参数所引用的标量包含一个完整的块时才会成功。换句话说，例如，如果你传递了一个单 \(x\) 速度的提取器，并且这个对象代表一个FE_RaviartThomas对象，那么你选择的单标量对象是一个更大的块的一部分，因此没有代表它的块屏蔽。然后，该函数将产生一个异常。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">标量</td><td>一个代表该有限元的单一标量矢量分量的对象。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个分量掩码，在所有分量中都是假的，除了与参数相对应的那一个。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00482">482</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a9294bf84eec96ac31f29808a5aa87551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9294bf84eec96ac31f29808a5aa87551">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个分量掩码，其元素数与此对象的向量分量一样多，并且其中对应于给定参数的 <code>dim</code> 分量为真。更多信息见 <a class="el" href="DEALGlossary.html#GlossBlockMask">术语表</a> 。 </p><dl class="section note"><dt>Note</dt><dd>同样的注意事项适用于上述函数的版本。 作为参数传递的提取器对象必须使其对应于完整的块，并且不会分割此元素的块。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">矢量</td><td>一个表示该有限元的dim矢量成分的对象。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个分量掩码，除了与参数对应的分量外，所有分量都是假的。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00493">493</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ace95b8ef3a342bbb8f82cb17113be612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace95b8ef3a342bbb8f82cb17113be612">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sym_tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个分量掩码，其元素数与此对象的向量分量相同，其中与给定参数对应的 <code>dim*(dim+1)/2</code> 分量为真。更多信息见 <a class="el" href="DEALGlossary.html#GlossBlockMask">术语表</a> 。 </p><dl class="section note"><dt>Note</dt><dd>同样的注意事项适用于上述函数的版本。 作为参数传递的提取器对象必须使其对应于完整的块，并且不分割此元素的块。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym_tensor</td><td>一个代表该有限元的dim*(dim+1)/2组件的对象，这些组件共同被解释为形成一个对称张量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个分量掩码，在所有分量中都是假的，除了与参数相对应的那些分量。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00504">504</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a931d71caa9f14212b8dd89337e155fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931d71caa9f14212b8dd89337e155fc1">&#9670;&nbsp;</a></span>block_mask() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMask.html">BlockMask</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::block_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>这个函数只有在参数所引用的组件包含完整的块时才会成功。换句话说，例如，如果你为单个 \(x\) 速度传递了一个组件掩码，而这个对象代表一个FE_RaviartThomas对象，那么你选择的单个组件是一个更大的块的一部分，因此没有代表它的块掩码。该函数就会产生一个异常。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component_mask</td><td>选择有限元单个组件的掩码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>选择与输入参数的选定块相对应的那些块的掩码。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00516">516</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a3584deb698371e24c78dcd27f962ede8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3584deb698371e24c78dcd27f962ede8">&#9670;&nbsp;</a></span>get_constant_modes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt;, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_constant_modes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个元素的常数模式列表。结果表中的行数取决于使用的元素。对于标准元素，该表的行数与元素中的元件和dofs_per_cell列的数量相同。对于有限元的每个分量，返回表中的行包含了该元上常数函数1的基础表示。然而，有一些标量元素存在不止一个常数模式，例如FE_Q_DG0元素。 为了将恒定模式与元素中的实际分量相匹配，返回的数据结构也会返回一个向量，其分量与元素上的恒定模式一样多，其中包含分量编号。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a17c0f8d4411b7f38517c35133615d655">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Hierarchical.html#a28d99f878144880dc3eea3d1afe63c7c">FE_Q_Hierarchical&lt; dim &gt;</a>, <a class="el" href="classFE__FaceP.html#a16a6e4ced2c0ddb9aacf6dd70c21d0f2">FE_FaceP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGP.html#a23c1210df0a01bec016950f85c3e07a9">FE_DGP&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQLegendre.html#a8a52e9e5eaf8f1ed7dda7d1899938670">FE_DGQLegendre&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#a63f409752cc322c50649d7812436e674">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__FaceQ_3_011_00_01spacedim_01_4.html#a659c315dfad12595524cfee4005f3c8a">FE_FaceQ&lt; 1, spacedim &gt;</a>, <a class="el" href="classFE__DGQ.html#a81b19ef0a43df8a26787525ffc6df8a7">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a9601be0cd77ad7c7bd3830ab4930e21e">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__FaceQ.html#a408e4b60ac239daac997f8783bdc1f1d">FE_FaceQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__Base.html#a89238e34b4cd4c6754de75233f52c619">FE_Q_Base&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#a6ca0ce5a16907bcb2debfe3541a54baf">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__TraceQ.html#a4327e00593bcef3ab72c199d171c8d4e">FE_TraceQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__SimplexPoly.html#a3c57547472200d784db3b565b566556b">FE_SimplexPoly&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01216">1216</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a5b35a290aa7dd7562911a92a13b11fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b35a290aa7dd7562911a92a13b11fee">&#9670;&nbsp;</a></span>get_unit_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_unit_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果派生的有限元定义了支持点，则返回单元格上试验函数的支持点。 允许某种插值操作的有限元通常有支持点。另一方面，通过例如面的力矩或导数来定义其自由度的元素没有支持点。在这种情况下，返回的域是空的。 如果有限元定义了支持点，那么它们的数量就等于该元的自由度数量。 数组中的点的顺序与<code>cell-&gt;get_dof_indices</code>函数返回的顺序一致。 关于支持点的详细信息，请参见类的文档。 </p><dl class="section note"><dt>Note</dt><dd>有限元素对该函数的实现以与形状函数相同的顺序返回这些点。形状函数的顺序通常记录在各个有限元类的类文件中。特别是，形状函数（以及随之而来的在该类的类文件中讨论的映射的正交点）将首先遍历那些位于顶点上的形状函数，然后是线，然后是四边形，等等。 </dd>
<dd>
如果这个元素实现了支持点，那么它将为每个形状函数返回一个这样的点。由于多个形状函数可能被定义在同一位置，这里返回的支持点可能是重复的。一个例子是一个 <code><a class="el" href="classFESystem.html">FESystem(FE_Q(1),3)</a></code> 类型的元素，每个支持点在返回的数组中会出现三次。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01049">1049</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a47f25ecdd4c356032bd44e3e6571d983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f25ecdd4c356032bd44e3e6571d983">&#9670;&nbsp;</a></span>has_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个有限元是否有定义的支持点。如果结果为真，那么调用get_unit_support_points()就会产生一个非空数组。 如果一个元素不是由插值形状函数定义的，例如由四边形上的P元素定义的，结果可能为假。通常只有当元素通过要求在某一点上为一，在所有与其他形状函数相关的点上为零来构造其形状函数时，它才会为真。 在组成元素中（即对于FESystem类），如果所有的基础元素都有定义的支持点，那么结果将是真的。FE_Nothing是FES系统中的一个特例，因为它有0个支持点，has_support_points()为假，但是在其他元素中包含FE_Nothing的FES系统将返回true。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01065">1065</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a240719f4c467b178c7dea32040f8015e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240719f4c467b178c7dea32040f8015e">&#9670;&nbsp;</a></span>unit_support_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_support_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 <code>indexth</code> 形状函数的支持点的位置。如果它不存在，引发一个异常。 默认实现只是从你从get_unit_support_points()得到的数组中返回相应的元素，但是派生元素可以重载这个函数。特别要注意的是，FESystem类重载了它，这样它就可以返回单个基础元素的支持点，如果不是所有基础元素都定义了支持点的话。这样，即使get_unit_support_points()只返回一个空数组，你仍然可以要求获得某些支持点。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a59ff9c9724937205d201b35a97fa8eb1">FESystem&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01096">1096</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a62ccbc59eb1eed98078b686568227c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ccbc59eb1eed98078b686568227c98">&#9670;&nbsp;</a></span>get_unit_face_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt; &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_unit_face_support_points </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果派生有限元定义了一些支持点，则返回单元面上的试探函数的支持点。 允许某种插值操作的有限元通常有支持点。另一方面，通过例如面的矩或导数来定义自由度的元素没有支持点。在这种情况下，返回的字段是空的 请注意，有支持点的元素不一定在面上有一些支持点，即使插值点在面上有物理位置。例如，不连续元素的插值点在顶点上，对于更高程度的元素也在面上，但它们没有被定义在面上，因为在这种情况下，来自面的两边（或来自顶点的所有相邻元素）的自由度将相互识别，这不是我们想要的）。因此在逻辑上，这些自由度被定义为属于单元，而不是属于面或顶点。 在这种情况下，返回的元素的长度将为零。 如果有限元定义了支持点，那么它们的数量就等于面的自由度数量（::dofs_per_face）。数组中的点的顺序与&lt;tt&gt;cell-&gt;face(face)-&gt;get_dof_indices函数返回的顺序一致。 关于支持点的详细信息，请参见类的文档。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01108">1108</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a40e0ebd1082fd37318aac7c5b69c99ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e0ebd1082fd37318aac7c5b69c99ba">&#9670;&nbsp;</a></span>has_face_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_face_support_points </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个有限元是否在面上定义了支持点。如果结果为真，那么调用get_unit_face_support_points()就会产生一个非空的向量。 更多信息请参见has_support_points()函数的文档。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01127">1127</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a76a38445c29e48889bcca49674f3be92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a38445c29e48889bcca49674f3be92">&#9670;&nbsp;</a></span>unit_face_support_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_face_support_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与unit_support_point()函数相对应的函数，但针对面。更多信息见那里。 </p>

<p>Reimplemented in <a class="el" href="classFESystem.html#a35f156493477b5e69ca8388e30f1a28d">FESystem&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01138">1138</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="acd7d4db3494e48ce40d49da6f2c7d4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7d4db3494e48ce40d49da6f2c7d4b2">&#9670;&nbsp;</a></span>get_generalized_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &amp; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_generalized_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个广义支持点的向量。 </p><dl class="section note"><dt>Note</dt><dd>该函数返回的向量总是唯一*支持点的最小集合。这与get_unit_support_points()的行为相反，后者对于一个有许多（拉格朗日）基元的FESystem来说，返回一个重复的单位支持点列表。 更多信息请参见 广义支持点的词汇表条目 。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01074">1074</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a4d7a3e41b44869ce600ae0b3a98b5b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7a3e41b44869ce600ae0b3a98b5b4e">&#9670;&nbsp;</a></span>has_generalized_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::has_generalized_support_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个有限元是否有定义的广义支持点。如果结果为真，那么调用get_generalized_support_points()就会产生一个非空的向量。 更多信息请参见 广义支持点的词汇条 。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01087">1087</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ae0ea3780c7d2e6140141a9afcbc421f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ea3780c7d2e6140141a9afcbc421f4">&#9670;&nbsp;</a></span>get_associated_geometry_primitive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGeometryPrimitive.html">GeometryPrimitive</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_associated_geometry_primitive </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_dof_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于一个给定的自由度，返回它是否与顶点、直线、四边形或六边形有逻辑联系。 例如，对于连续有限元来说，这与自由度的支持点所处的最低维度对象相吻合。举个例子，对于3D的 \(Q_1\) 元素，每个自由度都由一个形状函数定义，我们通过使用位于单元顶点的支持点进行内插得到。这些点的支持当然延伸到与这个顶点相连的所有边，以及相邻的面和单元内部，但我们说逻辑上自由度是与顶点相关的，因为这是它所关联的最低维度的对象。同样，对于3D中的 \(Q_2\) 元素，支持点位于边缘中点的自由度将从这个函数中得到 <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2a65afbb3592220b91df58e72e858050f4">GeometryPrimitive::line</a> 的值，而那些位于3D中面的中心的自由度将返回 <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2aeeed229077b068966c4edd2ff537b995">GeometryPrimitive::quad</a>. 。 为了使之更加正式，这个函数返回的对象种类代表了该对象，因此，对应于自由度的形状函数的支持，（即该函数 "生存
"的领域的那一部分）是所有共享该对象的单元的联盟。回到上面的例子，对于3D中的 \(Q_2\) ，支持点位于边缘中点的形状函数在所有共享边缘的单元上都有支持，而不仅仅是共享相邻面的单元，因此函数将返回 <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2a65afbb3592220b91df58e72e858050f4">GeometryPrimitive::line</a>. 另一方面，对于 \(DGQ_2\) 类型的不连续元素，与内插多项式相关的自由度，其支持点物理上位于一个单元的边界线上，但只在一个单元上非零。因此，它在逻辑上与该单元的内部相关联（即，与2d中的 <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2aeeed229077b068966c4edd2ff537b995">GeometryPrimitive::quad</a> 和3d中的 <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2acbbe64bcc53f9747fcf5ff863d59fe14">GeometryPrimitive::hex</a> 相关）。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_dof_index</td><td>一个形状函数或自由度的索引。这个索引必须在 <code>[0,dofs_per_cell)</code> 的范围内。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>这个函数返回的对象的整数值等于它所描述的对象的维度，因此可以在通用编程范式中使用。例如，如果一个自由度与一个顶点相关联，那么这个函数返回 <a class="el" href="classGeometryPrimitive.html#a8e0cad3ba3bc8f9cbe7fb4e8eaed66a2af5e3dcc6059fdf418fc23763c0224d9f">GeometryPrimitive::vertex</a>, ，其数值为0（顶点的维度）。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02730">2730</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a97e71a320cf0c2bcb0d0d9d8447aaa34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e71a320cf0c2bcb0d0d9d8447aaa34">&#9670;&nbsp;</a></span>convert_generalized_support_point_values_to_dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::convert_generalized_support_point_values_to_dof_values </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_point_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodal_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定参考单元的（广义）支持点的函数值 \(f(\mathbf x)\) ，然后该函数计算元素的节点值是什么，即 \(\Psi_i[f]\) ，其中 \(\Psi_i\) 是元素的节点函数（另见 <a class="el" href="DEALGlossary.html#GlossNodes">节点值或节点函数</a> ）。 然后，值 \(\Psi_i[f]\) 是<em>interpolates</em>给定函数 \(f(x)\) 的有限元函数的形状函数的扩展系数，即， \( f_h(\mathbf x) = \sum_i \Psi_i[f] \varphi_i(\mathbf x) \) 是 \(f\) 与当前元素的有限元插值。 这里描述的操作，例如在 <a class="el" href="namespaceFETools.html#a9f31747a809637e571e11c146d9bec0a">FETools::compute_node_matrix()</a> 函数中使用。 更详细地说，让我们假设当前元素的广义支持点（见 本词汇表条目 ）是 \(\hat{\mathbf x}_i\) ，与当前元素相关的节点函数是 \(\Psi_i[\cdot]\) 。然后，该元素基于广义支持点的事实意味着，如果我们将 \(\Psi_i\) 应用于（可能是矢量值的）有限元函数 \(\varphi\) ，结果必须具有 \(\Psi_i[\varphi] = f_i(\varphi(\hat{\mathbf x}_i))\) 的形式。</p>
<p>-换句话说，节点函数 \(\Psi_i\) 应用于 \(\varphi\) <em>only</em>的值取决于<em>values of \(\varphi\) at \(\hat{\mathbf x}_i\)</em>，而不是取决于其他地方的值，或 \(\varphi\) 的积分，或任何其他类型的信息。 \(f_i\) 的确切形式取决于元素。例如，对于标量 拉格朗日元素 ，我们有，事实上 \(\Psi_i[\varphi] = \varphi(\hat{\mathbf x}_i)\) 。如果你通过FESystem对象组合多个标量拉格朗日元素，那么 \(\Psi_i[\varphi] = \varphi(\hat{\mathbf x}_i)_{c(i)}\) 其中 \(c(i)\) 是 <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">FiniteElement::system_to_component_index()</a> 函数的返回值的第一个分量的结果。因此，在这两种情况下， \(f_i\) 只是身份（在标量情况下）或选择其参数的特定向量分量的函数。 另一方面，对于Raviart-Thomas元素，人们会认为 \(f_i(\mathbf y) = \mathbf y \cdot \mathbf n_i\) ，其中 \(\mathbf n_i\) 是定义形状函数的面的法向量。 鉴于所有这些，这个函数的作用如下。如果你输入一个在所有广义支持点的函数 \(\varphi\) 的值的列表（其中每个值实际上是一个值的向量，其分量与元素的分量一样多），那么这个函数返回一个通过对这些值应用节点函数得到的值的向量。换句话说，如果你传入 \(\{\varphi(\hat{\mathbf x}_i)\}_{i=0}^{N-1}\) 那么你将得到一个向量 \(\{\Psi[\varphi]\}_{i=0}^{N-1}\) 其中 \(N\) 等于 <code>dofs_per_cell</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">support_point_values</td><td>一个大小为 <code>dofs_per_cell</code> 的数组（等于 <a class="el" href="classFiniteElement.html#acd7d4db3494e48ce40d49da6f2c7d4b2">get_generalized_support_points()</a> 函数将返回的点数），每个元素是一个向量，其条目数量与该元素的向量成分相同。这个数组应该包含一个函数在当前元素的广义支持点的值。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodal_values</td><td>一个大小为 <code>dofs_per_cell</code> 的数组，包含应用于给定函数的元素的节点函数值。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>只有对于具有琐碎的MappingKind的元素，在实数单元上调用这个函数（转换后的）值是安全的。对于所有其他元素（例如符合H(curl)或H(div)的元素），向量值必须首先被转换到参考单元。 </dd>
<dd>
鉴于该函数应该做什么，该函数显然只能对实际实现（广义）支持点的元素起作用。没有广义支持点的元素</dd></dl>
<ul>
<li>例如，节点函数评估积分或函数矩的元素（如FE_Q_Hierarchical）。</li>
<li>一般来说不能理解这个函数所需的操作。因此，他们可能不会实现它。 </li>
</ul>

<p>Reimplemented in <a class="el" href="classFESystem.html#a4fffa81396f85e6a7b6b1ff6923b21a2">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q.html#a1c6146a0d1500b3f19fa69e790fababb">FE_Q&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__DGQArbitraryNodes.html#a939ddf504a5aa754364807e7a03664ee">FE_DGQArbitraryNodes&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Q__DG0.html#a6692463a98b782ab01d1ec782cc24ca0">FE_Q_DG0&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomasNodal.html#a928d6cb672c11753f40f99aeaafe3503">FE_RaviartThomasNodal&lt; dim &gt;</a>, <a class="el" href="classFE__DGQ.html#a3f09b22c8282190b43747b14df94a730">FE_DGQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Nedelec.html#a3de35ecf4a0ca524320fdbc42eb45f11">FE_Nedelec&lt; dim &gt;</a>, <a class="el" href="classFE__SimplexPoly.html#ab430c027125d420cfa98abafcc3efe0f">FE_SimplexPoly&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RaviartThomas.html#a0709d9daa417865bebb18a10d89a6827">FE_RaviartThomas&lt; dim &gt;</a>, <a class="el" href="classFE__Q__Bubbles.html#af07fc5823bfe5ca421eee2f73e128d9a">FE_Q_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__BernardiRaugel.html#a0c08e11df7f48de0c9e4717eec782d1d">FE_BernardiRaugel&lt; dim &gt;</a>, <a class="el" href="classFE__Q__iso__Q1.html#add375c9f1c1c9ebff7f84d50b52cc267">FE_Q_iso_Q1&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__ABF.html#a6c28f32bc75b377fb85d9f6e25795343">FE_ABF&lt; dim &gt;</a>, <a class="el" href="classFE__RT__Bubbles.html#a0bccf91eea36e8972c3931d740cfe7dd">FE_RT_Bubbles&lt; dim &gt;</a>, <a class="el" href="classFE__SimplexP__Bubbles.html#a134459dac94d317597b079331cbfa126">FE_SimplexP_Bubbles&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__RannacherTurek.html#ab3998174a9d2c6285054caee53a14d10">FE_RannacherTurek&lt; dim &gt;</a>, <a class="el" href="classFE__BDM.html#ac8fcdb63931aff1ce57b4276087361ec">FE_BDM&lt; dim &gt;</a>, <a class="el" href="classFE__FaceQ.html#ae065335d5db68ec635b9b3772f0b73fb">FE_FaceQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classFE__TraceQ.html#ab1c612b8b7a53ae57da80f04accd5268">FE_TraceQ&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01229">1229</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a62838f7428ee56e34c4081ca6d03bc26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62838f7428ee56e34c4081ca6d03bc26">&#9670;&nbsp;</a></span>reinit_restriction_and_prolongation_matrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::reinit_restriction_and_prolongation_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isotropic_restriction_only</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isotropic_prolongation_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将限制矩阵和延长矩阵的向量重设为正确的大小。对于每个细化案例，除了 <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase::no_refinement</a>, 和该细化案例的每个子案例，都会分配一个限制和延长矩阵的空间，关于实际的向量大小，请看限制和延长向量的文档。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isotropic_restriction_only</td><td>只有各向同性细化所需的限制矩阵被重新引用到合适的大小。 </td></tr>
    <tr><td class="paramname">isotropic_prolongation_only</td><td>只有各向同性细化所需的延长矩阵被重新引用到正确的大小。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00303">303</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ab1d72dc54ae8d760b3c9c4e5ce0f96c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d72dc54ae8d760b3c9c4e5ce0f96c4">&#9670;&nbsp;</a></span>interface_constraints_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableIndices.html">TableIndices</a>&lt; 2 &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::interface_constraints_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回接口约束矩阵的大小。由于每个派生的有限元类在初始化它们的尺寸时都需要这个，所以它被放在这个函数中，以避免每次都要重新计算这些矩阵的与尺寸有关的尺寸。 注意，有些元素没有实现某些多项式程度的接口约束。在这种情况下，这个函数仍然返回这些矩阵实现时应该有的大小，但实际的矩阵是空的。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l00899">899</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="ac7b5101c0c081760e5402767aed14c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b5101c0c081760e5402767aed14c0c">&#9670;&nbsp;</a></span>compute_n_nonzero_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::compute_n_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nonzero_components</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给出每个形状函数的非零分量的模式，为每个条目计算每个形状函数有多少分量是非零的。 这个函数在这个类的构造函数中使用。 </p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01267">1267</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a0d7236d243e42448327e719a9ea66a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7236d243e42448327e719a9ea66a81">&#9670;&nbsp;</a></span>get_face_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>像get_data()一样，但是返回一个对象，该对象以后将被用于评估单元格面上正交点的形状函数信息。然后该对象将被用于调用 <a class="el" href="classFiniteElement.html#a7c5fd937dc322e6028f60c30fc65f185">FiniteElement::fill_fe_face_values()</a>. 的实现，更多信息请参见get_data()的文档。 这个函数的默认实现将面的正交转换为具有适当正交点位置的单元格正交，并以此调用上述必须在派生类中实现的get_data()函数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">update_flags</td><td>一组UpdateFlags值，描述FEValues对象要求有限元计算哪种信息。这组标志也可以包括有限元不能计算的信息，例如，与映射产生的数据有关的标志。这个函数的实现需要在返回的对象中设置所有的数据字段，这些字段是产生这些标志所指定的有限元相关数据所必需的，并且可能已经预先计算了这些信息的一部分，如上文所述。元素可能希望在 <a class="el" href="classFiniteElement_1_1InternalDataBase.html#a99c4ead335ec713b3f9b3cdc8b5a1f40">InternalDataBase::update_each</a> 中存储这些更新标志（或这些标志的子集），以便在调用 <a class="el" href="classFiniteElement.html#a7c5fd937dc322e6028f60c30fc65f185">FiniteElement::fill_fe_face_values()</a> 时知道他们应该计算什么 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">映射</td><td>对用于计算形状函数的值和导数的映射的引用。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">正交</td><td>指对描述形状函数应被评估的对象的引用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>对FEValues将与此处返回的对象一起使用的对象的引用， <a class="el" href="classFiniteElement.html#a7c5fd937dc322e6028f60c30fc65f185">FiniteElement::fill_fe_face_values()</a> 的实现将在此处放置所要求的信息。这允许当前函数已经预先计算了可以在参考单元上计算的信息，如上所述。FEValues保证这个输出对象和当前函数返回的对象将总是一起使用。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个指向从InternalDataBase派生的类型的对象的指针，派生类可以用它来存储可以预先计算的抓取数据，或者用于抓取数组，然后只需要分配一次。 调用网站承担这个对象的所有权，并在不再需要时将其删除。 </dd></dl>

<p>Reimplemented in <a class="el" href="classFESystem.html#a1a69b6a5609cd010d1db0fdcb906a02f">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a3691e05f88f1db78fbd232d130692e8a">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a1b2ccb51d1367ebc4db1803503eb4c88">FE_PolyFace&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#a1b2ccb51d1367ebc4db1803503eb4c88">FE_PolyFace&lt; TensorProductPolynomials&lt; dim - 1 &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__PolyFace.html#a1b2ccb51d1367ebc4db1803503eb4c88">FE_PolyFace&lt; PolynomialSpace&lt; dim - 1 &gt;, dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a7e2f79f305092a89472245fb9ee4cdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2f79f305092a89472245fb9ee4cdf7">&#9670;&nbsp;</a></span>get_face_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>使用带有 <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> 参数的版本。</dd></dl>

</div>
</div>
<a id="af8d025c0e209ea71e8247eadb5f78b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d025c0e209ea71e8247eadb5f78b38">&#9670;&nbsp;</a></span>get_subface_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::<a class="el" href="classFiniteElement_1_1InternalDataBase.html">InternalDataBase</a> &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::get_subface_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与get_data()类似，但返回一个对象，该对象以后将用于评估单元格面子上的正交点的形状函数信息。该对象随后将被用于调用 <a class="el" href="classFiniteElement.html#ace7af117168f8d0fdb4bbdd516373625">FiniteElement::fill_fe_subface_values()</a>. 的实现，更多信息请参见get_data()的文档。 该函数的默认实现将面的正交转换为具有适当正交点位置的单元格正交，并以此调用上述必须在派生类中实现的get_data()函数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">update_flags</td><td>一组UpdateFlags值，描述FEValues对象要求有限元计算哪种信息。这组标志也可以包括有限元不能计算的信息，例如，与映射产生的数据有关的标志。这个函数的实现需要在返回的对象中设置所有的数据字段，这些字段是产生这些标志所指定的有限元相关数据所必需的，并且可能已经预先计算了这些信息的一部分，如上文所述。元素可能希望在 <a class="el" href="classFiniteElement_1_1InternalDataBase.html#a99c4ead335ec713b3f9b3cdc8b5a1f40">InternalDataBase::update_each</a> 中存储这些更新标志（或这些标志的子集），以便在 <a class="el" href="classFiniteElement.html#ace7af117168f8d0fdb4bbdd516373625">FiniteElement::fill_fe_subface_values()</a> 被调用时知道他们应该计算什么 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">映射</td><td>对用于计算形状函数的值和导数的映射的引用。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>对描述形状函数应被评估的对象的引用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>对对象的引用，FEValues将与这里返回的对象一起使用， <a class="el" href="classFiniteElement.html#ace7af117168f8d0fdb4bbdd516373625">FiniteElement::fill_fe_subface_values()</a> 的实现将在这里放置所需的信息。这允许当前函数已经预先计算了可以在参考单元上计算的信息，如上所述。FEValues保证这个输出对象和当前函数返回的对象将总是一起使用。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个指向从InternalDataBase派生的类型的对象的指针，派生类可以用它来存储可以预先计算的抓取数据，或者用于抓取数组，然后只需要分配一次。 调用网站承担这个对象的所有权，并在不再需要时将其删除。 </dd></dl>

<p>Reimplemented in <a class="el" href="classFESystem.html#ab12fe280e7d0b92e65a94381221ccb0b">FESystem&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__Enriched.html#a6c050155e5158fbb17f9283e85b8ac2e">FE_Enriched&lt; dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#afff6983e489d1feb1914dcc687939c86">FE_PolyFace&lt; PolynomialType, dim, spacedim &gt;</a>, <a class="el" href="classFE__PolyFace.html#afff6983e489d1feb1914dcc687939c86">FE_PolyFace&lt; TensorProductPolynomials&lt; dim - 1 &gt;, dim, spacedim &gt;</a>, and <a class="el" href="classFE__PolyFace.html#afff6983e489d1feb1914dcc687939c86">FE_PolyFace&lt; PolynomialSpace&lt; dim - 1 &gt;, dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="fe_8cc_source.html#l01383">1383</a> of file <a class="el" href="fe_8cc_source.html">fe.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a60aed438915b7d8d37b2a45c902e6bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60aed438915b7d8d37b2a45c902e6bfe">&#9670;&nbsp;</a></span>reference_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classReferenceCell.html">ReferenceCell</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::reference_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个元素所定义的参考单元的种类。例如，该元素的参考单元是正方形还是三角形，或更高维度的类似选择。 </p>

</div>
</div>
<a id="a5cfd4619615520b8446ac853826a7d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfd4619615520b8446ac853826a7d4c">&#9670;&nbsp;</a></span>n_unique_quads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_unique_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>唯一的四边形的数量。如果所有的四边形都有相同的类型，该值为1；否则等于四边形的数量。 </p>

</div>
</div>
<a id="ad6081492e85d34bbfbd334423e31ce42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6081492e85d34bbfbd334423e31ce42">&#9670;&nbsp;</a></span>n_unique_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_unique_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>独特的面的数量。如果所有的面都有相同的类型，值是1；否则等于面的数量。 </p>

</div>
</div>
<a id="a0d1f06778f87a7606cc2e0d5338b41ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1f06778f87a7606cc2e0d5338b41ab">&#9670;&nbsp;</a></span>n_dofs_per_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_dofs_per_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>每个顶点的道夫数。 </p>

</div>
</div>
<a id="a384464e3b59fe91485f603dc32db7dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384464e3b59fe91485f603dc32db7dd1">&#9670;&nbsp;</a></span>n_dofs_per_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_dofs_per_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>每行的道夫数。不包括低维物体上的道夫。 </p>

</div>
</div>
<a id="ad8259242b27dc19222cde2016a99dba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8259242b27dc19222cde2016a99dba2">&#9670;&nbsp;</a></span>n_dofs_per_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_dofs_per_quad </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>每个四边形的道夫数。不包括低维物体上的道夫。 </p>

</div>
</div>
<a id="aa32508c87a3850e94e59193f14c52d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32508c87a3850e94e59193f14c52d6f">&#9670;&nbsp;</a></span>max_dofs_per_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::max_dofs_per_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>每个四边形的最多道夫数。不包括低维物体上的道夫。 </p>

</div>
</div>
<a id="aecb7465f62a849481ae0bf5edc78ec7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb7465f62a849481ae0bf5edc78ec7d">&#9670;&nbsp;</a></span>n_dofs_per_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_dofs_per_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>每个六面体的道夫数。不包括低维物体上的道夫。 </p>

</div>
</div>
<a id="a4a5f5b1fc401af61dafc61d083f5ae7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5f5b1fc401af61dafc61d083f5ae7b">&#9670;&nbsp;</a></span>n_dofs_per_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_dofs_per_face </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>child</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>每个面的度数，累积所有低维物体的自由度。 </p>

</div>
</div>
<a id="a54eef7c23041e6750f0a71c2ca3028bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54eef7c23041e6750f0a71c2ca3028bd">&#9670;&nbsp;</a></span>max_dofs_per_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::max_dofs_per_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>每个面的最大度数，累积所有低维物体的自由度。 </p>

</div>
</div>
<a id="a33b522422da89e5c080e7405ad49d7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b522422da89e5c080e7405ad49d7c7">&#9670;&nbsp;</a></span>n_dofs_per_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_dofs_per_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>每个单元的自由度数，累积所有低维物体的自由度。 </p>

</div>
</div>
<a id="a6dc6a1e69b9c6594f6f08338d11ceb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc6a1e69b9c6594f6f08338d11ceb43">&#9670;&nbsp;</a></span>n_dofs_per_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int structdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_dofs_per_object </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回每个structdim维度对象的度数。对于 structdim==0，该函数因此返回 dofs_per_vertex，对于 structdim==1 dofs_per_line，等等。这个函数主要用于允许一些模板技巧，这些函数应该在各种对象上工作，而不想使用与这些对象相关的不同名称（顶点、线...）。 </p>

</div>
</div>
<a id="a5a698695065333035e493294ce92820e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a698695065333035e493294ce92820e">&#9670;&nbsp;</a></span>n_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>组件的数量。参见 <a class="el" href="DEALGlossary.html#GlossComponent">术语表 </a> 以获得更多信息。 </p>

</div>
</div>
<a id="a4c1c4ca934f26ff463caf35a574e9f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1c4ca934f26ff463caf35a574e9f14">&#9670;&nbsp;</a></span>n_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::n_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>块的数量。参见 术语表  以了解更多信息。 </p>

</div>
</div>
<a id="ab6b11a9d43bf383bb38953fd50dba34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b11a9d43bf383bb38953fd50dba34b">&#9670;&nbsp;</a></span>block_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&amp; <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::block_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>关于区块大小的详细信息。 </p>

</div>
</div>
<a id="a584a56a1611a86a04c8b9a26d0eb9f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584a56a1611a86a04c8b9a26d0eb9f27">&#9670;&nbsp;</a></span>tensor_degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::tensor_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>形状函数在单一坐标方向上的最大多项式程度。 这个函数可用于确定最佳正交规则。 </p>

</div>
</div>
<a id="a18e928460be93a004559b841f35ad698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e928460be93a004559b841f35ad698">&#9670;&nbsp;</a></span>conforms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::conforms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>测试一个有限元空间是否符合某个Sobolev空间。 </p><dl class="section note"><dt>Note</dt><dd>即使有限元空间具有比要求的更高的规则性，这个函数也会返回一个真值。 </dd></dl>

</div>
</div>
<a id="a078fb199880f2b29fc72d9c01d317bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078fb199880f2b29fc72d9c01d317bd0">&#9670;&nbsp;</a></span>get_first_line_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::get_first_line_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一行中dof的第一个索引。 </p>

</div>
</div>
<a id="a3a1b484c2e7afda2efaa11e7e31b5bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1b484c2e7afda2efaa11e7e31b5bbf">&#9670;&nbsp;</a></span>get_first_quad_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::get_first_quad_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_no</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回四边形上的第一个索引。 </p>

</div>
</div>
<a id="aff4361f6bf7db70f4961e67ddf97ebf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4361f6bf7db70f4961e67ddf97ebf8">&#9670;&nbsp;</a></span>get_first_hex_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::get_first_hex_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回六面体上的第一个索引。 </p>

</div>
</div>
<a id="a859d429b3a7a847713c6d2528c3f2e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859d429b3a7a847713c6d2528c3f2e97">&#9670;&nbsp;</a></span>get_first_face_line_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::get_first_face_line_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回面的数据在一条线上的第一个索引。 </p>

</div>
</div>
<a id="a9f2166738fc6fda9ef70988179d8d569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2166738fc6fda9ef70988179d8d569">&#9670;&nbsp;</a></span>get_first_face_quad_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::get_first_face_quad_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个四面体上的脸部数据的第一个索引。 </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abeecf4df065ca5f5701ba1190a190631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeecf4df065ca5f5701ba1190a190631">&#9670;&nbsp;</a></span>mapping_kind</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::mapping_kind</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用来将形状函数从参考单元映射到网格单元的映射类型。如果这个向量的长度为1，所有的形状函数都将采用相同的映射。如果向量的大小等于每个单元的有限元度数，那么每个形状函数将根据向量中的相应条目进行映射。 </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00174">174</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="a20234bd8b6c97e450bb3c0efcd836198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20234bd8b6c97e450bb3c0efcd836198">&#9670;&nbsp;</a></span>adjust_quad_dof_sign_for_face_orientation_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTable.html">Table</a>&lt;2, <a class="el" href="classbool.html">bool</a>&gt; &gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::adjust_quad_dof_sign_for_face_orientation_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00200">200</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="ae45a96809bedb741904aebe616a32ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45a96809bedb741904aebe616a32ba2">&#9670;&nbsp;</a></span>poly_space</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unique_ptr&lt;const <a class="el" href="classTensorPolynomialsBase.html">TensorPolynomialsBase</a>&lt;dim&gt; &gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::poly_space</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>传递给构造函数的对象的副本，描述多项式空间。 </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00450">450</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="a38c73bd10d9b2b3c8d11e390c23b1b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c73bd10d9b2b3c8d11e390c23b1b7e">&#9670;&nbsp;</a></span>inverse_node_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::inverse_node_matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>应用于多项式<em>p<sub>j</sub></em>的节点值<em>N<sub>i</sub></em>的矩阵<em>a<sub>ij</sub></em>的倒数。这个矩阵用于将::poly_space中提供的 "原始
"基础中的多项式转换为参考单元上的节点函数的对偶基础。 这个对象不是由FE_PolyTensor填充的，而是一个派生类允许重组基函数的机会。如果它留空，则使用::poly_space中的基础。 </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00459">459</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="a188e364c278533b4b319f702390322fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188e364c278533b4b319f702390322fd">&#9670;&nbsp;</a></span>cache_mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::cache_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个mutex，用来保护对下面的变量的访问。 </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00465">465</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="a6f3728ea2a8d8d8744ebe14bdf6cbb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3728ea2a8d8d8744ebe14bdf6cbb31">&#9670;&nbsp;</a></span>cached_point</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;dim&gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::cached_point</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果一个形状函数是在一个点上计算的，我们必须计算所有的形状函数来应用::inverse_node_matrix。为了避免过多的开销，我们对点和函数值进行缓存，以便下次评估。 </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00471">471</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="adb75d35170b98b1ba99090e566f6c5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb75d35170b98b1ba99090e566f6c5cd">&#9670;&nbsp;</a></span>cached_values</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;1, dim&gt; &gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::cached_values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>调用shape_value_component()后缓存的形状函数值。 </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00477">477</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="a306eab3ba19d1b62dd82b4126f466d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306eab3ba19d1b62dd82b4126f466d55">&#9670;&nbsp;</a></span>cached_grads</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;2, dim&gt; &gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::cached_grads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>调用shape_grad_component()后缓存的形状函数梯度。 </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00483">483</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="af14cdfca59390a4e648da7a0c7bee0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14cdfca59390a4e648da7a0c7bee0b7">&#9670;&nbsp;</a></span>cached_grad_grads</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;3, dim&gt; &gt; <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a>&lt; dim, spacedim &gt;::cached_grad_grads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在调用shape_grad_grad_component()后缓存形状函数的二阶导数。 </p>

<p class="definition">Definition at line <a class="el" href="fe__poly__tensor_8h_source.html#l00489">489</a> of file <a class="el" href="fe__poly__tensor_8h_source.html">fe_poly_tensor.h</a>.</p>

</div>
</div>
<a id="a577195e2fad97018b5dccb837952dad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577195e2fad97018b5dccb837952dad7">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>图像空间的维度，对应于三角法。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l00779">779</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a4993707a4ec342560ff74e5d22401794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4993707a4ec342560ff74e5d22401794">&#9670;&nbsp;</a></span>restriction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>投影矩阵的矢量。参见上面的get_restriction_matrix()。构造函数将这些矩阵初始化为零维，这可以由实现它们的派生类来改变。 注意， <code>restriction[refinement_case-1][child]</code> 包括了子类 <code>child</code> 对RefinementCase <code>refinement_case</code>. Here, we use <code>refinement_case-1</code> 的限制矩阵，而不是 <code>refinement_case</code> ，因为对于 <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase::no_refinement</a>(=0) 没有限制矩阵可用。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l01990">1990</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="afbc42f850096c429fd39cfcbde1b6b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc42f850096c429fd39cfcbde1b6b56">&#9670;&nbsp;</a></span>prolongation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::prolongation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>嵌入矩阵的矢量。见上面的<code><a class="el" href="classFiniteElement.html#a3a4671144d9976b133c4f79c9aefdd7c">get_prolongation_matrix()</a></code>。构造函数将这些矩阵初始化为零维，这可以由实现它们的派生类来改变。 注意， <code>prolongation[refinement_case-1][child]</code> 包括RefinementCase <code>refinement_case</code> 的子 <code>child</code> 的延长矩阵。这里，我们使用 <code>refinement_case-1</code> instead of <code>refinement_case</code> ，因为对于 <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase::no_refinement</a>(=0) ，没有可用的延长矩阵。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02002">2002</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ac8d4cd5afce6a401892aeb5a40ccfa2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d4cd5afce6a401892aeb5a40ccfa2f">&#9670;&nbsp;</a></span>interface_constraints</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::interface_constraints</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果线连接两个单元，其中一个单元被精炼过一次，则指定单元界面两边的道夫所依据的约束。 进一步的细节见派生类的一般描述。 这个字段在一维中显然是无用的，在那里有一个零尺寸。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02010">2010</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ab4f6e0c83686b918fbb92716ead92313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f6e0c83686b918fbb92716ead92313">&#9670;&nbsp;</a></span>unit_support_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>单元上的支持点的列表，如果有限元有任何支持点的话。构造函数让这个字段为空，派生类可以写入一些内容。 允许某种插值操作的有限元通常有支持点。另一方面，通过例如面的力矩或导数来定义自由度的元素没有支持点。在这种情况下，这个区域仍然是空的。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02017">2017</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a1cab5fe59b82da1fc25e1454b12c4fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cab5fe59b82da1fc25e1454b12c4fa9">&#9670;&nbsp;</a></span>unit_face_support_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim - 1&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::unit_face_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对面的情况也一样。参见get_unit_face_support_points()函数的描述，以讨论什么有助于面的支持点。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02023">2023</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ae2531d00b5c9e77e1e64981864c3b8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2531d00b5c9e77e1e64981864c3b8cc">&#9670;&nbsp;</a></span>generalized_support_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::generalized_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用于非拉格朗日元素的插值函数的支持点。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02029">2029</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a646b0f9a97e1df8fc14f9305149ed525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646b0f9a97e1df8fc14f9305149ed525">&#9670;&nbsp;</a></span>generalized_face_support_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim - 1&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::generalized_face_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用于非拉格朗日元素插值函数的面支持点。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02035">2035</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a5592f17f6c16d325de2d30f1cc051eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5592f17f6c16d325de2d30f1cc051eeb">&#9670;&nbsp;</a></span>adjust_quad_dof_index_for_face_orientation_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTable.html">Table</a>&lt;2, <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_quad_dof_index_for_face_orientation_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于在三维中具有非标准面的方向的面，面（四边形）上的道夫必须被移位，以便与正确的形状函数相结合。给定一个四边形上的局部目标 <code>index</code> ，如果该面具有非标准的面朝向，即 <code>old_index</p><ul>
<li>shift = new_index ，则返回局部索引的移动。在二维和一维中，不需要进行置换，所以这个向量是空的。在三维中，它的大小为 <code> <a class="el" href="classFiniteElementData.html#a00ab27b2dfa5520f2aa56f9bb8223878">dofs_per_quad</a> 8 </code> ，其中8是方向的数量，一个脸可以在（face_orientation、face_flip和face_rotation三个bool标志的所有组合）。 这个类的构造函数将这个表填上零，也就是说，根本就没有排列组合。派生的有限元类必须用正确的值来填充这个表。 </li>
</ul>
<p></code></p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02047">2047</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a6659bb0dccc62e2d680c964e5035daf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6659bb0dccc62e2d680c964e5035daf6">&#9670;&nbsp;</a></span>adjust_line_dof_index_for_line_orientation_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::adjust_line_dof_index_for_line_orientation_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于三维中具有非标准线方向的线条，线条上的道夫必须被置换，以便与正确的形状函数相结合。给出一条线上的局部道夫 <code>index</code> ，如果该线有非标准的线方向，即 <code>old_index + shift = new_index</code> ，则返回局部索引的移动。在二维和一维中，不需要进行置换，所以这个向量是空的。在三维中，它的大小为::dofs_per_line。 这个类的构造函数用零来填充这个表，也就是说，根本就没有permutation。派生的有限元类必须用正确的值填充这个向量。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02057">2057</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a9af218ae93821b61054de7e88e1734aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af218ae93821b61054de7e88e1734aa">&#9670;&nbsp;</a></span>system_to_component_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_component_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储system_to_component_index()将返回的内容。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02063">2063</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="abc61022ae105ef061458aa5f2d573055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc61022ae105ef061458aa5f2d573055">&#9670;&nbsp;</a></span>face_system_to_component_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_component_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>面上的线性方向和分量方向之间的映射。这在构造函数中是用默认值填充的，但如果有必要，派生类将不得不覆盖这些信息。 我们所说的分量是指向量分量，而不是指基本元素。因此，只有当一个形状函数只在一个分量中非零时，这些信息才有意义。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02071">2071</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a870f688170ad210708077eed94642d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870f688170ad210708077eed94642d73">&#9670;&nbsp;</a></span>system_to_base_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::system_to_base_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于每个形状函数，存储它属于哪个基元和这个基元的哪个实例（如果其倍数大于1），以及它在这个基元中的索引。如果该元素不是由其他元素组成的，那么基元素和实例总是零，而索引等于形状函数的编号。如果该元素是由其他元素的单一实例组成的（即所有的倍数都是1），这些实例都是标量的，那么该元素中的基值和道夫指数就等于::system_to_component_table。只有在该元素由其他元素组成，并且其中至少有一个元素本身是矢量值的情况下，它才会有所不同。 与::system_to_component_table相比，这个数组在向量值（即非原始）形状函数的情况下也有有效值。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02079">2079</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ab4e6a76c64f925c81561745fd6bc12c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e6a76c64f925c81561745fd6bc12c3">&#9670;&nbsp;</a></span>face_system_to_base_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt;std::pair&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::face_system_to_base_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>同样，对于面的指数也是如此。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02087">2087</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a61f62f39ded99d6525f1c33f4227ee8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f62f39ded99d6525f1c33f4227ee8d">&#9670;&nbsp;</a></span>base_to_block_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockIndices.html">BlockIndices</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::base_to_block_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于每个基数元素，存储由基数产生的块数和它将产生的块向量中的第一个块。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02093">2093</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="aaf2c44f3a207e0e11880820a29ac37a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2c44f3a207e0e11880820a29ac37a8">&#9670;&nbsp;</a></span>component_to_base_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::component_to_base_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>基数元素建立一个组件。 对于每个分量编号<code>c</code>，其条目有如下含义。 </p><dl>
<dt><code>table[c].first.first</code> </dt>
<dd><code>c</code>的基础元素的编号。这是你可以传递给base_element()的索引。  </dd>
<dt><code>table[c].first.second</code> </dt>
<dd><code>c</code>的基础元素的组成部分。这个值在0和这个基础元素的n_components()之间。  </dd>
<dt><code>table[c].second</code> </dt>
<dd>包含<code>c</code>的基础元素的倍数索引。这个值在0和这个基础元素的 <a class="el" href="classFiniteElement.html#aa009769e662e34081f60ff16327db1b1">element_multiplicity()</a> 之间。  </dd>
</dl>
<p>这个变量被这个类的构造函数设置为正确的大小，但是需要被派生类初始化，除非它的大小是1，而且唯一的条目是0，对于标量元素就是这样。 在这种情况下，由基类初始化就可以了。 </p><dl class="section note"><dt>Note</dt><dd>此表由 <a class="el" href="namespaceFETools_1_1Compositing.html#abd957d101116d4a8b4c17c0ee16ad202">FETools::Compositing::build_cell_tables()</a>. 填写。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02111">2111</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="aa8f4833a318127b42d2dc806bffe1c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f4833a318127b42d2dc806bffe1c2c">&#9670;&nbsp;</a></span>restriction_is_additive_flags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::restriction_is_additive_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个决定限制矩阵是连接还是相加的标志。更多信息请参见通用类文档中关于限制矩阵的讨论。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02117">2117</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="ae6fe073d1e3ce59791b142067482bd5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6fe073d1e3ce59791b142067482bd5b">&#9670;&nbsp;</a></span>nonzero_components</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classComponentMask.html">ComponentMask</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::nonzero_components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于每个形状函数，给出一个bools的向量（大小等于这个有限元素所具有的向量分量的数量），表明这些形状函数中的每个分量是非零的。 对于原始元素，只有一个非零分量。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02124">2124</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a0b7cb6ef5342900727931ef983636502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7cb6ef5342900727931ef983636502">&#9670;&nbsp;</a></span>n_nonzero_components_table</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::n_nonzero_components_table</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个数组持有::nonzero_components元素各自条目中的多少个值是非零的。因此，这个数组是一个捷径，可以让我们更快地获得这些信息，而不是在每次请求获得这些信息时都要计算非零条目。该字段在该类的构造函数中被初始化。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02130">2130</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="a4124079b6443590608046d8f150574f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4124079b6443590608046d8f150574f6">&#9670;&nbsp;</a></span>cached_primitivity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::cached_primitivity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储所有形状函数是否是原始的。由于找出这个是一个非常常见的操作，我们缓存了这个结果，即在构造函数中计算出这个值，以便更简单地访问。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l02136">2136</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>

</div>
</div>
<a id="af40fa679812dc4fcc76496aa9a139050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40fa679812dc4fcc76496aa9a139050">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>有限元的尺寸，也就是模板参数<code>dim</code>。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00219">219</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="ad82fdeb0955b7d59f32d5371adaaadbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82fdeb0955b7d59f32d5371adaaadbc">&#9670;&nbsp;</a></span>dofs_per_vertex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::dofs_per_vertex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个顶点上的自由度数量。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00245">245</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a490e2ded19c0a8cad0846e07e57e3e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490e2ded19c0a8cad0846e07e57e3e76">&#9670;&nbsp;</a></span>dofs_per_line</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::dofs_per_line</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一条线的自由度数；不包括线的顶点上的自由度。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00251">251</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a00ab27b2dfa5520f2aa56f9bb8223878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ab27b2dfa5520f2aa56f9bb8223878">&#9670;&nbsp;</a></span>dofs_per_quad</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::dofs_per_quad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>四边形的自由度数；不包括四边形的线和顶点的自由度。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00265">265</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a9014d27be7564a42c962848db0d2fd75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9014d27be7564a42c962848db0d2fd75">&#9670;&nbsp;</a></span>dofs_per_hex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::dofs_per_hex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>六面体的自由度数；不包括六面体的四边形、线和顶点上的自由度。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00279">279</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a8c172e26b87c60b3f7e5e3ebf155b62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c172e26b87c60b3f7e5e3ebf155b62e">&#9670;&nbsp;</a></span>first_line_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::first_line_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>线上自由度的第一个索引。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00285">285</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="aca9fc2a37fc1aa814ac73e93baca4bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9fc2a37fc1aa814ac73e93baca4bea">&#9670;&nbsp;</a></span>first_quad_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::first_quad_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个四边形上的第一个自由度的索引。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00299">299</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a649a135f376e3fba63ecf08c2b17cc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649a135f376e3fba63ecf08c2b17cc64">&#9670;&nbsp;</a></span>first_hex_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::first_hex_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>六面体上的第一个索引。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00305">305</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a70cf27d2dabe49e0c1f57954d7d08500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cf27d2dabe49e0c1f57954d7d08500">&#9670;&nbsp;</a></span>first_face_line_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::first_face_line_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>面的数据在一行中的第一个索引。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00319">319</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a0f85f3eae2daee423441fce5e87fa2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f85f3eae2daee423441fce5e87fa2e6">&#9670;&nbsp;</a></span>first_face_quad_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::first_face_quad_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>脸部数据在一个四边形上的第一个索引。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00333">333</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a358bffed1fba59ef4df715469473fd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358bffed1fba59ef4df715469473fd36">&#9670;&nbsp;</a></span>dofs_per_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::dofs_per_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个面的自由度数。这是构成一个面的<code>dim-1</code>以内的所有物体上自由度的累积数。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00347">347</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="ae2fa3b8d578ba488b4f37061bb0278bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fa3b8d578ba488b4f37061bb0278bb">&#9670;&nbsp;</a></span>dofs_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::dofs_per_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个单元上的总自由度数。这是构成一个单元的所有尺寸到<code>dim</code>的对象上的自由度的累积数。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00361">361</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a1ccdb4fd2c40a3e3cd92cb0361cddaf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccdb4fd2c40a3e3cd92cb0361cddaf8">&#9670;&nbsp;</a></span>components</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>该有限元的矢量分量的数量，以及图像空间的维度。对于矢量值的有限元（即当这个数字大于1时），矢量分量的数量在很多情况下等于在FESystem类的帮助下粘在一起的基本元素的数量。然而，对于像Nedelec元素这样的元素，尽管我们只有一个基础元素，但这个数字还是大于1的。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00367">367</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a2cbf5ad6b464871261dbd054bced18a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbf5ad6b464871261dbd054bced18a8">&#9670;&nbsp;</a></span>degree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::degree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>形状函数在单一坐标方向上的最大多项式程度。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00373">373</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="aca702ba3af0ed17eaffcfbbccf82067f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca702ba3af0ed17eaffcfbbccf82067f">&#9670;&nbsp;</a></span>conforming_space</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElementData.html#a0cd5f34c3ab828fac31004f3b52921a1">Conformity</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::conforming_space</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>表示这个元素所符合的空间。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00379">379</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<a id="a9346e3aae3032545c8a94b78a365ffcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9346e3aae3032545c8a94b78a365ffcb">&#9670;&nbsp;</a></span>block_indices_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockIndices.html">BlockIndices</a> <a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;::block_indices_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储一个描述复合元素每个块的尺寸的对象。对于一个不是FESystem的元素，这只包含一个长度为::dofs_per_cell的单一块。 </p>

<p class="definition">Definition at line <a class="el" href="fe__base_8h_source.html#l00385">385</a> of file <a class="el" href="fe__base_8h_source.html">fe_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/fe/<a class="el" href="fe__dg__vector_8h_source.html">fe_dg_vector.h</a></li>
<li>source/fe/<a class="el" href="fe__dg__vector_8cc_source.html">fe_dg_vector.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
