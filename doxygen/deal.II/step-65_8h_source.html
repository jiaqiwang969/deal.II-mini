<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step-65_8h_source.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: doc/doxygen/tutorial/step-65.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_e68e8157741866f444e17edd764ebbae.html">doc</a></li><li class="navelem"><a class="el" href="dir_04f2ecc425faf0d475a3caf484e551f3.html">doxygen</a></li><li class="navelem"><a class="el" href="dir_7f921e14d817774bc32ca4338fe11225.html">tutorial</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">step-65.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="step-65_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; = 0) <span class="keyword">const</span> <span class="keyword">override</span> </div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160; *     { </div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160; *       <span class="keywordflow">if</span> (p.norm_square() &lt; 0.25) </div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160; *         <span class="keywordflow">return</span> p.norm_square(); </div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160; *       <span class="keywordflow">else</span> </div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160; *         <span class="keywordflow">return</span> 0.1 * p.norm_square() + (0.25 - 0.025); </div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160; *     } </div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160; * </div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160; *     <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> </div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160; *     <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaae2b6dfb8a5c48206992d8310d176c37c">gradient</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, </div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160; *              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0) const override </div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160; *     { </div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160; *       <span class="keywordflow">if</span> (p.<a class="code" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a>() &lt; 0.25) </div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160; *         <span class="keywordflow">return</span> 2. * p; </div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160; *       <span class="keywordflow">else</span> </div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160; *         <span class="keywordflow">return</span> 0.2 * p; </div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160; *     } </div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160; *   }; </div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160; * </div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160; *   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160; *   <span class="keywordtype">double</span> coefficient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p) </div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160; *   { </div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160; *     <span class="keywordflow">if</span> (p.norm_square() &lt; 0.25) </div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160; *       <span class="keywordflow">return</span> 0.5; </div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160; *     <span class="keywordflow">else</span> </div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160; *       <span class="keywordflow">return</span> 5.0; </div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160; *   } </div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160; * </div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160; * <span class="keyword">@end</span>code</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160; * </div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160; * </div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160; * &lt;a name=<span class="stringliteral">&quot;ThePoissonProblemclass&quot;</span>&gt;&lt;/a&gt; </div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160; * &lt;h3&gt;The PoissonProblem <span class="keyword">class</span>&lt;/h3&gt;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160; * </div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160; * </div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160; * 泊松问题的实现与我们在  @ref step_5 <span class="stringliteral">&quot;step-5&quot;</span>  教程中使用的非常相似。两个主要的区别是，我们向程序中的各个步骤传递了一个映射对象，以便在两种映射表示法之间进行切换，正如介绍中所解释的那样，还有一个`计时器<span class="stringliteral">&#39;对象（TimerOutput类型），将用于测量各种情况下的运行时间。(映射对象的概念在 @ref step_10 &quot;step-10&quot; 和 @ref step_11 &quot;step-11&quot; 中首次提出，如果你想查一下这些类的用途的话)。</span></div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="stringliteral"> *   template &lt;int dim&gt; </span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="stringliteral"> *   class PoissonProblem </span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="stringliteral"> *   { </span></div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="stringliteral"> *   public: </span></div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="stringliteral"> *     PoissonProblem(); </span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="stringliteral"> *     void run(); </span></div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="stringliteral"> *   private: </span></div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="stringliteral"> *     void create_grid(); </span></div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="stringliteral"> *     void setup_system(const Mapping&lt;dim&gt; &amp;mapping); </span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="stringliteral"> *     void assemble_system(const Mapping&lt;dim&gt; &amp;mapping); </span></div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="stringliteral"> *     void solve(); </span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="stringliteral"> *     void postprocess(const Mapping&lt;dim&gt; &amp;mapping); </span></div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="stringliteral"> *     Triangulation&lt;dim&gt; triangulation; </span></div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="stringliteral"> *     FE_Q&lt;dim&gt;          fe; </span></div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="stringliteral"> *     DoFHandler&lt;dim&gt;    dof_handler; </span></div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="stringliteral"> *     AffineConstraints&lt;double&gt; constraints; </span></div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="stringliteral"> *     SparsityPattern           sparsity_pattern; </span></div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="stringliteral"> *     SparseMatrix&lt;double&gt;      system_matrix; </span></div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="stringliteral"> *     Vector&lt;double&gt;            solution; </span></div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="stringliteral"> *     Vector&lt;double&gt;            system_rhs; </span></div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="stringliteral"> *     TimerOutput timer; </span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="stringliteral"> *   }; </span></div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="stringliteral"> * 在构造函数中，我们设置了定时器对象来记录墙的时间，但在正常执行过程中是安静的。我们将在 `PoissonProblem::run()` 函数中查询它的计时细节。此外，我们为正在使用的有限元选择了一个相对较高的多项式三度。</span></div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="stringliteral"> *   template &lt;int dim&gt; </span></div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="stringliteral"> *   PoissonProblem&lt;dim&gt;::PoissonProblem() </span></div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<span class="stringliteral"> *     : fe(3) </span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;<span class="stringliteral"> *     , dof_handler(triangulation) </span></div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;<span class="stringliteral"> *     , timer(std::cout, TimerOutput::never, TimerOutput::wall_times) </span></div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;<span class="stringliteral"> *   {} </span></div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;<span class="stringliteral"> * &lt;a name=&quot;Gridcreationandinitializationofthemanifolds&quot;&gt;&lt;/a&gt; </span></div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="stringliteral"> * &lt;h3&gt;Grid creation and initialization of the manifolds&lt;/h3&gt;</span></div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;<span class="stringliteral"> * 接下来的函数介绍了TransfiniteInterpolationManifold的典型用法。第一步是创建所需的网格，这可以通过GridGenerator的两个网格的组合来完成。内球网格是很简单的。我们以原点为中心运行 GridGenerator::hyper_cube() ，半径为0.5（第三个函数参数）。第二个网格更有趣，构建方法如下。我们希望有一个在内部是球形的，但在外表面是平的网格。此外，内球的网格拓扑结构应该与外球的网格兼容，即它们的顶点重合，这样才能使两个网格合并起来。从 GridGenerator::hyper_shell 出来的网格满足了内侧的要求，如果它是用 @f$2d@f$ 的粗大单元创建的（在3D中我们将使用6个粗大单元）&amp;ndash；这与球的边界面的单元数量相同。对于外表面，我们利用这样一个事实：没有流形附着的壳表面的6个面将退化为立方体的表面。我们仍然缺少的是外壳边界的半径。由于我们想要一个范围为 @f$[-1, 1]@f$ 的立方体，而6单元壳将其8个外顶点放在8条对角线上，我们必须将点 @f$(\pm 1, \pm 1, \pm 1)@f$ 转化为半径。显然，在 @f$d@f$ 维度上，半径必须是 @f$\sqrt{d}@f$ ，也就是说，对于我们要考虑的三维情况，半径是 @f$\sqrt{3}@f$ 。</span></div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;<span class="stringliteral"> * 这样，我们就有了一个计划。在创建了球的内部三角形和外壳的三角形之后，我们将这两个网格合并，但是将GridGenerator中的函数可能从产生的三角形中设置的所有流形移除，以确保我们对流形有充分的控制。特别是，我们希望在细化过程中在边界上添加的额外点能够遵循平坦的流形描述。为了开始添加更合适的流形ID的过程，我们给所有的网格实体（单元、面、线）分配流形ID 0，这些实体以后将与TransfiniteInterpolationManifold相关联。然后，我们必须识别沿着半径为0.5的球体的面和线，并给它们标记一个不同的流形ID，以便随后给这些面和线分配一个SphericalManifold。由于我们在调用 GridGenerator::hyper_ball(), 后丢弃了所有预先存在的流形，我们手动检查了网格的单元格和所有的面。如果四个顶点的半径都是0.5，我们就在球体上找到了一个面，或者像我们在程序中写的那样，有  @f$r^2-0.25 \approx 0@f$  。注意，我们调用`cell-&gt;face(f)-&gt;set_all_manifold_ids(1)`来设置面和周围线上的流形id。此外，我们希望通过一个材料ID来区分球内和球外的单元，以便于可视化，对应于介绍中的图片。</span></div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;<span class="stringliteral"> *   template &lt;int dim&gt; </span></div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;<span class="stringliteral"> *   void PoissonProblem&lt;dim&gt;::create_grid() </span></div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;<span class="stringliteral"> *   { </span></div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;<span class="stringliteral"> *     Triangulation&lt;dim&gt; tria_inner; </span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;<span class="stringliteral"> *     GridGenerator::hyper_ball(tria_inner, Point&lt;dim&gt;(), 0.5); </span></div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;<span class="stringliteral"> *     Triangulation&lt;dim&gt; tria_outer; </span></div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;<span class="stringliteral"> *     GridGenerator::hyper_shell( </span></div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;<span class="stringliteral"> *       tria_outer, Point&lt;dim&gt;(), 0.5, std::sqrt(dim), 2 * dim); </span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;<span class="stringliteral"> *     GridGenerator::merge_triangulations(tria_inner, tria_outer, triangulation); </span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;<span class="stringliteral"> *     triangulation.reset_all_manifolds(); </span></div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;<span class="stringliteral"> *     triangulation.set_all_manifold_ids(0); </span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;<span class="stringliteral"> *     for (const auto &amp;cell : triangulation.cell_iterators()) </span></div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;<span class="stringliteral"> *       { </span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="stringliteral"> *         for (const auto &amp;face : cell-&gt;face_iterators()) </span></div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="stringliteral"> *           { </span></div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="stringliteral"> *             bool face_at_sphere_boundary = true; </span></div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="stringliteral"> *             for (const auto v : face-&gt;vertex_indices()) </span></div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="stringliteral"> *               { </span></div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="stringliteral"> *                 if (std::abs(face-&gt;vertex(v).norm_square() - 0.25) &gt; 1e-12) </span></div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="stringliteral"> *                   face_at_sphere_boundary = false; </span></div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="stringliteral"> *               } </span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="stringliteral"> *             if (face_at_sphere_boundary) </span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="stringliteral"> *               face-&gt;set_all_manifold_ids(1); </span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="stringliteral"> *           } </span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="stringliteral"> *         if (cell-&gt;center().norm_square() &lt; 0.25) </span></div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="stringliteral"> *           cell-&gt;set_material_id(1); </span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="stringliteral"> *         else </span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;<span class="stringliteral"> *           cell-&gt;set_material_id(0); </span></div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;<span class="stringliteral"> *       } </span></div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;<span class="stringliteral"> * 有了所有单元格、面和线的适当标记，我们可以将流形对象附加到这些数字上。流形ID为1的实体将得到一个球形流形，而流形ID为0的其他实体将被分配到TransfiniteInterpolationManifold。正如介绍中提到的，我们必须通过调用 TransfiniteInterpolationManifold::initialize() 显式初始化当前网格的流形，以获取粗略的网格单元和连接到这些单元边界的流形。我们还注意到，我们在这个函数中本地创建的流形对象是允许超出范围的（就像它们在函数范围结束时那样），因为Triangulation对象在内部复制它们。</span></div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="stringliteral"> * 在连接了所有的流形之后，我们最后将去细化网格几次，以创建一个足够大的测试案例。</span></div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;<span class="stringliteral"> *     triangulation.set_manifold(1, SphericalManifold&lt;dim&gt;()); </span></div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;<span class="stringliteral"> *     TransfiniteInterpolationManifold&lt;dim&gt; transfinite_manifold; </span></div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;<span class="stringliteral"> *     transfinite_manifold.initialize(triangulation); </span></div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;<span class="stringliteral"> *     triangulation.set_manifold(0, transfinite_manifold); </span></div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="stringliteral"> *     triangulation.refine_global(9 - 2 * dim); </span></div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;<span class="stringliteral"> *   } </span></div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;<span class="stringliteral"> * &lt;a name=&quot;Setupofdatastructures&quot;&gt;&lt;/a&gt; </span></div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;<span class="stringliteral"> * &lt;h3&gt;Setup of data structures&lt;/h3&gt;</span></div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="stringliteral"> * 下面的函数在其他教程中是众所周知的，它枚举了自由度，创建了一个约束对象并为线性系统设置了一个稀疏矩阵。唯一值得一提的是，该函数接收了一个映射对象的引用，然后我们将其传递给 VectorTools::interpolate_boundary_values() 函数，以确保我们的边界值在用于装配的高阶网格上被评估。在本例中，这并不重要，因为外表面是平的，但对于弯曲的外单元，这将导致边界值的更精确的近似。</span></div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="stringliteral"> *   template &lt;int dim&gt; </span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="stringliteral"> *   void PoissonProblem&lt;dim&gt;::setup_system(const Mapping&lt;dim&gt; &amp;mapping) </span></div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="stringliteral"> *   { </span></div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="stringliteral"> *     dof_handler.distribute_dofs(fe); </span></div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;<span class="stringliteral"> *     std::cout &lt;&lt; &quot;   Number of active cells:       &quot; </span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="stringliteral"> *               &lt;&lt; triangulation.n_global_active_cells() &lt;&lt; std::endl; </span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="stringliteral"> *     std::cout &lt;&lt; &quot;   Number of degrees of freedom: &quot; &lt;&lt; dof_handler.n_dofs() </span></div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;<span class="stringliteral"> *               &lt;&lt; std::endl; </span></div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="stringliteral"> *     { </span></div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;<span class="stringliteral"> *       TimerOutput::Scope scope(timer, &quot;Compute constraints&quot;); </span></div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;<span class="stringliteral"> *       constraints.clear(); </span></div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;<span class="stringliteral"> *       DoFTools::make_hanging_node_constraints(dof_handler, constraints); </span></div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;<span class="stringliteral"> *       VectorTools::interpolate_boundary_values( </span></div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="stringliteral"> *         mapping, dof_handler, 0, ExactSolution&lt;dim&gt;(), constraints); </span></div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;<span class="stringliteral"> *       constraints.close(); </span></div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;<span class="stringliteral"> *     } </span></div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="stringliteral"> *     DynamicSparsityPattern dsp(dof_handler.n_dofs()); </span></div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;<span class="stringliteral"> *     DoFTools::make_sparsity_pattern(dof_handler, dsp, constraints, false); </span></div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;<span class="stringliteral"> *     sparsity_pattern.copy_from(dsp); </span></div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="stringliteral"> *     system_matrix.reinit(sparsity_pattern); </span></div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;<span class="stringliteral"> *     solution.reinit(dof_handler.n_dofs()); </span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="stringliteral"> *     system_rhs.reinit(dof_handler.n_dofs()); </span></div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="stringliteral"> *   } </span></div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;<span class="stringliteral"> * &lt;a name=&quot;Assemblyofthesystemmatrixandrighthandside&quot;&gt;&lt;/a&gt; </span></div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;<span class="stringliteral"> * &lt;h3&gt;Assembly of the system matrix and right hand side&lt;/h3&gt;</span></div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;<span class="stringliteral"> * 组装线性系统的函数在前面的教程程序中也是众所周知的。有一点需要注意的是，我们将正交点的数量设置为多项式的度数加2，而不是像其他大多数教程中的度数加1。这是因为我们期望有一些额外的精度，因为映射也涉及到比解的多项式多一度的程度。</span></div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;<span class="stringliteral"> * 汇编中唯一有点不寻常的代码是我们计算单元格矩阵的方式。我们没有使用正交点索引、行和矩阵列的三个嵌套循环，而是首先收集形状函数的导数，乘以系数和积分因子`JxW`的乘积的平方根，放在一个单独的矩阵`partial_matrix`中。为了计算单元矩阵，我们在 &quot;partial_matrix.mTmult(cell_matrix, partial_matrix); &quot;一行中执行 &quot;cell_matrix = partial_matrix * transpose(partial_matrix)&quot;。为了理解这一点，我们要知道矩阵与矩阵的乘法是对`partial_matrix`的各列进行求和。如果我们用 </span></div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;<span class="stringliteral"> * @f$a(\mathbf{x}_q)@f$ 表示系数，临时矩阵的条目是 @f$\sqrt{\text{det}(J) w_q a(x)} \frac{\partial \varphi_i(\boldsymbol</span></div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;<span class="stringliteral"> * \xi_q)}{\partial x_k}@f$ 。如果我们将该矩阵的第&lt;i&gt;i&lt;/i&gt;行与第&lt;i&gt;j&lt;/i&gt;列相乘，我们计算出一个涉及 @f$\sum_q \sum_{k=1}^d \sqrt{\text{det}(J) w_q a(x)} \frac{\partial</span></div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;<span class="stringliteral"> * \varphi_i(\boldsymbol \xi_q)}{\partial x_k} \sqrt{\text{det}(J) w_q a(x)}</span></div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;<span class="stringliteral"> * \frac{\partial \varphi_j(\boldsymbol \xi_q)}{\partial x_k} = \sum_q</span></div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;<span class="stringliteral"> * \sum_{k=1}^d\text{det}(J) w_q a(x)\frac{\partial \varphi_i(\boldsymbol</span></div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;<span class="stringliteral"> * \xi_q)}{\partial x_k} \frac{\partial \varphi_j(\boldsymbol</span></div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;<span class="stringliteral"> * \xi_q)}{\partial x_k}@f$ 的嵌套和，这正是拉普拉斯方程的双线性形式所需的条款。</span></div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;<span class="stringliteral"> * 选择这种有点不寻常的方案的原因是由于计算三维中相对较高的多项式程度的单元矩阵所涉及的繁重工作。由于我们想在这个教程程序中强调映射的成本，我们最好以优化的方式进行装配，以便不追逐已经被社区解决的瓶颈。矩阵-矩阵乘法是HPC背景下最好的优化内核之一， FullMatrix::mTmult() 函数将调用到那些优化的BLAS函数。如果用户在配置deal.II时提供了一个好的BLAS库（如OpenBLAS或英特尔的MKL），那么单元矩阵的计算将执行到接近处理器的峰值算术性能。顺便提一下，尽管有优化的矩阵-矩阵乘法，但目前的策略在复杂性方面是次优的，因为要做的工作与 @f$(p+1)^9@f$ 度 @f$p@f$ 的运算成正比（这也适用于用FEValues的通常评估）。我们可以通过利用形状函数的张量乘积结构，用 @f$\mathcal O((p+1)^7)@f$ 的操作来计算单元格矩阵，就像交易二中的无矩阵框架那样。我们参考 @ref step_37 &quot;step-37&quot; 和张量积感知评估器FEEvaluation的文档，以了解如何实现更有效的单元矩阵计算的细节。</span></div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;<span class="stringliteral"> *   template &lt;int dim&gt; </span></div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;<span class="stringliteral"> *   void PoissonProblem&lt;dim&gt;::assemble_system(const Mapping&lt;dim&gt; &amp;mapping) </span></div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;<span class="stringliteral"> *   { </span></div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;<span class="stringliteral"> *     TimerOutput::Scope scope(timer, &quot;Assemble linear system&quot;); </span></div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;<span class="stringliteral"> *     const QGauss&lt;dim&gt; quadrature_formula(fe.degree + 2); </span></div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;<span class="stringliteral"> *     FEValues&lt;dim&gt;     fe_values(mapping, </span></div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;<span class="stringliteral"> *                             fe, </span></div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;<span class="stringliteral"> *                             quadrature_formula, </span></div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;<span class="stringliteral"> *                             update_values | update_gradients | </span></div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;<span class="stringliteral"> *                               update_quadrature_points | update_JxW_values); </span></div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;<span class="stringliteral"> *     const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); </span></div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;<span class="stringliteral"> *     const unsigned int n_q_points    = quadrature_formula.size(); </span></div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;<span class="stringliteral"> *     FullMatrix&lt;double&gt; cell_matrix(dofs_per_cell, dofs_per_cell); </span></div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;<span class="stringliteral"> *     Vector&lt;double&gt;     cell_rhs(dofs_per_cell); </span></div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;<span class="stringliteral"> *     FullMatrix&lt;double&gt; partial_matrix(dofs_per_cell, dim * n_q_points); </span></div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;<span class="stringliteral"> *     std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell); </span></div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;<span class="stringliteral"> *     for (const auto &amp;cell : dof_handler.active_cell_iterators()) </span></div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;<span class="stringliteral"> *       { </span></div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;<span class="stringliteral"> *         cell_rhs = 0.; </span></div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;<span class="stringliteral"> *         fe_values.reinit(cell); </span></div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;<span class="stringliteral"> *         for (unsigned int q_index = 0; q_index &lt; n_q_points; ++q_index) </span></div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;<span class="stringliteral"> *           { </span></div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;<span class="stringliteral"> *             const double current_coefficient = </span></div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="stringliteral"> *               coefficient(fe_values.quadrature_point(q_index)); </span></div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;<span class="stringliteral"> *             for (unsigned int i = 0; i &lt; dofs_per_cell; ++i) </span></div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="stringliteral"> *               { </span></div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;<span class="stringliteral"> *                 for (unsigned int d = 0; d &lt; dim; ++d) </span></div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;<span class="stringliteral"> *                   partial_matrix(i, q_index * dim + d) = </span></div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;<span class="stringliteral"> *                     std::sqrt(fe_values.JxW(q_index) * current_coefficient) * </span></div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;<span class="stringliteral"> *                     fe_values.shape_grad(i, q_index)[d]; </span></div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;<span class="stringliteral"> *                 cell_rhs(i) += </span></div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;<span class="stringliteral"> *                   (fe_values.shape_value(i, q_index) * // phi_i(x_q) </span></div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;<span class="stringliteral"> *                    (-dim) *                            // f(x_q) </span></div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;<span class="stringliteral"> *                    fe_values.JxW(q_index));            // dx </span></div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;<span class="stringliteral"> *               } </span></div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;<span class="stringliteral"> *           } </span></div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="stringliteral"> *         partial_matrix.mTmult(cell_matrix, partial_matrix); </span></div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="stringliteral"> *         cell-&gt;get_dof_indices(local_dof_indices); </span></div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;<span class="stringliteral"> *         constraints.distribute_local_to_global( </span></div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;<span class="stringliteral"> *           cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs); </span></div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;<span class="stringliteral"> *       } </span></div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;<span class="stringliteral"> *   } </span></div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;<span class="stringliteral"> * &lt;a name=&quot;Solutionofthelinearsystem&quot;&gt;&lt;/a&gt; </span></div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;<span class="stringliteral"> * &lt;h3&gt;Solution of the linear system&lt;/h3&gt;</span></div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="stringliteral"> * 对于线性系统的求解，我们选择一个简单的雅可比条件共轭梯度求解器，类似于早期教程中的设置。</span></div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="stringliteral"> *   template &lt;int dim&gt; </span></div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="stringliteral"> *   void PoissonProblem&lt;dim&gt;::solve() </span></div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="stringliteral"> *   { </span></div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="stringliteral"> *     TimerOutput::Scope scope(timer, &quot;Solve linear system&quot;); </span></div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;<span class="stringliteral"> *     SolverControl            solver_control(1000, 1e-12); </span></div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;<span class="stringliteral"> *     SolverCG&lt;Vector&lt;double&gt;&gt; solver(solver_control); </span></div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;<span class="stringliteral"> *     PreconditionJacobi&lt;SparseMatrix&lt;double&gt;&gt; preconditioner; </span></div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;<span class="stringliteral"> *     preconditioner.initialize(system_matrix); </span></div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;<span class="stringliteral"> *     solver.solve(system_matrix, solution, system_rhs, preconditioner); </span></div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;<span class="stringliteral"> *     constraints.distribute(solution); </span></div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;<span class="stringliteral"> *     std::cout &lt;&lt; &quot;   Number of solver iterations:  &quot; </span></div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;<span class="stringliteral"> *               &lt;&lt; solver_control.last_step() &lt;&lt; std::endl; </span></div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;<span class="stringliteral"> *   } </span></div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;<span class="stringliteral"> * &lt;a name=&quot;Outputofthesolutionandcomputationoferrors&quot;&gt;&lt;/a&gt; </span></div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;<span class="stringliteral"> * &lt;h3&gt;Output of the solution and computation of errors&lt;/h3&gt;</span></div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="stringliteral"> * 在下一个函数中，我们对解决方案做了各种后处理步骤，所有这些步骤都以这种或那种方式涉及映射。</span></div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;<span class="stringliteral"> * 我们做的第一个操作是把解决方案以及材料ID写到VTU文件中。这与其他许多教程程序中的做法类似。这个教程程序中提出的新内容是，我们要确保写到文件中用于可视化的数据实际上是deal.II内部使用的数据的忠实代表。这是因为大多数可视化数据格式只用顶点坐标表示单元，但没有办法表示deal.II中使用高阶映射时的曲线边界--换句话说，你在可视化工具中看到的东西实际上不是你正在计算的东西。顺带一提，在使用高阶形状函数时也是如此。大多数可视化工具只呈现双线性/三线性的表示。这在 DataOut::build_patches().) 中有详细的讨论。</span></div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;<span class="stringliteral"> * 所以我们需要确保高阶表示被写入文件中。我们需要考虑两个特别的话题。首先，我们通过 DataOutBase::VtkFlags 告诉DataOut对象，我们打算把元素的细分解释为高阶拉格朗日多项式，而不是双线性补丁的集合。最近的可视化程序，如ParaView 5.5版或更新的程序，然后可以呈现高阶解决方案（更多细节见&lt;a</span></div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="stringliteral"> * href=&quot;https:github.com/dealii/dealii/wiki/Notes-on-visualizing-high-order-output&quot;&gt;wiki</span></div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;<span class="stringliteral"> * page&lt;/a&gt;）。其次，我们需要确保映射被传递给 DataOut::build_patches() 方法。最后，DataOut类默认只打印&lt;i&gt;boundary&lt;/i&gt;单元的曲面，所以我们需要确保通过映射将内部单元也打印成曲面。</span></div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;<span class="stringliteral"> *   template &lt;int dim&gt; </span></div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;<span class="stringliteral"> *   void PoissonProblem&lt;dim&gt;::postprocess(const Mapping&lt;dim&gt; &amp;mapping) </span></div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;<span class="stringliteral"> *   { </span></div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;<span class="stringliteral"> *     { </span></div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;<span class="stringliteral"> *       TimerOutput::Scope scope(timer, &quot;Write output&quot;); </span></div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;<span class="stringliteral"> *       DataOut&lt;dim&gt; data_out; </span></div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;<span class="stringliteral"> *       DataOutBase::VtkFlags flags; </span></div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;<span class="stringliteral"> *       flags.write_higher_order_cells = true; </span></div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;<span class="stringliteral"> *       data_out.set_flags(flags); </span></div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;<span class="stringliteral"> *       data_out.attach_dof_handler(dof_handler); </span></div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;<span class="stringliteral"> *       data_out.add_data_vector(solution, &quot;solution&quot;); </span></div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;<span class="stringliteral"> *       Vector&lt;double&gt; material_ids(triangulation.n_active_cells()); </span></div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;<span class="stringliteral"> *       for (const auto &amp;cell : triangulation.active_cell_iterators()) </span></div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;<span class="stringliteral"> *         material_ids[cell-&gt;active_cell_index()] = cell-&gt;material_id(); </span></div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;<span class="stringliteral"> *       data_out.add_data_vector(material_ids, &quot;material_ids&quot;); </span></div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;<span class="stringliteral"> *       data_out.build_patches(mapping, </span></div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;<span class="stringliteral"> *                              fe.degree, </span></div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;<span class="stringliteral"> *                              DataOut&lt;dim&gt;::curved_inner_cells); </span></div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;<span class="stringliteral"> *       std::ofstream file( </span></div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;<span class="stringliteral"> *         (&quot;solution-&quot; + </span></div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;<span class="stringliteral"> *          std::to_string(triangulation.n_global_levels() - 10 + 2 * dim) + </span></div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;<span class="stringliteral"> *          &quot;.vtu&quot;) </span></div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;<span class="stringliteral"> *           .c_str()); </span></div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;<span class="stringliteral"> *       data_out.write_vtu(file); </span></div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;<span class="stringliteral"> *     } </span></div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;<span class="stringliteral"> * 后处理函数的下一个操作是对照分析解计算 @f$L_2@f$ 和 @f$H^1@f$ 误差。由于分析解是一个二次多项式，我们期望在这一点上得到一个非常准确的结果。如果我们是在一个具有平面面的简单网格上求解，并且系数的跳动与单元间的面对齐，那么我们会期望数值结果与分析解相吻合，直至舍去精度。然而，由于我们使用的是跟随球体的变形单元，这些单元只能由4度的多项式跟踪（比有限元的度数多一个），我们会发现在 @f$10^{-7}@f$ 附近有一个误差。我们可以通过增加多项式的度数或细化网格来获得更多的精度。</span></div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;<span class="stringliteral"> *     { </span></div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;<span class="stringliteral"> *       TimerOutput::Scope scope(timer, &quot;Compute error norms&quot;); </span></div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;<span class="stringliteral"> *       Vector&lt;double&gt; norm_per_cell_p(triangulation.n_active_cells()); </span></div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;<span class="stringliteral"> *       VectorTools::integrate_difference(mapping, </span></div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;<span class="stringliteral"> *                                         dof_handler, </span></div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;<span class="stringliteral"> *                                         solution, </span></div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;<span class="stringliteral"> *                                         ExactSolution&lt;dim&gt;(), </span></div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;<span class="stringliteral"> *                                         norm_per_cell_p, </span></div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;<span class="stringliteral"> *                                         QGauss&lt;dim&gt;(fe.degree + 2), </span></div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;<span class="stringliteral"> *                                         VectorTools::L2_norm); </span></div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;<span class="stringliteral"> *       std::cout &lt;&lt; &quot;   L2 error vs exact solution:   &quot; </span></div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;<span class="stringliteral"> *                 &lt;&lt; norm_per_cell_p.l2_norm() &lt;&lt; std::endl; </span></div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;<span class="stringliteral"> *       VectorTools::integrate_difference(mapping, </span></div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;<span class="stringliteral"> *                                         dof_handler, </span></div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;<span class="stringliteral"> *                                         solution, </span></div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;<span class="stringliteral"> *                                         ExactSolution&lt;dim&gt;(), </span></div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;<span class="stringliteral"> *                                         norm_per_cell_p, </span></div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;<span class="stringliteral"> *                                         QGauss&lt;dim&gt;(fe.degree + 2), </span></div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;<span class="stringliteral"> *                                         VectorTools::H1_norm); </span></div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;<span class="stringliteral"> *       std::cout &lt;&lt; &quot;   H1 error vs exact solution:   &quot; </span></div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;<span class="stringliteral"> *                 &lt;&lt; norm_per_cell_p.l2_norm() &lt;&lt; std::endl; </span></div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;<span class="stringliteral"> *     } </span></div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;<span class="stringliteral"> * 我们在这里做的最后一个后处理操作是用KellyErrorEstimator计算出一个误差估计。我们使用了与 @ref step_6 &quot;step-6&quot; 教程程序中完全相同的设置，只是我们还交出了映射，以确保误差是沿着曲线元素评估的，与程序的其余部分一致。然而，我们并没有真正使用这里的结果来驱动网格适应步骤（会沿着球体细化材料界面周围的网格），因为这里的重点是这个操作的成本。</span></div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;<span class="stringliteral"> *     { </span></div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;<span class="stringliteral"> *       TimerOutput::Scope scope(timer, &quot;Compute error estimator&quot;); </span></div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;<span class="stringliteral"> *       Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells()); </span></div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;<span class="stringliteral"> *       KellyErrorEstimator&lt;dim&gt;::estimate( </span></div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;<span class="stringliteral"> *         mapping, </span></div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;<span class="stringliteral"> *         dof_handler, </span></div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;<span class="stringliteral"> *         QGauss&lt;dim - 1&gt;(fe.degree + 1), </span></div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;<span class="stringliteral"> *         std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;(), </span></div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;<span class="stringliteral"> *         solution, </span></div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;<span class="stringliteral"> *         estimated_error_per_cell); </span></div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;<span class="stringliteral"> *       std::cout &lt;&lt; &quot;   Max cell-wise error estimate: &quot; </span></div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;<span class="stringliteral"> *                 &lt;&lt; estimated_error_per_cell.linfty_norm() &lt;&lt; std::endl; </span></div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;<span class="stringliteral"> *     } </span></div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;<span class="stringliteral"> *   } </span></div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;<span class="stringliteral"> * &lt;a name=&quot;ThePoissonProblemrunfunction&quot;&gt;&lt;/a&gt; </span></div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;<span class="stringliteral"> * &lt;h3&gt;The PoissonProblem::run() function&lt;/h3&gt;</span></div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;<span class="stringliteral"> * 最后，我们定义了`run()`函数，控制我们如何执行这个程序（由main()函数以常规方式调用）。我们首先调用`create_grid()`函数，用适当的流形设置我们的几何体。然后我们运行两个求解器链的实例，从方程的设置开始，组装线性系统，用一个简单的迭代求解器求解，以及上面讨论的后处理。这两个实例在使用映射的方式上有所不同。第一个使用传统的MappingQGeneric映射对象，我们将其初始化为比有限元多一级的程度；毕竟，我们期望几何表示是瓶颈，因为分析解只是二次多项式。实际上，事情在相当程度上是相互关联的，因为实坐标中多项式的评估涉及到高阶多项式的映射，而高阶多项式代表一些光滑的有理函数。因此，高阶多项式还是有回报的，所以进一步增加映射的度数是没有意义的)。一旦第一遍完成，我们就让定时器打印出各个阶段的计算时间的摘要。</span></div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;<span class="stringliteral"> *   template &lt;int dim&gt; </span></div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;<span class="stringliteral"> *   void PoissonProblem&lt;dim&gt;::run() </span></div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;<span class="stringliteral"> *   { </span></div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;<span class="stringliteral"> *     create_grid(); </span></div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;<span class="stringliteral"> *     { </span></div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;<span class="stringliteral"> *       std::cout &lt;&lt; std::endl </span></div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;<span class="stringliteral"> *                 &lt;&lt; &quot;====== Running with the basic MappingQGeneric class ====== &quot; </span></div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;<span class="stringliteral"> *                 &lt;&lt; std::endl </span></div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;<span class="stringliteral"> *                 &lt;&lt; std::endl; </span></div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;<span class="stringliteral"> *       MappingQGeneric&lt;dim&gt; mapping(fe.degree + 1); </span></div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;<span class="stringliteral"> *       setup_system(mapping); </span></div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;<span class="stringliteral"> *       assemble_system(mapping); </span></div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;<span class="stringliteral"> *       solve(); </span></div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;<span class="stringliteral"> *       postprocess(mapping); </span></div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;<span class="stringliteral"> *       timer.print_summary(); </span></div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;<span class="stringliteral"> *       timer.reset(); </span></div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;<span class="stringliteral"> *     } </span></div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;<span class="stringliteral"> * 对于第二个实例，我们转而设置了MappingQCache类。它的使用非常简单。在构建好它之后（考虑到我们希望它在其他情况下显示正确的度数功能，所以用度数），我们通过 MappingQCache::initialize() 函数填充缓存。在这个阶段，我们为缓存指定我们想要使用的映射（很明显，与之前的MappingQGeneric相同，以便重复相同的计算），然后再次运行相同的函数，现在交出修改后的映射。最后，我们再次打印重置后的累计壁挂时间，看看这些时间与原来的设置相比如何。</span></div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;<span class="stringliteral"> *     { </span></div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;<span class="stringliteral"> *       std::cout </span></div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;<span class="stringliteral"> *         &lt;&lt; &quot;====== Running with the optimized MappingQCache class ====== &quot; </span></div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;<span class="stringliteral"> *         &lt;&lt; std::endl </span></div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;<span class="stringliteral"> *         &lt;&lt; std::endl; </span></div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;<span class="stringliteral"> *       MappingQCache&lt;dim&gt; mapping(fe.degree + 1); </span></div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;<span class="stringliteral"> *       { </span></div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;<span class="stringliteral"> *         TimerOutput::Scope scope(timer, &quot;Initialize mapping cache&quot;); </span></div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;<span class="stringliteral"> *         mapping.initialize(MappingQGeneric&lt;dim&gt;(fe.degree + 1), triangulation); </span></div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;<span class="stringliteral"> *       } </span></div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;<span class="stringliteral"> *       std::cout &lt;&lt; &quot;   Memory consumption cache:     &quot; </span></div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;<span class="stringliteral"> *                 &lt;&lt; 1e-6 * mapping.memory_consumption() &lt;&lt; &quot; MB&quot; &lt;&lt; std::endl; </span></div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;<span class="stringliteral"> *       setup_system(mapping); </span></div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;<span class="stringliteral"> *       assemble_system(mapping); </span></div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;<span class="stringliteral"> *       solve(); </span></div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;<span class="stringliteral"> *       postprocess(mapping); </span></div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;<span class="stringliteral"> *       timer.print_summary(); </span></div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;<span class="stringliteral"> *     } </span></div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;<span class="stringliteral"> *   } </span></div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;<span class="stringliteral"> * } // namespace Step65 </span></div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;<span class="stringliteral"> * int main() </span></div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;<span class="stringliteral"> * { </span></div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;<span class="stringliteral"> *   Step65::PoissonProblem&lt;3&gt; test_program; </span></div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;<span class="stringliteral"> *   test_program.run(); </span></div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;<span class="stringliteral"> *   return 0; </span></div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;<span class="stringliteral"> * } </span></div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;<span class="stringliteral">examples/step-65/doc/results.dox</span></div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;<span class="stringliteral">&lt;a name=&quot;Results&quot;&gt;&lt;/a&gt;&lt;h1&gt;Results&lt;/h1&gt;</span></div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;<span class="stringliteral">&lt;a name=&quot;Programoutput&quot;&gt;&lt;/a&gt;&lt;h3&gt;Program output&lt;/h3&gt;</span></div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;<span class="stringliteral">如果我们用三度的多项式运行这个程序的三维版本，我们会得到以下程序输出。</span></div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;<span class="stringliteral">@code</span></div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;<span class="stringliteral">&gt; make run</span></div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;<span class="stringliteral">Scanning dependencies of target step-65</span></div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;<span class="stringliteral">[ 33%] Building CXX object CMakeFiles/step-65.dir/step-65.cc.o</span></div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;<span class="stringliteral">[ 66%] Linking CXX executable step-65</span></div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;<span class="stringliteral">[ 66%] Built target step-65</span></div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;<span class="stringliteral">[100%] Run step-65 with Release configuration</span></div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;<span class="stringliteral">====== Running with the basic MappingQGeneric class ======</span></div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;<span class="stringliteral">   Number of active cells:       6656</span></div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;<span class="stringliteral">   Number of degrees of freedom: 181609</span></div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;<span class="stringliteral">   Number of solver iterations:  285</span></div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;<span class="stringliteral">   L2 error vs exact solution:   8.99339e-08</span></div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;<span class="stringliteral">   H1 error vs exact solution:   6.45341e-06</span></div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;<span class="stringliteral">   Max cell-wise error estimate: 0.00743406</span></div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;<span class="stringliteral">+---------------------------------------------+------------+------------+</span></div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;<span class="stringliteral">| Total wallclock time elapsed since start    |      49.4s |            |</span></div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;<span class="stringliteral">|                                             |            |            |</span></div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;<span class="stringliteral">| Section                         | no. calls |  wall time | % of total |</span></div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;<span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;<span class="stringliteral">| Assemble linear system          |         1 |       5.8s |        12% |</span></div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;<span class="stringliteral">| Compute constraints             |         1 |     0.109s |      0.22% |</span></div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;<span class="stringliteral">| Compute error estimator         |         1 |      16.5s |        33% |</span></div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;<span class="stringliteral">| Compute error norms             |         1 |      9.11s |        18% |</span></div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;<span class="stringliteral">| Solve linear system             |         1 |      9.92s |        20% |</span></div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;<span class="stringliteral">| Write output                    |         1 |      4.85s |       9.8% |</span></div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;<span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;<span class="stringliteral">====== Running with the optimized MappingQCache class ======</span></div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="stringliteral">   Memory consumption cache:     22.9981 MB</span></div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;<span class="stringliteral">   Number of active cells:       6656</span></div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="stringliteral">   Number of degrees of freedom: 181609</span></div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="stringliteral">   Number of solver iterations:  285</span></div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;<span class="stringliteral">   L2 error vs exact solution:   8.99339e-08</span></div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="stringliteral">   H1 error vs exact solution:   6.45341e-06</span></div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;<span class="stringliteral">   Max cell-wise error estimate: 0.00743406</span></div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;<span class="stringliteral">+---------------------------------------------+------------+------------+</span></div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;<span class="stringliteral">| Total wallclock time elapsed since start    |      18.4s |            |</span></div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;<span class="stringliteral">|                                             |            |            |</span></div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;<span class="stringliteral">| Section                         | no. calls |  wall time | % of total |</span></div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;<span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;<span class="stringliteral">| Assemble linear system          |         1 |      1.44s |       7.8% |</span></div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;<span class="stringliteral">| Compute constraints             |         1 |   0.00336s |         0% |</span></div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;<span class="stringliteral">| Compute error estimator         |         1 |     0.476s |       2.6% |</span></div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;<span class="stringliteral">| Compute error norms             |         1 |     0.505s |       2.7% |</span></div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;<span class="stringliteral">| Initialize mapping cache        |         1 |      4.96s |        27% |</span></div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;<span class="stringliteral">| Solve linear system             |         1 |      9.95s |        54% |</span></div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;<span class="stringliteral">| Write output                    |         1 |     0.875s |       4.8% |</span></div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;<span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;<span class="stringliteral">[100%] Built target run</span></div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;<span class="stringliteral">@endcode</span></div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;<span class="stringliteral">在讨论时序之前，我们看一下MappingQCache对象的内存消耗。我们的程序打印出它占用了23MB的内存。如果我们把这个数字与单个（解或右侧）向量的内存消耗联系起来，即1.5MB（即181,609个元素乘以每条8字节的双精度），或者与系统矩阵和稀疏模式所消耗的内存联系起来（274MB），我们就会发现，考虑到它的好处，这并不是一个过于沉重的数据结构。</span></div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;<span class="stringliteral">在计时器方面，我们看到程序的整体运行时间明显改善了2.7倍。如果我们不考虑迭代求解器，它在两种情况下都是一样的（考虑到我们使用的简单预处理程序，以及稀疏矩阵-向量乘积对立方多项式的操作浪费的事实，它并不是最佳的），优势是几乎5倍。这对于一个线性静止问题来说是相当令人印象深刻的，而对于时间依赖性和非线性问题来说，成本的节省确实要突出得多，因为在这些问题上，会多次调用装配。如果我们研究一下各个组件，我们就会更清楚地了解发生了什么，以及为什么缓存会如此高效。在MappingQGeneric的情况下，基本上每一个涉及到映射的操作都需要至少5秒的时间来运行。规范的计算运行了两个 VectorTools::integrate_difference() 函数，每个都需要5秒。(约束条件的计算比较便宜，因为它只在边界的单元格中评估映射，用于边界条件的插值)。如果我们将这5秒与填充MappingQCache的时间相比较，即5.2秒（对于所有单元，而不仅仅是活动单元），很明显，在MappingQGeneric的情况下，映射支持点的计算比其他一切都重要。也许最引人注目的结果是误差估计器的时间，标记为 &quot;计算误差估计器&quot;，其中MappingQGeneric的实现需要17.3秒，而MappingQCache的变体不到0.5秒。前者如此昂贵的原因（比如说，比装配贵三倍）是误差估计涉及到对面的量的评估，其中网格中的每个面都要求映射的额外点，而这些点又要经过非常昂贵的TransfiniteInterpolationManifold类。由于每个单元有六个面，这种情况比在装配中发生得更频繁。同样，MappingQCache很好地消除了重复评估，将所有涉及流形的昂贵步骤汇总到一个被重复使用的初始化调用中。</span></div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;<span class="stringliteral"> *</span></div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;<span class="stringliteral"> *</span></div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;<span class="stringliteral">&lt;a name=&quot;PlainProg&quot;&gt;&lt;/a&gt;</span></div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;<span class="stringliteral">&lt;h1&gt; The plain program&lt;/h1&gt;</span></div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;<span class="stringliteral">@include &quot;step-65.cc&quot;</span></div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;<span class="stringliteral">*/</span></div><div class="ttc" id="classPoint_html"><div class="ttname"><a href="classPoint.html">Point&lt; dim &gt;</a></div></div>
<div class="ttc" id="namespaceinternal_html_aa5bef221c94bc6b9c5441c306a72cdbaae2b6dfb8a5c48206992d8310d176c37c"><div class="ttname"><a href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaae2b6dfb8a5c48206992d8310d176c37c">internal::EvaluatorQuantity::gradient</a></div></div>
<div class="ttc" id="classTensor_html_a7a3169a68a27cc04f2ad1fd9790b874c"><div class="ttname"><a href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">Tensor::norm_square</a></div><div class="ttdeci">constexpr numbers::NumberTraits&lt; Number &gt;::real_type norm_square() const</div></div>
<div class="ttc" id="classTensor_html"><div class="ttname"><a href="classTensor.html">Tensor&lt; 1, dim &gt;</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
