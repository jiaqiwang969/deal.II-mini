<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceMeshWorker.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MeshWorker Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MeshWorker Namespace Reference<div class="ingroups"><a class="el" href="group__Integrators.html">Integrators</a> &raquo; <a class="el" href="group__MeshWorker.html">The MeshWorker interface</a> &#124; <a class="el" href="group__Integrators.html">Integrators</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceMeshWorker_1_1Assembler"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker_1_1Assembler.html">Assembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceMeshWorker_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1DoFInfo.html">DoFInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1DoFInfoBox.html">DoFInfoBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1IntegrationInfo.html">IntegrationInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1IntegrationInfoBox.html">IntegrationInfoBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1LocalIntegrator.html">LocalIntegrator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1LocalResults.html">LocalResults</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1MGVectorData.html">MGVectorData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1VectorData.html">VectorData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1VectorDataBase.html">VectorDataBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1VectorSelector.html">VectorSelector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aac43ce31dc7c260ded0754ed6c87645d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#aac43ce31dc7c260ded0754ed6c87645d">CellWorkerFunctionType</a> = std::function&lt; void(const CellIteratorBaseType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;</td></tr>
<tr class="separator:aac43ce31dc7c260ded0754ed6c87645d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7128f169823a51c8ed8e4ce5e3cb207"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#ac7128f169823a51c8ed8e4ce5e3cb207">CopierFunctionType</a> = std::function&lt; void(const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;</td></tr>
<tr class="separator:ac7128f169823a51c8ed8e4ce5e3cb207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4b155e980747e8f5842cebcdded8fe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#a6e4b155e980747e8f5842cebcdded8fe">BoundaryWorkerFunctionType</a> = std::function&lt; void(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;</td></tr>
<tr class="separator:a6e4b155e980747e8f5842cebcdded8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce2abe92fbd932da793eb7d33ab793d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#a8ce2abe92fbd932da793eb7d33ab793d">FaceWorkerFunctionType</a> = std::function&lt; void(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;</td></tr>
<tr class="separator:a8ce2abe92fbd932da793eb7d33ab793d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac7a9db8b34d398d7d398d1e8809874aa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> { <br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaed4d52b3621a731948167ef7ad3a7a21">assemble_nothing</a> = 0, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a> = 0x0001, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaf2a9f870ef8ef434faafaca65a6cf3e6">assemble_ghost_cells</a> = 0x0002, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763">assemble_own_interior_faces_once</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaacff5b091a4938006db62e7ccebd377b7">assemble_own_interior_faces_both</a> = 0x0008, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaaf53835f3f0c49e6ba2c01e76b8d2612e">assemble_ghost_faces_once</a> = 0x0010, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa9396964e7e270fe0a0c5d01474721c24">assemble_ghost_faces_both</a> = 0x0020, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">assemble_boundary_faces</a> = 0x0040, 
<br />
&#160;&#160;<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa59231a54b9e844e500c0b35a30e15ecc">cells_after_faces</a> = 0x0080, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaae2716ac8c17468f0676ae25254d289d9">work_on_cells</a> = assemble_own_cells | assemble_ghost_cells, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa229cba0b2f66f6421585b5f7a36b817b">work_on_faces</a>, 
<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa45067bf49336f1a3d7ae55e2a65fc83f">work_on_boundary</a> = assemble_boundary_faces
<br />
 }</td></tr>
<tr class="separator:ac7a9db8b34d398d7d398d1e8809874aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a291f88eb27019383975855c6c6a617aa"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:a291f88eb27019383975855c6c6a617aa"><td class="memTemplItemLeft" align="right" valign="top">StreamType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#a291f88eb27019383975855c6c6a617aa">operator&lt;&lt;</a> (StreamType &amp;s, <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> u)</td></tr>
<tr class="separator:a291f88eb27019383975855c6c6a617aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc968cec1e4b2fb3b0819f3efc28bd0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#adc968cec1e4b2fb3b0819f3efc28bd0d">operator|</a> (<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> f1, <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> f2)</td></tr>
<tr class="separator:adc968cec1e4b2fb3b0819f3efc28bd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3668e47de98be1abba3d69e0ad20fa4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#a3668e47de98be1abba3d69e0ad20fa4b">operator|=</a> (<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> &amp;f1, <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> f2)</td></tr>
<tr class="separator:a3668e47de98be1abba3d69e0ad20fa4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942bcd91597d0b5eb774c160cdf41986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#a942bcd91597d0b5eb774c160cdf41986">operator &amp;</a> (<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> f1, <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> f2)</td></tr>
<tr class="separator:a942bcd91597d0b5eb774c160cdf41986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eab9fb314978a26d497cf7946998212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html#a0eab9fb314978a26d497cf7946998212">operator &amp;=</a> (<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> &amp;f1, <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> f2)</td></tr>
<tr class="separator:a0eab9fb314978a26d497cf7946998212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5a59dde8686a651b12d040cc5afdf9a"><td class="memTemplParams" colspan="2">template&lt;class INFOBOX , class DOFINFO , int dim, int spacedim, class ITERATOR &gt; </td></tr>
<tr class="memitem:gaf5a59dde8686a651b12d040cc5afdf9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#gaf5a59dde8686a651b12d040cc5afdf9a">cell_action</a> (ITERATOR cell, <a class="el" href="classMeshWorker_1_1DoFInfoBox.html">DoFInfoBox</a>&lt; dim, DOFINFO &gt; &amp;dof_info, INFOBOX &amp;info, const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;cell_worker, const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;boundary_worker, const std::function&lt; void(DOFINFO &amp;, DOFINFO &amp;, typename INFOBOX::CellInfo &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;face_worker, const <a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a> &amp;loop_control)</td></tr>
<tr class="separator:gaf5a59dde8686a651b12d040cc5afdf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad10f528ab87f39fbb0531d24f238b2f3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class DOFINFO , class INFOBOX , class ASSEMBLER , class ITERATOR &gt; </td></tr>
<tr class="memitem:gad10f528ab87f39fbb0531d24f238b2f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop</a> (ITERATOR begin, typename <a class="el" href="structidentity.html">identity</a>&lt; ITERATOR &gt;::type end, DOFINFO &amp;dinfo, INFOBOX &amp;info, const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;cell_worker, const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;boundary_worker, const std::function&lt; void(DOFINFO &amp;, DOFINFO &amp;, typename INFOBOX::CellInfo &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;face_worker, ASSEMBLER &amp;assembler, const <a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a> &amp;lctrl=<a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a>())</td></tr>
<tr class="separator:gad10f528ab87f39fbb0531d24f238b2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93cfb35f7969ce8f0be7628255dfe7fb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class ITERATOR , class ASSEMBLER &gt; </td></tr>
<tr class="memitem:ga93cfb35f7969ce8f0be7628255dfe7fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">integration_loop</a> (ITERATOR begin, typename <a class="el" href="structidentity.html">identity</a>&lt; ITERATOR &gt;::type end, <a class="el" href="classMeshWorker_1_1DoFInfo.html">DoFInfo</a>&lt; dim, spacedim &gt; &amp;dof_info, <a class="el" href="classMeshWorker_1_1IntegrationInfoBox.html">IntegrationInfoBox</a>&lt; dim, spacedim &gt; &amp;box, const <a class="el" href="classMeshWorker_1_1LocalIntegrator.html">LocalIntegrator</a>&lt; dim, spacedim &gt; &amp;integrator, ASSEMBLER &amp;assembler, const <a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a> &amp;lctrl=<a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a>())</td></tr>
<tr class="separator:ga93cfb35f7969ce8f0be7628255dfe7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ec61fbd188fb320fe8ca166a79b322"><td class="memTemplParams" colspan="2">template&lt;class CellIteratorType , class ScratchData , class CopyData , class CellIteratorBaseType  = typename internal::CellIteratorBaseType&lt;CellIteratorType&gt;::type&gt; </td></tr>
<tr class="memitem:ga76ec61fbd188fb320fe8ca166a79b322"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop</a> (const CellIteratorType &amp;begin, const CellIteratorType &amp;end, const <a class="el" href="namespaceMeshWorker.html#aac43ce31dc7c260ded0754ed6c87645d">CellWorkerFunctionType</a> &amp;cell_worker, const CopierType &amp;copier, const <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;sample_scratch_data, const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;sample_copy_data, const <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> flags=<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a>, const <a class="el" href="namespaceMeshWorker.html#a6e4b155e980747e8f5842cebcdded8fe">BoundaryWorkerFunctionType</a> &amp;boundary_worker=<a class="el" href="namespaceMeshWorker.html#a6e4b155e980747e8f5842cebcdded8fe">BoundaryWorkerFunctionType</a>(), const <a class="el" href="namespaceMeshWorker.html#a8ce2abe92fbd932da793eb7d33ab793d">FaceWorkerFunctionType</a> &amp;face_worker=<a class="el" href="namespaceMeshWorker.html#a8ce2abe92fbd932da793eb7d33ab793d">FaceWorkerFunctionType</a>(), const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:ga76ec61fbd188fb320fe8ca166a79b322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1cf14f6f8ff8f5e1f168c19ad4979b9"><td class="memTemplParams" colspan="2">template&lt;class CellIteratorType , class ScratchData , class CopyData , class CellIteratorBaseType  = typename internal::CellIteratorBaseType&lt;CellIteratorType&gt;::type&gt; </td></tr>
<tr class="memitem:gae1cf14f6f8ff8f5e1f168c19ad4979b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#gae1cf14f6f8ff8f5e1f168c19ad4979b9">mesh_loop</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; CellIteratorType &gt; iterator_range, const typename <a class="el" href="structidentity.html">identity</a>&lt; std::function&lt; void(const CellIteratorBaseType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::type &amp;cell_worker, const typename <a class="el" href="structidentity.html">identity</a>&lt; std::function&lt; void(const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::type &amp;copier, const <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;sample_scratch_data, const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;sample_copy_data, const <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> flags=<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a>, const typename <a class="el" href="structidentity.html">identity</a>&lt; std::function&lt; void(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::type &amp;boundary_worker=std::function&lt; void(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;(), const typename <a class="el" href="structidentity.html">identity</a>&lt; std::function&lt; void(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::type &amp;face_worker=std::function&lt; void(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;(), const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:gae1cf14f6f8ff8f5e1f168c19ad4979b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab233c65f7c758c094edbf9a0b5687d5e"><td class="memTemplParams" colspan="2">template&lt;class CellIteratorType , class ScratchData , class CopyData , class MainClass &gt; </td></tr>
<tr class="memitem:gab233c65f7c758c094edbf9a0b5687d5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#gab233c65f7c758c094edbf9a0b5687d5e">mesh_loop</a> (const CellIteratorType &amp;begin, const typename <a class="el" href="structidentity.html">identity</a>&lt; CellIteratorType &gt;::type &amp;end, MainClass &amp;main_class, void(MainClass::*cell_worker)(const CellIteratorType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;), void(MainClass::*copier)(const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;), const <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;sample_scratch_data, const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;sample_copy_data, const <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> flags=<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a>, void(MainClass::*boundary_worker)(const CellIteratorType &amp;, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)=nullptr, void(MainClass::*face_worker)(const CellIteratorType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, const CellIteratorType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)=nullptr, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:gab233c65f7c758c094edbf9a0b5687d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47cf9870f0e4e1952e77d7c77a560998"><td class="memTemplParams" colspan="2">template&lt;class CellIteratorType , class ScratchData , class CopyData , class MainClass , class CellIteratorBaseType  = typename internal::CellIteratorBaseType&lt;CellIteratorType&gt;::type&gt; </td></tr>
<tr class="memitem:ga47cf9870f0e4e1952e77d7c77a560998"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#ga47cf9870f0e4e1952e77d7c77a560998">mesh_loop</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; CellIteratorType &gt; iterator_range, MainClass &amp;main_class, void(MainClass::*cell_worker)(const CellIteratorBaseType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;), void(MainClass::*copier)(const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;), const <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;sample_scratch_data, const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;sample_copy_data, const <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> flags=<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a>, void(MainClass::*boundary_worker)(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)=nullptr, void(MainClass::*face_worker)(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)=nullptr, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:ga47cf9870f0e4e1952e77d7c77a560998"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>一个用于网格循环的函数和类的集合，它是每个有限元程序中无处不在的部分。 这个命名空间的主力是loop()函数，它实现了对所有网格单元的完全通用循环。由于对loop()的调用由于其通用性而容易出错，对于许多应用来说，最好从 <a class="el" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a> 派生出一个类，并使用不太通用的 <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">integration_loop()</a>。 <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a>依赖于作为参数交给它的某些对象。这些对象有两种类型， <code>info</code> 对象，如 <a class="el" href="classMeshWorker_1_1DoFInfo.html">DoFInfo</a> 和 IntegrationInfo，以及 LocalWorker 和 IntegrationWorker 等工作对象。 工作者对象通常做两个不同的工作：首先，他们计算一个单元或面对全局操作的本地贡献。其次，它们将这个局部贡献集合到全局结果中，无论是函数、形式还是双线性形式。第一项工作是针对被解决的问题的，而第二项工作是通用的，只取决于数据结构。因此，工人组装成全局数据的基类在命名空间Assembler中提供。 </p><h3>Template argument types</h3>
<p>函数loop()和cell_action()需要一些参数，这些参数是模板参数。让我们在这里列出这些类的最低要求并描述它们的属性。 </p><h4>ITERATOR</h4>
<p>任何具有<code><a class="el" href="structSynchronousIterators.html#a574336a8166e3537d57c0d677df48ce9">operator++()</a></code>并指向TriaAccessor或派生类的对象。 </p><h4>DOFINFO</h4>
<p>关于一个实现的例子，请参考类模板DoFInfo。为了与cell_action()和loop()协同工作，DOFINFO需要遵循以下接口。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>DOFINFO</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  DOFINFO();</div><div class="line">  DOFINFO(<span class="keyword">const</span> DOFINFO&amp;);</div><div class="line">  DOFINFO&amp; operator=(<span class="keyword">const</span> DOFINFO&amp;);</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> CellIt&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> CellIt&amp; c);</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> CellIt, <span class="keyword">class</span> FaceIt&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> CellIt&amp; c, <span class="keyword">const</span> FaceIt&amp; f, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n);</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> CellIt, <span class="keyword">class</span> FaceIt&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> CellIt&amp; c, <span class="keyword">const</span> FaceIt&amp; f, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s);</div><div class="line"></div><div class="line"><span class="keyword">friend</span> <span class="keyword">template</span> <span class="keyword">class </span>DoFInfoBox&lt;int dim, DOFINFO&gt;;</div><div class="line">};</div></div><!-- fragment --><p>这三个私有函数是由DoFInfoBox调用的，其他地方应该不需要。很明显，它们可以被公开，然后末尾的friend声明可能会被遗漏。 此外，你将需要至少一个公共构造函数。此外，DOFINFO还相当无用：需要与INTEGRATIONINFO和ASSEMBLER接口的函数。 DOFINFO对象被聚集在一个DoFInfoBox中。在这些对象中，我们存储了对每个单元及其面的局部操作的结果。一旦所有这些信息都被收集起来，一个ASSEMBLER被用来将其组装成全局数据。 </p><h4>INFOBOX</h4>
<p>这种类型在IntegrationInfoBox中得到了体现。它在INFO对象中收集单元格和面的动作的输入数据（见下文）。它为loop()和cell_action()提供以下接口。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>INFOBOX</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keyword">class</span> DOFINFO&gt;</div><div class="line">  <span class="keywordtype">void</span> post_cell(<span class="keyword">const</span> DoFInfoBox&lt;dim, DOFINFO&gt;&amp;);</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keyword">class</span> DOFINFO&gt;</div><div class="line">  <span class="keywordtype">void</span> post_faces(<span class="keyword">const</span> DoFInfoBox&lt;dim, DOFINFO&gt;&amp;);</div><div class="line"></div><div class="line">  INFO cell;</div><div class="line">  INFO boundary;</div><div class="line">  INFO face;</div><div class="line">  INFO subface;</div><div class="line">  INFO neighbor;</div><div class="line">};</div></div><!-- fragment --><p>这个类的主要目的是收集五个INFO对象，它们包含了每个单元或面所使用的临时数据。对这些对象的要求列在下面。在这里，我们只注意到需要有这5个对象的名字在上面列出。 两个函数模板是在cell_action()中调用的回调函数。第一个是在工作面之前调用的，第二个是在工作面之后调用的。 </p><h4>INFO</h4>
<p>关于这些对象的例子，请参见IntegrationInfo。它们包含了每个单元或面所需的临时数据，以计算出结果。MeshWorker只使用接口</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>INFO</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> DOFINFO&amp; i);</div><div class="line">};</div></div><!-- fragment --><h3>Simplified interfaces</h3>
<p>由于loop()是相当普遍的，所以有一个专门的integration_loop()，它是一个具有简化接口的loop()的包装器。 <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">integration_loop()</a>函数循环从IntegrationInfoBox对象中获取大部分需要传递给loop()的信息。它的用途在 <a class="el" href="step_12.html">step-12</a> 中作了解释，但简而言之，它需要在单元格、内部或边界面上做局部积分的函数，它还需要一个对象（称为 "装配器"）将这些局部贡献复制到全局矩阵和右手对象中。 在我们能够运行积分循环之前，我们必须在我们的IntegrationWorker和assembler对象中初始化几个数据结构。例如，我们必须决定正交规则，或者我们可能需要比默认更新标志更多的东西。 </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aac43ce31dc7c260ded0754ed6c87645d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac43ce31dc7c260ded0754ed6c87645d">&#9670;&nbsp;</a></span>CellWorkerFunctionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceMeshWorker.html#aac43ce31dc7c260ded0754ed6c87645d">MeshWorker::CellWorkerFunctionType</a> = typedef std::function&lt; void(const CellIteratorBaseType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个别名为Mesh_loop()中使用的单元格工作者的函数类型引入了一个友好而简短的名称。 </p>

<p class="definition">Definition at line <a class="el" href="mesh__loop_8h_source.html#l00107">107</a> of file <a class="el" href="mesh__loop_8h_source.html">mesh_loop.h</a>.</p>

</div>
</div>
<a id="ac7128f169823a51c8ed8e4ce5e3cb207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7128f169823a51c8ed8e4ce5e3cb207">&#9670;&nbsp;</a></span>CopierFunctionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceMeshWorker.html#ac7128f169823a51c8ed8e4ce5e3cb207">MeshWorker::CopierFunctionType</a> = typedef std::function&lt;void(const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个别名为Mesh_loop()中使用的单元格工作者的函数类型引入了一个友好而简短的名字。 </p>

<p class="definition">Definition at line <a class="el" href="mesh__loop_8h_source.html#l00113">113</a> of file <a class="el" href="mesh__loop_8h_source.html">mesh_loop.h</a>.</p>

</div>
</div>
<a id="a6e4b155e980747e8f5842cebcdded8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4b155e980747e8f5842cebcdded8fe">&#9670;&nbsp;</a></span>BoundaryWorkerFunctionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceMeshWorker.html#a6e4b155e980747e8f5842cebcdded8fe">MeshWorker::BoundaryWorkerFunctionType</a> = typedef std::function&lt;void(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个别名为Mesh_loop()中使用的边界工作者的函数类型引入了一个友好而简短的名字。 </p>

<p class="definition">Definition at line <a class="el" href="mesh__loop_8h_source.html#l00123">123</a> of file <a class="el" href="mesh__loop_8h_source.html">mesh_loop.h</a>.</p>

</div>
</div>
<a id="a8ce2abe92fbd932da793eb7d33ab793d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce2abe92fbd932da793eb7d33ab793d">&#9670;&nbsp;</a></span>FaceWorkerFunctionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceMeshWorker.html#a8ce2abe92fbd932da793eb7d33ab793d">MeshWorker::FaceWorkerFunctionType</a> = typedef std::function&lt;void(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个别名为Mesh_loop()中使用的面片工作者的函数类型引入了一个友好而简短的名称。 </p>

<p class="definition">Definition at line <a class="el" href="mesh__loop_8h_source.html#l00137">137</a> of file <a class="el" href="mesh__loop_8h_source.html">mesh_loop.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac7a9db8b34d398d7d398d1e8809874aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a9db8b34d398d7d398d1e8809874aa">&#9670;&nbsp;</a></span>AssembleFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">MeshWorker::AssembleFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给予Mesh_loop()函数的枚举类型，告诉该函数哪些元素需要被组装起来。 你可以用位法或 <code><a class="el" href="namespaceMeshWorker.html#adc968cec1e4b2fb3b0819f3efc28bd0d">operator|(AssembleFlags,AssembleFlags)</a></code> 串联的方式选择多个标志。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaed4d52b3621a731948167ef7ad3a7a21"></a>assemble_nothing&#160;</td><td class="fielddoc"><p>什么都不做。 </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa"></a>assemble_own_cells&#160;</td><td class="fielddoc"><p>在本地拥有的单元上进行组合。 </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaf2a9f870ef8ef434faafaca65a6cf3e6"></a>assemble_ghost_cells&#160;</td><td class="fielddoc"><p>集合在幽灵细胞上。 </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763"></a>assemble_own_interior_faces_once&#160;</td><td class="fielddoc"><p>在两个本地拥有的单元格之间的内部面上进行集合，每个面只访问一次。 </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaacff5b091a4938006db62e7ccebd377b7"></a>assemble_own_interior_faces_both&#160;</td><td class="fielddoc"><p>在两个本地拥有的单元格之间的内部面上集合，对每个内部面访问两次，从相邻的两个单元格中各访问一次。 </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaaf53835f3f0c49e6ba2c01e76b8d2612e"></a>assemble_ghost_faces_once&#160;</td><td class="fielddoc"><p>在一个本地拥有的单元和一个幽灵单元之间的面进行组装，确保只有一个进程将组装这些面（从较细的一面或具有较低mpi等级的进程）。 </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa9396964e7e270fe0a0c5d01474721c24"></a>assemble_ghost_faces_both&#160;</td><td class="fielddoc"><p>在一个本地拥有的单元和一个幽灵单元之间的面进行组装。两个进程都将组装这些面。请注意，它们永远不会在一个进程中从两边进行装配。 </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d"></a>assemble_boundary_faces&#160;</td><td class="fielddoc"><p>在本地拥有的单元格的边界面上进行组装。 </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa59231a54b9e844e500c0b35a30e15ecc"></a>cells_after_faces&#160;</td><td class="fielddoc"><p>默认情况下，我们会在面积分之前装配单元积分。如果指定了这个标志，单元格将在面和边界之后被装配。 </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaae2716ac8c17468f0676ae25254d289d9"></a>work_on_cells&#160;</td><td class="fielddoc"><p>结合标志来决定是否对单元进行任何工作。 </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa229cba0b2f66f6421585b5f7a36b817b"></a>work_on_faces&#160;</td><td class="fielddoc"><p>结合标志来决定是否对面进行任何工作。 </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a9db8b34d398d7d398d1e8809874aaa45067bf49336f1a3d7ae55e2a65fc83f"></a>work_on_boundary&#160;</td><td class="fielddoc"><p>结合标志来确定是否对边界面做了任何工作。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="assemble__flags_8h_source.html#l00039">39</a> of file <a class="el" href="assemble__flags_8h_source.html">assemble_flags.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a291f88eb27019383975855c6c6a617aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291f88eb27019383975855c6c6a617aa">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StreamType&amp; MeshWorker::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>输出运算符，将组合标志作为一组or'd文本值输出。 <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="assemble__flags_8h_source.html#l00117">117</a> of file <a class="el" href="assemble__flags_8h_source.html">assemble_flags.h</a>.</p>

</div>
</div>
<a id="adc968cec1e4b2fb3b0819f3efc28bd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc968cec1e4b2fb3b0819f3efc28bd0d">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> MeshWorker::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>全局运算符，它返回一个对象，其中所有的位都被设置为第一或第二个参数中的设置。这个操作符的存在是因为如果它不存在，那么bit-or <code>操作符|</code>的结果将是一个整数，当我们试图将其分配给AssembleFlags类型的对象时，会引发编译器警告。 <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="assemble__flags_8h_source.html#l00144">144</a> of file <a class="el" href="assemble__flags_8h_source.html">assemble_flags.h</a>.</p>

</div>
</div>
<a id="a3668e47de98be1abba3d69e0ad20fa4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3668e47de98be1abba3d69e0ad20fa4b">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&amp; MeshWorker::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>全局运算符，将第二个参数的位也设置在第一个参数中。 <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="assemble__flags_8h_source.html#l00158">158</a> of file <a class="el" href="assemble__flags_8h_source.html">assemble_flags.h</a>.</p>

</div>
</div>
<a id="a942bcd91597d0b5eb774c160cdf41986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942bcd91597d0b5eb774c160cdf41986">&#9670;&nbsp;</a></span>operator &()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> MeshWorker::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>全局操作符，它返回一个对象，其中所有位都被设置在第一个和第二个参数中。这个操作符的存在是因为如果它不存在，那么比特和<code>操作符&amp;</code>的结果将是一个整数，当我们试图将其分配给AssembleFlags类型的对象时，会引发编译器警告。 <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="assemble__flags_8h_source.html#l00170">170</a> of file <a class="el" href="assemble__flags_8h_source.html">assemble_flags.h</a>.</p>

</div>
</div>
<a id="a0eab9fb314978a26d497cf7946998212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eab9fb314978a26d497cf7946998212">&#9670;&nbsp;</a></span>operator &=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&amp; MeshWorker::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>全局操作符，如果第一个参数中的所有位没有在第二个参数中设置，则清除它们。 <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="assemble__flags_8h_source.html#l00183">183</a> of file <a class="el" href="assemble__flags_8h_source.html">assemble_flags.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
