<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classparallel_1_1distributed_1_1SolutionTransfer.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: parallel::distributed::SolutionTransfer&lt; dim, VectorType, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceparallel.html">parallel</a></li><li class="navelem"><a class="el" href="namespaceparallel_1_1distributed.html">distributed</a></li><li class="navelem"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">SolutionTransfer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classparallel_1_1distributed_1_1SolutionTransfer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">parallel::distributed::SolutionTransfer&lt; dim, VectorType, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Parallel.html">Parallel computing</a> &raquo; <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="distributed_2solution__transfer_8h_source.html">deal.II/distributed/solution_transfer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8d5f02a680eae36c7fa00b35667e897e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a8d5f02a680eae36c7fa00b35667e897e">SolutionTransfer</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof)</td></tr>
<tr class="separator:a8d5f02a680eae36c7fa00b35667e897e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad524cea8cfaada4745c6ce53367af3eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#ad524cea8cfaada4745c6ce53367af3eb">~SolutionTransfer</a> ()=default</td></tr>
<tr class="separator:ad524cea8cfaada4745c6ce53367af3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315e174af6accd0be073296939d11c86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a315e174af6accd0be073296939d11c86">prepare_for_coarsening_and_refinement</a> (const std::vector&lt; const <a class="el" href="classVectorType.html">VectorType</a> *&gt; &amp;all_in)</td></tr>
<tr class="separator:a315e174af6accd0be073296939d11c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fceda8e6dc3a02ffb67ac4208a3b54e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a4fceda8e6dc3a02ffb67ac4208a3b54e">prepare_for_coarsening_and_refinement</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;in)</td></tr>
<tr class="separator:a4fceda8e6dc3a02ffb67ac4208a3b54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6af36babfcc432b93c741f2b02174ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#aa6af36babfcc432b93c741f2b02174ca">interpolate</a> (std::vector&lt; <a class="el" href="classVectorType.html">VectorType</a> *&gt; &amp;all_out)</td></tr>
<tr class="separator:aa6af36babfcc432b93c741f2b02174ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3aa87e06c75834cfe119e6a299d3508"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#af3aa87e06c75834cfe119e6a299d3508">interpolate</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;out)</td></tr>
<tr class="separator:af3aa87e06c75834cfe119e6a299d3508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd182696d78fa7361a37af6ce3644e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#aefd182696d78fa7361a37af6ce3644e8">prepare_for_serialization</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;in)</td></tr>
<tr class="separator:aefd182696d78fa7361a37af6ce3644e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd069aab4332e123234917878ee79f47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#afd069aab4332e123234917878ee79f47">prepare_for_serialization</a> (const std::vector&lt; const <a class="el" href="classVectorType.html">VectorType</a> *&gt; &amp;all_in)</td></tr>
<tr class="separator:afd069aab4332e123234917878ee79f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a353b0c792ca900c973b7ead88291af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a7a353b0c792ca900c973b7ead88291af">deserialize</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;in)</td></tr>
<tr class="separator:a7a353b0c792ca900c973b7ead88291af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbb3b6a400df9b7e2a3bc103dbc0154"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a2cbb3b6a400df9b7e2a3bc103dbc0154">deserialize</a> (std::vector&lt; <a class="el" href="classVectorType.html">VectorType</a> *&gt; &amp;all_in)</td></tr>
<tr class="separator:a2cbb3b6a400df9b7e2a3bc103dbc0154"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0ccedcfd4c7a6d6e5683acebbbbe74fa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a0ccedcfd4c7a6d6e5683acebbbbe74fa">pack_callback</a> (const typename <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const typename <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::CellStatus status)</td></tr>
<tr class="separator:a0ccedcfd4c7a6d6e5683acebbbbe74fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e17efd1bcd774a318d193ff2af8ec4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a1e17efd1bcd774a318d193ff2af8ec4e">unpack_callback</a> (const typename <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const typename <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::CellStatus status, const boost::iterator_range&lt; std::vector&lt; char &gt;::const_iterator &gt; &amp;data_range, std::vector&lt; <a class="el" href="classVectorType.html">VectorType</a> *&gt; &amp;all_out)</td></tr>
<tr class="separator:a1e17efd1bcd774a318d193ff2af8ec4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448393b9d7a009e81c36d81d318e2378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a448393b9d7a009e81c36d81d318e2378">register_data_attach</a> ()</td></tr>
<tr class="separator:a448393b9d7a009e81c36d81d318e2378"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9c40c4923a69889f320aff7bb602730b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;, <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a9c40c4923a69889f320aff7bb602730b">dof_handler</a></td></tr>
<tr class="separator:a9c40c4923a69889f320aff7bb602730b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93dfd411779ad00d8e55cc126048ad9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classVectorType.html">VectorType</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#aa93dfd411779ad00d8e55cc126048ad9">input_vectors</a></td></tr>
<tr class="separator:aa93dfd411779ad00d8e55cc126048ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6f6151829c20e55ad399f9609454f6"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a7e6f6151829c20e55ad399f9609454f6">handle</a></td></tr>
<tr class="separator:a7e6f6151829c20e55ad399f9609454f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename VectorType, int spacedim = dim&gt;<br />
class parallel::distributed::SolutionTransfer&lt; dim, VectorType, spacedim &gt;</h3>

<p>Transfer a discrete FE function (like a solution vector) by interpolation while refining and/or coarsening a distributed grid and handles the necessary communication.</p>
<dl class="section note"><dt>Note</dt><dd>It is important to note, that if you use more than one <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">SolutionTransfer</a> object at the same time, that the calls to prepare_*() and <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#aa6af36babfcc432b93c741f2b02174ca">interpolate()</a>/deserialize() need to be in the same order.</dd></dl>
<h3>Note on ghost elements</h3>
<p>In a parallel computation PETSc or Trilinos vector may contain ghost elements or not. For reading in information with <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a315e174af6accd0be073296939d11c86">prepare_for_coarsening_and_refinement()</a> or <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#aefd182696d78fa7361a37af6ce3644e8">prepare_for_serialization()</a> you need to supply vectors with ghost elements, so that all locally_active elements can be read. On the other hand, ghosted vectors are generally not writable, so for calls to <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#aa6af36babfcc432b93c741f2b02174ca">interpolate()</a> or <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a7a353b0c792ca900c973b7ead88291af">deserialize()</a> you need to supply distributed vectors without ghost elements. More precisely, during interpolation the current algorithm writes into all locally active degrees of freedom.</p>
<h3>Transferring a solution</h3>
<p>Here VectorType is your favorite vector type, e.g. <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, or corresponding block vectors. </p><div class="fragment"><div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, VectorType&gt;</a> soltrans(<a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a9c40c4923a69889f320aff7bb602730b">dof_handler</a>);</div><div class="line"><span class="comment">// flag some cells for refinement and coarsening, e.g.</span></div><div class="line"><a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">GridRefinement::refine_and_coarsen_fixed_fraction</a>(tria,</div><div class="line">                                                  error_indicators,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.05);</div><div class="line"></div><div class="line"><span class="comment">// prepare the triangulation,</span></div><div class="line">tria.prepare_coarsening_and_refinement();</div><div class="line"></div><div class="line"><span class="comment">// prepare the SolutionTransfer object for coarsening and refinement</span></div><div class="line"><span class="comment">// and give the solution vector that we intend to interpolate later,</span></div><div class="line">soltrans.prepare_for_coarsening_and_refinement(solution);</div><div class="line"></div><div class="line"><span class="comment">// actually execute the refinement,</span></div><div class="line">tria.execute_coarsening_and_refinement ();</div><div class="line"></div><div class="line"><span class="comment">// redistribute dofs,</span></div><div class="line"><a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a9c40c4923a69889f320aff7bb602730b">dof_handler</a>.distribute_dofs (fe);</div><div class="line"></div><div class="line"><span class="comment">// and interpolate the solution</span></div><div class="line"><a class="code" href="classVectorType.html">VectorType</a> interpolated_solution;</div><div class="line"></div><div class="line"><span class="comment">//create VectorType in the right size here</span></div><div class="line">soltrans.interpolate(interpolated_solution);</div></div><!-- fragment --><p>As the grid is distributed, it is important to note that the old solution(s) must be copied to one that also provides access to the locally relevant DoF values (these values required for the interpolation process): </p><div class="fragment"><div class="line"><span class="comment">// Create initial indexsets pertaining to the grid before refinement</span></div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs, locally_relevant_dofs;</div><div class="line">locally_owned_dofs = <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a9c40c4923a69889f320aff7bb602730b">dof_handler</a>.locally_owned_dofs();</div><div class="line"><a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(<a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a9c40c4923a69889f320aff7bb602730b">dof_handler</a>,</div><div class="line">locally_relevant_dofs);</div><div class="line"></div><div class="line"><span class="comment">// The solution vector only knows about locally owned DoFs</span></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution;</div><div class="line">solution.<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a655ae9c8d3595133abe1131fcbb97b6d">reinit</a>(locally_owned_dofs,</div><div class="line">                mpi_communicator);</div><div class="line">...</div><div class="line"><span class="comment">// Transfer solution to vector that provides access to</span></div><div class="line"><span class="comment">// locally relevant DoFs</span></div><div class="line">TrilinosWrappers::MPI::Vector old_solution;</div><div class="line">old_solution.reinit(locally_owned_dofs,</div><div class="line">                    locally_relevant_dofs,</div><div class="line">                    mpi_communicator);</div><div class="line">old_solution = solution;</div><div class="line"></div><div class="line"><span class="comment">// Initialize SolutionTransfer object</span></div><div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, VectorType&gt;</a> soltrans(<a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a9c40c4923a69889f320aff7bb602730b">dof_handler</a>);</div><div class="line">soltrans.prepare_for_coarsening_and_refinement(old_solution);</div><div class="line">...</div><div class="line"><span class="comment">// Refine grid</span></div><div class="line"><span class="comment">// Recreate locally_owned_dofs and locally_relevant_dofs index sets</span></div><div class="line">...</div><div class="line">solution.<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a655ae9c8d3595133abe1131fcbb97b6d">reinit</a>(locally_owned_dofs, mpi_communicator);</div><div class="line">soltrans.interpolate(solution);</div></div><!-- fragment --><p>Different from PETSc and Trilinos vectors, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> allows writing into ghost elements. For a ghosted vector the interpolation step can be accomplished via </p><div class="fragment"><div class="line">interpolated_solution.zero_out_ghost_values();</div><div class="line">soltrans.interpolate(interpolated_solution);</div><div class="line">interpolated_solution.update_ghost_values();</div></div><!-- fragment --><h3>Use for Serialization</h3>
<p>This class can be used to serialize and later deserialize a distributed mesh with solution vectors to a file. If you use more than one <a class="el" href="classDoFHandler.html">DoFHandler</a> and therefore more than one <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">SolutionTransfer</a> object, they need to be serialized and deserialized in the same order.</p>
<p>If vector has the locally relevant DoFs, serialization works as follows: </p><div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim,VectorType&gt;</a></div><div class="line">  sol_trans(<a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a9c40c4923a69889f320aff7bb602730b">dof_handler</a>);</div><div class="line">sol_trans.prepare_for_serialization (vector);</div><div class="line"></div><div class="line">triangulation.save(filename);</div></div><!-- fragment --><p> For deserialization the vector needs to be a distributed vector (without ghost elements): </p><div class="fragment"><div class="line"><span class="comment">//[create coarse mesh...]</span></div><div class="line">triangulation.load(filename);</div><div class="line"></div><div class="line"><a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim,VectorType&gt;</a></div><div class="line">  sol_trans(<a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a9c40c4923a69889f320aff7bb602730b">dof_handler</a>);</div><div class="line">sol_trans.deserialize (distributed_vector);</div></div><!-- fragment --><h3>Note on usage with <a class="el" href="classDoFHandler.html">DoFHandler</a> with hp-capabilities</h3>
<p>Since data on <a class="el" href="classDoFHandler.html">DoFHandler</a> objects with hp-capabilities is associated with many different <a class="el" href="classFiniteElement.html">FiniteElement</a> objects, each cell's data has to be processed with its corresponding <code>future_fe_index</code>. Further, if refinement is involved, data will be packed on the parent cell with its <code>future_fe_index</code> and unpacked later with the same index on its children. If cells get coarsened into one, data will be packed on the children with the least dominant finite element of their common subspace, and unpacked on the parent with this particular finite element (consult <a class="el" href="classhp_1_1FECollection.html#aae4e336f83e16ba6291d3748d52438d8">hp::FECollection::find_dominated_fe_extended()</a> for more information).</p>
<p>Transferring a solution across refinement works exactly like in the non-hp-case. However, when considering serialization, we also have to store the active FE indices in an additional step. A code snippet demonstrating serialization with the <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> class with <a class="el" href="classDoFHandler.html">DoFHandler</a> objects with hp-capabilities is provided in the following. Here VectorType is your favorite vector type, e.g. <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, or corresponding block vectors.</p>
<p>If vector has the locally relevant DoFs, serialization works as follows: </p><div class="fragment"><div class="line">parallel::distributed::</div><div class="line">  SolutionTransfer&lt;dim, VectorType, DoFHandler&lt;dim,spacedim&gt;&gt;</div><div class="line">    sol_trans(hp_dof_handler);</div><div class="line"></div><div class="line">hp_dof_handler.prepare_for_serialization_of_active_fe_indices();</div><div class="line">sol_trans.prepare_for_serialization(vector);</div><div class="line"></div><div class="line">triangulation.save(filename);</div></div><!-- fragment --><p>For deserialization the vector needs to be a distributed vector (without ghost elements): </p><div class="fragment"><div class="line"><span class="comment">//[create coarse mesh...]</span></div><div class="line">triangulation.load(filename);</div><div class="line"></div><div class="line"><a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim,spacedim&gt;</a> fe_collection;</div><div class="line"><span class="comment">//[prepare identical fe_collection...]</span></div><div class="line"></div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim,spacedim&gt;</a> hp_dof_handler(triangulation);</div><div class="line"><span class="comment">// We need to introduce our dof_handler to the fe_collection</span></div><div class="line"><span class="comment">// before setting all active FE indices.</span></div><div class="line">hp_dof_handler.deserialize_active_fe_indices();</div><div class="line">hp_dof_handler.distribute_dofs(fe_collection);</div><div class="line"></div><div class="line">parallel::distributed::</div><div class="line">  SolutionTransfer&lt;dim,VectorType,DoFHandler&lt;dim,spacedim&gt;&gt;</div><div class="line">    sol_trans(hp_dof_handler);</div><div class="line">sol_trans.deserialize(distributed_vector);</div></div><!-- fragment --><h3>Interaction with hanging nodes</h3>
<p>In essence, this class implements the same steps as does <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> (though the implementation is entirely separate). Consequently, the same issue with hanging nodes and coarsening can happen with this class as happens with <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a>. See there for an extended discussion. </p>

<p class="definition">Definition at line <a class="el" href="distributed_2solution__transfer_8h_source.html#l00222">222</a> of file <a class="el" href="distributed_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8d5f02a680eae36c7fa00b35667e897e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5f02a680eae36c7fa00b35667e897e">&#9670;&nbsp;</a></span>SolutionTransfer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::<a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">SolutionTransfer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> on which all operations will happen. At the time when this constructor is called, the <a class="el" href="classDoFHandler.html">DoFHandler</a> still points to the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a> before the refinement in question happens. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad524cea8cfaada4745c6ce53367af3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad524cea8cfaada4745c6ce53367af3eb">&#9670;&nbsp;</a></span>~SolutionTransfer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::~<a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">SolutionTransfer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a315e174af6accd0be073296939d11c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315e174af6accd0be073296939d11c86">&#9670;&nbsp;</a></span>prepare_for_coarsening_and_refinement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::prepare_for_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classVectorType.html">VectorType</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare the current object for coarsening and refinement. It stores the dof indices of each cell and stores the dof values of the vectors in <code>all_in</code> in each cell that'll be coarsened. <code>all_in</code> includes all vectors that are to be interpolated onto the new (refined and/or coarsened) grid. </p>

</div>
</div>
<a id="a4fceda8e6dc3a02ffb67ac4208a3b54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fceda8e6dc3a02ffb67ac4208a3b54e">&#9670;&nbsp;</a></span>prepare_for_coarsening_and_refinement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::prepare_for_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous function but for only one discrete function to be interpolated. </p>

</div>
</div>
<a id="aa6af36babfcc432b93c741f2b02174ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6af36babfcc432b93c741f2b02174ca">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::interpolate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVectorType.html">VectorType</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpolate the data previously stored in this object before the mesh was refined or coarsened onto the current set of cells. Do so for each of the vectors provided to <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a315e174af6accd0be073296939d11c86">prepare_for_coarsening_and_refinement()</a> and write the result into the given set of vectors. </p>

</div>
</div>
<a id="af3aa87e06c75834cfe119e6a299d3508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3aa87e06c75834cfe119e6a299d3508">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous function. It interpolates only one function. It assumes the vectors having the right sizes (i.e. <code>in.size()==n_dofs_old</code>, <code>out.size()==n_dofs_refined</code>)</p>
<p>Multiple calling of this function is NOT allowed. Interpolating several functions can be performed in one step by using <code>interpolate (all_in, all_out)</code> </p>

</div>
</div>
<a id="aefd182696d78fa7361a37af6ce3644e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd182696d78fa7361a37af6ce3644e8">&#9670;&nbsp;</a></span>prepare_for_serialization() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::prepare_for_serialization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare the serialization of the given vector. The serialization is done by <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">Triangulation::save()</a>. The given vector needs all information on the locally active DoFs (it must be ghosted). See documentation of this class for more information. </p>

</div>
</div>
<a id="afd069aab4332e123234917878ee79f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd069aab4332e123234917878ee79f47">&#9670;&nbsp;</a></span>prepare_for_serialization() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::prepare_for_serialization </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classVectorType.html">VectorType</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the function above, only for a list of vectors. </p>

</div>
</div>
<a id="a7a353b0c792ca900c973b7ead88291af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a353b0c792ca900c973b7ead88291af">&#9670;&nbsp;</a></span>deserialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::deserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute the deserialization of the given vector. This needs to be done after calling <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">Triangulation::load()</a>. The given vector must be a fully distributed vector without ghost elements. See documentation of this class for more information. </p>

</div>
</div>
<a id="a2cbb3b6a400df9b7e2a3bc103dbc0154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbb3b6a400df9b7e2a3bc103dbc0154">&#9670;&nbsp;</a></span>deserialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::deserialize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVectorType.html">VectorType</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the function above, only for a list of vectors. </p>

</div>
</div>
<a id="a0ccedcfd4c7a6d6e5683acebbbbe74fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccedcfd4c7a6d6e5683acebbbbe74fa">&#9670;&nbsp;</a></span>pack_callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;char&gt; <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::pack_callback </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::CellStatus&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A callback function used to pack the data on the current mesh into objects that can later be retrieved after refinement, coarsening and repartitioning. </p>

</div>
</div>
<a id="a1e17efd1bcd774a318d193ff2af8ec4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e17efd1bcd774a318d193ff2af8ec4e">&#9670;&nbsp;</a></span>unpack_callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::unpack_callback </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::CellStatus&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::iterator_range&lt; std::vector&lt; char &gt;::const_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVectorType.html">VectorType</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A callback function used to unpack the data on the current mesh that has been packed up previously on the mesh before refinement, coarsening and repartitioning. </p>

</div>
</div>
<a id="a448393b9d7a009e81c36d81d318e2378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448393b9d7a009e81c36d81d318e2378">&#9670;&nbsp;</a></span>register_data_attach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::register_data_attach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers the <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html#a0ccedcfd4c7a6d6e5683acebbbbe74fa">pack_callback()</a> function to the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> that has been assigned to the <a class="el" href="classDoFHandler.html">DoFHandler</a> class member and stores the returning handle. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9c40c4923a69889f320aff7bb602730b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c40c4923a69889f320aff7bb602730b">&#9670;&nbsp;</a></span>dof_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim, spacedim&gt;, <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">SolutionTransfer</a>&lt;dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim&gt; &gt; <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::dof_handler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the degree of freedom handler to work with. </p>

<p class="definition">Definition at line <a class="el" href="distributed_2solution__transfer_8h_source.html#l00317">317</a> of file <a class="el" href="distributed_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<a id="aa93dfd411779ad00d8e55cc126048ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93dfd411779ad00d8e55cc126048ad9">&#9670;&nbsp;</a></span>input_vectors</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;const <a class="el" href="classVectorType.html">VectorType</a> *&gt; <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::input_vectors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A vector that stores pointers to all the vectors we are supposed to copy over from the old to the new mesh. </p>

<p class="definition">Definition at line <a class="el" href="distributed_2solution__transfer_8h_source.html#l00323">323</a> of file <a class="el" href="distributed_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<a id="a7e6f6151829c20e55ad399f9609454f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6f6151829c20e55ad399f9609454f6">&#9670;&nbsp;</a></span>handle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt; dim, <a class="el" href="classVectorType.html">VectorType</a>, spacedim &gt;::handle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The handle that the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">Triangulation</a> has assigned to this object with which we can access our memory offset and our pack function. </p>

<p class="definition">Definition at line <a class="el" href="distributed_2solution__transfer_8h_source.html#l00329">329</a> of file <a class="el" href="distributed_2solution__transfer_8h_source.html">solution_transfer.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/distributed/<a class="el" href="distributed_2solution__transfer_8h_source.html">solution_transfer.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
