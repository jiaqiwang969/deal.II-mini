<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classMappingQ.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MappingQ&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classMappingQ-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MappingQ&lt; dim, spacedim &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a> &raquo; <a class="el" href="group__mapping.html">Mappings between reference and real cell</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="mapping__manifold_8h_source.html">deal.II/fe/mapping_manifold.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MappingQ&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classMappingQ__inherit__graph.svg" width="440" height="276"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ_1_1InternalData.html">InternalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a19cdcf97add1dac6bbe9cf1f2314cc0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a19cdcf97add1dac6bbe9cf1f2314cc0a">MappingQ</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMappingQ.html#a8ab23f3f7c43c36211348f2546e04ffd">polynomial_degree</a>, const <a class="el" href="classbool.html">bool</a> <a class="el" href="classMappingQ.html#a9d9bd27a3448d74cc7a737f6044facf0">use_mapping_q_on_all_cells</a>=false)</td></tr>
<tr class="separator:a19cdcf97add1dac6bbe9cf1f2314cc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1f93d2845588f4c821a19f3f245088"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a9b1f93d2845588f4c821a19f3f245088">MappingQ</a> (const <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt; &amp;mapping)</td></tr>
<tr class="separator:a9b1f93d2845588f4c821a19f3f245088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebd9130b864a8393b33482f6a825d49"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#afebd9130b864a8393b33482f6a825d49">get_degree</a> () const</td></tr>
<tr class="separator:afebd9130b864a8393b33482f6a825d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce8820a3a72cfd31612d5cc2f7ee075"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a5ce8820a3a72cfd31612d5cc2f7ee075">preserves_vertex_locations</a> () const override</td></tr>
<tr class="separator:a5ce8820a3a72cfd31612d5cc2f7ee075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a20f4c766e3a09c9ea6a6a9852d2209"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a4a20f4c766e3a09c9ea6a6a9852d2209">get_bounding_box</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const override</td></tr>
<tr class="separator:a4a20f4c766e3a09c9ea6a6a9852d2209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda09e02a3ee5ec03dfa0eb91e1c98ea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#afda09e02a3ee5ec03dfa0eb91e1c98ea">is_compatible_with</a> (const <a class="el" href="classReferenceCell.html">ReferenceCell</a> &amp;reference_cell) const override</td></tr>
<tr class="separator:afda09e02a3ee5ec03dfa0eb91e1c98ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac044bfceb5034603c3b44410831dd6a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#ac044bfceb5034603c3b44410831dd6a8">transform_unit_to_real_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:ac044bfceb5034603c3b44410831dd6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad080ba84f31a1f4bbd547c591a278c39"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#ad080ba84f31a1f4bbd547c591a278c39">transform_real_to_unit_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const override</td></tr>
<tr class="separator:ad080ba84f31a1f4bbd547c591a278c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d38ae55553333d2d2da4b22ef7ad9ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a8d38ae55553333d2d2da4b22ef7ad9ce">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt; &amp;output) const override</td></tr>
<tr class="separator:a8d38ae55553333d2d2da4b22ef7ad9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c0f75032706b44482ddb85e4264549"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a85c0f75032706b44482ddb85e4264549">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;output) const override</td></tr>
<tr class="separator:a85c0f75032706b44482ddb85e4264549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a3566e6ca07a4e86ccd6ca8e1cfe5a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a11a3566e6ca07a4e86ccd6ca8e1cfe5a">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;output) const override</td></tr>
<tr class="separator:a11a3566e6ca07a4e86ccd6ca8e1cfe5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb799c7303bc8ba79dcab5464f698d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a5fb799c7303bc8ba79dcab5464f698d5">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;output) const override</td></tr>
<tr class="separator:a5fb799c7303bc8ba79dcab5464f698d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc3537969ea26cbc92647d553fed15e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#afcc3537969ea26cbc92647d553fed15e">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;output) const override</td></tr>
<tr class="separator:afcc3537969ea26cbc92647d553fed15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20cc628269287050bc74cc74a85c139"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#ac20cc628269287050bc74cc74a85c139">clone</a> () const override</td></tr>
<tr class="separator:ac20cc628269287050bc74cc74a85c139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f37fd5b4a965f3f4ae0d0ca3060156"><td class="memItemLeft" align="right" valign="top">virtual boost::container::small_vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_cell &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#af3f37fd5b4a965f3f4ae0d0ca3060156">get_vertices</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const</td></tr>
<tr class="separator:af3f37fd5b4a965f3f4ae0d0ca3060156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6376f7ab802afb171a00a1a7748cf2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a8a6376f7ab802afb171a00a1a7748cf2">get_center</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classbool.html">bool</a> map_center_of_reference_cell=true) const</td></tr>
<tr class="separator:a8a6376f7ab802afb171a00a1a7748cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">引用单元格和实数单元格之间的映射点</div></td></tr>
<tr class="memitem:a0e4eddf3673a9b22104c05bfdfe96bbb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a0e4eddf3673a9b22104c05bfdfe96bbb">transform_points_real_to_unit_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;real_points, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;unit_points) const</td></tr>
<tr class="separator:a0e4eddf3673a9b22104c05bfdfe96bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078f4e617fdb287e1dc7a5efa227b0ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a078f4e617fdb287e1dc7a5efa227b0ae">project_real_point_to_unit_point_on_face</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const</td></tr>
<tr class="separator:a078f4e617fdb287e1dc7a5efa227b0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">异常情况 @{</div></td></tr>
<tr class="memitem:a72122ff6ee588e788415f3124c48bb0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a72122ff6ee588e788415f3124c48bb0d">DeclException0</a> (ExcInvalidData)</td></tr>
<tr class="separator:a72122ff6ee588e788415f3124c48bb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5086637353e09ce6fb8d84f81be8affa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5086637353e09ce6fb8d84f81be8affa">DeclExceptionMsg</a> (ExcTransformationFailed, &quot;Computing the mapping between a real space point and a point in reference &quot; &quot;space failed, typically because the given point lies outside the cell &quot; &quot;where the inverse mapping is not unique.&quot;)</td></tr>
<tr class="separator:ga5086637353e09ce6fb8d84f81be8affa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga142dcb2a567c72d6cc2607070cd56a83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga142dcb2a567c72d6cc2607070cd56a83">DeclException3</a> (ExcDistortedMappedCell, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The image of the mapping applied to cell with <a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a> [&quot;&lt;&lt; arg1&lt;&lt; &quot;] is distorted. The cell geometry or the &quot;&lt;&lt; &quot;mapping are invalid, giving a non-positive volume &quot;&lt;&lt; &quot;fraction of &quot;&lt;&lt; arg2&lt;&lt; &quot; in quadrature point &quot;&lt;&lt; arg3&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:ga142dcb2a567c72d6cc2607070cd56a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">与FEValues的接口</div></td></tr>
<tr class="memitem:ae772c05feadd3a7a753c351c78ffad25"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#ae772c05feadd3a7a753c351c78ffad25">requires_update_flags</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags) const override</td></tr>
<tr class="separator:ae772c05feadd3a7a753c351c78ffad25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a91247a05bb8b0830dac3feead8c857"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a2a91247a05bb8b0830dac3feead8c857">get_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature) const override</td></tr>
<tr class="separator:a2a91247a05bb8b0830dac3feead8c857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d541cb896cd92874e299d0e30a71e1"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a97d541cb896cd92874e299d0e30a71e1">get_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature) const override</td></tr>
<tr class="separator:a97d541cb896cd92874e299d0e30a71e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df30dc89b42435d39d5547cc6f398cb"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a4df30dc89b42435d39d5547cc6f398cb">get_subface_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature) const override</td></tr>
<tr class="separator:a4df30dc89b42435d39d5547cc6f398cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c28ad911ada620b00f6f17c823ae38"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a80c28ad911ada620b00f6f17c823ae38">fill_fe_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a80c28ad911ada620b00f6f17c823ae38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4629cea9642d14655abbba2e6a5113e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#af4629cea9642d14655abbba2e6a5113e">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:af4629cea9642d14655abbba2e6a5113e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d26263547a910cae5c31026a4d1a3b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a55d26263547a910cae5c31026a4d1a3b">fill_fe_subface_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> subface_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a55d26263547a910cae5c31026a4d1a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">与FEValues的接口</div></td></tr>
<tr class="memitem:a85e75b674cebc41831eac23a44732fcf"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a85e75b674cebc41831eac23a44732fcf">get_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature) const</td></tr>
<tr class="separator:a85e75b674cebc41831eac23a44732fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69cb4dd66dd3745b483f4703cb1fb69"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">fill_fe_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const =0</td></tr>
<tr class="separator:ac69cb4dd66dd3745b483f4703cb1fb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baf527d46a7f2391dbb3dd5dc416864"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a9baf527d46a7f2391dbb3dd5dc416864">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a9baf527d46a7f2391dbb3dd5dc416864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51c964b1e51b69db3f4933b97bff8c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#aa51c964b1e51b69db3f4933b97bff8c8">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:aa51c964b1e51b69db3f4933b97bff8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7f6025bc3f10e8f7da2c8a68eaff4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a9f7f6025bc3f10e8f7da2c8a68eaff4a">fill_fe_subface_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> subface_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const =0</td></tr>
<tr class="separator:a9f7f6025bc3f10e8f7da2c8a68eaff4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8ab23f3f7c43c36211348f2546e04ffd"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a8ab23f3f7c43c36211348f2546e04ffd">polynomial_degree</a></td></tr>
<tr class="separator:a8ab23f3f7c43c36211348f2546e04ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9bd27a3448d74cc7a737f6044facf0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a9d9bd27a3448d74cc7a737f6044facf0">use_mapping_q_on_all_cells</a></td></tr>
<tr class="separator:a9d9bd27a3448d74cc7a737f6044facf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2bd47a99a2c7d6dbe2326ad5fc067a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#a0b2bd47a99a2c7d6dbe2326ad5fc067a">q1_mapping</a></td></tr>
<tr class="separator:a0b2bd47a99a2c7d6dbe2326ad5fc067a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdbdf7750f384ed054a8bdcbbec2136"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQ.html#adbdbdf7750f384ed054a8bdcbbec2136">qp_mapping</a></td></tr>
<tr class="separator:adbdbdf7750f384ed054a8bdcbbec2136"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class MappingQ&lt; dim, spacedim &gt;</h3>

<p>一个在域的边界单元（或者，如果在构造函数中要求，对所有单元）上实现度数为 \(p\) 的多项式映射的类，以及对内部单元的线性映射。 该类实际上命名不当，因为（除非在构造对象时明确指定，见下文），它实际上不使用度数为 \(p\) <em>everywhere</em>的映射，而只在边界的单元上使用。这与MappingQGeneric类形成对比，后者确实在任何地方都使用度数为 \(Q_p\) 的多项式映射 \(p\) 。当前类的重点是，在很多情况下，曲线域只提供了关于边界处的边缘到底是如何形成的信息，但我们对内部的边缘一无所知。因此，在没有其他信息的情况下，我们只能假设内部边缘是直线，在这种情况下，内部单元也可以被视为双线性四边形或三线性六面体。(在 <a class="el" href="step_1.html">step-1</a> 中已经展示了这样的网格的例子，但在 <a class="el" href="step_6.html">step-6</a> 的 "结果 "部分也有讨论) 。因为双线/三线映射的计算成本明显低于高阶映射，在这种情况下，只在域的边界单元上使用高阶映射是有利的。这个类正好实现了这种行为。 有一些特殊情况值得考虑。</p>
<ul>
<li>如果你想对所有单元使用高阶映射，你可以通过设置构造函数的第二个参数为true来实现。这只有在你能实际提供关于网格内部边缘和面应该如何弯曲的信息时才有意义。这通常是通过将Manifold与内部单元格和边缘关联来实现的。一个简单的例子在 <a class="el" href="step_6.html">step-6</a> 的 "结果 "部分讨论；关于流形的完整讨论在 <a class="el" href="step_53.html">step-53</a> 中提供。</li>
<li>如果你将true作为该类的第二个参数，那么实际上完全等同于立即生成一个MappingQGeneric对象。</li>
<li>如果提供的多项式程度是1，这个类也完全等同于MappingQGeneric。这是因为在这种情况下，在域的内部和边界的单元上使用的映射不能被区分。</li>
<li>如果你正在处理嵌入更高空间维度的网格，也就是说，如果dim!=spacedim，那么每个单元都被认为是在域的边界，因此对所有单元都使用高阶映射；同样，这个类也相当于立即使用MappingQGeneric。 <h4>Behavior along curved boundaries and with different manifolds</h4>
</li>
</ul>
<p>关于不同流形混合情况下的映射行为和收敛率，请参考MappingQGeneric的相关章节。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__manifold_8h_source.html#l00034">34</a> of file <a class="el" href="mapping__manifold_8h_source.html">mapping_manifold.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a19cdcf97add1dac6bbe9cf1f2314cc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19cdcf97add1dac6bbe9cf1f2314cc0a">&#9670;&nbsp;</a></span>MappingQ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::<a class="el" href="classMappingQ.html">MappingQ</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>polynomial_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_mapping_q_on_all_cells</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。 <code>polynomial_degree</code> 表示用于映射单元格边界的多项式的程度。 第二个参数决定了高阶映射是否也应该用于内部单元。如果它的值是 <code>false</code> （默认值），那么在内部就使用低阶映射。这对大多数情况来说是足够的，因为高阶映射只是用来更好地接近边界。在这种情况下，内部以直线为界的单元是可以接受的。然而，在有些情况下，人们也希望在内部使用高阶映射。MappingQEulerian类就是这样一种情况。 如果 <code>dim</code> 不等于 <code>spacedim</code>, ， <code>use_mapping_q_on_all_cells</code> 的值就会被忽略，也就是说，如果我们考虑的是嵌入高维空间的表面的网格。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00061">61</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="a9b1f93d2845588f4c821a19f3f245088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1f93d2845588f4c821a19f3f245088">&#9670;&nbsp;</a></span>MappingQ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::<a class="el" href="classMappingQ.html">MappingQ</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制构造器。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00089">89</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afebd9130b864a8393b33482f6a825d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebd9130b864a8393b33482f6a825d49">&#9670;&nbsp;</a></span>get_degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::get_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回映射的程度，即传递给构造函数的值。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00122">122</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="a5ce8820a3a72cfd31612d5cc2f7ee075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce8820a3a72cfd31612d5cc2f7ee075">&#9670;&nbsp;</a></span>preserves_vertex_locations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::preserves_vertex_locations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>总是返回 <code>true</code> ，因为这个类中函数的默认实现保留了顶点位置。 </p>

<p>Implements <a class="el" href="classMapping.html#accdebb05aa5f08dda54941868ce9fbe8">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classMappingQEulerian.html#a516485960c1867ad2e96a1736cffacf8">MappingQEulerian&lt; dim, VectorType, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00131">131</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="a4a20f4c766e3a09c9ea6a6a9852d2209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a20f4c766e3a09c9ea6a6a9852d2209">&#9670;&nbsp;</a></span>get_bounding_box()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt; <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::get_bounding_box </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回映射的单元格的边界盒。 如果你使用的是保留顶点位置的(bi-,tri-)线性映射，这个函数简单地返回同样由<code>cell-&gt;bounding_box()</code>产生的值。然而，也有一些映射会增加位移或选择完全不同的位置，例如MappingQEulerian、MappingQ1Eulerian或MappingFEField。 对于线性映射，该函数返回包含单元格所有顶点的边界框，如get_vertices()方法所返回的。对于通过支持点定义的高阶映射，边界盒只保证包含所有支持点，而且一般来说，它只是真正边界盒的近似值，可能更大。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">单元格</td><td>你想计算边界框的单元格 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classMapping.html#a50d2861c7e444384240609ec53093a54">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classMappingQEulerian.html#a71a17c22f99d5faca0456fda65be2ed1">MappingQEulerian&lt; dim, VectorType, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00549">549</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="afda09e02a3ee5ec03dfa0eb91e1c98ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda09e02a3ee5ec03dfa0eb91e1c98ea">&#9670;&nbsp;</a></span>is_compatible_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::is_compatible_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classReferenceCell.html">ReferenceCell</a> &amp;&#160;</td>
          <td class="paramname"><em>reference_cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个Mapping实例是否与 <code>reference_cell</code>. 中的单元格类型兼容。 </p>

<p>Implements <a class="el" href="classMapping.html#a0d8ac8be12bd87c4e7f529778ec317de">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00564">564</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="ac044bfceb5034603c3b44410831dd6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac044bfceb5034603c3b44410831dd6a8">&#9670;&nbsp;</a></span>transform_unit_to_real_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::transform_unit_to_real_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将单元格上的点 <code>p</code> 转换为实单元格 <code>cell</code> 上的点 <code>p_real</code> ，并返回 <code>p_real</code>. 。 </p>

<p>Implements <a class="el" href="classMapping.html#ae5df63553eb8ed170c3b90524853dd48">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00507">507</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="ad080ba84f31a1f4bbd547c591a278c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad080ba84f31a1f4bbd547c591a278c39">&#9670;&nbsp;</a></span>transform_real_to_unit_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt; <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::transform_real_to_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将实细胞上的点 <code>p</code> 转换到单元格 <code>cell</code> 上的点 <code>p_unit</code> ，并返回 <code>p_unit</code>. 使用牛顿迭代和 <code>transform_unit_to_real_cell</code> 函数。 在一维情况下，该函数返回实点 <code>p</code> 在 <code>cell</code>. 标识的曲线或曲面上的法线投影。 </p><dl class="section note"><dt>Note</dt><dd>如果要计算反映射的点位于单元格边界之外，从参考（单位）单元格坐标到实数单元格坐标系的多项式映射并不总是可逆的。 在这种情况下，当前函数可能无法计算出参考单元上的一个点，该点在映射下的图像等于给定的点 <code>p</code>. 如果是这种情况，那么这个函数会抛出一个 Mapping::ExcTransformationFailed 类型的异常。 因此，给定的点 <code>p</code> 是否位于单元格之外，可以通过检查返回的参考坐标是否位于参考单元格之内或之外来确定（例如，使用 <a class="el" href="structGeometryInfo.html#ace2d235da3d7459096d535d360bcf3d3">GeometryInfo::is_inside_unit_cell</a>) 或是否抛出了上述的异常。 </dd></dl>

<p>Implements <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00524">524</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="a8d38ae55553333d2d2da4b22ef7ad9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d38ae55553333d2d2da4b22ef7ad9ce">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>根据所选的MappingKind对矢量或1-差分形式的场进行变换。 </p><dl class="section note"><dt>Note</dt><dd>通常情况下，这个函数被一个有限元调用，填充FEValues对象。对于这个有限元，应该有一个别名MappingKind，如 <code>mapping_bdm</code>, <code>mapping_nedelec</code>, 等。这个别名应该优先于使用下面的种类。 目前由派生类实现的映射种类是。 <ul>
<li>
<code>mapping_contravariant:</code> 通过Jacobian将参考单元上的矢量场映射到物理单元。 <p class="formulaDsp">
\[ \mathbf u(\mathbf x) = J(\hat{\mathbf x})\hat{\mathbf u}(\hat{\mathbf x}). \]
</p>
 在物理学中，这通常被称为反变量变换。在数学上，它是一个矢量场的前推。 </li>
<li>
<code>mapping_covariant:</code> 将参考单元上的一形场映射到物理单元上的一形场。理论上，这将指的是DerivativeForm&lt;1,dim,1&gt;，但我们将这种类型与Tensor&lt;1,dim&gt;进行规范性的识别）。在数学上，它是微分形式的回拉 <p class="formulaDsp">
\[ \mathbf u(\mathbf x) = J(\hat{\mathbf x})(J(\hat{\mathbf x})^{T} J(\hat{\mathbf x}))^{-1}\hat{\mathbf u}(\hat{\mathbf x}). \]
</p>
标量可微分函数的梯度是这样转化的。 在dim=spacedim的情况下，前面的公式简化为 <p class="formulaDsp">
\[ \mathbf u(\mathbf x) = J(\hat{\mathbf x})^{-T}\hat{\mathbf u}(\hat{\mathbf x}) \]
</p>
，因为我们假设映射 \(\mathbf F_K\) 总是可逆的，因此其雅各布 \(J\) 是一个可逆矩阵。 </li>
<li>
<code>mapping_piola:</code> 参考单元上的<em>dim-1</em>形式的场也由矢量场表示，但同样以不同的方式变换，即通过皮奥拉变换 <p class="formulaDsp">
\[ \mathbf u(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J(\hat{\mathbf x}) \hat{\mathbf u}(\hat{\mathbf x}). \]
</p>
 </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">输入</td><td>一个应该被映射的输入对象的数组（或数组的一部分）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>要应用的映射的种类。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>一个指向 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类型的对象的指针，该对象包含先前由映射存储的信息。指向的对象是由get_data()、get_face_data()或get_subface_data()函数创建的，在调用当前函数之前，将作为对当前单元格的fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()调用的一部分而被更新。换句话说，这个对象也代表了与哪个单元格有关的变换应该被应用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">输出</td><td>一个数组（或数组的一部分），转换后的对象应该被放入其中。(注意，数组视图是 <code>常数，但它所指向的张量不是。</code>) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00388">388</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="a85c0f75032706b44482ddb85e4264549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c0f75032706b44482ddb85e4264549">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个微分形式的场从参考单元转换到物理单元。 认为 \(\mathbf{T} = \nabla \mathbf u\) 和 \(\hat{\mathbf T} = \hat \nabla \hat{\mathbf u}\) 是有用的， \(\mathbf u\) 是一个矢量场。 目前由派生类实现的映射种类有。 </p><ul>
<li>
<code>mapping_covariant:</code> 将参考单元上的形式域映射到物理单元上的形式域。在数学上，它是微分形式的回拉 <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})(J(\hat{\mathbf x})^{T} J(\hat{\mathbf x}))^{-1}. \]
</p>
间隔向量值微分函数的雅各布斯是这样转换的。 在dim=spacedim的情况下，前面的公式简化为 <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = \hat{\mathbf u}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
</ul>
<p>。 </p><dl class="section note"><dt>Note</dt><dd>如果把这个变换变成一个模板函数，其等级在<code><a class="el" href="classDerivativeForm.html">DerivativeForm</a> &lt;1, dim, rank &gt;</code>. 中会更合理，可惜C++不允许模板化虚拟函数。这就是为什么我们在这个函数transform()上面使用mapping_covariant()时，将<code><a class="el" href="classDerivativeForm.html">DerivativeForm</a> &lt;1, dim, 1 &gt;</code> 标识为 <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> 。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>应该被映射的输入对象的一个数组（或数组的一部分）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>要应用的映射的种类。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>一个指向 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类型的对象的指针，该对象包含先前由映射存储的信息。指向的对象是由get_data()、get_face_data()或get_subface_data()函数创建的，在调用当前函数之前，将作为对当前单元格的fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()调用的一部分被更新。换句话说，这个对象也代表了与哪个单元格有关的变换应该被应用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">输出</td><td>一个数组（或数组的一部分），转换后的对象应该被放入其中。(注意，数组视图是 <code>常数，但它所指向的张量不是。</code>) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#a871f491f3d06fda8a30157c8c2b6ae08">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00411">411</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="a11a3566e6ca07a4e86ccd6ca8e1cfe5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a3566e6ca07a4e86ccd6ca8e1cfe5a">&#9670;&nbsp;</a></span>transform() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个张量场从参考单元转换到物理单元。 这些张量通常是参考单元中已经从物理单元拉回来的矢量场的雅各布系数。 目前由派生类实现的映射种类有。 </p><ul>
<li>
<code>mapping_contravariant_gradient:</code> 它假设 \(\mathbf u(\mathbf x) = J \hat{\mathbf u}\) 这样 <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = J(\hat{\mathbf x}) \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_covariant_gradient:</code> 它假设 \(\mathbf u(\mathbf x) = J^{-T} \hat{\mathbf u}\) 这样 <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = J(\hat{\mathbf x})^{-T} \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_piola_gradient:</code> 它假设 \(\mathbf u(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J(\hat{\mathbf x}) \hat{\mathbf u}(\hat{\mathbf x})\) 这样 <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J(\hat{\mathbf x}) \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 ] </li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd>mapping_covariant_gradient、mapping_contravariant_gradient和mapping_piola_gradient的公式只对线性映射而言是真的。例如，如果映射是双线性的（或具有高阶多项式程度），那么就会有一个与 \(J\) 的导数相关的缺失项。</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">输入</td><td>一个应该被映射的输入对象的数组（或数组的一部分）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>要应用的映射的种类。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>一个指向 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类型的对象的指针，该对象包含先前由映射存储的信息。指向的对象是由get_data()、get_face_data()或get_subface_data()函数创建的，在调用当前函数之前，将作为对当前单元格的fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()调用的一部分被更新。换句话说，这个对象也代表了与哪个单元格有关的变换应该被应用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>一个数组（或数组的一部分），转换后的对象应该被放入其中。(注意，数组视图是 <code>常数，但它所指向的张量不是。</code>) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#ab22b7178a30a5ec26003ffc8fd02d8dd">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00435">435</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="a5fb799c7303bc8ba79dcab5464f698d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb799c7303bc8ba79dcab5464f698d5">&#9670;&nbsp;</a></span>transform() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个张量场从参考单元转换到物理单元。 这种张量在大多数情况下是参考单元中的向量场的 hessians，这些向量场已经从物理单元拉回来。 目前由派生类实现的映射种类有。 </p><ul>
<li>
<code>mapping_covariant_gradient:</code> 将参考单元上的形式场映射到物理单元上的形式场。在数学上，它是微分形式 <p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = \hat{\mathbf T}_{iJK}(\hat{\mathbf x}) J_{jJ}^{\dagger} J_{kK}^{\dagger}\]
</p>
的回拉，其中 <p class="formulaDsp">
\[ J^{\dagger} = J(\hat{\mathbf x})(J(\hat{\mathbf x})^{T} J(\hat{\mathbf x}))^{-1}. \]
</p>
 </li>
</ul>
<p>间隔向量值可微函数的Hessians是这样转化的（在减去导数与雅各布梯度的乘积后）。 在dim=spacedim的情况下，前面的公式简化为 </p><p class="formulaDsp">
\[J^{\dagger} = J^{-1}\]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>应该被映射的输入对象的数组（或数组的一部分）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>要应用的映射的种类。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>一个指向类型为 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 的对象的指针，该对象包含先前由映射存储的信息。指向的对象是由get_data()、get_face_data()或get_subface_data()函数创建的，在调用当前函数之前，将作为对当前单元格的fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()调用的一部分被更新。换句话说，这个对象也代表了与哪个单元格有关的变换应该被应用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>一个数组（或数组的一部分），转换后的对象应该被放入其中。(注意，数组视图是 <code>常数，但它指向的张量不是。</code>) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#abe09058f596dbda03936270390f3d2e4">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00459">459</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="afcc3537969ea26cbc92647d553fed15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc3537969ea26cbc92647d553fed15e">&#9670;&nbsp;</a></span>transform() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个3差分形式的场从参考单元转换到物理单元。 认为 \(\mathbf{T}_{ijk} = D^2_{jk} \mathbf u_i\) 和 \(\mathbf{\hat T}_{IJK} = \hat D^2_{JK} \mathbf{\hat u}_I\) 很有用， \(\mathbf u_i\) 是一个矢量场。 目前由派生类实现的映射种类是。 </p><ul>
<li>
<code>mapping_contravariant_hessian:</code> 它假定 \(\mathbf u_i(\mathbf x) = J_{iI} \hat{\mathbf u}_I\) 以便 <p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = J_{iI}(\hat{\mathbf x}) \hat{\mathbf T}_{IJK}(\hat{\mathbf x}) J_{jJ}(\hat{\mathbf x})^{-1} J_{kK}(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_covariant_hessian:</code> 它假定 \(\mathbf u_i(\mathbf x) = J_{iI}^{-T} \hat{\mathbf u}_I\) 以便 <p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = J_iI(\hat{\mathbf x})^{-1} \hat{\mathbf T}_{IJK}(\hat{\mathbf x}) J_{jJ}(\hat{\mathbf x})^{-1} J_{kK}(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_piola_hessian:</code> ] 它假定 \(\mathbf u_i(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J_{iI}(\hat{\mathbf x}) \hat{\mathbf u}(\hat{\mathbf x})\) 这样 <p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J_{iI}(\hat{\mathbf x}) \hat{\mathbf T}_{IJK}(\hat{\mathbf x}) J_{jJ}(\hat{\mathbf x})^{-1} J_{kK}(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">输入</td><td>一个应该被映射的输入对象的数组（或数组的一部分）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>要应用的映射的种类。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>一个指向 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类型的对象的指针，该对象包含先前由映射存储的信息。指向的对象是由get_data()、get_face_data()或get_subface_data()函数创建的，在调用当前函数之前，将作为对当前单元格的fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()调用的一部分被更新。换句话说，这个对象也代表了与哪个单元格有关的变换应该被应用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>一个数组（或数组的一部分），转换后的对象应该被放入其中。 </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#a38deb68a3d62e46bababbcb10bc928d8">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00483">483</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="ac20cc628269287050bc74cc74a85c139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20cc628269287050bc74cc74a85c139">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个指向当前对象副本的指针。然后，这个副本的调用者就拥有了它的所有权。 </p>

<p>Implements <a class="el" href="classMapping.html#aefbf70ea6f93dba57ac3fa7eb2e51992">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classMappingQEulerian.html#a20829c9a27e30a255729c66b6a93cb32">MappingQEulerian&lt; dim, VectorType, spacedim &gt;</a>, and <a class="el" href="classMappingC1.html#a4f2af8401ec7639b92a7fc1cf20a4be9">MappingC1&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00539">539</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="ae772c05feadd3a7a753c351c78ffad25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae772c05feadd3a7a753c351c78ffad25">&#9670;&nbsp;</a></span>requires_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::requires_update_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定一组更新标志，计算哪些其他的量<em>also</em>需要被计算，以满足给定标志的请求。 然后返回原始标志集和刚刚计算的标志的组合。 举个例子，如果 <code>update_flags</code> 包含update_JxW_values（即雅各布式的行列式和正交公式提供的权重的乘积），一个映射可能需要计算完整的雅各布式矩阵，以便计算其行列式。然后他们将不仅返回update_JxW_values，而且还返回update_jacobians。在计算JxW值的派生类中，内部实际上不是这样做的</p>
<ul>
<li>他们设置了update_contravariant_transformation来代替，由此也可以计算出行列式。</li>
<li>但这并不影响这个例子的启发性）。) 关于这个函数和FEValues之间的互动的广泛讨论可以在 <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and</a> 文档模块中找到。 <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> </dd></dl>
</li>
</ul>

<p>Implements <a class="el" href="classMapping.html#a4c62b5a55ca40e2b38c6a3a1f460d540">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00140">140</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="a2a91247a05bb8b0830dac3feead8c857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a91247a05bb8b0830dac3feead8c857">&#9670;&nbsp;</a></span>get_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt; <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::get_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建并返回一个指向对象的指针，映射可以在该对象中存储数据，这些数据只需要计算一次，但在映射应用于具体单元时都可以使用（例如，在各种transform()函数中，以及构成映射与FEValues类接口的fill_fe_values()、fill_fe_face_values()和fill_fe_subface_values()中）。 派生类将返回指向从 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 派生的类型的对象的指针（更多信息见那里），并且可能已经预先计算了一些信息（根据未来对映射的要求，由更新标志指定）和给定的正交对象。随后对transform()或fill_fe_values()和friends的调用将收到这里创建的对象（具有相同的更新标志集和相同的正交对象）。因此，派生类可以在其get_data()函数中预先计算一些信息，并将其存储在内部数据对象中。 映射类不会跟踪由该函数创建的对象。因此，所有权将归调用者所有。 关于这个函数和FEValues之间的互动的广泛讨论可以在 <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and</a> 文档模块中找到。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_flags</td><td>一组标志，定义了在未来调用transform()或fill_fe_values()函数组时对映射类的期望。这组标志可能包含映射不知道如何处理的标志（例如，对于事实上由有限元类计算的信息，如 UpdateFlags::update_values). 派生类将需要存储这些标志，或者至少是需要映射在fill_fe_values()中执行任何操作的标志子集，在 <a class="el" href="classMapping_1_1InternalDataBase.html#a43f4579d65a86db27d208ebf42ad3f44">InternalDataBase::update_each</a>. </td></tr>
    <tr><td class="paramname">quadrature</td><td>必须计算映射信息的正交对象。这包括正交点的位置和权重。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个指向新创建的InternalDataBase类型（或派生类）对象的指针。该对象的所有权转移给调用函数。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++允许派生类中的虚拟函数可以返回不是InternalDataBase类型的对象的指针，但实际上是指向InternalDataBase的类<em>derived</em>的对象的指针。(这个特性被称为 "共变返回类型"。)这在某些情况下是很有用的，因为在派生类中的调用将立即使用返回的对象，知道它的真实（派生）类型。 </dd></dl>

<p>Implements <a class="el" href="classMapping.html#a2fdce92a1ba733f9652de666d3475a34">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00150">150</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="a97d541cb896cd92874e299d0e30a71e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d541cb896cd92874e299d0e30a71e1">&#9670;&nbsp;</a></span>get_face_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt; <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>像get_data()一样，但是为以后调用transform()或fill_fe_face_values()做准备，这些调用需要关于从参考面到具体单元面的映射信息。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_flags</td><td>一组标志，定义在未来调用transform()或fill_fe_values()函数组时对映射类的期望。这组标志可能包含映射不知道如何处理的标志（例如，对于事实上由有限元类计算的信息，如 UpdateFlags::update_values). 派生类将需要存储这些标志，或者至少是需要映射在fill_fe_values()中执行任何操作的标志子集，在 <a class="el" href="classMapping_1_1InternalDataBase.html#a43f4579d65a86db27d208ebf42ad3f44">InternalDataBase::update_each</a>. </td></tr>
    <tr><td class="paramname">quadrature</td><td>需要计算映射信息的正交对象。这包括正交点的位置和权重。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个指向新创建的InternalDataBase类型（或派生类）对象的指针。该对象的所有权转移给调用函数。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++允许派生类中的虚拟函数可以返回不是InternalDataBase类型的对象的指针，但实际上是指向InternalDataBase的类<em>derived</em>的对象的指针。(这个特性被称为 "共变返回类型"。)这在某些情况下是很有用的，因为在派生类中的调用将立即使用返回的对象，知道它的真实（派生）类型。 </dd></dl>

<p>Reimplemented from <a class="el" href="classMapping.html#af3955d81e5bb00f69c566e0890fddeb6">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00181">181</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="a4df30dc89b42435d39d5547cc6f398cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df30dc89b42435d39d5547cc6f398cb">&#9670;&nbsp;</a></span>get_subface_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt; <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::get_subface_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>像get_data()和get_face_data()一样，但是为以后调用transform()或fill_fe_subface_values()做准备，这些调用将需要关于从参考面到具体单元的面的子（即子面）的映射信息。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_flags</td><td>一组标志，定义在未来调用transform()或fill_fe_values()函数组时对映射类的期望。这组标志可能包含映射不知道如何处理的标志（例如，对于事实上由有限元类计算的信息，如 UpdateFlags::update_values). 派生类将需要存储这些标志，或者至少是需要映射在fill_fe_values()中执行任何操作的标志子集，在 <a class="el" href="classMapping_1_1InternalDataBase.html#a43f4579d65a86db27d208ebf42ad3f44">InternalDataBase::update_each</a>. </td></tr>
    <tr><td class="paramname">quadrature</td><td>必须计算映射信息的正交对象。这包括正交点的位置和权重。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个指向新创建的InternalDataBase类型（或派生类）对象的指针。该对象的所有权转移给调用函数。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++允许派生类中的虚拟函数可以返回不是InternalDataBase类型的对象的指针，但实际上是指向InternalDataBase的类<em>derived</em>的对象的指针。(这个特性被称为 "共变返回类型"。)这在某些情况下是很有用的，在这些情况下，调用是在派生类中，并且将立即使用返回的对象，知道它的真实（派生）类型。 </dd></dl>

<p>Implements <a class="el" href="classMapping.html#aa101c7827bf40a80b9adac393d830af1">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00218">218</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="a80c28ad911ada620b00f6f17c823ae38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c28ad911ada620b00f6f17c823ae38">&#9670;&nbsp;</a></span>fill_fe_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classMappingQEulerian.html#a144001ee2a1e1f0933e6a4d748830688">MappingQEulerian&lt; dim, VectorType, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00252">252</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="af4629cea9642d14655abbba2e6a5113e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4629cea9642d14655abbba2e6a5113e">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00306">306</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="a55d26263547a910cae5c31026a4d1a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d26263547a910cae5c31026a4d1a3b">&#9670;&nbsp;</a></span>fill_fe_subface_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__q_8cc_source.html#l00342">342</a> of file <a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a>.</p>

</div>
</div>
<a id="af3f37fd5b4a965f3f4ae0d0ca3060156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f37fd5b4a965f3f4ae0d0ca3060156">&#9670;&nbsp;</a></span>get_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_cell &gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个单元格的映射顶点。 大多数时候，这些值将仅仅是由 <code>cell-&gt;vertex(v)</code> 返回的顶点 <code>v</code> 的坐标，即由三角法存储的信息。 然而，也有增加位移或选择完全不同位置的映射，例如MappingQEulerian, <a class="el" href="classMappingQ1Eulerian.html">MappingQ1Eulerian</a>, 或MappingFEField。 这个函数的默认实现只是返回三角形所存储的信息，即： <code>cell-&gt;vertex(v)</code> . </p>

<p>Reimplemented in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ae1f6479ed386a00610eb138937705b5b">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQEulerian_1_1MappingQEulerianGeneric.html#a550a08b0626318f016ba6f7b6c7b115f">MappingQEulerian&lt; dim, VectorType, spacedim &gt;::MappingQEulerianGeneric</a>, <a class="el" href="classMappingQEulerian.html#a27e82d02aea674ad2463141b3188b8c7">MappingQEulerian&lt; dim, VectorType, spacedim &gt;</a>, and <a class="el" href="classMappingQ1Eulerian.html#a1b6dcd79f532e305122ef10ab31665a8">MappingQ1Eulerian&lt; dim, VectorType, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping_8cc_source.html#l00033">33</a> of file <a class="el" href="mapping_8cc_source.html">mapping.cc</a>.</p>

</div>
</div>
<a id="a8a6376f7ab802afb171a00a1a7748cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6376f7ab802afb171a00a1a7748cf2">&#9670;&nbsp;</a></span>get_center()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_center </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>map_center_of_reference_cell</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个单元格的映射中心。 如果你使用的是保留顶点位置的(bi-,tri-)线性映射，这个函数只是返回同样由<code>cell-&gt;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center()</a></code>产生的值。然而，也有一些映射会增加位移或选择完全不同的位置，例如MappingQEulerian、MappingQ1Eulerian或MappingFEField，以及基于高阶多项式的映射，对于这些映射，中心可能不会与顶点位置的平均值重合。 默认情况下，该函数返回参考单元中心的前推。如果参数 <code>map_center_of_reference_cell</code> 被设置为false，那么返回值将是由get_vertices()方法返回的顶点位置的平均值。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>你想计算中心的单元格 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_center_of_reference_cell</td><td>一个标志，用于将计算单元格中心的算法从应用于参考单元格中心的transform_unit_to_real_cell()转换为计算顶点平均数。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mapping_8cc_source.html#l00049">49</a> of file <a class="el" href="mapping_8cc_source.html">mapping.cc</a>.</p>

</div>
</div>
<a id="a0e4eddf3673a9b22104c05bfdfe96bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4eddf3673a9b22104c05bfdfe96bbb">&#9670;&nbsp;</a></span>transform_points_real_to_unit_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::transform_points_real_to_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>real_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将多个点从真实点位置映射到参考位置的点。其功能基本上与在所有点上循环并为每个点单独调用 <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a> 函数相同，但对于某些实现了更专业的版本的映射，如MappingQGeneric，其速度会更快。行为上的唯一区别是，这个函数永远不会抛出ExcTransformationFailed()异常。如果对<code>real_points[i]</code>转换失败，返回的<code>unit_points[i]</code>包含 std::numeric_limits&lt;double&gt;::infinity() 作为第一个条目。 </p>

<p>Reimplemented in <a class="el" href="classMappingQGeneric.html#a7fed5446020926f01f434e18568bdda1">MappingQGeneric&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping_8cc_source.html#l00087">87</a> of file <a class="el" href="mapping_8cc_source.html">mapping.cc</a>.</p>

</div>
</div>
<a id="a078f4e617fdb287e1dc7a5efa227b0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078f4e617fdb287e1dc7a5efa227b0ae">&#9670;&nbsp;</a></span>project_real_point_to_unit_point_on_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::project_real_point_to_unit_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将实数 <code>cell</code> 上的点 <code>p</code> 转换为参考单元上的对应点，然后将此点投射到给定面数 <code>face_no</code>. 的面的坐标系中的一个(dim-1)维的点，理想情况下，点 <code>p</code> 靠近面 <code>face_no</code>, ，但技术上单元中的任何点都可以被投影。 当dim=1时，这个函数没有物理意义，所以在这种情况下它会抛出一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="mapping_8cc_source.html#l00111">111</a> of file <a class="el" href="mapping_8cc_source.html">mapping.cc</a>.</p>

</div>
</div>
<a id="a72122ff6ee588e788415f3124c48bb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72122ff6ee588e788415f3124c48bb0d">&#9670;&nbsp;</a></span>DeclException0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidData&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a85e75b674cebc41831eac23a44732fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e75b674cebc41831eac23a44732fcf">&#9670;&nbsp;</a></span>get_face_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>使用带有 <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> 参数的版本。</dd></dl>

</div>
</div>
<a id="ac69cb4dd66dd3745b483f4703cb1fb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69cb4dd66dd3745b483f4703cb1fb69">&#9670;&nbsp;</a></span>fill_fe_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算从参考单元到此函数的第一个参数所指示的实数单元的映射信息。派生类将不得不根据它们所代表的映射类型来实现这个函数。它被 <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a>. 调用。从概念上讲，这个函数代表了从参考坐标 \(\mathbf\in [0,1]^d\) 到实空间坐标 \(\mathbf x\) 的映射 \(K\) 的应用。它的目的是计算以下种类的数据。</p>
<ul>
<li>从应用映射本身产生的数据，例如，计算实数单元上正交点的位置 \(\mathbf x_q = \mathbf F_K(\hat{\mathbf x}_q)\) ，对FEValues的用户直接有用，例如在装配过程中。</li>
<li>数据是有限元实现在真实单元上计算其形状函数所必需的。为此， <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> 函数在当前函数后调用 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> ，该函数的输出作为 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a>. 的输入。这里需要计算的信息的例子是映射的Jacobian， \(\hat\nabla \mathbf F_K(\hat{\mathbf x})\) 或其逆，例如，将参考单元上的形状函数的梯度转换为实单元上形状函数的梯度。 这个函数计算出来的信息被用来填充这个函数的输出参数的各个成员变量。该结构中的哪些成员变量应该被填充，由存储在传递给该函数的 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 对象中的更新标志决定。 关于此函数和FEValues之间的互动的广泛讨论可以在 <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and</a> 文档模块中找到。 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>三角形中的单元格，本函数要计算从参考单元格到的映射。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_similarity</td><td>作为第一个参数的单元格是否是最近一次调用此函数的单元格的简单平移、旋转等。这个信息是通过匹配前一个单元和当前单元之间的顶点（由三角结构存储）简单计算出来的。这里传递的值可能被这个函数的实现所修改，然后应该被返回（见关于这个函数的返回值的讨论）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>对当前评估中使用的正交公式的引用。这个正交对象与创建 <code>internal_data</code> 对象时使用的对象相同。该对象既用于映射正交点的位置，也用于计算每个正交点的JxW值（涉及正交权重）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_data</td><td>一个对先前由get_data()创建的对象的引用，可用于存储映射在参考单元上可以计算一次的信息。参见 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类的文档，以了解这些对象的用途的广泛描述。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>对成员变量应被计算的对象的引用。并非所有这个参数的成员都需要被填充；哪些成员需要被填充是由存储在 <code>internal_data</code> 对象内的更新标志决定的。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>这个函数的 <code>cell_similarity</code> 参数的一个更新值。当 <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> 调用 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a>. 时，返回的值将被用于相应的参数。在大多数情况下，派生类只想返回为 <code>cell_similarity传递的值。然而，这个函数的实现可能会降低细胞相似度的级别。例如，对于那些不仅考虑到单元格顶点的位置（如Triangulation所报告的），而且还考虑到映射的其他特定信息的类，就是这种情况。目的是</code> <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> 可以只根据单元格的顶点来计算一个单元格是否与前一个单元格相似，而映射也可以考虑位移场（例如，在MappingQ1Eulerian和MappingFEField类中）。在这种情况下，映射可能会得出结论，先前计算的单元格相似度过于乐观，并通过返回一个不那么乐观的单元格相似度值，使其在随后的使用中无效 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> 。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>FEValues确保这个函数总是用同一对 <code>internal_data</code> 和 <code>output_data</code> 对象调用。换句话说，如果这个函数的实现知道它在之前的调用中已经把一个数据写入了输出参数，那么在以后的调用中，如果实现知道这是同一个值，就没有必要再把它复制到那里。 </dd></dl>
</li>
</ul>

<p>Implemented in <a class="el" href="classMappingQGeneric.html#a55f47dbce73174cb01825bd1e5cfda6d">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a59b63864eafeb2108b680877a9e98d48">MappingFE&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a5fab53e64c416d06a467ef51082ec594">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a9baf527d46a7f2391dbb3dd5dc416864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9baf527d46a7f2391dbb3dd5dc416864">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数等同于 <a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a>, ，但用于单元格的面。有关其目的的广泛讨论，请参见那里。它被 <a class="el" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">FEFaceValues::reinit()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">单元格所调用，该函数要计算从参考单元格到的映射。</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>请求提供信息的给定单元的面的编号。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>当前评估中使用的正交公式的引用。此正交对象与创建 <code>internal_data</code> 对象时使用的对象相同。该对象既用于映射正交点的位置，也用于计算每个正交点的JxW值（涉及正交权重）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_data</td><td>一个对先前由get_data()创建的对象的引用，可用于存储映射在参考单元上可以计算一次的信息。参见 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类的文档，以了解这些对象的用途的广泛描述。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>对成员变量应被计算的对象的引用。并非这个参数的所有成员都需要被填充；哪些成员需要被填充是由存储在 <code>internal_data</code> 对象内的更新标志决定的。 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMappingQGeneric.html#ac29df449ce7ed25d529cdfcd45873133">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a168c668ed9104cf9ee21a61fc752aa34">MappingFE&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#afce07f0330ff95ddf05a3c3ea944aaa2">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aa51c964b1e51b69db3f4933b97bff8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51c964b1e51b69db3f4933b97bff8c8">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>使用带有 <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> 参数的版本。</dd></dl>

</div>
</div>
<a id="a9f7f6025bc3f10e8f7da2c8a68eaff4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7f6025bc3f10e8f7da2c8a68eaff4a">&#9670;&nbsp;</a></span>fill_fe_subface_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数等同于 <a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a>, ，但适用于单元格的子面（即面的子女）。关于其目的的广泛讨论见那里。它被 <a class="el" href="classFESubfaceValues.html#a341778d1291f936d5192a39f2531472a">FESubfaceValues::reinit()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>三角形中的单元格，这个函数要为其计算从参考单元格到的映射。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>请求提供信息的给定单元的面的编号。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subface_no</td><td>请求提供信息的给定单元的面的子的编号。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>对当前评估中使用的正交公式的引用。这个正交对象与创建 <code>internal_data</code> 对象时使用的对象相同。该对象既用于映射正交点的位置，也用于计算每个正交点的JxW值（涉及正交权重）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_data</td><td>一个对先前由get_data()创建的对象的引用，可用于存储映射在参考单元上可以计算一次的信息。参见 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类的文档，以了解这些对象的用途的广泛描述。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>对成员变量应被计算的对象的引用。并非所有这个参数的成员都需要被填充；哪些成员需要被填充是由存储在 <code>internal_data</code> 对象内的更新标志决定的。 </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMappingQGeneric.html#a57a3be45fcb87da0a08e12472e26f5fd">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a138b962e1730d898efc05d2d7ed7534c">MappingFE&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a4f87d1f43404d195f52c21fe096014ed">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8ab23f3f7c43c36211348f2546e04ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab23f3f7c43c36211348f2546e04ffd">&#9670;&nbsp;</a></span>polynomial_degree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::polynomial_degree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将在域的边界的所有单元上使用的单元的多项式程度，如果指定的话，也可以在任何地方使用。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8h_source.html#l00312">312</a> of file <a class="el" href="mapping__q_8h_source.html">mapping_q.h</a>.</p>

</div>
</div>
<a id="a9d9bd27a3448d74cc7a737f6044facf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9bd27a3448d74cc7a737f6044facf0">&#9670;&nbsp;</a></span>use_mapping_q_on_all_cells</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::use_mapping_q_on_all_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果这个标志设置为 <code>true</code> ，那么 <code><a class="el" href="classMappingQ.html">MappingQ</a></code> 将用于所有单元，而不仅仅是用于边界单元。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q_8h_source.html#l00319">319</a> of file <a class="el" href="mapping__q_8h_source.html">mapping_q.h</a>.</p>

</div>
</div>
<a id="a0b2bd47a99a2c7d6dbe2326ad5fc067a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2bd47a99a2c7d6dbe2326ad5fc067a">&#9670;&nbsp;</a></span>q1_mapping</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::q1_mapping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向一个Q1映射的指针。除非在调用构造函数时设置了use_mapping_q_on_all_cells，否则该映射将用于内部单元。该映射也用于transform_real_to_unit_cell()中的任何单元，以便在我们使用完整的映射进行更昂贵的牛顿迭代之前，对点的位置进行一个廉价的初始猜测。 </p><dl class="section note"><dt>Note</dt><dd>MappingQEulerian将这个指针重设为MappingQ1Eulerian类型的对象，以确保Q1映射也知道欧拉位移的适当移位和变换。这也意味着我们确实需要在这里存储我们自己的Q1映射，而不是简单地求助于 <a class="el" href="structStaticMappingQ1.html#a62b367e32a8ae7a2883955bd9dc08655">StaticMappingQ1::mapping</a>. 。 </dd>
<dd>
如果当前对象使用的多项式程度是1，那么qp_mapping和q1_mapping变量就会指向同一个底层对象。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mapping__q_8h_source.html#l00330">330</a> of file <a class="el" href="mapping__q_8h_source.html">mapping_q.h</a>.</p>

</div>
</div>
<a id="adbdbdf7750f384ed054a8bdcbbec2136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbdbdf7750f384ed054a8bdcbbec2136">&#9670;&nbsp;</a></span>qp_mapping</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classMappingQ.html">MappingQ</a>&lt; dim, spacedim &gt;::qp_mapping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向一个Q_p映射的指针。除非在调用构造函数时设置了use_mapping_q_on_all_cells（在这种情况下，它用于所有单元），否则该映射将用于边界单元。 </p><dl class="section note"><dt>Note</dt><dd>MappingQEulerian和MappingC1将这个指针重置为他们自己实现的对象，以确保Q_p映射也知道欧拉位移的适当移动和转换（欧拉情况）和支持点的适当选择（C1情况）。 </dd>
<dd>
如果用于当前对象的多项式程度为1，那么qp_mapping和q1_mapping变量就会指向同一个底层对象。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mapping__q_8h_source.html#l00340">340</a> of file <a class="el" href="mapping__q_8h_source.html">mapping_q.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/fe/<a class="el" href="mapping__manifold_8h_source.html">mapping_manifold.h</a></li>
<li>include/deal.II/fe/<a class="el" href="mapping__q_8h_source.html">mapping_q.h</a></li>
<li>source/fe/<a class="el" href="mapping__q_8cc_source.html">mapping_q.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
