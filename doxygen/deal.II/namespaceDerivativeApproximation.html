<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceDerivativeApproximation.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DerivativeApproximation Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DerivativeApproximation Namespace Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a98d28e4c1c17164c48719cdfe4a363e6"><td class="memTemplParams" colspan="2">template&lt;int dim, class InputVector , int spacedim&gt; </td></tr>
<tr class="memitem:a98d28e4c1c17164c48719cdfe4a363e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#a98d28e4c1c17164c48719cdfe4a363e6">approximate_gradient</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;<a class="el" href="namespaceDerivativeApproximation.html#acb554e2cd5a43377269eb278b394dfa2">derivative_norm</a>, const unsigned <a class="el" href="classint.html">int</a> component=0)</td></tr>
<tr class="separator:a98d28e4c1c17164c48719cdfe4a363e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c2ca39370d2d8f4ad0c055e5bef1f0"><td class="memTemplParams" colspan="2">template&lt;int dim, class InputVector , int spacedim&gt; </td></tr>
<tr class="memitem:a59c2ca39370d2d8f4ad0c055e5bef1f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#a59c2ca39370d2d8f4ad0c055e5bef1f0">approximate_gradient</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;<a class="el" href="namespaceDerivativeApproximation.html#acb554e2cd5a43377269eb278b394dfa2">derivative_norm</a>, const unsigned <a class="el" href="classint.html">int</a> component=0)</td></tr>
<tr class="separator:a59c2ca39370d2d8f4ad0c055e5bef1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca261738b02c0160c5aeae4ffe95e4a"><td class="memTemplParams" colspan="2">template&lt;int dim, class InputVector , int spacedim&gt; </td></tr>
<tr class="memitem:aeca261738b02c0160c5aeae4ffe95e4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#aeca261738b02c0160c5aeae4ffe95e4a">approximate_second_derivative</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;<a class="el" href="namespaceDerivativeApproximation.html#acb554e2cd5a43377269eb278b394dfa2">derivative_norm</a>, const unsigned <a class="el" href="classint.html">int</a> component=0)</td></tr>
<tr class="separator:aeca261738b02c0160c5aeae4ffe95e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26a316b4f6846f3cb25beeb02720d27"><td class="memTemplParams" colspan="2">template&lt;int dim, class InputVector , int spacedim&gt; </td></tr>
<tr class="memitem:ac26a316b4f6846f3cb25beeb02720d27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#ac26a316b4f6846f3cb25beeb02720d27">approximate_second_derivative</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;<a class="el" href="namespaceDerivativeApproximation.html#acb554e2cd5a43377269eb278b394dfa2">derivative_norm</a>, const unsigned <a class="el" href="classint.html">int</a> component=0)</td></tr>
<tr class="separator:ac26a316b4f6846f3cb25beeb02720d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c6d9490f14d9f99349b961f5fcca17"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class InputVector , int order&gt; </td></tr>
<tr class="memitem:ad7c6d9490f14d9f99349b961f5fcca17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#ad7c6d9490f14d9f99349b961f5fcca17">approximate_derivative_tensor</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell, <a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt; &amp;derivative, const unsigned <a class="el" href="classint.html">int</a> component=0)</td></tr>
<tr class="separator:ad7c6d9490f14d9f99349b961f5fcca17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3521f27ab836e06a85b66a5006f8d652"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class InputVector , int order&gt; </td></tr>
<tr class="memitem:a3521f27ab836e06a85b66a5006f8d652"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#a3521f27ab836e06a85b66a5006f8d652">approximate_derivative_tensor</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell, <a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt; &amp;derivative, const unsigned <a class="el" href="classint.html">int</a> component=0)</td></tr>
<tr class="separator:a3521f27ab836e06a85b66a5006f8d652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb554e2cd5a43377269eb278b394dfa2"><td class="memTemplParams" colspan="2">template&lt;int dim, int order&gt; </td></tr>
<tr class="memitem:acb554e2cd5a43377269eb278b394dfa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#acb554e2cd5a43377269eb278b394dfa2">derivative_norm</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt; &amp;derivative)</td></tr>
<tr class="separator:acb554e2cd5a43377269eb278b394dfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229a3f171f4f453368d65bd53fa6be4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#a229a3f171f4f453368d65bd53fa6be4e">DeclException2</a> (ExcVectorLengthVsNActiveCells, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The output vector needs to have a size equal &quot; &quot;to the number of active cells of your triangulation &quot; &quot;but has length &quot;&lt;&lt; arg1&lt;&lt; &quot;There are &quot;&lt;&lt; arg2&lt;&lt; &quot; active cells in your triangulation.&quot;)</td></tr>
<tr class="separator:a229a3f171f4f453368d65bd53fa6be4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1727e7483b379665421a80571822f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#a6c1727e7483b379665421a80571822f2">DeclExceptionMsg</a> (ExcInsufficientDirections, &quot;While computing a finite difference approximation to &quot; &quot;derivatives, the algorithm encountered a cell on which &quot; &quot;the number of linearly &quot; &quot;independent directions that span the matrix Y (discussed &quot; &quot;in the documentation of the DerivativeApproximation &quot; &quot;class) is not equal to dim. The matrix Y then is &quot; &quot;rank deficient and can not be inverted. A common reason &quot; &quot;why this might be happening is if a cell has neither &quot; &quot;left/right (or up/down, or front/back) neighbors, for &quot; &quot;example because the mesh is too coarse.&quot;)</td></tr>
<tr class="separator:a6c1727e7483b379665421a80571822f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace provides functions that compute a cell-wise approximation of the norm of a derivative of a finite element field by taking difference quotients between neighboring cells. This is a rather simple but efficient form to get an error indicator, since it can be computed with relatively little numerical effort and yet gives a reasonable approximation.</p>
<p>The way the difference quotients are computed on cell \(K\) is the following (here described for the approximation of the gradient of a finite element field, but see below for higher derivatives): let \(K&#39;\) be a neighboring cell, and let \(y_{K&#39;}=x_{K&#39;}-x_K\) be the distance vector between the centers of the two cells, then \( \frac{u_h(x_{K&#39;}) - u_h(x_K)}{ \|y_{K&#39;}\| }\) is an approximation of the directional derivative \( \nabla u(x_K) \cdot \frac{y_{K&#39;}}{ \|y_{K&#39;}\| }.\) By multiplying both terms by \(\frac{y_{K&#39;}}{ \|y_{K&#39;}\| }\) from the left and summing over all neighbors \(K&#39;\), we obtain \( \sum_{K&#39;} \left( \frac{y_{K&#39;}}{ \|y_{K&#39;}\|} \frac{y_{K&#39;}^T}{ \|y_{K&#39;}\| } \right) \nabla u(x_K) \approx \sum_{K&#39;} \left( \frac{y_{K&#39;}}{ \|y_{K&#39;}\|} \frac{u_h(x_{K&#39;}) - u_h(x_K)}{ \|y_{K&#39;}\| } \right).\)</p>
<p>Thus, if the matrix \( Y = \sum_{K&#39;} \left( \frac{y_{K&#39;}}{\|y_{K&#39;}\|} \frac{y_{K&#39;}^T}{ \|y_{K&#39;}\| } \right)\) is regular (which is the case when the vectors \(y_{K&#39;}\) to all neighbors span the whole space), we can obtain an approximation to the true gradient by \( \nabla u(x_K) \approx Y^{-1} \sum_{K&#39;} \left( \frac{y_{K&#39;}}{\|y_{K&#39;}\|} \frac{u_h(x_{K&#39;}) - u_h(x_K)}{ \|y_{K&#39;}\| } \right).\) This is a quantity that is easily computed. The value returned for each cell when calling the <code>approximate_gradient</code> function of this class is the \(l_2\) norm of this approximation to the gradient. To make this a useful quantity, you may want to scale each element by the correct power of the respective cell size.</p>
<p>The computation of this quantity must fail if a cell has only neighbors for which the direction vectors \(y_K\) do not span the whole space, since then the matrix \(Y\) is no longer invertible. If this happens, you will get an error similar to this one: </p><div class="fragment"><div class="line">--------------------------------------------------------</div><div class="line">An error occurred in line &lt;749&gt;</div><div class="line">of file &lt;source/numerics/derivative_approximation.cc&gt; in <span class="keyword">function</span></div><div class="line">    <span class="keywordtype">void</span> DerivativeApproximation::approximate(...)</div><div class="line">[with DerivativeDescription = DerivativeApproximation::Gradient&lt;3&gt;, <span class="keywordtype">int</span></div><div class="line">dim = 3, InputVector = <a class="code" href="classVector.html">Vector&lt;double&gt;</a>, spacedim = 3]</div><div class="line">The violated condition was:</div><div class="line">    <a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(Y) != 0</div><div class="line">The name and <a class="code" href="namespaceThreads_1_1internal.html#a8d237a30d09b13e0b5adbe0fd1dfb188">call</a> sequence of the exception was:</div><div class="line">    ExcInsufficientDirections()</div><div class="line">Additional Information:</div><div class="line">(none)</div><div class="line">--------------------------------------------------------</div></div><!-- fragment --><p> As can easily be verified, this can only happen on very coarse grids, when some cells and all their neighbors have not been refined even once. You should therefore only call the functions of this class if all cells are at least once refined. In practice this is not much of a restriction.</p>
<h3>Approximation of higher derivatives</h3>
<p>Similar to the reasoning above, approximations to higher derivatives can be computed in a similar fashion. For example, the tensor of second derivatives is approximated by the formula \( \nabla^2 u(x_K) \approx Y^{-1} \sum_{K&#39;} \left( \frac{y_{K&#39;}}{\|y_{K&#39;}\|} \otimes \frac{\nabla u_h(x_{K&#39;}) - \nabla u_h(x_K)}{ \|y_{K&#39;}\| } \right), \) where \(\otimes\) denotes the outer product of two vectors. Note that unlike the true tensor of second derivatives, its approximation is not necessarily symmetric. This is due to the fact that in the derivation, it is not clear whether we shall consider as projected second derivative the term \(\nabla^2 u y_{KK&#39;}\) or \(y_{KK&#39;}^T \nabla^2 u\). Depending on which choice we take, we obtain one approximation of the tensor of second derivatives or its transpose. To avoid this ambiguity, as result we take the symmetrized form, which is the mean value of the approximation and its transpose.</p>
<p>The returned value on each cell is the spectral norm of the approximated tensor of second derivatives, i.e. the largest eigenvalue by absolute value. This equals the largest curvature of the finite element field at each cell, and the spectral norm is the matrix norm associated to the \(l_2\) vector norm.</p>
<p>Even higher than the second derivative can be obtained along the same lines as exposed above.</p>
<h3>Refinement indicators based on the derivatives</h3>
<p>If you would like to base a refinement criterion upon these approximation of the derivatives, you will have to scale the results of this class by an appropriate power of the mesh width. For example, since \(\|u-u_h\|^2_{L_2} \le C h^2 \|\nabla u\|^2_{L_2}\), it might be the right thing to scale the indicators as \(\eta_K = h \|\nabla u\|_K\), i.e. \(\eta_K = h^{1+d/2} \|\nabla u\|_{\infty;K}\), i.e. the right power is \(1+d/2\).</p>
<p>Likewise, for the second derivative, one should choose a power of the mesh size \(h\) one higher than for the gradient.</p>
<h3>Implementation</h3>
<p>The formulae for the computation of approximations to the gradient and to the tensor of second derivatives shown above are very much alike. The basic difference is that in one case the finite difference quotient is a scalar, while in the other case it is a vector. For higher derivatives, this would be a tensor of even higher rank. We then have to form the outer product of this difference quotient with the distance vector \(y_{KK&#39;}\), symmetrize it, contract it with the matrix \(Y^{-1}\) and compute its norm. To make the implementation simpler and to allow for code reuse, all these operations that are dependent on the actual order of the derivatives to be approximated, as well as the computation of the quantities entering the difference quotient, have been separated into auxiliary nested classes (names <code>Gradient</code> and <code>SecondDerivative</code>) and the main algorithm is simply passed one or the other data types and asks them to perform the order dependent operations. The main framework that is independent of this, such as finding all active neighbors, or setting up the matrix \(Y\) is done in the main function <code>approximate</code>.</p>
<p>Due to this way of operation, the class may be easily extended for higher order derivatives than are presently implemented. Basically, only an additional class along the lines of the derivative descriptor classes <code>Gradient</code> and <code>SecondDerivative</code> has to be implemented, with the respective alias and functions replaced by the appropriate analogues for the derivative that is to be approximated. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a98d28e4c1c17164c48719cdfe4a363e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d28e4c1c17164c48719cdfe4a363e6">&#9670;&nbsp;</a></span>approximate_gradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InputVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to obtain an approximation of the gradient. Pass it the DoF handler object that describes the finite element field, a nodal value vector, and receive the cell-wise Euclidean norm of the approximated gradient.</p>
<p>The last parameter denotes the solution component, for which the gradient is to be computed. It defaults to the first component. For scalar elements, this is the only valid choice; for vector-valued ones, any component between zero and the number of vector components can be given here.</p>
<p>In a parallel computation the <code>solution</code> vector needs to contain the locally relevant unknowns. </p>

</div>
</div>
<a id="a59c2ca39370d2d8f4ad0c055e5bef1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c2ca39370d2d8f4ad0c055e5bef1f0">&#9670;&nbsp;</a></span>approximate_gradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InputVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the function above with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="aeca261738b02c0160c5aeae4ffe95e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca261738b02c0160c5aeae4ffe95e4a">&#9670;&nbsp;</a></span>approximate_second_derivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InputVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_second_derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the analogue to the one above, computing finite difference approximations of the tensor of second derivatives. Pass it the DoF handler object that describes the finite element field, a nodal value vector, and receive the cell-wise spectral norm of the approximated tensor of second derivatives. The spectral norm is the matrix norm associated to the \(l_2\) vector norm.</p>
<p>The last parameter denotes the solution component, for which the gradient is to be computed. It defaults to the first component. For scalar elements, this is the only valid choice; for vector-valued ones, any component between zero and the number of vector components can be given here.</p>
<p>In a parallel computation the <code>solution</code> vector needs to contain the locally relevant unknowns. </p>

</div>
</div>
<a id="ac26a316b4f6846f3cb25beeb02720d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26a316b4f6846f3cb25beeb02720d27">&#9670;&nbsp;</a></span>approximate_second_derivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InputVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_second_derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the function above with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="ad7c6d9490f14d9f99349b961f5fcca17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c6d9490f14d9f99349b961f5fcca17">&#9670;&nbsp;</a></span>approximate_derivative_tensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class InputVector , int order&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_derivative_tensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function calculates the <code>order</code>-th order approximate derivative and returns the full tensor for a single cell.</p>
<p>The last parameter denotes the solution component, for which the gradient is to be computed. It defaults to the first component. For scalar elements, this is the only valid choice; for vector-valued ones, any component between zero and the number of vector components can be given here.</p>
<p>In a parallel computation the <code>solution</code> vector needs to contain the locally relevant unknowns. </p>

</div>
</div>
<a id="a3521f27ab836e06a85b66a5006f8d652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3521f27ab836e06a85b66a5006f8d652">&#9670;&nbsp;</a></span>approximate_derivative_tensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class InputVector , int order&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_derivative_tensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="acb554e2cd5a43377269eb278b394dfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb554e2cd5a43377269eb278b394dfa2">&#9670;&nbsp;</a></span>derivative_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int order&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> DerivativeApproximation::derivative_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the norm of the derivative. </p>

</div>
</div>
<a id="a229a3f171f4f453368d65bd53fa6be4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229a3f171f4f453368d65bd53fa6be4e">&#9670;&nbsp;</a></span>DeclException2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DerivativeApproximation::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcVectorLengthVsNActiveCells&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The output vector needs to have a size equal &quot; &quot;to the number of active cells of your triangulation &quot; &quot;but has length &quot;&lt;&lt; arg1&lt;&lt; &quot;There are &quot;&lt;&lt; arg2&lt;&lt; &quot; active cells in your triangulation.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a6c1727e7483b379665421a80571822f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1727e7483b379665421a80571822f2">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DerivativeApproximation::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcInsufficientDirections&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;While computing a finite difference approximation to &quot; &quot;&#160;</td>
          <td class="paramname"><em>derivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">the algorithm encountered a cell on which &quot; &quot;the number of linearly &quot; &quot;independent directions that span the matrix Y(discussed &quot; &quot;in the documentation of the DerivativeApproximation &quot; &quot;class) is not equal to dim. The matrix Y then is &quot; &quot;rank deficient and can not be inverted. A common reason &quot; &quot;why this might be happening is if a cell has neither &quot; &quot;left/right(or up/down, or front/back)&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">for &quot; &quot;example because the mesh is too coarse.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
