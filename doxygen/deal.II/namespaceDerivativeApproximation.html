<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceDerivativeApproximation.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DerivativeApproximation Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DerivativeApproximation Namespace Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDerivativeApproximation_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a98d28e4c1c17164c48719cdfe4a363e6"><td class="memTemplParams" colspan="2">template&lt;int dim, class InputVector , int spacedim&gt; </td></tr>
<tr class="memitem:a98d28e4c1c17164c48719cdfe4a363e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#a98d28e4c1c17164c48719cdfe4a363e6">approximate_gradient</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;<a class="el" href="namespaceDerivativeApproximation.html#acb554e2cd5a43377269eb278b394dfa2">derivative_norm</a>, const unsigned <a class="el" href="classint.html">int</a> component=0)</td></tr>
<tr class="separator:a98d28e4c1c17164c48719cdfe4a363e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c2ca39370d2d8f4ad0c055e5bef1f0"><td class="memTemplParams" colspan="2">template&lt;int dim, class InputVector , int spacedim&gt; </td></tr>
<tr class="memitem:a59c2ca39370d2d8f4ad0c055e5bef1f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#a59c2ca39370d2d8f4ad0c055e5bef1f0">approximate_gradient</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;<a class="el" href="namespaceDerivativeApproximation.html#acb554e2cd5a43377269eb278b394dfa2">derivative_norm</a>, const unsigned <a class="el" href="classint.html">int</a> component=0)</td></tr>
<tr class="separator:a59c2ca39370d2d8f4ad0c055e5bef1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca261738b02c0160c5aeae4ffe95e4a"><td class="memTemplParams" colspan="2">template&lt;int dim, class InputVector , int spacedim&gt; </td></tr>
<tr class="memitem:aeca261738b02c0160c5aeae4ffe95e4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#aeca261738b02c0160c5aeae4ffe95e4a">approximate_second_derivative</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;<a class="el" href="namespaceDerivativeApproximation.html#acb554e2cd5a43377269eb278b394dfa2">derivative_norm</a>, const unsigned <a class="el" href="classint.html">int</a> component=0)</td></tr>
<tr class="separator:aeca261738b02c0160c5aeae4ffe95e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26a316b4f6846f3cb25beeb02720d27"><td class="memTemplParams" colspan="2">template&lt;int dim, class InputVector , int spacedim&gt; </td></tr>
<tr class="memitem:ac26a316b4f6846f3cb25beeb02720d27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#ac26a316b4f6846f3cb25beeb02720d27">approximate_second_derivative</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;<a class="el" href="namespaceDerivativeApproximation.html#acb554e2cd5a43377269eb278b394dfa2">derivative_norm</a>, const unsigned <a class="el" href="classint.html">int</a> component=0)</td></tr>
<tr class="separator:ac26a316b4f6846f3cb25beeb02720d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c6d9490f14d9f99349b961f5fcca17"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class InputVector , int order&gt; </td></tr>
<tr class="memitem:ad7c6d9490f14d9f99349b961f5fcca17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#ad7c6d9490f14d9f99349b961f5fcca17">approximate_derivative_tensor</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell, <a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt; &amp;derivative, const unsigned <a class="el" href="classint.html">int</a> component=0)</td></tr>
<tr class="separator:ad7c6d9490f14d9f99349b961f5fcca17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3521f27ab836e06a85b66a5006f8d652"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class InputVector , int order&gt; </td></tr>
<tr class="memitem:a3521f27ab836e06a85b66a5006f8d652"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#a3521f27ab836e06a85b66a5006f8d652">approximate_derivative_tensor</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InputVector &amp;solution, const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell, <a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt; &amp;derivative, const unsigned <a class="el" href="classint.html">int</a> component=0)</td></tr>
<tr class="separator:a3521f27ab836e06a85b66a5006f8d652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb554e2cd5a43377269eb278b394dfa2"><td class="memTemplParams" colspan="2">template&lt;int dim, int order&gt; </td></tr>
<tr class="memitem:acb554e2cd5a43377269eb278b394dfa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#acb554e2cd5a43377269eb278b394dfa2">derivative_norm</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt; &amp;derivative)</td></tr>
<tr class="separator:acb554e2cd5a43377269eb278b394dfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229a3f171f4f453368d65bd53fa6be4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#a229a3f171f4f453368d65bd53fa6be4e">DeclException2</a> (ExcVectorLengthVsNActiveCells, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The output vector needs to have a size equal &quot; &quot;to the number of active cells of your <a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a> &quot; &quot;but has length &quot;&lt;&lt; arg1&lt;&lt; &quot;There are &quot;&lt;&lt; arg2&lt;&lt; &quot; active cells in your triangulation.&quot;)</td></tr>
<tr class="separator:a229a3f171f4f453368d65bd53fa6be4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1727e7483b379665421a80571822f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDerivativeApproximation.html#a6c1727e7483b379665421a80571822f2">DeclExceptionMsg</a> (ExcInsufficientDirections, &quot;While computing a finite difference approximation to &quot; &quot;derivatives, the algorithm encountered a cell on which &quot; &quot;the number of linearly &quot; &quot;independent directions that span the matrix Y (discussed &quot; &quot;in the documentation of the DerivativeApproximation &quot; &quot;class) is not equal to dim. The matrix Y then is &quot; &quot;rank deficient and can not be inverted. A common reason &quot; &quot;why this might be happening is if a cell has neither &quot; &quot;left/right (or up/down, or front/back) neighbors, for &quot; &quot;example because the mesh is too coarse.&quot;)</td></tr>
<tr class="separator:a6c1727e7483b379665421a80571822f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>这个命名空间提供了一些函数，这些函数通过取相邻单元之间的差值商来计算有限元场的导数的规范的逐一逼近。这是一种相当简单而有效的错误指示形式，因为它可以用相对较少的数值努力来计算，但却能给出一个合理的近似值。 在单元格 \(K\) 上计算差商的方式如下（这里描述的是有限元场梯度的近似，但对于更高的导数见下文）：让 \(K&#39;\) 是一个相邻的单元格，让 \(y_{K&#39;}=x_{K&#39;}-x_K\) ]是两个单元中心之间的距离向量，那么 \( \frac{u_h(x_{K&#39;}) - u_h(x_K)}{ \|y_{K&#39;}\| }\) 是方向性导数的近似值 \( \nabla u(x_K) \cdot \frac{y_{K&#39;}}{ \|y_{K&#39;}\| }.\) 通过从左边开始乘以 \(\frac{y_{K&#39;}}{ \|y_{K&#39;}\| }\) 并对所有邻居 \(K&#39;\) 求和，我们得到 \( \sum_{K&#39;} \left( \frac{y_{K&#39;}}{ \|y_{K&#39;}\|} \frac{y_{K&#39;}^T}{ \|y_{K&#39;}\| } \right) \nabla u(x_K) \approx \sum_{K&#39;} \left( \frac{y_{K&#39;}}{ \|y_{K&#39;}\|} \frac{u_h(x_{K&#39;}) - u_h(x_K)}{ \|y_{K&#39;}\| } \right).\) 因此，如果矩阵 \( Y = \sum_{K&#39;} \left( \frac{y_{K&#39;}}{\|y_{K&#39;}\|} \frac{y_{K&#39;}^T}{ \|y_{K&#39;}\| } \right)\) 是规则的（当向量 \(y_{K&#39;}\) 到所有邻居跨越整个空间时就是这种情况），我们可以通过 \( \nabla u(x_K) \approx Y^{-1} \sum_{K&#39;} \left( \frac{y_{K&#39;}}{\|y_{K&#39;}\|} \frac{u_h(x_{K&#39;}) - u_h(x_K)}{ \|y_{K&#39;}\| } \right).\) 得到真实梯度的近似值，这是一个容易计算的量。当调用该类的 <code>approximate_gradient</code> 函数时，每个单元格的返回值是这个梯度近似值的 \(l_2\) 准则。为了使这个量成为一个有用的量，你可能想把每个元素按各自的单元格大小的正确幂进行缩放。 如果一个单元只有方向向量 \(y_K\) 不跨越整个空间的邻居，那么这个量的计算一定会失败，因为此时矩阵 \(Y\) 不再是可逆的。如果发生这种情况，你会得到一个类似于这个的错误。</p>
<div class="fragment"><div class="line">--------------------------------------------------------</div><div class="line">An error occurred in line &lt;749&gt;</div><div class="line">of file &lt;source/numerics/derivative_approximation.cc&gt; in <span class="keyword">function</span></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceDerivativeApproximation_1_1internal.html#a4bea05d5ab84ca1e802db9a0217d1d6c">DerivativeApproximation::approximate</a>(...)</div><div class="line">[with DerivativeDescription = DerivativeApproximation::Gradient&lt;3&gt;, <span class="keywordtype">int</span></div><div class="line">dim = 3, InputVector = <a class="code" href="classVector.html">Vector&lt;double&gt;</a>, spacedim = 3]</div><div class="line">The violated condition was:</div><div class="line">  <a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(Y) != 0</div><div class="line">The name and <a class="code" href="namespaceThreads_1_1internal.html#a8d237a30d09b13e0b5adbe0fd1dfb188">call</a> sequence of the exception was:</div><div class="line">  ExcInsufficientDirections()</div><div class="line">Additional Information:</div><div class="line">(none)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">--------------------------------------------------------</div></div><!-- fragment --><p> 正如很容易验证的那样，这种情况只可能发生在非常粗糙的网格上，当一些单元和它们的所有邻居甚至没有被精炼过一次。因此，你应该只在所有单元至少被精炼过一次的情况下才调用这个类别的函数。在实践中，这并不是一个很大的限制。</p>
<h3>Approximation of higher derivatives</h3>
<p>与上面的推理类似，高阶导数的近似值也可以用类似的方式计算。例如，二阶导数的张量由公式 \( \nabla^2 u(x_K) \approx Y^{-1} \sum_{K&#39;} \left( \frac{y_{K&#39;}}{\|y_{K&#39;}\|} \otimes \frac{\nabla u_h(x_{K&#39;}) - \nabla u_h(x_K)}{ \|y_{K&#39;}\| } \right), \) 近似，其中 \(\otimes\) 表示两个向量的外积。请注意，与真正的二阶导数张量不同，其近似值不一定是对称的。这是由于在推导过程中，不清楚我们是将 \(\nabla^2 u y_{KK&#39;}\) 还是 \(y_{KK&#39;}^T \nabla^2 u\) 项作为投射二阶导数。根据我们的选择，我们会得到二阶导数张量的一个近似值或其转置。为了避免这种模糊性，作为结果，我们采取对称的形式，即近似值及其转置的平均值。 每个单元格的返回值是二阶导数的近似张量的谱准则，即绝对值最大的特征值。这等于每个单元的有限元场的最大曲率，谱规范是与 \(l_2\) 向量规范相关的矩阵规范。 甚至比二阶导数更高的导数也可以沿着上面暴露的相同思路得到。</p>
<h3>Refinement indicators based on the derivatives</h3>
<p>如果你想在这些导数的近似值的基础上建立一个细化标准，你必须将这一类的结果按网格宽度的一个适当的幂进行缩放。例如，由于 \(\|u-u_h\|^2_{L_2} \le C h^2 \|\nabla u\|^2_{L_2}\) ，可能正确的做法是将指标缩放为 \(\eta_K = h \|\nabla u\|_K\) ，即 \(\eta_K = h^{1+d/2} \|\nabla u\|_{\infty;K}\) ，即正确的幂是 \(1+d/2\) 。 同样的，对于二阶导数，应该选择比梯度高一个的网格大小 \(h\) 的幂。</p>
<h3>Implementation</h3>
<p>上面显示的梯度和二阶导数张量的近似计算公式是非常相似的。基本区别在于，在一种情况下，有限差分商是一个标量，而在另一种情况下，它是一个矢量。对于更高的导数，这将是一个更高等级的张量。然后我们必须用距离向量 \(y_{KK&#39;}\) 形成这个差分商的外积，对其进行对称，用矩阵 \(Y^{-1}\) 收缩，并计算其规范。为了使实现更简单并允许代码重用，所有这些取决于要逼近的导数的实际顺序的操作，以及进入差商的量的计算，都被分离到辅助嵌套类中（名称为 <code>Gradient</code> 和 <code>SecondDerivative</code>) ），主算法只是传递一个或其他数据类型并要求它们执行取决于顺序的操作。独立于此的主要框架，如寻找所有活动邻居，或设置矩阵 \(Y\) 是在主函数 <code>approximate</code>. 中完成的。 由于这种操作方式，该类可以很容易地扩展到比目前实现的更高阶导数。基本上，只需要按照导数描述符类 <code>梯度和</code> <code>SecondDerivative</code> 的思路实现一个额外的类，用要近似的导数的适当类似物替换各自的别名和函数。 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a98d28e4c1c17164c48719cdfe4a363e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d28e4c1c17164c48719cdfe4a363e6">&#9670;&nbsp;</a></span>approximate_gradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InputVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>该函数用于获得梯度的近似值。将描述有限元场的DoF处理程序对象和一个节点值向量传递给它，并接收近似梯度的单元格欧氏规范。 最后一个参数是指要计算梯度的解分量。它默认为第一个分量。对于标量元素，这是唯一有效的选择；对于矢量值元素，可以在这里给出零和矢量分量数量之间的任何分量。 在并行计算中， <code>solution</code> 向量需要包含本地相关的未知数。 </p>

<p class="definition">Definition at line <a class="el" href="derivative__approximation_8cc_source.html#l01015">1015</a> of file <a class="el" href="derivative__approximation_8cc_source.html">derivative_approximation.cc</a>.</p>

</div>
</div>
<a id="a59c2ca39370d2d8f4ad0c055e5bef1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c2ca39370d2d8f4ad0c055e5bef1f0">&#9670;&nbsp;</a></span>approximate_gradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InputVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim&gt;(1)</code>. 调用上述函数。 </p>

<p class="definition">Definition at line <a class="el" href="derivative__approximation_8cc_source.html#l01028">1028</a> of file <a class="el" href="derivative__approximation_8cc_source.html">derivative_approximation.cc</a>.</p>

</div>
</div>
<a id="aeca261738b02c0160c5aeae4ffe95e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca261738b02c0160c5aeae4ffe95e4a">&#9670;&nbsp;</a></span>approximate_second_derivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InputVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_second_derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数是上面那个函数的类似物，计算二阶导数张量的有限差分近似值。将描述有限元场的DoF处理程序对象、节点值向量传递给它，并接收第二导数张量近似值的单元格谱准则。谱准则是与 \(l_2\) 向量准则相关的矩阵准则。 最后一个参数是指要计算梯度的解分量。它默认为第一个分量。对于标量元素，这是唯一有效的选择；对于矢量值元素，这里可以给出零和矢量分量数量之间的任何分量。 在并行计算中， <code>solution</code> 向量需要包含本地相关的未知数。 </p>

<p class="definition">Definition at line <a class="el" href="derivative__approximation_8cc_source.html#l01044">1044</a> of file <a class="el" href="derivative__approximation_8cc_source.html">derivative_approximation.cc</a>.</p>

</div>
</div>
<a id="ac26a316b4f6846f3cb25beeb02720d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26a316b4f6846f3cb25beeb02720d27">&#9670;&nbsp;</a></span>approximate_second_derivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InputVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_second_derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim&gt;(1)</code>. 调用上述函数。 </p>

<p class="definition">Definition at line <a class="el" href="derivative__approximation_8cc_source.html#l01057">1057</a> of file <a class="el" href="derivative__approximation_8cc_source.html">derivative_approximation.cc</a>.</p>

</div>
</div>
<a id="ad7c6d9490f14d9f99349b961f5fcca17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c6d9490f14d9f99349b961f5fcca17">&#9670;&nbsp;</a></span>approximate_derivative_tensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class InputVector , int order&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_derivative_tensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数计算<code>阶</code>-阶近似导数，并返回单个单元的完整张量。 最后一个参数是指要计算梯度的解分量。它默认为第一个分量。对于标量元素，这是唯一有效的选择；对于矢量值元素，可以在这里给出零和矢量分量数量之间的任何分量。 在并行计算中， <code>solution</code> 向量需要包含本地相关的未知数。 </p>

<p class="definition">Definition at line <a class="el" href="derivative__approximation_8cc_source.html#l01073">1073</a> of file <a class="el" href="derivative__approximation_8cc_source.html">derivative_approximation.cc</a>.</p>

</div>
</div>
<a id="a3521f27ab836e06a85b66a5006f8d652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3521f27ab836e06a85b66a5006f8d652">&#9670;&nbsp;</a></span>approximate_derivative_tensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class InputVector , int order&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DerivativeApproximation::approximate_derivative_tensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>同上，<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim&gt;(1)</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="derivative__approximation_8cc_source.html#l01095">1095</a> of file <a class="el" href="derivative__approximation_8cc_source.html">derivative_approximation.cc</a>.</p>

</div>
</div>
<a id="acb554e2cd5a43377269eb278b394dfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb554e2cd5a43377269eb278b394dfa2">&#9670;&nbsp;</a></span>derivative_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int order&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> DerivativeApproximation::derivative_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; order, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>derivative</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回导数的规范。 </p>

<p class="definition">Definition at line <a class="el" href="derivative__approximation_8cc_source.html#l01122">1122</a> of file <a class="el" href="derivative__approximation_8cc_source.html">derivative_approximation.cc</a>.</p>

</div>
</div>
<a id="a229a3f171f4f453368d65bd53fa6be4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229a3f171f4f453368d65bd53fa6be4e">&#9670;&nbsp;</a></span>DeclException2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DerivativeApproximation::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcVectorLengthVsNActiveCells&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The output vector needs to have a size equal &quot; &quot;to the number of active cells of your <a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a> &quot; &quot;but has length &quot;&lt;&lt; arg1&lt;&lt; &quot;There are &quot;&lt;&lt; arg2&lt;&lt; &quot; active cells in your triangulation.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a6c1727e7483b379665421a80571822f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1727e7483b379665421a80571822f2">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DerivativeApproximation::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcInsufficientDirections&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;While computing a finite difference approximation to &quot; &quot;&#160;</td>
          <td class="paramname"><em>derivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">the algorithm encountered a cell on which &quot; &quot;the number of linearly &quot; &quot;independent directions that span the matrix Y(discussed &quot; &quot;in the documentation of the DerivativeApproximation &quot; &quot;class) is not equal to dim. The matrix Y then is &quot; &quot;rank deficient and can not be inverted. A common reason &quot; &quot;why this might be happening is if a cell has neither &quot; &quot;left/right(or up/down, or front/back)&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">for &quot; &quot;example because the mesh is too coarse.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
