<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classMappingQCache.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MappingQCache&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classMappingQCache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MappingQCache&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a> &raquo; <a class="el" href="group__mapping.html">Mappings between reference and real cell</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="mapping__q__cache_8h_source.html">deal.II/fe/mapping_q_cache.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MappingQCache&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classMappingQCache__inherit__graph.svg" width="214" height="291"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a90e57f54c9d59928a232452c9783a480"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#a90e57f54c9d59928a232452c9783a480">MappingQCache</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMappingQGeneric.html#ad003bfed73fda03fa261b3c10f64da15">polynomial_degree</a>)</td></tr>
<tr class="separator:a90e57f54c9d59928a232452c9783a480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d935c3b1791a878b0d9f1517e1404a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#a1d935c3b1791a878b0d9f1517e1404a0">MappingQCache</a> (const <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt; &amp;mapping)</td></tr>
<tr class="separator:a1d935c3b1791a878b0d9f1517e1404a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0aeca904f30acda893e6ef523bf107d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#aa0aeca904f30acda893e6ef523bf107d">~MappingQCache</a> ()</td></tr>
<tr class="separator:aa0aeca904f30acda893e6ef523bf107d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab111812de834e9ae85c92c664b9f8302"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#ab111812de834e9ae85c92c664b9f8302">clone</a> () const override</td></tr>
<tr class="separator:ab111812de834e9ae85c92c664b9f8302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e3dbb03b4a54cd2436831fa9626773"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#a73e3dbb03b4a54cd2436831fa9626773">preserves_vertex_locations</a> () const override</td></tr>
<tr class="separator:a73e3dbb03b4a54cd2436831fa9626773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c3ac515088ee08df64075954629314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#ab7c3ac515088ee08df64075954629314">initialize</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</td></tr>
<tr class="separator:ab7c3ac515088ee08df64075954629314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b16b54c1d2c2027c79b5cfc706d1b2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#a9b16b54c1d2c2027c79b5cfc706d1b2e">initialize</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt; &amp;mapping)</td></tr>
<tr class="separator:a9b16b54c1d2c2027c79b5cfc706d1b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a0989ff761dd3d6ff67d649302a134"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#ab4a0989ff761dd3d6ff67d649302a134">initialize</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const std::function&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt;(const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;)&gt; &amp;compute_points_on_cell)</td></tr>
<tr class="separator:ab4a0989ff761dd3d6ff67d649302a134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8625d9c22e77e9d4925279da1d3df856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#a8625d9c22e77e9d4925279da1d3df856">initialize</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::function&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;(const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;)&gt; &amp;transformation_function, const <a class="el" href="classbool.html">bool</a> function_describes_relative_displacement)</td></tr>
<tr class="separator:a8625d9c22e77e9d4925279da1d3df856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15aa3eba4e0b8cdeb0773536fc60297e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#a15aa3eba4e0b8cdeb0773536fc60297e">initialize</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;transformation_function, const <a class="el" href="classbool.html">bool</a> function_describes_relative_displacement)</td></tr>
<tr class="separator:a15aa3eba4e0b8cdeb0773536fc60297e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cba1e0de299e9596261849b8c3edb41"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a3cba1e0de299e9596261849b8c3edb41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#a3cba1e0de299e9596261849b8c3edb41">initialize</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;vector, const <a class="el" href="classbool.html">bool</a> vector_describes_relative_displacement)</td></tr>
<tr class="separator:a3cba1e0de299e9596261849b8c3edb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ce38cbec744a0c4cbe94b208ab3237"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a80ce38cbec744a0c4cbe94b208ab3237"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#a80ce38cbec744a0c4cbe94b208ab3237">initialize</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;vectors, const <a class="el" href="classbool.html">bool</a> vector_describes_relative_displacement)</td></tr>
<tr class="separator:a80ce38cbec744a0c4cbe94b208ab3237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec1b572003e45fbd23c03009b2bcd7d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#a2ec1b572003e45fbd23c03009b2bcd7d">memory_consumption</a> () const</td></tr>
<tr class="separator:a2ec1b572003e45fbd23c03009b2bcd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1990c7922dbb8ec6ddd2ff58514d501b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a1990c7922dbb8ec6ddd2ff58514d501b">get_degree</a> () const</td></tr>
<tr class="separator:a1990c7922dbb8ec6ddd2ff58514d501b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215e8c4e5161b4531c339c62d066f605"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a215e8c4e5161b4531c339c62d066f605">get_bounding_box</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const override</td></tr>
<tr class="separator:a215e8c4e5161b4531c339c62d066f605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d64a71ab7336dde2370cd958eb9898a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a6d64a71ab7336dde2370cd958eb9898a">is_compatible_with</a> (const <a class="el" href="classReferenceCell.html">ReferenceCell</a> &amp;reference_cell) const override</td></tr>
<tr class="separator:a6d64a71ab7336dde2370cd958eb9898a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f37fd5b4a965f3f4ae0d0ca3060156"><td class="memItemLeft" align="right" valign="top">virtual boost::container::small_vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_cell &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#af3f37fd5b4a965f3f4ae0d0ca3060156">get_vertices</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const</td></tr>
<tr class="separator:af3f37fd5b4a965f3f4ae0d0ca3060156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6376f7ab802afb171a00a1a7748cf2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a8a6376f7ab802afb171a00a1a7748cf2">get_center</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classbool.html">bool</a> map_center_of_reference_cell=true) const</td></tr>
<tr class="separator:a8a6376f7ab802afb171a00a1a7748cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">参考单元和实数单元之间的映射点</div></td></tr>
<tr class="memitem:a25716700fc33cb61661c1854a391a6ee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a25716700fc33cb61661c1854a391a6ee">transform_unit_to_real_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a25716700fc33cb61661c1854a391a6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0218e12c99cc01a46bbe76f79a8c7c64"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a0218e12c99cc01a46bbe76f79a8c7c64">transform_real_to_unit_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const override</td></tr>
<tr class="separator:a0218e12c99cc01a46bbe76f79a8c7c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fed5446020926f01f434e18568bdda1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a7fed5446020926f01f434e18568bdda1">transform_points_real_to_unit_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;real_points, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;unit_points) const override</td></tr>
<tr class="separator:a7fed5446020926f01f434e18568bdda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">将张量从参考坐标转换为实坐标的函数 @{</div></td></tr>
<tr class="memitem:a92313b892a6d57dfac68f7abeda952bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a92313b892a6d57dfac68f7abeda952bf">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt; &amp;output) const override</td></tr>
<tr class="separator:a92313b892a6d57dfac68f7abeda952bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9585e10bdca9ca62a5e574875617e3da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a9585e10bdca9ca62a5e574875617e3da">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;output) const override</td></tr>
<tr class="separator:a9585e10bdca9ca62a5e574875617e3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0527f139542e7bc4a82d718a4137499d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a0527f139542e7bc4a82d718a4137499d">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;output) const override</td></tr>
<tr class="separator:a0527f139542e7bc4a82d718a4137499d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84a343f050259f1d7270fb60c066713"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#af84a343f050259f1d7270fb60c066713">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;output) const override</td></tr>
<tr class="separator:af84a343f050259f1d7270fb60c066713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37b2188f37b3945e498afba8182613f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#ab37b2188f37b3945e498afba8182613f">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;output) const override</td></tr>
<tr class="separator:ab37b2188f37b3945e498afba8182613f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">与FEValues和朋友的接口</div></td></tr>
<tr class="memitem:ac8f9dce75f554ce486bafd9d92f7744e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#ac8f9dce75f554ce486bafd9d92f7744e">requires_update_flags</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags) const override</td></tr>
<tr class="separator:ac8f9dce75f554ce486bafd9d92f7744e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a66a10ce2b30d71906de3e16c7595cb"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a9a66a10ce2b30d71906de3e16c7595cb">get_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature) const override</td></tr>
<tr class="separator:a9a66a10ce2b30d71906de3e16c7595cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8dbbf44bd25ced74d96458c62a4b74f"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#ae8dbbf44bd25ced74d96458c62a4b74f">get_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature) const override</td></tr>
<tr class="separator:ae8dbbf44bd25ced74d96458c62a4b74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f66b84a5495273300392c6e2bec063"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a48f66b84a5495273300392c6e2bec063">get_subface_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature) const override</td></tr>
<tr class="separator:a48f66b84a5495273300392c6e2bec063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f47dbce73174cb01825bd1e5cfda6d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a55f47dbce73174cb01825bd1e5cfda6d">fill_fe_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a55f47dbce73174cb01825bd1e5cfda6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29df449ce7ed25d529cdfcd45873133"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#ac29df449ce7ed25d529cdfcd45873133">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:ac29df449ce7ed25d529cdfcd45873133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a3be45fcb87da0a08e12472e26f5fd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a57a3be45fcb87da0a08e12472e26f5fd">fill_fe_subface_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> subface_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a57a3be45fcb87da0a08e12472e26f5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4ddbb820ac561fca628d582cc57812"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a8b4ddbb820ac561fca628d582cc57812">fill_mapping_data_for_generic_points</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;unit_points, const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a8b4ddbb820ac561fca628d582cc57812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">引用单元格和实数单元格之间的映射点</div></td></tr>
<tr class="memitem:a078f4e617fdb287e1dc7a5efa227b0ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a078f4e617fdb287e1dc7a5efa227b0ae">project_real_point_to_unit_point_on_face</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const</td></tr>
<tr class="separator:a078f4e617fdb287e1dc7a5efa227b0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">异常情况 @{</div></td></tr>
<tr class="memitem:a72122ff6ee588e788415f3124c48bb0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a72122ff6ee588e788415f3124c48bb0d">DeclException0</a> (ExcInvalidData)</td></tr>
<tr class="separator:a72122ff6ee588e788415f3124c48bb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5086637353e09ce6fb8d84f81be8affa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5086637353e09ce6fb8d84f81be8affa">DeclExceptionMsg</a> (ExcTransformationFailed, &quot;Computing the mapping between a real space point and a point in reference &quot; &quot;space failed, typically because the given point lies outside the cell &quot; &quot;where the inverse mapping is not unique.&quot;)</td></tr>
<tr class="separator:ga5086637353e09ce6fb8d84f81be8affa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga142dcb2a567c72d6cc2607070cd56a83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga142dcb2a567c72d6cc2607070cd56a83">DeclException3</a> (ExcDistortedMappedCell, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The image of the mapping applied to cell with <a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a> [&quot;&lt;&lt; arg1&lt;&lt; &quot;] is distorted. The cell geometry or the &quot;&lt;&lt; &quot;mapping are invalid, giving a non-positive volume &quot;&lt;&lt; &quot;fraction of &quot;&lt;&lt; arg2&lt;&lt; &quot; in quadrature point &quot;&lt;&lt; arg3&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:ga142dcb2a567c72d6cc2607070cd56a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8e2a0343d57b1b3eed0fec653197b29f"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#a8e2a0343d57b1b3eed0fec653197b29f">compute_mapping_support_points</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const override</td></tr>
<tr class="separator:a8e2a0343d57b1b3eed0fec653197b29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5c1ec190e6d300c5379ab4c6171241"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a0c5c1ec190e6d300c5379ab4c6171241">transform_real_to_unit_cell_internal</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;initial_p_unit) const</td></tr>
<tr class="separator:a0c5c1ec190e6d300c5379ab4c6171241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6af289148eb3e4b8f4f57a0a4db8fc"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aff6af289148eb3e4b8f4f57a0a4db8fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#aff6af289148eb3e4b8f4f57a0a4db8fc">transform_real_to_unit_cell_internal</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; &amp;initial_p_unit) const</td></tr>
<tr class="separator:aff6af289148eb3e4b8f4f57a0a4db8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad3296f2a3a274dbf670bd97db8bdc3"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aaad3296f2a3a274dbf670bd97db8bdc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#aaad3296f2a3a274dbf670bd97db8bdc3">transform_real_to_unit_cell_internal</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;initial_p_unit) const</td></tr>
<tr class="separator:aaad3296f2a3a274dbf670bd97db8bdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1337dba5f7b6c26a4921d6a99063ea"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2c1337dba5f7b6c26a4921d6a99063ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a2c1337dba5f7b6c26a4921d6a99063ea">transform_real_to_unit_cell_internal</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;initial_p_unit) const</td></tr>
<tr class="separator:a2c1337dba5f7b6c26a4921d6a99063ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b288f72deddedf72b2749764ca899a7"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a3b288f72deddedf72b2749764ca899a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a3b288f72deddedf72b2749764ca899a7">transform_real_to_unit_cell_internal</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; &amp;initial_p_unit) const</td></tr>
<tr class="separator:a3b288f72deddedf72b2749764ca899a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b833209847a286dd8ba74358733c63"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af1b833209847a286dd8ba74358733c63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#af1b833209847a286dd8ba74358733c63">transform_real_to_unit_cell_internal</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 3 &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;initial_p_unit) const</td></tr>
<tr class="separator:af1b833209847a286dd8ba74358733c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bdac1fb0c1282cdeeda8a5cae37614"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a02bdac1fb0c1282cdeeda8a5cae37614"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a02bdac1fb0c1282cdeeda8a5cae37614">transform_real_to_unit_cell_internal</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::cell_iterator &amp;, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;, const <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; &amp;) const</td></tr>
<tr class="separator:a02bdac1fb0c1282cdeeda8a5cae37614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a3fc04a288095f8e507415884beb21"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a95a3fc04a288095f8e507415884beb21">add_line_support_points</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;a) const</td></tr>
<tr class="separator:a95a3fc04a288095f8e507415884beb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c57b3baff2c0bcfe263c0be8340950e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a7c57b3baff2c0bcfe263c0be8340950e">add_quad_support_points</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;a) const</td></tr>
<tr class="separator:a7c57b3baff2c0bcfe263c0be8340950e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf4aae37431be4e98d99eeebbd9e994"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a0bf4aae37431be4e98d99eeebbd9e994"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a0bf4aae37431be4e98d99eeebbd9e994">add_quad_support_points</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::cell_iterator &amp;cell, std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&gt; &amp;a) const</td></tr>
<tr class="separator:a0bf4aae37431be4e98d99eeebbd9e994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca1167a7de3f52d89da7a0f3119ce11"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:afca1167a7de3f52d89da7a0f3119ce11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#afca1167a7de3f52d89da7a0f3119ce11">add_quad_support_points</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 3 &gt;::cell_iterator &amp;cell, std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&gt; &amp;a) const</td></tr>
<tr class="separator:afca1167a7de3f52d89da7a0f3119ce11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">与FEValues的接口</div></td></tr>
<tr class="memitem:a85e75b674cebc41831eac23a44732fcf"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a85e75b674cebc41831eac23a44732fcf">get_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature) const</td></tr>
<tr class="separator:a85e75b674cebc41831eac23a44732fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51c964b1e51b69db3f4933b97bff8c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#aa51c964b1e51b69db3f4933b97bff8c8">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:aa51c964b1e51b69db3f4933b97bff8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad003bfed73fda03fa261b3c10f64da15"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#ad003bfed73fda03fa261b3c10f64da15">polynomial_degree</a></td></tr>
<tr class="separator:ad003bfed73fda03fa261b3c10f64da15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed38f97b4d21de82739c1093181bf60"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a9ed38f97b4d21de82739c1093181bf60">line_support_points</a></td></tr>
<tr class="separator:a9ed38f97b4d21de82739c1093181bf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b24bf56e5b985af7caa8c6441b338a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPolynomials_1_1Polynomial.html">Polynomials::Polynomial</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#af3b24bf56e5b985af7caa8c6441b338a">polynomials_1d</a></td></tr>
<tr class="separator:af3b24bf56e5b985af7caa8c6441b338a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef845cd736c730be7cde12bfc53bdd7a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#aef845cd736c730be7cde12bfc53bdd7a">renumber_lexicographic_to_hierarchic</a></td></tr>
<tr class="separator:aef845cd736c730be7cde12bfc53bdd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d09fe67f77a011aa7aa440cbbac690"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a87d09fe67f77a011aa7aa440cbbac690">unit_cell_support_points</a></td></tr>
<tr class="separator:a87d09fe67f77a011aa7aa440cbbac690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e13292c68ac279f84d5736211fe91b3"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a1e13292c68ac279f84d5736211fe91b3">support_point_weights_perimeter_to_interior</a></td></tr>
<tr class="separator:a1e13292c68ac279f84d5736211fe91b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e54a03863f22b019d5f9cc4b8e40814"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQGeneric.html#a5e54a03863f22b019d5f9cc4b8e40814">support_point_weights_cell</a></td></tr>
<tr class="separator:a5e54a03863f22b019d5f9cc4b8e40814"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a23f3845de8ec963e201837ab1a7d53ba"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; std::vector&lt; std::vector&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#a23f3845de8ec963e201837ab1a7d53ba">support_point_cache</a></td></tr>
<tr class="separator:a23f3845de8ec963e201837ab1a7d53ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9aa318ad48c85309e3cb915f46a93cf"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#ab9aa318ad48c85309e3cb915f46a93cf">clear_signal</a></td></tr>
<tr class="separator:ab9aa318ad48c85309e3cb915f46a93cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5c140ec21bf31145a84a093220431c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingQCache.html#a8f5c140ec21bf31145a84a093220431c">uses_level_info</a></td></tr>
<tr class="separator:a8f5c140ec21bf31145a84a093220431c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class MappingQCache&lt; dim, spacedim &gt;</h3>

<p>这个类以 <a class="el" href="classMappingQGeneric.html#a30567734a9cfb887bd36d7c0216187fd">MappingQGeneric::compute_mapping_support_points()</a> 函数的形式为MappingQ家族的对象实现了一个缓存策略，它被用于MappingQGeneric的所有操作中。映射的信息是由 <a class="el" href="classMappingQCache.html#ab7c3ac515088ee08df64075954629314">MappingQCache::initialize()</a> 函数预先计算出来的。 这个类的使用在 <a class="el" href="step_65.html">step-65</a> 中有广泛的讨论。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8h_source.html#l00053">53</a> of file <a class="el" href="mapping__q__cache_8h_source.html">mapping_q_cache.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a90e57f54c9d59928a232452c9783a480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e57f54c9d59928a232452c9783a480">&#9670;&nbsp;</a></span>MappingQCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::<a class="el" href="classMappingQCache.html">MappingQCache</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>polynomial_degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构造函数。 <code>polynomial_degree</code> 表示用于从参考单元映射到实数单元的多项式的度数。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8cc_source.html#l00040">40</a> of file <a class="el" href="mapping__q__cache_8cc_source.html">mapping_q_cache.cc</a>.</p>

</div>
</div>
<a id="a1d935c3b1791a878b0d9f1517e1404a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d935c3b1791a878b0d9f1517e1404a0">&#9670;&nbsp;</a></span>MappingQCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::<a class="el" href="classMappingQCache.html">MappingQCache</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制构造器。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8cc_source.html#l00049">49</a> of file <a class="el" href="mapping__q__cache_8cc_source.html">mapping_q_cache.cc</a>.</p>

</div>
</div>
<a id="aa0aeca904f30acda893e6ef523bf107d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0aeca904f30acda893e6ef523bf107d">&#9670;&nbsp;</a></span>~MappingQCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::~<a class="el" href="classMappingQCache.html">MappingQCache</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>解构器。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8cc_source.html#l00059">59</a> of file <a class="el" href="mapping__q__cache_8cc_source.html">mapping_q_cache.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab111812de834e9ae85c92c664b9f8302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab111812de834e9ae85c92c664b9f8302">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classMappingQCache.html#ab111812de834e9ae85c92c664b9f8302">clone()</a>功能。有关文档，请参见 <a class="el" href="classMapping.html#aefbf70ea6f93dba57ac3fa7eb2e51992">Mapping::clone()</a>. 。 </p>

<p>Reimplemented from <a class="el" href="classMappingQGeneric.html#ab68e57c7c366164037c204b7d30c9961">MappingQGeneric&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8cc_source.html#l00073">73</a> of file <a class="el" href="mapping__q__cache_8cc_source.html">mapping_q_cache.cc</a>.</p>

</div>
</div>
<a id="a73e3dbb03b4a54cd2436831fa9626773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e3dbb03b4a54cd2436831fa9626773">&#9670;&nbsp;</a></span>preserves_vertex_locations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::preserves_vertex_locations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 <code>false</code> ，因为顶点位置的保存取决于交给 <a class="el" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit()</a> 函数的映射。 </p>

<p>Reimplemented from <a class="el" href="classMappingQGeneric.html#ae4dd9672848fd7657d3d42bd82d43fb6">MappingQGeneric&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8cc_source.html#l00082">82</a> of file <a class="el" href="mapping__q__cache_8cc_source.html">mapping_q_cache.cc</a>.</p>

</div>
</div>
<a id="ab7c3ac515088ee08df64075954629314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c3ac515088ee08df64075954629314">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过计算给定三角形的所有单元（在所有层次上）的映射支持点来初始化数据缓存。 </p><dl class="section note"><dt>Note</dt><dd>在底层三角图的信号 <a class="el" href="structTriangulation_1_1Signals.html#a55d248cb964be99370fdcbec620a4420">Triangulation::Signals::any_change</a> 时，缓存失效。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8cc_source.html#l00091">91</a> of file <a class="el" href="mapping__q__cache_8cc_source.html">mapping_q_cache.cc</a>.</p>

</div>
</div>
<a id="a9b16b54c1d2c2027c79b5cfc706d1b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b16b54c1d2c2027c79b5cfc706d1b2e">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过计算给定三角形的所有单元（在所有层面）的映射支持点来初始化数据缓存。 </p><dl class="section note"><dt>Note</dt><dd>缓存在底层三角图的信号 <a class="el" href="structTriangulation_1_1Signals.html#a55d248cb964be99370fdcbec620a4420">Triangulation::Signals::any_change</a> 时失效。</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd>使用上面的initialize()版本代替。</dd></dl>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8cc_source.html#l00141">141</a> of file <a class="el" href="mapping__q__cache_8cc_source.html">mapping_q_cache.cc</a>.</p>

</div>
</div>
<a id="ab4a0989ff761dd3d6ff67d649302a134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a0989ff761dd3d6ff67d649302a134">&#9670;&nbsp;</a></span>initialize() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt;(const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>compute_points_on_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过让作为参数的函数提供给定三角形的所有单元（在所有层面）的映射支持点来初始化数据缓存。该函数必须返回一个<code><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;</code>的向量，其长度与多项式空间的大小相同， \((p+1)^\text{dim}\) ，其中 \(p\) 是映射的多项式程度，而且必须按照映射或FE_Q对其点的排序，即首先是所有 \(2^\text{dim}\) 的顶点，然后是线、四边形和六边形的点，按照通常的分层编号。除了给定的点的数量之外，没有尝试在内部验证这些点。 </p><dl class="section note"><dt>Note</dt><dd>如果启用了多线程，这个函数将并行运行，多次调用传入的函数。因此，在 <a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads()</a>&gt;1, 的情况下，用户代码必须确保该函数（通常是一个lambda）不会写进与其他线程共享的数据。 </dd>
<dd>
缓存在底层三角化的信号 <a class="el" href="structTriangulation_1_1Signals.html#a55d248cb964be99370fdcbec620a4420">Triangulation::Signals::any_change</a> 时被无效。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8cc_source.html#l00152">152</a> of file <a class="el" href="mapping__q__cache_8cc_source.html">mapping_q_cache.cc</a>.</p>

</div>
</div>
<a id="a8625d9c22e77e9d4925279da1d3df856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8625d9c22e77e9d4925279da1d3df856">&#9670;&nbsp;</a></span>initialize() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;(const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>function_describes_relative_displacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过计算给定三角形的所有单元（在所有层次上）和给定 <code>mapping</code> 的映射支持点并通过函数 <code>transformation_function</code>. 转换这些点来初始化数据缓存。 bool <code>function_describes_relative_displacement</code> 表示函数 <code>transformation_function</code> 映射到绝对坐标。 如果参数设置为真，函数的返回值将被解释为相对变形，其结果最终将被添加到原始点上，用于本类最终使用的支持点。 这个函数调用前一个函数，所以上面列出的关于线程的评论也适用于此。 </p><dl class="section note"><dt>Note</dt><dd>缓存在底层三角函数的信号 <a class="el" href="structTriangulation_1_1Signals.html#a55d248cb964be99370fdcbec620a4420">Triangulation::Signals::any_change</a> 时被废止。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8cc_source.html#l00193">193</a> of file <a class="el" href="mapping__q__cache_8cc_source.html">mapping_q_cache.cc</a>.</p>

</div>
</div>
<a id="a15aa3eba4e0b8cdeb0773536fc60297e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15aa3eba4e0b8cdeb0773536fc60297e">&#9670;&nbsp;</a></span>initialize() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformation_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>function_describes_relative_displacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，但取一个 <a class="el" href="classFunction.html">Function</a> 对象。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8cc_source.html#l00260">260</a> of file <a class="el" href="mapping__q__cache_8cc_source.html">mapping_q_cache.cc</a>.</p>

</div>
</div>
<a id="a3cba1e0de299e9596261849b8c3edb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cba1e0de299e9596261849b8c3edb41">&#9670;&nbsp;</a></span>initialize() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>vector_describes_relative_displacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过一个离散字段（由 <code>dof_handler</code> 和 <code>vector</code>) 指定，描述每个支持点的绝对或相对位置，初始化活动单元的数据缓存。 </p><dl class="section note"><dt>Note</dt><dd>通过使用这个函数进行重新初始化，这个类的行为就像MappingFEField（vector_describes_relative_displacement == false）或MappingQEulerian（vector_describes_relative_displacement == true），但内部的操作要高效得多。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8cc_source.html#l00304">304</a> of file <a class="el" href="mapping__q__cache_8cc_source.html">mapping_q_cache.cc</a>.</p>

</div>
</div>
<a id="a80ce38cbec744a0c4cbe94b208ab3237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ce38cbec744a0c4cbe94b208ab3237">&#9670;&nbsp;</a></span>initialize() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>vector_describes_relative_displacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过一个描述每个支持点的绝对或相对位置的解决方案（由 <code>dof_handler</code> 和一组 <code>vectors</code> 在三角测量的所有层面上指定）来初始化所有非人工单元的数据缓存。 </p><dl class="section note"><dt>Note</dt><dd>通过使用这个函数进行重新初始化，这个类的行为就像MappingFEField（vector_describes_relative_displacement == false）或MappingQEulerian（vector_describes_relative_displacement == true），但内部的操作要高效得多。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8cc_source.html#l00501">501</a> of file <a class="el" href="mapping__q__cache_8cc_source.html">mapping_q_cache.cc</a>.</p>

</div>
</div>
<a id="a2ec1b572003e45fbd23c03009b2bcd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec1b572003e45fbd23c03009b2bcd7d">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回缓存的内存消耗（以字节为单位）。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8cc_source.html#l00715">715</a> of file <a class="el" href="mapping__q__cache_8cc_source.html">mapping_q_cache.cc</a>.</p>

</div>
</div>
<a id="a8e2a0343d57b1b3eed0fec653197b29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2a0343d57b1b3eed0fec653197b29f">&#9670;&nbsp;</a></span>compute_mapping_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::compute_mapping_support_points </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这是从基类MappingQGeneric中重写的主要函数。 </p>

<p>Reimplemented from <a class="el" href="classMappingQGeneric.html#a30567734a9cfb887bd36d7c0216187fd">MappingQGeneric&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8cc_source.html#l00728">728</a> of file <a class="el" href="mapping__q__cache_8cc_source.html">mapping_q_cache.cc</a>.</p>

</div>
</div>
<a id="a1990c7922dbb8ec6ddd2ff58514d501b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1990c7922dbb8ec6ddd2ff58514d501b">&#9670;&nbsp;</a></span>get_degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::get_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回映射的程度，即传递给构造函数的值。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00416">416</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a215e8c4e5161b4531c339c62d066f605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215e8c4e5161b4531c339c62d066f605">&#9670;&nbsp;</a></span>get_bounding_box()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::get_bounding_box </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回映射的单元格的边界盒。 如果你使用的是保留顶点位置的(bi-,tri-)线性映射，这个函数简单地返回同样由<code>cell-&gt;bounding_box()</code>产生的值。然而，也有一些映射会增加位移或选择完全不同的位置，例如MappingQEulerian、MappingQ1Eulerian或MappingFEField。 对于线性映射，该函数返回包含单元格所有顶点的边界框，如get_vertices()方法所返回的。对于通过支持点定义的高阶映射，边界盒只保证包含所有支持点，而且一般来说，它只是真正边界盒的近似值，可能更大。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">单元格</td><td>你想计算边界框的单元格 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classMapping.html#a50d2861c7e444384240609ec53093a54">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01749">1749</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a6d64a71ab7336dde2370cd958eb9898a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d64a71ab7336dde2370cd958eb9898a">&#9670;&nbsp;</a></span>is_compatible_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::is_compatible_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classReferenceCell.html">ReferenceCell</a> &amp;&#160;</td>
          <td class="paramname"><em>reference_cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个Mapping实例是否与 <code>reference_cell</code>. 中的单元格类型兼容。 </p>

<p>Implements <a class="el" href="classMapping.html#a0d8ac8be12bd87c4e7f529778ec317de">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01759">1759</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a25716700fc33cb61661c1854a391a6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25716700fc33cb61661c1854a391a6ee">&#9670;&nbsp;</a></span>transform_unit_to_real_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform_unit_to_real_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将单元格上的点 <code>p</code> 映射到实数单元格上的相应点 <code>cell</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">单元格</td><td>迭代器到将用于定义映射的单元。 </td></tr>
    <tr><td class="paramname">p</td><td>参考单元格上一个点的位置。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>参考点的位置，使用由当前实现映射的派生类所定义的映射映射到实空间，以及第一个参数所确定的单元格的坐标。 </dd></dl>

<p>Implements <a class="el" href="classMapping.html#ae5df63553eb8ed170c3b90524853dd48">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00425">425</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a0218e12c99cc01a46bbe76f79a8c7c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0218e12c99cc01a46bbe76f79a8c7c64">&#9670;&nbsp;</a></span>transform_real_to_unit_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform_real_to_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将实数 <code>p</code> 上的点 <code>cell</code> 映射到单元格上的相应点，并返回其坐标。这个函数提供了transform_unit_to_real_cell()所提供的映射的逆映射。 在一维的情况下，本函数返回实点 <code>p</code> 在 <code>cell</code>. 所标识的曲线或曲面上的法线投影。 </p><dl class="section note"><dt>Note</dt><dd>如果要计算反映射的点位于单元格边界之外，从参考（单位）单元格坐标到实数单元格坐标系的多项式映射并不总是可逆的。在这种情况下，当前函数可能无法计算参考单元上的一个点，该点在映射下的图像等于给定的点 <code>p</code>. 如果是这种情况，该函数会抛出一个 Mapping::ExcTransformationFailed 类型的异常。因此，给定的点 <code>p</code> 是否位于单元格之外可以通过检查返回的参考坐标是否位于参考单元格之内或之外来确定（例如，使用 <a class="el" href="structGeometryInfo.html#ace2d235da3d7459096d535d360bcf3d3">GeometryInfo::is_inside_unit_cell()</a>) 或上述异常是否被抛出。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>将用于定义映射的单元的迭代器。 </td></tr>
    <tr><td class="paramname">p</td><td>给定单元格上的一个点的位置。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>点的参考单元位置，当映射到实空间时等于第二个参数给出的坐标。这个映射使用由当前实现映射的派生类所定义的映射，以及第一个参数所确定的单元格的坐标。 </dd></dl>

<p>Implements <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00603">603</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a7fed5446020926f01f434e18568bdda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fed5446020926f01f434e18568bdda1">&#9670;&nbsp;</a></span>transform_points_real_to_unit_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform_points_real_to_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>real_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将多个点从真实点位置映射到参考位置的点。其功能基本上与在所有点上循环并为每个点单独调用 <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a> 函数相同，但对于某些实现了更专业的版本的映射，如MappingQGeneric，其速度会更快。行为上的唯一区别是，这个函数永远不会抛出ExcTransformationFailed()异常。如果对<code>real_points[i]</code>转换失败，返回的<code>unit_points[i]</code>包含 std::numeric_limits&lt;double&gt;::infinity() 作为第一个条目。 </p>

<p>Reimplemented from <a class="el" href="classMapping.html#a0e4eddf3673a9b22104c05bfdfe96bbb">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00724">724</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a92313b892a6d57dfac68f7abeda952bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92313b892a6d57dfac68f7abeda952bf">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>根据所选的MappingKind对矢量或1-差分形式的场进行变换。 </p><dl class="section note"><dt>Note</dt><dd>通常情况下，这个函数被一个有限元调用，填充FEValues对象。对于这个有限元，应该有一个别名MappingKind，如 <code>mapping_bdm</code>, <code>mapping_nedelec</code>, 等。这个别名应该优先于使用下面的种类。 目前由派生类实现的映射种类是。 <ul>
<li>
<code>mapping_contravariant:</code> 通过Jacobian将参考单元上的矢量场映射到物理单元。 <p class="formulaDsp">
\[ \mathbf u(\mathbf x) = J(\hat{\mathbf x})\hat{\mathbf u}(\hat{\mathbf x}). \]
</p>
 在物理学中，这通常被称为反变量变换。在数学上，它是一个矢量场的前推。 </li>
<li>
<code>mapping_covariant:</code> 将参考单元上的一形场映射到物理单元上的一形场。理论上，这将指的是DerivativeForm&lt;1,dim,1&gt;，但我们将这种类型与Tensor&lt;1,dim&gt;进行规范性的识别）。在数学上，它是微分形式的回拉 <p class="formulaDsp">
\[ \mathbf u(\mathbf x) = J(\hat{\mathbf x})(J(\hat{\mathbf x})^{T} J(\hat{\mathbf x}))^{-1}\hat{\mathbf u}(\hat{\mathbf x}). \]
</p>
标量可微分函数的梯度是这样转化的。 在dim=spacedim的情况下，前面的公式简化为 <p class="formulaDsp">
\[ \mathbf u(\mathbf x) = J(\hat{\mathbf x})^{-T}\hat{\mathbf u}(\hat{\mathbf x}) \]
</p>
，因为我们假设映射 \(\mathbf F_K\) 总是可逆的，因此其雅各布 \(J\) 是一个可逆矩阵。 </li>
<li>
<code>mapping_piola:</code> 参考单元上的<em>dim-1</em>形式的场也由矢量场表示，但同样以不同的方式变换，即通过皮奥拉变换 <p class="formulaDsp">
\[ \mathbf u(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J(\hat{\mathbf x}) \hat{\mathbf u}(\hat{\mathbf x}). \]
</p>
 </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">输入</td><td>一个应该被映射的输入对象的数组（或数组的一部分）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>要应用的映射的种类。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>一个指向 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类型的对象的指针，该对象包含先前由映射存储的信息。指向的对象是由get_data()、get_face_data()或get_subface_data()函数创建的，在调用当前函数之前，将作为对当前单元格的fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()调用的一部分而被更新。换句话说，这个对象也代表了与哪个单元格有关的变换应该被应用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">输出</td><td>一个数组（或数组的一部分），转换后的对象应该被放入其中。(注意，数组视图是 <code>常数，但它所指向的张量不是。</code>) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01341">1341</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a9585e10bdca9ca62a5e574875617e3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9585e10bdca9ca62a5e574875617e3da">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个微分形式的场从参考单元转换到物理单元。 认为 \(\mathbf{T} = \nabla \mathbf u\) 和 \(\hat{\mathbf T} = \hat \nabla \hat{\mathbf u}\) 是有用的， \(\mathbf u\) 是一个矢量场。 目前由派生类实现的映射种类有。 </p><ul>
<li>
<code>mapping_covariant:</code> 将参考单元上的形式域映射到物理单元上的形式域。在数学上，它是微分形式的回拉 <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})(J(\hat{\mathbf x})^{T} J(\hat{\mathbf x}))^{-1}. \]
</p>
间隔向量值微分函数的雅各布斯是这样转换的。 在dim=spacedim的情况下，前面的公式简化为 <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = \hat{\mathbf u}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
</ul>
<p>。 </p><dl class="section note"><dt>Note</dt><dd>如果把这个变换变成一个模板函数，其等级在<code><a class="el" href="classDerivativeForm.html">DerivativeForm</a> &lt;1, dim, rank &gt;</code>. 中会更合理，可惜C++不允许模板化虚拟函数。这就是为什么我们在这个函数transform()上面使用mapping_covariant()时，将<code><a class="el" href="classDerivativeForm.html">DerivativeForm</a> &lt;1, dim, 1 &gt;</code> 标识为 <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> 。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>应该被映射的输入对象的一个数组（或数组的一部分）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>要应用的映射的种类。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>一个指向 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类型的对象的指针，该对象包含先前由映射存储的信息。指向的对象是由get_data()、get_face_data()或get_subface_data()函数创建的，在调用当前函数之前，将作为对当前单元格的fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()调用的一部分被更新。换句话说，这个对象也代表了与哪个单元格有关的变换应该被应用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">输出</td><td>一个数组（或数组的一部分），转换后的对象应该被放入其中。(注意，数组视图是 <code>常数，但它所指向的张量不是。</code>) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#a871f491f3d06fda8a30157c8c2b6ae08">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01357">1357</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a0527f139542e7bc4a82d718a4137499d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0527f139542e7bc4a82d718a4137499d">&#9670;&nbsp;</a></span>transform() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个张量场从参考单元转换到物理单元。 这些张量通常是参考单元中已经从物理单元拉回来的矢量场的雅各布系数。 目前由派生类实现的映射种类有。 </p><ul>
<li>
<code>mapping_contravariant_gradient:</code> 它假设 \(\mathbf u(\mathbf x) = J \hat{\mathbf u}\) 这样 <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = J(\hat{\mathbf x}) \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_covariant_gradient:</code> 它假设 \(\mathbf u(\mathbf x) = J^{-T} \hat{\mathbf u}\) 这样 <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = J(\hat{\mathbf x})^{-T} \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_piola_gradient:</code> 它假设 \(\mathbf u(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J(\hat{\mathbf x}) \hat{\mathbf u}(\hat{\mathbf x})\) 这样 <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J(\hat{\mathbf x}) \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 ] </li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd>mapping_covariant_gradient、mapping_contravariant_gradient和mapping_piola_gradient的公式只对线性映射而言是真的。例如，如果映射是双线性的（或具有高阶多项式程度），那么就会有一个与 \(J\) 的导数相关的缺失项。</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">输入</td><td>一个应该被映射的输入对象的数组（或数组的一部分）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>要应用的映射的种类。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>一个指向 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类型的对象的指针，该对象包含先前由映射存储的信息。指向的对象是由get_data()、get_face_data()或get_subface_data()函数创建的，在调用当前函数之前，将作为对当前单元格的fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()调用的一部分被更新。换句话说，这个对象也代表了与哪个单元格有关的变换应该被应用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>一个数组（或数组的一部分），转换后的对象应该被放入其中。(注意，数组视图是 <code>常数，但它所指向的张量不是。</code>) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#ab22b7178a30a5ec26003ffc8fd02d8dd">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01371">1371</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="af84a343f050259f1d7270fb60c066713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84a343f050259f1d7270fb60c066713">&#9670;&nbsp;</a></span>transform() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个张量场从参考单元转换到物理单元。 这种张量在大多数情况下是参考单元中的向量场的 hessians，这些向量场已经从物理单元拉回来。 目前由派生类实现的映射种类有。 </p><ul>
<li>
<code>mapping_covariant_gradient:</code> 将参考单元上的形式场映射到物理单元上的形式场。在数学上，它是微分形式 <p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = \hat{\mathbf T}_{iJK}(\hat{\mathbf x}) J_{jJ}^{\dagger} J_{kK}^{\dagger}\]
</p>
的回拉，其中 <p class="formulaDsp">
\[ J^{\dagger} = J(\hat{\mathbf x})(J(\hat{\mathbf x})^{T} J(\hat{\mathbf x}))^{-1}. \]
</p>
 </li>
</ul>
<p>间隔向量值可微函数的Hessians是这样转化的（在减去导数与雅各布梯度的乘积后）。 在dim=spacedim的情况下，前面的公式简化为 </p><p class="formulaDsp">
\[J^{\dagger} = J^{-1}\]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>应该被映射的输入对象的数组（或数组的一部分）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>要应用的映射的种类。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>一个指向类型为 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 的对象的指针，该对象包含先前由映射存储的信息。指向的对象是由get_data()、get_face_data()或get_subface_data()函数创建的，在调用当前函数之前，将作为对当前单元格的fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()调用的一部分被更新。换句话说，这个对象也代表了与哪个单元格有关的变换应该被应用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>一个数组（或数组的一部分），转换后的对象应该被放入其中。(注意，数组视图是 <code>常数，但它指向的张量不是。</code>) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#abe09058f596dbda03936270390f3d2e4">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01401">1401</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="ab37b2188f37b3945e498afba8182613f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37b2188f37b3945e498afba8182613f">&#9670;&nbsp;</a></span>transform() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个3差分形式的场从参考单元转换到物理单元。 认为 \(\mathbf{T}_{ijk} = D^2_{jk} \mathbf u_i\) 和 \(\mathbf{\hat T}_{IJK} = \hat D^2_{JK} \mathbf{\hat u}_I\) 很有用， \(\mathbf u_i\) 是一个矢量场。 目前由派生类实现的映射种类是。 </p><ul>
<li>
<code>mapping_contravariant_hessian:</code> 它假定 \(\mathbf u_i(\mathbf x) = J_{iI} \hat{\mathbf u}_I\) 以便 <p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = J_{iI}(\hat{\mathbf x}) \hat{\mathbf T}_{IJK}(\hat{\mathbf x}) J_{jJ}(\hat{\mathbf x})^{-1} J_{kK}(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_covariant_hessian:</code> 它假定 \(\mathbf u_i(\mathbf x) = J_{iI}^{-T} \hat{\mathbf u}_I\) 以便 <p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = J_iI(\hat{\mathbf x})^{-1} \hat{\mathbf T}_{IJK}(\hat{\mathbf x}) J_{jJ}(\hat{\mathbf x})^{-1} J_{kK}(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_piola_hessian:</code> ] 它假定 \(\mathbf u_i(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J_{iI}(\hat{\mathbf x}) \hat{\mathbf u}(\hat{\mathbf x})\) 这样 <p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J_{iI}(\hat{\mathbf x}) \hat{\mathbf T}_{IJK}(\hat{\mathbf x}) J_{jJ}(\hat{\mathbf x})^{-1} J_{kK}(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">输入</td><td>一个应该被映射的输入对象的数组（或数组的一部分）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>要应用的映射的种类。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>一个指向 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类型的对象的指针，该对象包含先前由映射存储的信息。指向的对象是由get_data()、get_face_data()或get_subface_data()函数创建的，在调用当前函数之前，将作为对当前单元格的fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()调用的一部分被更新。换句话说，这个对象也代表了与哪个单元格有关的变换应该被应用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>一个数组（或数组的一部分），转换后的对象应该被放入其中。 </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#a38deb68a3d62e46bababbcb10bc928d8">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01450">1450</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="ac8f9dce75f554ce486bafd9d92f7744e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f9dce75f554ce486bafd9d92f7744e">&#9670;&nbsp;</a></span>requires_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::requires_update_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定一组更新标志，计算哪些其他的量<em>also</em>需要被计算，以满足给定标志的请求。 然后返回原始标志集和刚刚计算的标志的组合。 举个例子，如果 <code>update_flags</code> 包含update_JxW_values（即雅各布式的行列式和正交公式提供的权重的乘积），一个映射可能需要计算完整的雅各布式矩阵，以便计算其行列式。然后他们将不仅返回update_JxW_values，而且还返回update_jacobians。在计算JxW值的派生类中，内部实际上不是这样做的</p>
<ul>
<li>他们设置了update_contravariant_transformation来代替，由此也可以计算出行列式。</li>
<li>但这并不影响这个例子的启发性）。) 关于这个函数和FEValues之间的互动的广泛讨论可以在 <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and</a> 文档模块中找到。 <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> </dd></dl>
</li>
</ul>

<p>Implements <a class="el" href="classMapping.html#a4c62b5a55ca40e2b38c6a3a1f460d540">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00807">807</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a9a66a10ce2b30d71906de3e16c7595cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a66a10ce2b30d71906de3e16c7595cb">&#9670;&nbsp;</a></span>get_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::get_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建并返回一个指向对象的指针，映射可以在该对象中存储数据，这些数据只需要计算一次，但在映射应用于具体单元时都可以使用（例如，在各种transform()函数中，以及构成映射与FEValues类接口的fill_fe_values()、fill_fe_face_values()和fill_fe_subface_values()中）。 派生类将返回指向从 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 派生的类型的对象的指针（更多信息见那里），并且可能已经预先计算了一些信息（根据未来对映射的要求，由更新标志指定）和给定的正交对象。随后对transform()或fill_fe_values()和friends的调用将收到这里创建的对象（具有相同的更新标志集和相同的正交对象）。因此，派生类可以在其get_data()函数中预先计算一些信息，并将其存储在内部数据对象中。 映射类不会跟踪由该函数创建的对象。因此，所有权将归调用者所有。 关于这个函数和FEValues之间的互动的广泛讨论可以在 <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and</a> 文档模块中找到。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_flags</td><td>一组标志，定义了在未来调用transform()或fill_fe_values()函数组时对映射类的期望。这组标志可能包含映射不知道如何处理的标志（例如，对于事实上由有限元类计算的信息，如 UpdateFlags::update_values). 派生类将需要存储这些标志，或者至少是需要映射在fill_fe_values()中执行任何操作的标志子集，在 <a class="el" href="classMapping_1_1InternalDataBase.html#a43f4579d65a86db27d208ebf42ad3f44">InternalDataBase::update_each</a>. </td></tr>
    <tr><td class="paramname">quadrature</td><td>必须计算映射信息的正交对象。这包括正交点的位置和权重。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个指向新创建的InternalDataBase类型（或派生类）对象的指针。该对象的所有权转移给调用函数。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++允许派生类中的虚拟函数可以返回不是InternalDataBase类型的对象的指针，但实际上是指向InternalDataBase的类<em>derived</em>的对象的指针。(这个特性被称为 "共变返回类型"。)这在某些情况下是很有用的，因为在派生类中的调用将立即使用返回的对象，知道它的真实（派生）类型。 </dd></dl>

<p>Implements <a class="el" href="classMapping.html#a2fdce92a1ba733f9652de666d3475a34">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00864">864</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="ae8dbbf44bd25ced74d96458c62a4b74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8dbbf44bd25ced74d96458c62a4b74f">&#9670;&nbsp;</a></span>get_face_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>像get_data()一样，但是为以后调用transform()或fill_fe_face_values()做准备，这些调用需要关于从参考面到具体单元面的映射信息。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_flags</td><td>一组标志，定义在未来调用transform()或fill_fe_values()函数组时对映射类的期望。这组标志可能包含映射不知道如何处理的标志（例如，对于事实上由有限元类计算的信息，如 UpdateFlags::update_values). 派生类将需要存储这些标志，或者至少是需要映射在fill_fe_values()中执行任何操作的标志子集，在 <a class="el" href="classMapping_1_1InternalDataBase.html#a43f4579d65a86db27d208ebf42ad3f44">InternalDataBase::update_each</a>. </td></tr>
    <tr><td class="paramname">quadrature</td><td>需要计算映射信息的正交对象。这包括正交点的位置和权重。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个指向新创建的InternalDataBase类型（或派生类）对象的指针。该对象的所有权转移给调用函数。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++允许派生类中的虚拟函数可以返回不是InternalDataBase类型的对象的指针，但实际上是指向InternalDataBase的类<em>derived</em>的对象的指针。(这个特性被称为 "共变返回类型"。)这在某些情况下是很有用的，因为在派生类中的调用将立即使用返回的对象，知道它的真实（派生）类型。 </dd></dl>

<p>Reimplemented from <a class="el" href="classMapping.html#af3955d81e5bb00f69c566e0890fddeb6">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00879">879</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a85e75b674cebc41831eac23a44732fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e75b674cebc41831eac23a44732fcf">&#9670;&nbsp;</a></span>get_face_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>使用带有 <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> 参数的版本。</dd></dl>

</div>
</div>
<a id="a48f66b84a5495273300392c6e2bec063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f66b84a5495273300392c6e2bec063">&#9670;&nbsp;</a></span>get_subface_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::get_subface_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>像get_data()和get_face_data()一样，但是为以后调用transform()或fill_fe_subface_values()做准备，这些调用将需要关于从参考面到具体单元的面的子（即子面）的映射信息。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_flags</td><td>一组标志，定义在未来调用transform()或fill_fe_values()函数组时对映射类的期望。这组标志可能包含映射不知道如何处理的标志（例如，对于事实上由有限元类计算的信息，如 UpdateFlags::update_values). 派生类将需要存储这些标志，或者至少是需要映射在fill_fe_values()中执行任何操作的标志子集，在 <a class="el" href="classMapping_1_1InternalDataBase.html#a43f4579d65a86db27d208ebf42ad3f44">InternalDataBase::update_each</a>. </td></tr>
    <tr><td class="paramname">quadrature</td><td>必须计算映射信息的正交对象。这包括正交点的位置和权重。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个指向新创建的InternalDataBase类型（或派生类）对象的指针。该对象的所有权转移给调用函数。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++允许派生类中的虚拟函数可以返回不是InternalDataBase类型的对象的指针，但实际上是指向InternalDataBase的类<em>derived</em>的对象的指针。(这个特性被称为 "共变返回类型"。)这在某些情况下是很有用的，在这些情况下，调用是在派生类中，并且将立即使用返回的对象，知道它的真实（派生）类型。 </dd></dl>

<p>Implements <a class="el" href="classMapping.html#aa101c7827bf40a80b9adac393d830af1">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00900">900</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a55f47dbce73174cb01825bd1e5cfda6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f47dbce73174cb01825bd1e5cfda6d">&#9670;&nbsp;</a></span>fill_fe_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算从参考单元到此函数的第一个参数所指示的实数单元的映射信息。派生类将不得不根据它们所代表的映射类型来实现这个函数。它被 <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a>. 调用。从概念上讲，这个函数代表了从参考坐标 \(\mathbf\in [0,1]^d\) 到实空间坐标 \(\mathbf x\) 的映射 \(K\) 的应用。它的目的是计算以下种类的数据。</p>
<ul>
<li>从应用映射本身产生的数据，例如，计算实数单元上正交点的位置 \(\mathbf x_q = \mathbf F_K(\hat{\mathbf x}_q)\) ，对FEValues的用户直接有用，例如在装配过程中。</li>
<li>数据是有限元实现在真实单元上计算其形状函数所必需的。为此， <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> 函数在当前函数后调用 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> ，该函数的输出作为 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a>. 的输入。这里需要计算的信息的例子是映射的Jacobian， \(\hat\nabla \mathbf F_K(\hat{\mathbf x})\) 或其逆，例如，将参考单元上的形状函数的梯度转换为实单元上形状函数的梯度。 这个函数计算出来的信息被用来填充这个函数的输出参数的各个成员变量。该结构中的哪些成员变量应该被填充，由存储在传递给该函数的 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 对象中的更新标志决定。 关于此函数和FEValues之间的互动的广泛讨论可以在 <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and</a> 文档模块中找到。 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>三角形中的单元格，本函数要计算从参考单元格到的映射。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_similarity</td><td>作为第一个参数的单元格是否是最近一次调用此函数的单元格的简单平移、旋转等。这个信息是通过匹配前一个单元和当前单元之间的顶点（由三角结构存储）简单计算出来的。这里传递的值可能被这个函数的实现所修改，然后应该被返回（见关于这个函数的返回值的讨论）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>对当前评估中使用的正交公式的引用。这个正交对象与创建 <code>internal_data</code> 对象时使用的对象相同。该对象既用于映射正交点的位置，也用于计算每个正交点的JxW值（涉及正交权重）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_data</td><td>一个对先前由get_data()创建的对象的引用，可用于存储映射在参考单元上可以计算一次的信息。参见 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类的文档，以了解这些对象的用途的广泛描述。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>对成员变量应被计算的对象的引用。并非所有这个参数的成员都需要被填充；哪些成员需要被填充是由存储在 <code>internal_data</code> 对象内的更新标志决定的。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>这个函数的 <code>cell_similarity</code> 参数的一个更新值。当 <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> 调用 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a>. 时，返回的值将被用于相应的参数。在大多数情况下，派生类只想返回为 <code>cell_similarity传递的值。然而，这个函数的实现可能会降低细胞相似度的级别。例如，对于那些不仅考虑到单元格顶点的位置（如Triangulation所报告的），而且还考虑到映射的其他特定信息的类，就是这种情况。目的是</code> <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> 可以只根据单元格的顶点来计算一个单元格是否与前一个单元格相似，而映射也可以考虑位移场（例如，在MappingQ1Eulerian和MappingFEField类中）。在这种情况下，映射可能会得出结论，先前计算的单元格相似度过于乐观，并通过返回一个不那么乐观的单元格相似度值，使其在随后的使用中无效 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> 。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>FEValues确保这个函数总是用同一对 <code>internal_data</code> 和 <code>output_data</code> 对象调用。换句话说，如果这个函数的实现知道它在之前的调用中已经把一个数据写入了输出参数，那么在以后的调用中，如果实现知道这是同一个值，就没有必要再把它复制到那里。 </dd></dl>
</li>
</ul>

<p>Implements <a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00919">919</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="ac29df449ce7ed25d529cdfcd45873133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29df449ce7ed25d529cdfcd45873133">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数等同于 <a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a>, ，但用于单元格的面。有关其目的的广泛讨论，请参见那里。它被 <a class="el" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">FEFaceValues::reinit()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">单元格所调用，该函数要计算从参考单元格到的映射。</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>请求提供信息的给定单元的面的编号。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>当前评估中使用的正交公式的引用。此正交对象与创建 <code>internal_data</code> 对象时使用的对象相同。该对象既用于映射正交点的位置，也用于计算每个正交点的JxW值（涉及正交权重）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_data</td><td>一个对先前由get_data()创建的对象的引用，可用于存储映射在参考单元上可以计算一次的信息。参见 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类的文档，以了解这些对象的用途的广泛描述。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>对成员变量应被计算的对象的引用。并非这个参数的所有成员都需要被填充；哪些成员需要被填充是由存储在 <code>internal_data</code> 对象内的更新标志决定的。 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classMapping.html#a9baf527d46a7f2391dbb3dd5dc416864">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01141">1141</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="aa51c964b1e51b69db3f4933b97bff8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51c964b1e51b69db3f4933b97bff8c8">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>使用带有 <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> 参数的版本。</dd></dl>

</div>
</div>
<a id="a57a3be45fcb87da0a08e12472e26f5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a3be45fcb87da0a08e12472e26f5fd">&#9670;&nbsp;</a></span>fill_fe_subface_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数等同于 <a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a>, ，但适用于单元格的子面（即面的子女）。关于其目的的广泛讨论见那里。它被 <a class="el" href="classFESubfaceValues.html#a341778d1291f936d5192a39f2531472a">FESubfaceValues::reinit()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>三角形中的单元格，这个函数要为其计算从参考单元格到的映射。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>请求提供信息的给定单元的面的编号。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subface_no</td><td>请求提供信息的给定单元的面的子的编号。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>对当前评估中使用的正交公式的引用。这个正交对象与创建 <code>internal_data</code> 对象时使用的对象相同。该对象既用于映射正交点的位置，也用于计算每个正交点的JxW值（涉及正交权重）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_data</td><td>一个对先前由get_data()创建的对象的引用，可用于存储映射在参考单元上可以计算一次的信息。参见 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类的文档，以了解这些对象的用途的广泛描述。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>对成员变量应被计算的对象的引用。并非所有这个参数的成员都需要被填充；哪些成员需要被填充是由存储在 <code>internal_data</code> 对象内的更新标志决定的。 </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#a9f7f6025bc3f10e8f7da2c8a68eaff4a">Mapping&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01190">1190</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a8b4ddbb820ac561fca628d582cc57812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4ddbb820ac561fca628d582cc57812">&#9670;&nbsp;</a></span>fill_mapping_data_for_generic_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::fill_mapping_data_for_generic_points </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>相对于其他的fill_fe_values()和fill_fe_face_values()函数依赖InternalDataBase的预计算信息，这个函数在传入当前函数的单元格和点上选择灵活的评估路径。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>要评估映射的单元 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit_points</td><td>参考坐标中的点，应该在这里计算变换（Jacobians，位置）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update_flags</td><td>应该被计算的信息种类。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>一个包含评估量的结构，例如在给定单元上应用映射及其底层流形后产生的雅各布系数。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01240">1240</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a0c5c1ec190e6d300c5379ab4c6171241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5c1ec190e6d300c5379ab4c6171241">&#9670;&nbsp;</a></span>transform_real_to_unit_cell_internal() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::transform_real_to_unit_cell_internal </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_p_unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过牛顿迭代将实单元上的点 <code>p</code> 转换为单位单元上的相应点 <code>cell</code> 。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00460">460</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="aff6af289148eb3e4b8f4f57a0a4db8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6af289148eb3e4b8f4f57a0a4db8fc">&#9670;&nbsp;</a></span>transform_real_to_unit_cell_internal() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; 1, 1 &gt;::transform_real_to_unit_cell_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 1 &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_p_unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00474">474</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="aaad3296f2a3a274dbf670bd97db8bdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad3296f2a3a274dbf670bd97db8bdc3">&#9670;&nbsp;</a></span>transform_real_to_unit_cell_internal() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; 2, 2 &gt;::transform_real_to_unit_cell_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_p_unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00494">494</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a2c1337dba5f7b6c26a4921d6a99063ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1337dba5f7b6c26a4921d6a99063ea">&#9670;&nbsp;</a></span>transform_real_to_unit_cell_internal() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; 3, 3 &gt;::transform_real_to_unit_cell_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_p_unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00512">512</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a3b288f72deddedf72b2749764ca899a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b288f72deddedf72b2749764ca899a7">&#9670;&nbsp;</a></span>transform_real_to_unit_cell_internal() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; 1, 2 &gt;::transform_real_to_unit_cell_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 2 &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_p_unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00530">530</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="af1b833209847a286dd8ba74358733c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b833209847a286dd8ba74358733c63">&#9670;&nbsp;</a></span>transform_real_to_unit_cell_internal() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; 2, 3 &gt;::transform_real_to_unit_cell_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 3 &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_p_unit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00561">561</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a02bdac1fb0c1282cdeeda8a5cae37614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02bdac1fb0c1282cdeeda8a5cae37614">&#9670;&nbsp;</a></span>transform_real_to_unit_cell_internal() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; 1, 3 &gt;::transform_real_to_unit_cell_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, 3 &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l00590">590</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a95a3fc04a288095f8e507415884beb21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a3fc04a288095f8e507415884beb21">&#9670;&nbsp;</a></span>add_line_support_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::add_line_support_points </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将位于给定单元格边界线上的所有形状函数的支持点追加到矢量 <code>a</code>. 中 位于线的顶点上的点不包括在内。 该函数使用线的底层流形对象（如果没有设置，则使用单元格的底层流形对象）来确定请求的点的位置。这个函数通常由compute_mapping_support_points()函数调用。 这个函数是虚拟的，以便让派生类选择形状函数支持点的方式与本类不同，本类选择的点是边界上的插值点。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01473">1473</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a7c57b3baff2c0bcfe263c0be8340950e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c57b3baff2c0bcfe263c0be8340950e">&#9670;&nbsp;</a></span>add_quad_support_points() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::add_quad_support_points </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将位于给定单元格的边界面（3D中的四边形）上的所有形状函数的支持点附加到矢量上 <code>a</code>. 这个函数只定义于<code>dim=3</code>。位于四边形的顶点或线上的点不包括在内。 该函数使用四边形的底层流形对象（如果没有设置，则使用单元格的底层流形对象）来确定所请求的点的位置。这个函数通常由compute_mapping_support_points()调用。 这个函数是虚拟的，以便允许派生类以不同于本类的方式选择形状函数支持点，本类选择的点是边界上的插值点。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01639">1639</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="a0bf4aae37431be4e98d99eeebbd9e994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf4aae37431be4e98d99eeebbd9e994">&#9670;&nbsp;</a></span>add_quad_support_points() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; 3, 3 &gt;::add_quad_support_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01540">1540</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="afca1167a7de3f52d89da7a0f3119ce11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca1167a7de3f52d89da7a0f3119ce11">&#9670;&nbsp;</a></span>add_quad_support_points() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; 2, 3 &gt;::add_quad_support_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 3 &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8cc_source.html#l01609">1609</a> of file <a class="el" href="mapping__q__generic_8cc_source.html">mapping_q_generic.cc</a>.</p>

</div>
</div>
<a id="af3f37fd5b4a965f3f4ae0d0ca3060156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f37fd5b4a965f3f4ae0d0ca3060156">&#9670;&nbsp;</a></span>get_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_cell &gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个单元格的映射顶点。 大多数时候，这些值将仅仅是由 <code>cell-&gt;vertex(v)</code> 返回的顶点 <code>v</code> 的坐标，即由三角法存储的信息。 然而，也有增加位移或选择完全不同位置的映射，例如MappingQEulerian, <a class="el" href="classMappingQ1Eulerian.html">MappingQ1Eulerian</a>, 或MappingFEField。 这个函数的默认实现只是返回三角形所存储的信息，即： <code>cell-&gt;vertex(v)</code> . </p>

<p>Reimplemented in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ae1f6479ed386a00610eb138937705b5b">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQEulerian_1_1MappingQEulerianGeneric.html#a550a08b0626318f016ba6f7b6c7b115f">MappingQEulerian&lt; dim, VectorType, spacedim &gt;::MappingQEulerianGeneric</a>, <a class="el" href="classMappingQEulerian.html#a27e82d02aea674ad2463141b3188b8c7">MappingQEulerian&lt; dim, VectorType, spacedim &gt;</a>, and <a class="el" href="classMappingQ1Eulerian.html#a1b6dcd79f532e305122ef10ab31665a8">MappingQ1Eulerian&lt; dim, VectorType, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping_8cc_source.html#l00033">33</a> of file <a class="el" href="mapping_8cc_source.html">mapping.cc</a>.</p>

</div>
</div>
<a id="a8a6376f7ab802afb171a00a1a7748cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6376f7ab802afb171a00a1a7748cf2">&#9670;&nbsp;</a></span>get_center()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_center </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>map_center_of_reference_cell</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个单元格的映射中心。 如果你使用的是保留顶点位置的(bi-,tri-)线性映射，这个函数只是返回同样由<code>cell-&gt;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center()</a></code>产生的值。然而，也有一些映射会增加位移或选择完全不同的位置，例如MappingQEulerian、MappingQ1Eulerian或MappingFEField，以及基于高阶多项式的映射，对于这些映射，中心可能不会与顶点位置的平均值重合。 默认情况下，该函数返回参考单元中心的前推。如果参数 <code>map_center_of_reference_cell</code> 被设置为false，那么返回值将是由get_vertices()方法返回的顶点位置的平均值。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>你想计算中心的单元格 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_center_of_reference_cell</td><td>一个标志，用于将计算单元格中心的算法从应用于参考单元格中心的transform_unit_to_real_cell()转换为计算顶点平均数。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mapping_8cc_source.html#l00049">49</a> of file <a class="el" href="mapping_8cc_source.html">mapping.cc</a>.</p>

</div>
</div>
<a id="a078f4e617fdb287e1dc7a5efa227b0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078f4e617fdb287e1dc7a5efa227b0ae">&#9670;&nbsp;</a></span>project_real_point_to_unit_point_on_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::project_real_point_to_unit_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将实数 <code>cell</code> 上的点 <code>p</code> 转换为参考单元上的对应点，然后将此点投射到给定面数 <code>face_no</code>. 的面的坐标系中的一个(dim-1)维的点，理想情况下，点 <code>p</code> 靠近面 <code>face_no</code>, ，但技术上单元中的任何点都可以被投影。 当dim=1时，这个函数没有物理意义，所以在这种情况下它会抛出一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="mapping_8cc_source.html#l00111">111</a> of file <a class="el" href="mapping_8cc_source.html">mapping.cc</a>.</p>

</div>
</div>
<a id="a72122ff6ee588e788415f3124c48bb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72122ff6ee588e788415f3124c48bb0d">&#9670;&nbsp;</a></span>DeclException0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidData&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a23f3845de8ec963e201837ab1a7d53ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f3845de8ec963e201837ab1a7d53ba">&#9670;&nbsp;</a></span>support_point_cache</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;std::vector&lt;std::vector&lt;std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt; &gt; &gt; &gt; <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::support_point_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>调用initialize()时填充的点缓存。它被做成一个共享指针，以允许多个实例（通过clone()创建）共享这个缓存。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8h_source.html#l00217">217</a> of file <a class="el" href="mapping__q__cache_8h_source.html">mapping_q_cache.h</a>.</p>

</div>
</div>
<a id="ab9aa318ad48c85309e3cb915f46a93cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9aa318ad48c85309e3cb915f46a93cf">&#9670;&nbsp;</a></span>clear_signal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::clear_signal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与 Triangulation::signals::any 的连接，一旦这个类超出范围就必须被重置。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8h_source.html#l00224">224</a> of file <a class="el" href="mapping__q__cache_8h_source.html">mapping_q_cache.h</a>.</p>

</div>
</div>
<a id="a8f5c140ec21bf31145a84a093220431c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5c140ec21bf31145a84a093220431c">&#9670;&nbsp;</a></span>uses_level_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMappingQCache.html">MappingQCache</a>&lt; dim, spacedim &gt;::uses_level_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指定是否已经为层次上的单元设置了support_point_cache。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__cache_8h_source.html#l00230">230</a> of file <a class="el" href="mapping__q__cache_8h_source.html">mapping_q_cache.h</a>.</p>

</div>
</div>
<a id="ad003bfed73fda03fa261b3c10f64da15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad003bfed73fda03fa261b3c10f64da15">&#9670;&nbsp;</a></span>polynomial_degree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::polynomial_degree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用作单元格映射的形状函数的多项式的程度。 </p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8h_source.html#l00567">567</a> of file <a class="el" href="mapping__q__generic_8h_source.html">mapping_q_generic.h</a>.</p>

</div>
</div>
<a id="a9ed38f97b4d21de82739c1093181bf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed38f97b4d21de82739c1093181bf60">&#9670;&nbsp;</a></span>line_support_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;1&gt; &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::line_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8h_source.html#l00572">572</a> of file <a class="el" href="mapping__q__generic_8h_source.html">mapping_q_generic.h</a>.</p>

</div>
</div>
<a id="af3b24bf56e5b985af7caa8c6441b338a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b24bf56e5b985af7caa8c6441b338a">&#9670;&nbsp;</a></span>polynomials_1d</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPolynomials_1_1Polynomial.html">Polynomials::Polynomial</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::polynomials_1d</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8h_source.html#l00577">577</a> of file <a class="el" href="mapping__q__generic_8h_source.html">mapping_q_generic.h</a>.</p>

</div>
</div>
<a id="aef845cd736c730be7cde12bfc53bdd7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef845cd736c730be7cde12bfc53bdd7a">&#9670;&nbsp;</a></span>renumber_lexicographic_to_hierarchic</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::renumber_lexicographic_to_hierarchic</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8h_source.html#l00582">582</a> of file <a class="el" href="mapping__q__generic_8h_source.html">mapping_q_generic.h</a>.</p>

</div>
</div>
<a id="a87d09fe67f77a011aa7aa440cbbac690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d09fe67f77a011aa7aa440cbbac690">&#9670;&nbsp;</a></span>unit_cell_support_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::unit_cell_support_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8h_source.html#l00587">587</a> of file <a class="el" href="mapping__q__generic_8h_source.html">mapping_q_generic.h</a>.</p>

</div>
</div>
<a id="a1e13292c68ac279f84d5736211fe91b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e13292c68ac279f84d5736211fe91b3">&#9670;&nbsp;</a></span>support_point_weights_perimeter_to_interior</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classTable.html">Table</a>&lt;2, <a class="el" href="classdouble.html">double</a>&gt; &gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::support_point_weights_perimeter_to_interior</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个权重表的向量，我们将物体（直线、四边形、六边形）周边的支持点的位置与之相乘，得到内部支持点的位置。 进入该表的方法是 <code></code>[structdim-1], ，即用0来访问直线上的支持点权重（即Gauss-Lobatto正交的内部点），用1来访问从周长到四边形内部的支持点权重，用2来访问从周长到六角形内部的支持点权重。 该表本身包含有多少列，就有多少个特定对象的周边点（2代表直线， <code>4 + 4*(degree-1)</code> 代表四边形， <code>8 + 12*(degree-1)</p><ul>
<li>6*(degree-1)*(degree-1) 代表六边形）和多少行，就有多少个严格意义上的内部点。 该表的定义见 "映射 "报告的公式（8）。 </li>
</ul>
<p></code></p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8h_source.html#l00601">601</a> of file <a class="el" href="mapping__q__generic_8h_source.html">mapping_q_generic.h</a>.</p>

</div>
</div>
<a id="a5e54a03863f22b019d5f9cc4b8e40814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e54a03863f22b019d5f9cc4b8e40814">&#9670;&nbsp;</a></span>support_point_weights_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTable.html">Table</a>&lt;2, <a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt; dim, spacedim &gt;::support_point_weights_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个权重表，我们将单元格的顶点位置与之相乘，得到所有额外支持点的位置，包括线、四边形和六边形（根据情况）。这个数据结构是在我们一次性填充所有支持点时使用的，如果一个单元的所有子实体都连接着同一个流形，就会出现这种情况。这样一来，我们就可以避免为映射转换数据时的一些开销。 该表的行数与单元格的顶点数相同（一维为2，二维为4，三维为8），行数与映射中的额外支持点数相同，即：<code>(degree+1)^dim</code></p>
<p><code></p><ul>
<li>2^dim。 </li>
</ul>
<p></code></p>

<p class="definition">Definition at line <a class="el" href="mapping__q__generic_8h_source.html#l00610">610</a> of file <a class="el" href="mapping__q__generic_8h_source.html">mapping_q_generic.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/fe/<a class="el" href="mapping__q__cache_8h_source.html">mapping_q_cache.h</a></li>
<li>source/fe/<a class="el" href="mapping__q__cache_8cc_source.html">mapping_q_cache.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
