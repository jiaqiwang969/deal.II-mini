<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFilteredIterator.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FilteredIterator&lt; BaseIterator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classFilteredIterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FilteredIterator&lt; BaseIterator &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a><a class="el" href="group__grid.html">Grid classes</a> &raquo;  &#124; <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="filtered__iterator_8h_source.html">deal.II/grid/filtered_iterator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FilteredIterator&lt; BaseIterator &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFilteredIterator__inherit__graph.svg" width="212" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator_1_1PredicateBase.html">PredicateBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator_1_1PredicateTemplate.html">PredicateTemplate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7a3986520a6165a77e5b112049f95864"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a7a3986520a6165a77e5b112049f95864">AccessorType</a> = typename BaseIterator::AccessorType</td></tr>
<tr class="separator:a7a3986520a6165a77e5b112049f95864"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abdb7a4cce0c39d3fece3d3f272b06be8"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:abdb7a4cce0c39d3fece3d3f272b06be8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#abdb7a4cce0c39d3fece3d3f272b06be8">FilteredIterator</a> (Predicate p)</td></tr>
<tr class="separator:abdb7a4cce0c39d3fece3d3f272b06be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d5b3bb5eec9b464ea0ebce290aa610"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a60d5b3bb5eec9b464ea0ebce290aa610"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a60d5b3bb5eec9b464ea0ebce290aa610">FilteredIterator</a> (Predicate p, const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;bi)</td></tr>
<tr class="separator:a60d5b3bb5eec9b464ea0ebce290aa610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab7a13002adffd786ae8862c9551d1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a5ab7a13002adffd786ae8862c9551d1b">FilteredIterator</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;fi)</td></tr>
<tr class="separator:a5ab7a13002adffd786ae8862c9551d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3884629b4542ec8d2e66d0ff0a84b77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#af3884629b4542ec8d2e66d0ff0a84b77">operator=</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;fi)</td></tr>
<tr class="separator:af3884629b4542ec8d2e66d0ff0a84b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59726d809ae2f31cf87e234be9dd60bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a59726d809ae2f31cf87e234be9dd60bb">operator=</a> (const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;fi)</td></tr>
<tr class="separator:a59726d809ae2f31cf87e234be9dd60bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2793a746a3c8fd7d005461fa43828dc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a2793a746a3c8fd7d005461fa43828dc7">set_to_next_positive</a> (const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;bi)</td></tr>
<tr class="separator:a2793a746a3c8fd7d005461fa43828dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3511a0ed07877e0e40c69492bb2c920e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a3511a0ed07877e0e40c69492bb2c920e">set_to_previous_positive</a> (const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;bi)</td></tr>
<tr class="separator:a3511a0ed07877e0e40c69492bb2c920e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896a2449c181a18d48ef16d8af3205f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a896a2449c181a18d48ef16d8af3205f1">operator==</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;fi) const</td></tr>
<tr class="separator:a896a2449c181a18d48ef16d8af3205f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7350af8676cc98cd1114a87afce47891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a7350af8676cc98cd1114a87afce47891">operator==</a> (const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;fi) const</td></tr>
<tr class="separator:a7350af8676cc98cd1114a87afce47891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb1462542c6f5b1993c13c5af0a04b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a8cb1462542c6f5b1993c13c5af0a04b7">operator!=</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;fi) const</td></tr>
<tr class="separator:a8cb1462542c6f5b1993c13c5af0a04b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245437d652fb44642fb34c28545f1de2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a245437d652fb44642fb34c28545f1de2">operator!=</a> (const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;fi) const</td></tr>
<tr class="separator:a245437d652fb44642fb34c28545f1de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb790e543dd7713670478462bc77bf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#abfb790e543dd7713670478462bc77bf3">operator&lt;</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;fi) const</td></tr>
<tr class="separator:abfb790e543dd7713670478462bc77bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ff0049dfc58d9df66b09dda7b4ebd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#af4ff0049dfc58d9df66b09dda7b4ebd3">operator&lt;</a> (const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;fi) const</td></tr>
<tr class="separator:af4ff0049dfc58d9df66b09dda7b4ebd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af443c6eaae6bbf6d469d6f9c2bd8d45f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#af443c6eaae6bbf6d469d6f9c2bd8d45f">operator++</a> ()</td></tr>
<tr class="separator:af443c6eaae6bbf6d469d6f9c2bd8d45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631025a97f88c3af83fd197e74955952"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a631025a97f88c3af83fd197e74955952">operator++</a> (<a class="el" href="classint.html">int</a>)</td></tr>
<tr class="separator:a631025a97f88c3af83fd197e74955952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684a24d262a47514fcff64fc3e86c580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a684a24d262a47514fcff64fc3e86c580">operator--</a> ()</td></tr>
<tr class="separator:a684a24d262a47514fcff64fc3e86c580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1df9fa9cac3f0c00c27eb692200a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a8b1df9fa9cac3f0c00c27eb692200a03">operator--</a> (<a class="el" href="classint.html">int</a>)</td></tr>
<tr class="separator:a8b1df9fa9cac3f0c00c27eb692200a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fdbe00c6000dba265cb268d68d8050"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a11fdbe00c6000dba265cb268d68d8050">DeclException1</a> (ExcInvalidElement, <a class="el" href="classBaseIterator.html">BaseIterator</a>,&lt;&lt; &quot;The element &quot;&lt;&lt; arg1&lt;&lt; &quot; with which you want to compare or which you want to&quot;&lt;&lt; &quot; assign from is invalid since it does not satisfy the predicate.&quot;)</td></tr>
<tr class="separator:a11fdbe00c6000dba265cb268d68d8050"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af3fa14c68ec8687f259e2bc2c7f69439"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; const <a class="el" href="classFilteredIterator_1_1PredicateBase.html">PredicateBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#af3fa14c68ec8687f259e2bc2c7f69439">predicate</a></td></tr>
<tr class="separator:af3fa14c68ec8687f259e2bc2c7f69439"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ab70266a7220e6ff4e3f915e0fb44a4dd"><td class="memTemplParams" colspan="2">template&lt;typename BaseIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ab70266a7220e6ff4e3f915e0fb44a4dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#ab70266a7220e6ff4e3f915e0fb44a4dd">make_filtered_iterator</a> (const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;i, const Predicate &amp;p)</td></tr>
<tr class="separator:ab70266a7220e6ff4e3f915e0fb44a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3948dd66d9e66ac55d89dc8f75fa4855"><td class="memTemplParams" colspan="2">template&lt;typename BaseIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ga3948dd66d9e66ac55d89dc8f75fa4855"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga3948dd66d9e66ac55d89dc8f75fa4855">filter_iterators</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; i, const Predicate &amp;p)</td></tr>
<tr class="separator:ga3948dd66d9e66ac55d89dc8f75fa4855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05713415704536e5b0e967d33c2c77c1"><td class="memTemplParams" colspan="2">template&lt;typename BaseIterator , typename Predicate , typename... Targs&gt; </td></tr>
<tr class="memitem:ga05713415704536e5b0e967d33c2c77c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="structinternal_1_1FilteredIteratorImplementation_1_1NestFilteredIterators.html">internal::FilteredIteratorImplementation::NestFilteredIterators</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a>, std::tuple&lt; Predicate, Targs... &gt; &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga05713415704536e5b0e967d33c2c77c1">filter_iterators</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; i, const Predicate &amp;p, const Targs... args)</td></tr>
<tr class="separator:ga05713415704536e5b0e967d33c2c77c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename BaseIterator&gt;<br />
class FilteredIterator&lt; BaseIterator &gt;</h3>

<p>This class provides a certain view on a range of triangulation or <a class="el" href="classDoFHandler.html">DoFHandler</a> iterators by only iterating over elements that satisfy a given filter (called a <em>predicate</em>, following the notation of the C++ standard library). Once initialized with a predicate and a value for the iterator, a filtered iterator hops to the next or previous element that satisfies the predicate if operators ++ or -- are invoked. Intermediate iterator values that lie in between but do not satisfy the predicate are skipped. It is thus very simple to write loops over a certain class of objects without the need to explicitly write down the condition they have to satisfy in each loop iteration. This in particular is helpful if functions are called with a pair of iterators denoting a range on which they shall act, by choosing a filtered iterator instead of usual ones.</p>
<p>This class is used in step-32.</p>
<h3>Predicates</h3>
<p>The object that represent the condition an iterator has to satisfy only have to provide an interface that allows to call the evaluation operator, i.e. <code>bool operator() (const <a class="el" href="classBaseIterator.html">BaseIterator</a>&amp;)</code>. This includes function pointers as well as classes that implement an <code>bool operator ()(const <a class="el" href="classBaseIterator.html">BaseIterator</a>&amp;)</code>. Then, the <a class="el" href="classFilteredIterator.html">FilteredIterator</a> will skip all objects where the return value of this function is <code>false</code>.</p>
<p>An example of a simple valid predicate is the following: given the function </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BIterator&gt;</div><div class="line"><span class="keywordtype">bool</span> level_equal_to_3 (<span class="keyword">const</span> BIterator&amp; c)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (static_cast&lt;unsigned int&gt;(c-&gt;level()) == 3);</div><div class="line">};</div></div><!-- fragment --><p> then </p><div class="fragment"><div class="line">&amp;level_equal_to_3&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator&gt;</div></div><!-- fragment --><p> is a valid predicate.</p>
<p>Likewise, given the following binary function </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BIterator&gt;</div><div class="line"><span class="keywordtype">bool</span> level_equal_to (<span class="keyword">const</span> BIterator&amp;     c,</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (static_cast&lt;unsigned int&gt;(c-&gt;level()) == level);</div><div class="line">};</div></div><!-- fragment --><p> then </p><div class="fragment"><div class="line">[](<span class="keyword">const</span> BIterator&amp; c){ <span class="keywordflow">return</span> level_equal_to&lt;active_cell_iterator&gt;(c, 3);}</div></div><!-- fragment --><p> is another valid predicate (here: a function that returns true if either the iterator is past the end or the level is equal to the second argument; this second argument is taken considered fixed when creating the lambda function).</p>
<p>Finally, classes can be predicates. The following class is one: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Active</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> Iterator &amp;i)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> i-&gt;is_active();</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p> and objects of this type can be used as predicates. Likewise, this more complicated one can also be used: </p><div class="fragment"><div class="line"><span class="keyword">class </span>SubdomainEqualTo</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SubdomainEqualTo (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::subdomain_id</a> <a class="code" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id</a>)</div><div class="line">    : subdomain_id (subdomain_id)</div><div class="line">  {};</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> Iterator &amp;i)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (i-&gt;subdomain_id() == <a class="code" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::subdomain_id</a> <a class="code" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id</a>;</div><div class="line">};</div></div><!-- fragment --><p> Objects like <code>SubdomainEqualTo(3)</code> can then be used as predicates.</p>
<p>Since whenever a predicate is evaluated it is checked that the iterator checked is actually valid (i.e. not past the end), no checks for this case have to be performed inside predicates.</p>
<p>A number of filter classes are already implemented in the <a class="el" href="namespaceIteratorFilters.html">IteratorFilters</a> namespace, but writing different ones is simple following the examples above.</p>
<h3>Initialization of filtered iterators</h3>
<p>Filtered iterators are given a predicate at construction time which cannot be changed any more. This behavior would be expected if the predicate would have been given as a template parameter to the class, but since that would make the declaration of filtered iterators a nightmare, we rather give the predicate as an unchangeable entity to the constructor. Note that one can assign a filtered iterator with one predicate to another filtered iterator with another type; yet, this does <em>not</em> change the predicate of the assigned-to iterator, only the pointer indicating the iterator is changed.</p>
<p>If a filtered iterator is not assigned a value of the underlying (unfiltered) iterator type, the default value is taken. If, however, a value is given to the constructor, that value has either to be past the end, or has to satisfy the predicate. For example, if the predicate only evaluates to true if the level of an object is equal to three, then <code>tria.begin_active(3)</code> would be a valid choice while <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">tria.begin()</a></code> would not since the latter also returns iterators to non-active cells which always start at level 0.</p>
<p>Since one often only has some iterator and wants to set a filtered iterator to the first one that satisfies a predicate (for example, the first one for which the user flag is set, or the first one with a given subdomain id), there are assignment functions <a class="el" href="classFilteredIterator.html#a2793a746a3c8fd7d005461fa43828dc7">set_to_next_positive</a> and <a class="el" href="classFilteredIterator.html#a3511a0ed07877e0e40c69492bb2c920e">set_to_previous_positive</a> that assign the next or last previous iterator that satisfies the predicate, i.e. they follow the list of iterators in either direction until they find a matching one (or the past-the-end iterator). Like the <code>operator=</code> they return the resulting value of the filtered iterator.</p>
<h3>Examples</h3>
<p>The following call counts the number of active cells that have a set user flag: </p><div class="fragment"><div class="line"><a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">begin</a> (<a class="code" href="classIteratorFilters_1_1UserFlagSet.html">IteratorFilters::UserFlagSet</a>()),</div><div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a> (<a class="code" href="classIteratorFilters_1_1UserFlagSet.html">IteratorFilters::UserFlagSet</a>());</div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">begin</a>.set_to_next_positive(tria.begin_active());</div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a> = tria.end();</div><div class="line">n_flagged_cells = <a class="code" href="namespacemystl.html#a5ecb09f5cd83c4465b4645b381730651">std::distance</a> (<a class="code" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">begin</a>, <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a>);</div></div><!-- fragment --><p> Note that by the <code>set_to_next_positive</code> call the first cell with a set user flag was assigned to the <code>begin</code> iterator. For the end iterator, no such call was necessary, since the past-the-end iterator always satisfies all predicates.</p>
<p>The same can be achieved by the following snippet, though harder to read: </p><div class="fragment"><div class="line"><span class="keyword">using</span> FI =</div><div class="line">  <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator</a>&gt;;</div><div class="line">n_flagged_cells =</div><div class="line">  <a class="code" href="namespacemystl.html#a5ecb09f5cd83c4465b4645b381730651">std::distance</a> (</div><div class="line">    FI(<a class="code" href="classIteratorFilters_1_1UserFlagSet.html">IteratorFilters::UserFlagSet</a>()).<a class="code" href="classFilteredIterator.html#a2793a746a3c8fd7d005461fa43828dc7">set_to_next_positive</a>(</div><div class="line">      tria.begin_active()),</div><div class="line">    FI(<a class="code" href="classIteratorFilters_1_1UserFlagSet.html">IteratorFilters::UserFlagSet</a>(), tria.end()));</div></div><!-- fragment --><p> It relies on the fact that if we create an unnamed filtered iterator with a given predicate but no iterator value and assign it the next positive value with respect to this predicate, it returns itself which is then used as the first parameter to the <code>std::distance</code> function. This procedure is not necessary for the end element to this function here, since the past-the-end iterator always satisfies the predicate so that we can assign this value to the filtered iterator directly in the constructor.</p>
<p>Finally, the following loop only assembles the matrix on cells with subdomain id equal to three: </p><div class="fragment"><div class="line"><a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">  cell (<a class="code" href="classIteratorFilters_1_1SubdomainEqualTo.html">IteratorFilters::SubdomainEqualTo</a>(3)),</div><div class="line">  endc (<a class="code" href="classIteratorFilters_1_1SubdomainEqualTo.html">IteratorFilters::SubdomainEqualTo</a>(3), tria.end());</div><div class="line">cell.<a class="code" href="classFilteredIterator.html#a2793a746a3c8fd7d005461fa43828dc7">set_to_next_positive</a> (tria.begin_active());</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  assemble_local_matrix (cell);</div></div><!-- fragment --><p>Since comparison between filtered and unfiltered iterators is defined, we could as well have let the <code>endc</code> variable in the last example be of type <a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">Triangulation::active_cell_iterator</a> since it is unchanged and its value does not depend on the filter. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00524">524</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7a3986520a6165a77e5b112049f95864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3986520a6165a77e5b112049f95864">&#9670;&nbsp;</a></span>AccessorType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::<a class="el" href="classFilteredIterator.html#a7a3986520a6165a77e5b112049f95864">AccessorType</a> =  typename BaseIterator::AccessorType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef to the accessor type of the underlying iterator. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00530">530</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abdb7a4cce0c39d3fece3d3f272b06be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb7a4cce0c39d3fece3d3f272b06be8">&#9670;&nbsp;</a></span>FilteredIterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::<a class="el" href="classFilteredIterator.html">FilteredIterator</a> </td>
          <td>(</td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Set the iterator to the default state and use the given predicate for filtering subsequent assignment and iteration. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00925">925</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a60d5b3bb5eec9b464ea0ebce290aa610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d5b3bb5eec9b464ea0ebce290aa610">&#9670;&nbsp;</a></span>FilteredIterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::<a class="el" href="classFilteredIterator.html">FilteredIterator</a> </td>
          <td>(</td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>bi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Use the given predicate for filtering and initialize the iterator with the given value.</p>
<p>If the initial value <code>bi</code> does not satisfy the predicate <code>p</code> then it is advanced until we either hit the past-the-end iterator, or the predicate is satisfied. This allows, for example, to write code like </p><div class="fragment"><div class="line"><a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">  cell (<a class="code" href="classIteratorFilters_1_1SubdomainEqualTo.html">IteratorFilters::SubdomainEqualTo</a>(13),</div><div class="line">        triangulation.begin_active());</div></div><!-- fragment --><p>If the cell <code>triangulation.begin_active()</code> does not have a subdomain_id equal to 13, then the iterator will automatically be advanced to the first cell that has. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00933">933</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a5ab7a13002adffd786ae8862c9551d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab7a13002adffd786ae8862c9551d1b">&#9670;&nbsp;</a></span>FilteredIterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::<a class="el" href="classFilteredIterator.html">FilteredIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Copy the predicate and iterator value of the given argument. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00945">945</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af3884629b4542ec8d2e66d0ff0a84b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3884629b4542ec8d2e66d0ff0a84b77">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator. Copy the iterator value of the argument, but as discussed in the class documentation, the predicate of the argument is not copied. The iterator value underlying the argument has to satisfy the predicate of the object assigned to, as given at its construction time. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00959">959</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a59726d809ae2f31cf87e234be9dd60bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59726d809ae2f31cf87e234be9dd60bb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator. Copy the iterator value of the argument, and keep the predicate of this object. The given iterator value has to satisfy the predicate of the object assigned to, as given at its construction time. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00974">974</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a2793a746a3c8fd7d005461fa43828dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2793a746a3c8fd7d005461fa43828dc7">&#9670;&nbsp;</a></span>set_to_next_positive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::set_to_next_positive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>bi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search for the next iterator from <code>bi</code> onwards that satisfies the predicate of this object and assign it to this object.</p>
<p>Since filtered iterators are automatically converted to the underlying base iterator type, you can also give a filtered iterator as argument to this function. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00986">986</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a3511a0ed07877e0e40c69492bb2c920e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3511a0ed07877e0e40c69492bb2c920e">&#9670;&nbsp;</a></span>set_to_previous_positive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::set_to_previous_positive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>bi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>As above, but search for the previous iterator from <code>bi</code> backwards that satisfies the predicate of this object and assign it to this object.</p>
<p>Since filtered iterators are automatically converted to the underlying base iterator type, you can also give a filtered iterator as argument to this function. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00999">999</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a896a2449c181a18d48ef16d8af3205f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896a2449c181a18d48ef16d8af3205f1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for equality of the underlying iterator values of this and the given object.</p>
<p>We do not compare for equality of the predicates. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01012">1012</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a7350af8676cc98cd1114a87afce47891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7350af8676cc98cd1114a87afce47891">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for equality of the underlying iterator value of this object with the given object.</p>
<p>The predicate of this object is irrelevant for this operation. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01042">1042</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a8cb1462542c6f5b1993c13c5af0a04b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb1462542c6f5b1993c13c5af0a04b7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for inequality of the underlying iterator values of this and the given object.</p>
<p>We do not compare for equality of the predicates. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01022">1022</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a245437d652fb44642fb34c28545f1de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245437d652fb44642fb34c28545f1de2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for inequality of the underlying iterator value of this object with the given object.</p>
<p>The predicate of this object is irrelevant for this operation. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01051">1051</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="abfb790e543dd7713670478462bc77bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb790e543dd7713670478462bc77bf3">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for ordering of the underlying iterator values of this and the given object.</p>
<p>We do not compare the predicates. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01032">1032</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="af4ff0049dfc58d9df66b09dda7b4ebd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ff0049dfc58d9df66b09dda7b4ebd3">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for ordering of the underlying iterator value of this object with the given object.</p>
<p>The predicate of this object is irrelevant for this operation. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01060">1060</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="af443c6eaae6bbf6d469d6f9c2bd8d45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af443c6eaae6bbf6d469d6f9c2bd8d45f">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prefix advancement operator: move to the next iterator value satisfying the predicate and return the new iterator value. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01068">1068</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a631025a97f88c3af83fd197e74955952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631025a97f88c3af83fd197e74955952">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Postfix advancement operator: move to the next iterator value satisfying the predicate and return the old iterator value. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01081">1081</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a684a24d262a47514fcff64fc3e86c580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684a24d262a47514fcff64fc3e86c580">&#9670;&nbsp;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prefix decrement operator: move to the previous iterator value satisfying the predicate and return the new iterator value. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01096">1096</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a8b1df9fa9cac3f0c00c27eb692200a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1df9fa9cac3f0c00c27eb692200a03">&#9670;&nbsp;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Postfix advancement operator: move to the previous iterator value satisfying the predicate and return the old iterator value. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01109">1109</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a11fdbe00c6000dba265cb268d68d8050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fdbe00c6000dba265cb268d68d8050">&#9670;&nbsp;</a></span>DeclException1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidElement&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBaseIterator.html">BaseIterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The element &quot;&lt;&lt; arg1&lt;&lt; &quot; with which you want to compare or which you want to&quot;&lt;&lt; &quot; assign from is invalid since it does not satisfy the predicate.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab70266a7220e6ff4e3f915e0fb44a4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70266a7220e6ff4e3f915e0fb44a4dd">&#9670;&nbsp;</a></span>make_filtered_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; make_filtered_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an object of type <a class="el" href="classFilteredIterator.html">FilteredIterator</a> given the base iterator and predicate. This function makes the creation of temporary objects (for example as function arguments) a lot simpler because one does not have to explicitly specify the type of the base iterator by hand &ndash; it is deduced automatically here. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00788">788</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af3fa14c68ec8687f259e2bc2c7f69439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fa14c68ec8687f259e2bc2c7f69439">&#9670;&nbsp;</a></span>predicate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;const <a class="el" href="classFilteredIterator_1_1PredicateBase.html">PredicateBase</a>&gt; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::predicate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to an object that encapsulated the actual data type of the predicate given to the constructor. </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00772">772</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/grid/<a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
