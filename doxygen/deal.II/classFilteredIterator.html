<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFilteredIterator.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FilteredIterator&lt; BaseIterator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classFilteredIterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FilteredIterator&lt; BaseIterator &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grids and Triangulations</a><a class="el" href="group__grid.html">Grids and Triangulations</a> &raquo;  &#124; <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="filtered__iterator_8h_source.html">deal.II/grid/filtered_iterator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FilteredIterator&lt; BaseIterator &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFilteredIterator__inherit__graph.svg" width="239" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator_1_1PredicateBase.html">PredicateBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator_1_1PredicateTemplate.html">PredicateTemplate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7a3986520a6165a77e5b112049f95864"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a7a3986520a6165a77e5b112049f95864">AccessorType</a> = typename BaseIterator::AccessorType</td></tr>
<tr class="separator:a7a3986520a6165a77e5b112049f95864"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abdb7a4cce0c39d3fece3d3f272b06be8"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:abdb7a4cce0c39d3fece3d3f272b06be8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#abdb7a4cce0c39d3fece3d3f272b06be8">FilteredIterator</a> (Predicate p)</td></tr>
<tr class="separator:abdb7a4cce0c39d3fece3d3f272b06be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d5b3bb5eec9b464ea0ebce290aa610"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a60d5b3bb5eec9b464ea0ebce290aa610"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a60d5b3bb5eec9b464ea0ebce290aa610">FilteredIterator</a> (Predicate p, const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;bi)</td></tr>
<tr class="separator:a60d5b3bb5eec9b464ea0ebce290aa610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab7a13002adffd786ae8862c9551d1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a5ab7a13002adffd786ae8862c9551d1b">FilteredIterator</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;fi)</td></tr>
<tr class="separator:a5ab7a13002adffd786ae8862c9551d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3884629b4542ec8d2e66d0ff0a84b77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#af3884629b4542ec8d2e66d0ff0a84b77">operator=</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;fi)</td></tr>
<tr class="separator:af3884629b4542ec8d2e66d0ff0a84b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59726d809ae2f31cf87e234be9dd60bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a59726d809ae2f31cf87e234be9dd60bb">operator=</a> (const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;fi)</td></tr>
<tr class="separator:a59726d809ae2f31cf87e234be9dd60bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2793a746a3c8fd7d005461fa43828dc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a2793a746a3c8fd7d005461fa43828dc7">set_to_next_positive</a> (const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;bi)</td></tr>
<tr class="separator:a2793a746a3c8fd7d005461fa43828dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3511a0ed07877e0e40c69492bb2c920e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a3511a0ed07877e0e40c69492bb2c920e">set_to_previous_positive</a> (const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;bi)</td></tr>
<tr class="separator:a3511a0ed07877e0e40c69492bb2c920e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896a2449c181a18d48ef16d8af3205f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a896a2449c181a18d48ef16d8af3205f1">operator==</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;fi) const</td></tr>
<tr class="separator:a896a2449c181a18d48ef16d8af3205f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7350af8676cc98cd1114a87afce47891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a7350af8676cc98cd1114a87afce47891">operator==</a> (const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;fi) const</td></tr>
<tr class="separator:a7350af8676cc98cd1114a87afce47891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb1462542c6f5b1993c13c5af0a04b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a8cb1462542c6f5b1993c13c5af0a04b7">operator!=</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;fi) const</td></tr>
<tr class="separator:a8cb1462542c6f5b1993c13c5af0a04b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245437d652fb44642fb34c28545f1de2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a245437d652fb44642fb34c28545f1de2">operator!=</a> (const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;fi) const</td></tr>
<tr class="separator:a245437d652fb44642fb34c28545f1de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb790e543dd7713670478462bc77bf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#abfb790e543dd7713670478462bc77bf3">operator&lt;</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;fi) const</td></tr>
<tr class="separator:abfb790e543dd7713670478462bc77bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ff0049dfc58d9df66b09dda7b4ebd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#af4ff0049dfc58d9df66b09dda7b4ebd3">operator&lt;</a> (const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;fi) const</td></tr>
<tr class="separator:af4ff0049dfc58d9df66b09dda7b4ebd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af443c6eaae6bbf6d469d6f9c2bd8d45f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#af443c6eaae6bbf6d469d6f9c2bd8d45f">operator++</a> ()</td></tr>
<tr class="separator:af443c6eaae6bbf6d469d6f9c2bd8d45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631025a97f88c3af83fd197e74955952"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a631025a97f88c3af83fd197e74955952">operator++</a> (<a class="el" href="classint.html">int</a>)</td></tr>
<tr class="separator:a631025a97f88c3af83fd197e74955952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684a24d262a47514fcff64fc3e86c580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a684a24d262a47514fcff64fc3e86c580">operator--</a> ()</td></tr>
<tr class="separator:a684a24d262a47514fcff64fc3e86c580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1df9fa9cac3f0c00c27eb692200a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a8b1df9fa9cac3f0c00c27eb692200a03">operator--</a> (<a class="el" href="classint.html">int</a>)</td></tr>
<tr class="separator:a8b1df9fa9cac3f0c00c27eb692200a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fdbe00c6000dba265cb268d68d8050"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#a11fdbe00c6000dba265cb268d68d8050">DeclException1</a> (ExcInvalidElement, <a class="el" href="classBaseIterator.html">BaseIterator</a>,&lt;&lt; &quot;The element &quot;&lt;&lt; arg1&lt;&lt; &quot; with which you want to compare or which you want to&quot;&lt;&lt; &quot; assign from is invalid since it does not satisfy the predicate.&quot;)</td></tr>
<tr class="separator:a11fdbe00c6000dba265cb268d68d8050"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af3fa14c68ec8687f259e2bc2c7f69439"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; const <a class="el" href="classFilteredIterator_1_1PredicateBase.html">PredicateBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#af3fa14c68ec8687f259e2bc2c7f69439">predicate</a></td></tr>
<tr class="separator:af3fa14c68ec8687f259e2bc2c7f69439"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ab70266a7220e6ff4e3f915e0fb44a4dd"><td class="memTemplParams" colspan="2">template&lt;typename BaseIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ab70266a7220e6ff4e3f915e0fb44a4dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFilteredIterator.html#ab70266a7220e6ff4e3f915e0fb44a4dd">make_filtered_iterator</a> (const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;i, const Predicate &amp;p)</td></tr>
<tr class="separator:ab70266a7220e6ff4e3f915e0fb44a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3948dd66d9e66ac55d89dc8f75fa4855"><td class="memTemplParams" colspan="2">template&lt;typename BaseIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ga3948dd66d9e66ac55d89dc8f75fa4855"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga3948dd66d9e66ac55d89dc8f75fa4855">filter_iterators</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; i, const Predicate &amp;p)</td></tr>
<tr class="separator:ga3948dd66d9e66ac55d89dc8f75fa4855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05713415704536e5b0e967d33c2c77c1"><td class="memTemplParams" colspan="2">template&lt;typename BaseIterator , typename Predicate , typename... Targs&gt; </td></tr>
<tr class="memitem:ga05713415704536e5b0e967d33c2c77c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; typename <a class="el" href="structinternal_1_1FilteredIteratorImplementation_1_1NestFilteredIterators.html">internal::FilteredIteratorImplementation::NestFilteredIterators</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a>, std::tuple&lt; Predicate, Targs... &gt; &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga05713415704536e5b0e967d33c2c77c1">filter_iterators</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; i, const Predicate &amp;p, const Targs... args)</td></tr>
<tr class="separator:ga05713415704536e5b0e967d33c2c77c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename BaseIterator&gt;<br />
class FilteredIterator&lt; BaseIterator &gt;</h3>

<p>这个类通过只迭代满足给定过滤器（称为 <em> 谓词 </em> ，遵循C++标准库的符号）的元素，提供了对一系列三角形或DoFHandler迭代器的某种看法。一旦用谓词和迭代器的值进行初始化，如果调用操作符++或--，过滤的迭代器会跳到满足谓词的下一个或上一个元素。位于两者之间但不满足谓词的中间迭代器值被跳过。因此，在某一类对象上写循环是非常简单的，不需要明确写出它们在每个循环迭代中必须满足的条件。如果函数被调用时有一对迭代器，表示它们将在一个范围内行动，通过选择一个过滤的迭代器而不是通常的迭代器，这尤其有帮助。 该类在 <a class="el" href="step_32.html">step-32</a> 中使用。</p>
<h3>Predicates</h3>
<p>代表迭代器必须满足的条件的对象只需要提供一个允许调用评估操作符的接口，即 <code>bool operator() (const <a class="el" href="classBaseIterator.html">BaseIterator</a>&amp;)</code> 。这包括函数指针以及实现<code>bool operator ()(const <a class="el" href="classBaseIterator.html">BaseIterator</a>&amp;)</code>的类。然后，FilteredIterator将跳过所有该函数的返回值为 <code>false</code> 的对象。</p>
<p>一个简单的有效谓词的例子如下：给定函数</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BIterator&gt;</div><div class="line"><span class="keywordtype">bool</span> level_equal_to_3 (<span class="keyword">const</span> BIterator&amp; c)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (static_cast&lt;unsigned int&gt;(c-&gt;level()) == 3);</div><div class="line">};</div></div><!-- fragment --><p> 那么</p>
<div class="fragment"><div class="line">&amp;level_equal_to_3&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator&gt;</div></div><!-- fragment --><p> 是一个有效的谓词。 同样地，给定以下二元函数 </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BIterator&gt;</div><div class="line"><span class="keywordtype">bool</span> level_equal_to (<span class="keyword">const</span> BIterator&amp;     c,</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (static_cast&lt;unsigned int&gt;(c-&gt;level()) == level);</div><div class="line">};</div></div><!-- fragment --><p> 那么</p>
<div class="fragment"><div class="line">[](<span class="keyword">const</span> BIterator&amp; c){ <span class="keywordflow">return</span> level_equal_to&lt;active_cell_iterator&gt;(c, 3);}</div></div><!-- fragment --><p> 是另一个有效的谓词（这里：一个函数，如果迭代器过了终点或者水平等于第二个参数，则返回真；这个第二个参数在创建lambda函数时被视为固定的）。 最后，类可以是谓词。下面这个类就是一个。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Active</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> Iterator &amp;i)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> i-&gt;is_active();</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p> 而这种类型的对象可以作为谓词使用。同样地，这个更复杂的也可以使用。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SubdomainEqualTo</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SubdomainEqualTo (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::subdomain_id</a> <a class="code" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id</a>)</div><div class="line">    : subdomain_id (subdomain_id)</div><div class="line">  {};</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> Iterator &amp;i)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (i-&gt;subdomain_id() == <a class="code" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::subdomain_id</a> <a class="code" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id</a>;</div><div class="line">};</div></div><!-- fragment --><p> 像 <code>SubdomainEqualTo(3)</code> 这样的对象就可以作为谓词使用。 因为每当一个谓词被评估时，都会检查被检查的迭代器是否真的有效（即没有超过终点），所以在谓词内部不需要对这种情况进行检查。 很多过滤器类已经在IteratorFilters命名空间中实现了，但是按照上面的例子，编写不同的过滤器也很简单。</p>
<h3>Initialization of filtered iterators</h3>
<p>过滤的迭代器在构造时被赋予一个谓词，这个谓词不能再被改变。如果这个谓词是作为一个模板参数给类的话，这种行为是可以预期的，但由于这将使过滤迭代器的声明成为一场噩梦，我们宁愿把谓词作为一个不可改变的实体给构造器。请注意，人们可以将一个具有一个谓词的过滤迭代器分配给另一个具有另一种类型的过滤迭代器；然而，这并不 <em> 改变分配给迭代器的谓词，只有指示迭代器的指针被改变。 如果一个被过滤的迭代器没有被分配一个底层（未被过滤的）迭代器类型的值，那么将采取默认值。然而，如果给构造函数一个值，该值必须超过终点，或者必须满足谓词。例如，如果谓词只在对象的级别等于3时才评估为真，那么 <code>tria.begin_active(3)</code> 将是一个有效的选择，而 <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">tria.begin()</a></code> 则不是，因为后者也会返回非活动单元的迭代器，这些单元总是从级别0开始。 由于人们经常只有一些迭代器，并希望将过滤后的迭代器设置为第一个满足谓词的迭代器（例如，第一个设置了用户标志的迭代器，或者第一个具有给定子域id的迭代器），因此有一些赋值函数::set_to_next_positive和::set_to_previous_positive，它们将满足谓词的下一个或上一个迭代器赋值，即。 也就是说，它们沿着迭代器列表的任一方向追踪，直到找到一个匹配的迭代器（或过去的迭代器）。像 <code>operator=</code> 一样，它们返回过滤后的迭代器的结果值。</em></p>
<p><em> </p><h3>Examples</h3>
<p></em></p>
<p><em> 下面的调用计算了有设置用户标志的活动单元的数量。</em></p>
<p><em></p><div class="fragment"><div class="line"><a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">begin</a> (<a class="code" href="classIteratorFilters_1_1UserFlagSet.html">IteratorFilters::UserFlagSet</a>()),</div><div class="line">  <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a> (<a class="code" href="classIteratorFilters_1_1UserFlagSet.html">IteratorFilters::UserFlagSet</a>());</div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">begin</a>.set_to_next_positive(tria.begin_active());</div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a> = tria.end();</div><div class="line">n_flagged_cells = std::distance (<a class="code" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">begin</a>, <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a>);</div></div><!-- fragment --><p> 请注意，通过 <code>set_to_next_positive</code> 的调用，第一个有设置用户标志的单元被分配到 <code>begin</code> 迭代器。对于结束迭代器来说，没有必要进行这样的调用，因为过去结束迭代器总是满足所有的谓词。 同样的情况可以通过下面的片段来实现，虽然比较难读。</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">using</span> FI =</div><div class="line">  <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator</a>&gt;;</div><div class="line">n_flagged_cells =</div><div class="line">  std::distance (</div><div class="line">    FI(<a class="code" href="classIteratorFilters_1_1UserFlagSet.html">IteratorFilters::UserFlagSet</a>()).<a class="code" href="classFilteredIterator.html#a2793a746a3c8fd7d005461fa43828dc7">set_to_next_positive</a>(</div><div class="line">      tria.begin_active()),</div><div class="line">    FI(<a class="code" href="classIteratorFilters_1_1UserFlagSet.html">IteratorFilters::UserFlagSet</a>(), tria.end()));</div></div><!-- fragment --><p> 它依赖于这样一个事实：如果我们用一个给定的谓词创建一个未命名的过滤迭代器，但没有迭代器的值，并给它分配关于这个谓词的下一个正值，它就会返回自己，然后作为 <code>std::distance</code> 函数的第一个参数。这个过程对于这里的这个函数的结束元素来说是没有必要的，因为过去的结束迭代器总是满足谓词，所以我们可以在构造函数中直接将这个值分配给过滤的迭代器。 最后，下面的循环只在子域id等于3的单元格上组装矩阵。</em></p>
<p><em></p><div class="fragment"><div class="line"><a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">cell (<a class="code" href="classIteratorFilters_1_1SubdomainEqualTo.html">IteratorFilters::SubdomainEqualTo</a>(3)),</div><div class="line">endc (<a class="code" href="classIteratorFilters_1_1SubdomainEqualTo.html">IteratorFilters::SubdomainEqualTo</a>(3), tria.end());</div><div class="line">cell.<a class="code" href="classFilteredIterator.html#a2793a746a3c8fd7d005461fa43828dc7">set_to_next_positive</a> (tria.begin_active());</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">assemble_local_matrix (cell);</div></div><!-- fragment --><p></em></p>
<p><em>由于定义了过滤和未过滤的迭代器之间的比较，我们也可以让最后一个例子中的 <code>endc</code> 变量为 <a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">Triangulation::active_cell_iterator</a> 类型，因为它是不变的，其值不取决于过滤器。 </em></p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00452">452</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7a3986520a6165a77e5b112049f95864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3986520a6165a77e5b112049f95864">&#9670;&nbsp;</a></span>AccessorType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::<a class="el" href="classFilteredIterator.html#a7a3986520a6165a77e5b112049f95864">AccessorType</a> =  typename BaseIterator::AccessorType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对底层迭代器的访问器类型的类型定义。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00459">459</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abdb7a4cce0c39d3fece3d3f272b06be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb7a4cce0c39d3fece3d3f272b06be8">&#9670;&nbsp;</a></span>FilteredIterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::<a class="el" href="classFilteredIterator.html">FilteredIterator</a> </td>
          <td>(</td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构造函数。将迭代器设置为默认状态并使用给定的谓词来过滤后续的赋值和迭代。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00842">842</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a60d5b3bb5eec9b464ea0ebce290aa610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d5b3bb5eec9b464ea0ebce290aa610">&#9670;&nbsp;</a></span>FilteredIterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::<a class="el" href="classFilteredIterator.html">FilteredIterator</a> </td>
          <td>(</td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>bi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构造函数。使用给定的谓词进行过滤，用给定的值初始化迭代器。 如果初始值 <code>bi</code> 不满足谓词 <code>p</code> ，那么它就会被推进，直到我们碰到过去结束的迭代器，或者谓词被满足。例如，这允许写这样的代码 </p><div class="fragment"><div class="line"><a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename Triangulation&lt;dim&gt;::active_cell_iterator</a>&gt;</div><div class="line">cell (<a class="code" href="classIteratorFilters_1_1SubdomainEqualTo.html">IteratorFilters::SubdomainEqualTo</a>(13),</div><div class="line">      <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.begin_active());</div></div><!-- fragment --><p> 如果单元格 <code>triangulation.begin_active()</code> 没有等于13的subdomain_id，那么迭代器将自动推进到第一个有的单元格。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00850">850</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a5ab7a13002adffd786ae8862c9551d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab7a13002adffd786ae8862c9551d1b">&#9670;&nbsp;</a></span>FilteredIterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::<a class="el" href="classFilteredIterator.html">FilteredIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制构造函数。复制给定参数的谓词和迭代器的值。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00862">862</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af3884629b4542ec8d2e66d0ff0a84b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3884629b4542ec8d2e66d0ff0a84b77">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>赋值运算符。复制参数的迭代器值，但是正如在类的文档中所讨论的，参数的谓词并没有被复制。参数的迭代器值必须满足被赋值对象的谓词，这是在其构造时给出的。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00876">876</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a59726d809ae2f31cf87e234be9dd60bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59726d809ae2f31cf87e234be9dd60bb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>赋值运算符。复制参数的迭代器值，并保留该对象的谓词。给定的迭代器值必须满足分配到的对象的谓词，如在其构造时给出的。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00891">891</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a2793a746a3c8fd7d005461fa43828dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2793a746a3c8fd7d005461fa43828dc7">&#9670;&nbsp;</a></span>set_to_next_positive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::set_to_next_positive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>bi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从 <code>bi</code> 开始搜索下一个满足此对象的谓词的迭代器，并将其分配给此对象。 因为过滤后的迭代器会自动转换为底层的基本迭代器类型，所以你也可以给一个过滤后的迭代器作为这个函数的参数。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00903">903</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a3511a0ed07877e0e40c69492bb2c920e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3511a0ed07877e0e40c69492bb2c920e">&#9670;&nbsp;</a></span>set_to_previous_positive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::set_to_previous_positive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>bi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如上所述，但是从 <code>bi</code> 向后搜索满足此对象谓词的前一个迭代器，并将其分配给此对象。 由于过滤后的迭代器会自动转换为底层的基本迭代器类型，你也可以给一个过滤后的迭代器作为这个函数的参数。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00916">916</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a896a2449c181a18d48ef16d8af3205f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896a2449c181a18d48ef16d8af3205f1">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>比较this和给定对象的基础迭代器值是否相等。 我们不对谓词的平等性进行比较。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00929">929</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a7350af8676cc98cd1114a87afce47891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7350af8676cc98cd1114a87afce47891">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>比较这个对象和给定对象的基本迭代器值是否相等。 此对象的谓词与此操作无关。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00959">959</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a8cb1462542c6f5b1993c13c5af0a04b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb1462542c6f5b1993c13c5af0a04b7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>比较此对象和给定对象的基础迭代器值的不平等。 我们不对谓词的平等性进行比较。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00939">939</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a245437d652fb44642fb34c28545f1de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245437d652fb44642fb34c28545f1de2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>比较此对象的底层迭代器值与给定对象的不平等性。 此对象的谓词与此操作无关。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00968">968</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="abfb790e543dd7713670478462bc77bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb790e543dd7713670478462bc77bf3">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>比较此对象和给定对象的基础迭代器值的排序。 我们不比较谓词。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00949">949</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="af4ff0049dfc58d9df66b09dda7b4ebd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ff0049dfc58d9df66b09dda7b4ebd3">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>比较这个对象和给定对象的底层迭代器值的排序。 此对象的谓词与此操作无关。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00977">977</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="af443c6eaae6bbf6d469d6f9c2bd8d45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af443c6eaae6bbf6d469d6f9c2bd8d45f">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>前缀推进操作：移动到满足前提条件的下一个迭代器值，并返回新的迭代器值。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00985">985</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a631025a97f88c3af83fd197e74955952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631025a97f88c3af83fd197e74955952">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>后缀推进运算符：移动到满足谓词的下一个迭代器值，并返回旧的迭代器值。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00998">998</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a684a24d262a47514fcff64fc3e86c580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684a24d262a47514fcff64fc3e86c580">&#9670;&nbsp;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; &amp; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>前缀递减运算符：移动到满足谓词的前一个迭代器值，并返回新的迭代器值。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01013">1013</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a8b1df9fa9cac3f0c00c27eb692200a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1df9fa9cac3f0c00c27eb692200a03">&#9670;&nbsp;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>后缀进位运算符：移动到满足谓词的前一个迭代器值，并返回旧的迭代器值。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l01026">1026</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<a id="a11fdbe00c6000dba265cb268d68d8050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fdbe00c6000dba265cb268d68d8050">&#9670;&nbsp;</a></span>DeclException1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidElement&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBaseIterator.html">BaseIterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The element &quot;&lt;&lt; arg1&lt;&lt; &quot; with which you want to compare or which you want to&quot;&lt;&lt; &quot; assign from is invalid since it does not satisfy the predicate.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况。 </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab70266a7220e6ff4e3f915e0fb44a4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70266a7220e6ff4e3f915e0fb44a4dd">&#9670;&nbsp;</a></span>make_filtered_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt; make_filtered_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBaseIterator.html">BaseIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给出基础迭代器和谓词，创建一个FilteredIterator类型的对象。 这个函数使创建临时对象（例如作为函数参数）变得简单得多，因为人们不需要明确地用手指定基迭代器的类型。</p>
<ul>
<li>它是在这里自动推导出来的。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00697">697</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af3fa14c68ec8687f259e2bc2c7f69439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fa14c68ec8687f259e2bc2c7f69439">&#9670;&nbsp;</a></span>predicate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;const <a class="el" href="classFilteredIterator_1_1PredicateBase.html">PredicateBase</a>&gt; <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classBaseIterator.html">BaseIterator</a> &gt;::predicate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向一个对象的指针，该对象封装了给与构造函数的谓词的实际数据类型。 </p>

<p class="definition">Definition at line <a class="el" href="filtered__iterator_8h_source.html#l00681">681</a> of file <a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/grid/<a class="el" href="filtered__iterator_8h_source.html">filtered_iterator.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
