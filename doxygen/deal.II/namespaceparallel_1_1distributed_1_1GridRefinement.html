<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceparallel_1_1distributed_1_1GridRefinement.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: parallel::distributed::GridRefinement Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceparallel.html">parallel</a></li><li class="navelem"><a class="el" href="namespaceparallel_1_1distributed.html">distributed</a></li><li class="navelem"><a class="el" href="namespaceparallel_1_1distributed_1_1GridRefinement.html">GridRefinement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">parallel::distributed::GridRefinement Namespace Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa2ffb707a796ae6dedb75036606ef2e6"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , int spacedim&gt; </td></tr>
<tr class="memitem:aa2ffb707a796ae6dedb75036606ef2e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">refine_and_coarsen_fixed_number</a> (<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const ::<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;criteria, const <a class="el" href="classdouble.html">double</a> top_fraction_of_cells, const <a class="el" href="classdouble.html">double</a> bottom_fraction_of_cells, const <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> max_n_cells=std::numeric_limits&lt; <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> &gt;::max())</td></tr>
<tr class="separator:aa2ffb707a796ae6dedb75036606ef2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5159e3207f6786f0749fc0b66ab8ca3"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , int spacedim&gt; </td></tr>
<tr class="memitem:ae5159e3207f6786f0749fc0b66ab8ca3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">refine_and_coarsen_fixed_fraction</a> (<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const ::<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;criteria, const <a class="el" href="classdouble.html">double</a> top_fraction_of_error, const <a class="el" href="classdouble.html">double</a> bottom_fraction_of_error, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a> norm_type=VectorTools::NormType::L1_norm)</td></tr>
<tr class="separator:ae5159e3207f6786f0749fc0b66ab8ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace provides a collection of functions that aid in refinement and coarsening of triangulations. Despite the name of the namespace, the functions do not actually <em>refine</em> the triangulation, but only <em>mark cells for refinement or coarsening</em>. In other words, they perform the "mark" part of the typical "solve-estimate-mark-refine" cycle of the adaptive finite element loop.</p>
<p>In contrast to the functions in namespace <a class="el" href="namespaceGridRefinement.html">GridRefinement</a>, the functions in the current namespace are intended for distributed meshes, i.e., objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa2ffb707a796ae6dedb75036606ef2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ffb707a796ae6dedb75036606ef2e6">&#9670;&nbsp;</a></span>refine_and_coarsen_fixed_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>top_fraction_of_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>bottom_fraction_of_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;</td>
          <td class="paramname"><em>max_n_cells</em> = <code>std::numeric_limits&lt;&#160;<a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">GridRefinement::refine_and_coarsen_fixed_number</a>, but for parallel distributed triangulations.</p>
<p>The vector of criteria needs to be a vector of refinement criteria for all cells active on the current triangulation, i.e., it needs to be of length <code>tria.n_active_cells()</code> (and not <code>tria.n_locally_owned_active_cells()</code>). In other words, the vector needs to include entries for ghost and artificial cells. However, the current function will only look at the indicators that correspond to those cells that are actually locally owned, and ignore the indicators for all other cells. The function will then coordinate among all processors that store part of the triangulation so that at the end a fraction <code>top_fraction_of_cells</code> of all <a class="el" href="classparallel_1_1TriangulationBase.html#a46548d5ed479030dbc75d8fbb2b68d11">Triangulation::n_global_active_cells()</a> active cells are refined, rather than a fraction of the Triangulation::n_locally_active_cells on each processor individually. In other words, it may be that on some processors, no cells are refined at all.</p>
<p>The same is true for the fraction of cells that is coarsened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td>The triangulation whose cells this function is supposed to mark for coarsening and refinement.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">criteria</td><td>The refinement criterion for each mesh cell active on the current triangulation. Entries may not be negative.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_fraction_of_cells</td><td>The fraction of cells to be refined. If this number is zero, no cells will be refined. If it equals one, the result will be flagging for global refinement.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom_fraction_of_cells</td><td>The fraction of cells to be coarsened. If this number is zero, no cells will be coarsened.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_n_cells</td><td>This argument can be used to specify a maximal number of cells. If this number is going to be exceeded upon refinement, then refinement and coarsening fractions are going to be adjusted in an attempt to reach the maximum number of cells. Be aware though that through proliferation of refinement due to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a>, this number is only an indicator. The default value of this argument is to impose no limit on the number of cells. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5159e3207f6786f0749fc0b66ab8ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5159e3207f6786f0749fc0b66ab8ca3">&#9670;&nbsp;</a></span>refine_and_coarsen_fixed_fraction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void parallel::distributed::GridRefinement::refine_and_coarsen_fixed_fraction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>top_fraction_of_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>bottom_fraction_of_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a>&#160;</td>
          <td class="paramname"><em>norm_type</em> = <code>VectorTools::NormType::L1_norm</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">GridRefinement::refine_and_coarsen_fixed_fraction</a>, but for parallel distributed triangulations.</p>
<p>The vector of criteria needs to be a vector of refinement criteria for all cells active on the current triangulation, i.e., it needs to be of length <code>tria.n_active_cells()</code> (and not <code>tria.n_locally_owned_active_cells()</code>). In other words, the vector needs to include entries for ghost and artificial cells. However, the current function will only look at the indicators that correspond to those cells that are actually locally owned, and ignore the indicators for all other cells. The function will then coordinate among all processors that store part of the triangulation so that at the end the smallest fraction of <a class="el" href="classparallel_1_1TriangulationBase.html#a46548d5ed479030dbc75d8fbb2b68d11">Triangulation::n_global_active_cells</a> (not <a class="el" href="classparallel_1_1TriangulationBase.html#a74e904416671ca175093274144e49439">Triangulation::n_locally_owned_active_cells()</a> on each processor individually) is refined that together make up a total of <code>top_fraction_of_error</code> of the total error. In other words, it may be that on some processors, no cells are refined at all.</p>
<p>The same is true for the fraction of cells that is coarsened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td>The triangulation whose cells this function is supposed to mark for coarsening and refinement.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">criteria</td><td>The refinement criterion computed on each mesh cell active on the current triangulation. Entries may not be negative.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_fraction_of_error</td><td>The fraction of the total estimate which should be refined. If this number is zero, no cells will be refined. If it equals one, the result will be flagging for global refinement.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom_fraction_of_error</td><td>The fraction of the estimate coarsened. If this number is zero, no cells will be coarsened.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">norm_type</td><td>To determine thresholds, combined errors on subsets of cells are calculated as norms of the criteria on these cells. Different types of norms can be used for this purpose, from which VectorTools::NormType::L1_norm and VectorTools::NormType::L2_norm are currently supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
