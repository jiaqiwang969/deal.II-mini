<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step-25_8h_source.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: doc/doxygen/tutorial/step-25.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_e68e8157741866f444e17edd764ebbae.html">doc</a></li><li class="navelem"><a class="el" href="dir_04f2ecc425faf0d475a3caf484e551f3.html">doxygen</a></li><li class="navelem"><a class="el" href="dir_7f921e14d817774bc32ca4338fe11225.html">tutorial</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">step-25.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="step-25_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; = 0) <span class="keyword">const</span> <span class="keyword">override</span> </div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160; *     { </div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160; *       <span class="keyword">const</span> <span class="keywordtype">double</span> t = this-&gt;<a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">get_time</a>(); </div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160; * </div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160; *       <span class="keywordflow">switch</span> (dim) </div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160; *         { </div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160; *           <span class="keywordflow">case</span> 1: </div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160; *             { </div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160; *               <span class="keyword">const</span> <span class="keywordtype">double</span> m  = 0.5; </div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160; *               <span class="keyword">const</span> <span class="keywordtype">double</span> c1 = 0.; </div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160; *               <span class="keyword">const</span> <span class="keywordtype">double</span> c2 = 0.; </div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160; *               <span class="keywordflow">return</span> -4. * <a class="code" href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">std::atan</a>(m / std::sqrt(1. - m * m) * </div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160; *                                      std::sin(std::sqrt(1. - m * m) * t + c2) / </div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160; *                                      <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">std::cosh</a>(m * p[0] + c1)); </div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160; *             } </div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160; * </div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160; *           <span class="keywordflow">case</span> 2: </div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160; *             { </div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160; *               <span class="keyword">const</span> <span class="keywordtype">double</span> theta  = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> / 4.; </div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160; *               <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c">lambda</a> = 1.; </div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160; *               <span class="keyword">const</span> <span class="keywordtype">double</span> a0     = 1.; </div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160; *               <span class="keyword">const</span> <span class="keywordtype">double</span> s      = 1.; </div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160; *               <span class="keyword">const</span> <span class="keywordtype">double</span> arg    = p[0] * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta) + </div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160; *                                  <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(theta) * (p[1] * <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">std::cosh</a>(lambda) + </div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160; *                                                     t * <a class="code" href="namespaceDifferentiation_1_1SD.html#a766e4d9bbfe24e99245081947db6a0c7">std::sinh</a>(lambda)); </div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160; *               <span class="keywordflow">return</span> 4. * <a class="code" href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">std::atan</a>(a0 * std::exp(s * arg)); </div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160; *             } </div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160; * </div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160; *           <span class="keywordflow">case</span> 3: </div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160; *             { </div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160; *               <span class="keyword">const</span> <span class="keywordtype">double</span> theta = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> / 4; </div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160; *               <span class="keyword">const</span> <span class="keywordtype">double</span> phi   = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> / 4; </div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160; *               <span class="keyword">const</span> <span class="keywordtype">double</span> tau   = 1.; </div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160; *               <span class="keyword">const</span> <span class="keywordtype">double</span> c0    = 1.; </div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160; *               <span class="keyword">const</span> <span class="keywordtype">double</span> s     = 1.; </div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160; *               <span class="keyword">const</span> <span class="keywordtype">double</span> arg   = p[0] * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta) + </div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160; *                                  p[1] * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(theta) * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(phi) + </div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160; *                                  <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(theta) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(phi) * </div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160; *                                    (p[2] * <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">std::cosh</a>(tau) + t * <a class="code" href="namespaceDifferentiation_1_1SD.html#a766e4d9bbfe24e99245081947db6a0c7">std::sinh</a>(tau)); </div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160; *               <span class="keywordflow">return</span> 4. * <a class="code" href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">std::atan</a>(c0 * std::exp(s * arg)); </div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160; *             } </div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160; * </div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160; *           <span class="keywordflow">default</span>: </div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160; *             <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()); </div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160; *             <span class="keywordflow">return</span> -1e8; </div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160; *         } </div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160; *     } </div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160; *   }; </div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160; * </div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160; * <span class="keyword">@end</span>code</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160; * </div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160; * 在本节的第二部分，我们提供初始条件。我们很懒惰（也很谨慎），不想第二次实现与上面相同的函数。相反，如果我们被查询到初始条件，我们会创建一个对象 &lt;code&gt;ExactSolution&lt;/code&gt; ，将其设置为正确的时间，并让它计算当时的精确解的任何值。</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160; * </div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160; * </div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160; * </div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160; * @code</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160; *   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160; *   <span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; </div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160; *   { </div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160; *   <span class="keyword">public</span>: </div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160; *     InitialValues(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_components = 1, <span class="keyword">const</span> <span class="keywordtype">double</span> time = 0.) </div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160; *       : <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>(<a class="code" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>, <a class="code" href="classFunctionTime.html#a8932e3ec9ed7b6f6d6a91c23f82e36d8">time</a>) </div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160; *     {} </div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160; * </div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160; *     <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p, </div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160; *                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) const override </div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160; *     { </div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160; *       <span class="keywordflow">return</span> ExactSolution&lt;dim&gt;(1, this-&gt;<a class="code" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a>()).<a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(p, component); </div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160; *     } </div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160; *   }; </div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160; * <span class="keyword">@end</span>code</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160; * </div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160; * </div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160; * &lt;a name=<span class="stringliteral">&quot;ImplementationofthecodeSineGordonProblemcodeclass&quot;</span>&gt;&lt;/a&gt; </div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160; * &lt;h3&gt;Implementation of the &lt;code&gt;SineGordonProblem&lt;/code&gt; <span class="keyword">class</span>&lt;/h3&gt;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160; * </div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160; * </div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160; * 让我们继续讨论主类的实现，因为它实现了介绍中概述的算法。</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160; * </div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160; * </div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160; * </div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160; * &lt;a name=<span class="stringliteral">&quot;SineGordonProblemSineGordonProblem&quot;</span>&gt;&lt;/a&gt; </div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160; * &lt;h4&gt;SineGordonProblem::SineGordonProblem&lt;/h4&gt;</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160; * </div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160; * </div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160; * 这是 &lt;code&gt;SineGordonProblem&lt;/code&gt; 类的构造函数。它指定了所需的有限元的多项式程度，关联了一个 &lt;code&gt;<a class="code" href="classDoFHandler.html">DoFHandler</a>&lt;/code&gt; to the &lt;code&gt;<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>&lt;/code&gt; 对象（就像在示例程序 @ref step_3 <span class="stringliteral">&quot;step-3&quot;</span> 和 @ref step_4 <span class="stringliteral">&quot;step-4&quot;</span> 中一样），初始化了当前或初始时间、最终时间、时间步长，以及时间步长方案的 @f$\theta@f$ 值。由于我们在这里计算的解是时间周期性的，所以开始时间的实际值并不重要，我们选择它是为了让我们在一个有趣的时间开始。</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160; * </div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160; * </div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160; * 请注意，如果我们选择显式欧拉时间步进方案（ @f$\theta = 0@f$ ），那么我们必须选择一个时间步进 @f$k \le h@f$ ，否则该方案不稳定，解中可能出现振荡。Crank-Nicolson方案（ @f$\theta = \frac{1}{2}@f$ ）和隐式Euler方案（ @f$\theta=1@f$ ）不存在这个缺陷，因为它们是无条件稳定的。然而，即使如此，时间步长也应选择在 @f$h@f$ 的数量级上，以获得一个好的解决方案。由于我们知道我们的网格是由矩形的均匀细分而来，我们可以很容易地计算出这个时间步长；如果我们有一个不同的域， @ref step_24 <span class="stringliteral">&quot;step-24&quot;</span> 中的技术使用 <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a> 也是可以的。</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160; * </div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160; * </div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160; * </div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160; * @code</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160; *   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160; *   SineGordonProblem&lt;dim&gt;::SineGordonProblem() </div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160; *     : fe(1) </div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160; *     , dof_handler(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>) </div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160; *     , n_global_refinements(6) </div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160; *     , <a class="code" href="classFunctionTime.html#a8932e3ec9ed7b6f6d6a91c23f82e36d8">time</a>(-5.4414) </div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160; *     , final_time(2.7207) </div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160; *     , time_step(10 * 1. / std::pow(2., 1. * n_global_refinements)) </div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160; *     , theta(0.5) </div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160; *     , output_timestep_skip(1) </div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160; *   {} </div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160; * <span class="keyword">@end</span>code</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160; * </div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160; * </div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160; * &lt;a name=<span class="stringliteral">&quot;SineGordonProblemmake_grid_and_dofs&quot;</span>&gt;&lt;/a&gt; </div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160; * &lt;h4&gt;SineGordonProblem::make_grid_and_dofs&lt;/h4&gt;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160; * </div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160; * </div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160; * 这个函数创建了一个 &lt;code&gt;dim&lt;/code&gt; 维度的矩形网格，并对其进行了多次细化。同时，一旦自由度被集合起来， &lt;code&gt;SineGordonProblem&lt;/code&gt; 类的所有矩阵和向量成员都被初始化为相应的大小。像 @ref step_24 <span class="stringliteral">&quot;step-24&quot;</span> 一样，我们使用 &lt;code&gt;<a class="code" href="namespaceMatrixCreator.html">MatrixCreator</a>&lt;/code&gt; 函数来生成质量矩阵 @f$M@f$ 和拉普拉斯矩阵 @f$A@f$ ，并在程序的剩余时间里将它们存储在适当的变量中。</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160; * </div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160; * </div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160; * </div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160; * @code</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160; *   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160; *   <span class="keywordtype">void</span> SineGordonProblem&lt;dim&gt;::make_grid_and_dofs() </div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160; *   { </div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160; *     <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, -10, 10); </div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160; *     <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.refine_global(n_global_refinements); </div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160; * </div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160; *     std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_active_cells() </div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160; *               &lt;&lt; std::endl </div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160; *               &lt;&lt; <span class="stringliteral">&quot;   Total number of cells: &quot;</span> &lt;&lt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.n_cells() </div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160; *               &lt;&lt; std::endl; </div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160; * </div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160; *     dof_handler.distribute_dofs(fe); </div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160; * </div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160; *     std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs() </div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160; *               &lt;&lt; std::endl; </div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160; * </div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160; *     <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs(), dof_handler.n_dofs()); </div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160; *     <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp); </div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160; *     sparsity_pattern.copy_from(dsp); </div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160; * </div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160; *     system_matrix.reinit(sparsity_pattern); </div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160; *     <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(sparsity_pattern); </div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160; *     laplace_matrix.reinit(sparsity_pattern); </div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160; * </div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160; *     <a class="code" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a>(dof_handler, </div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160; *                                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 1), </div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160; *                                       <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>); </div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160; *     <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a>(dof_handler, </div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160; *                                          <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 1), </div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160; *                                          laplace_matrix); </div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160; * </div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160; *     solution.reinit(dof_handler.n_dofs()); </div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160; *     solution_update.reinit(dof_handler.n_dofs()); </div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160; *     old_solution.reinit(dof_handler.n_dofs()); </div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160; *     M_x_velocity.reinit(dof_handler.n_dofs()); </div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160; *     system_rhs.reinit(dof_handler.n_dofs()); </div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160; *   } </div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160; * <span class="keyword">@end</span>code</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160; * </div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160; * </div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160; * &lt;a name=<span class="stringliteral">&quot;SineGordonProblemassemble_system&quot;</span>&gt;&lt;/a&gt; </div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160; * &lt;h4&gt;SineGordonProblem::assemble_system&lt;/h4&gt;</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160; * </div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160; * </div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160; * 这个函数为牛顿方法的每次迭代组装系统矩阵和右手向量。关于系统矩阵和右手边的明确公式，读者应该参考导论。</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160; * </div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160; * </div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160; * 请注意，在每个时间步长中，我们必须把对矩阵和右手边的各种贡献加起来。与 @ref step_23 <span class="stringliteral">&quot;step-23&quot;</span> 和 @ref step_24 <span class="stringliteral">&quot;step-24&quot;</span> 相比，这需要集合更多的项，因为它们取决于前一个时间步骤或前一个非线性步骤的解。我们使用函数 &lt;code&gt;compute_nl_matrix&lt;/code&gt; 和 &lt;code&gt;compute_nl_term&lt;/code&gt; 来做到这一点，而本函数提供了顶层逻辑。</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160; * </div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160; * </div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160; * </div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160; * @code</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160; *   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160; *   <span class="keywordtype">void</span> SineGordonProblem&lt;dim&gt;::assemble_system() </div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160; *   { </div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160; * </div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160; * <span class="keyword">@end</span>code</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160; * </div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160; * 首先我们组装雅各布矩阵 @f$F<span class="stringliteral">&#39;_h(U^{n,l})@f$  ，其中 @f$U^{n,l}@f$ 为方便起见被储存在向量 &lt;code&gt;solution&lt;/code&gt; 中。</span></div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;<span class="stringliteral"> *     system_matrix.copy_from(mass_matrix); </span></div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;<span class="stringliteral"> *     system_matrix.add(std::pow(time_step * theta, 2), laplace_matrix); </span></div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="stringliteral"> *     SparseMatrix&lt;double&gt; tmp_matrix(sparsity_pattern); </span></div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="stringliteral"> *     compute_nl_matrix(old_solution, solution, tmp_matrix); </span></div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;<span class="stringliteral"> *     system_matrix.add(std::pow(time_step * theta, 2), tmp_matrix); </span></div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="stringliteral"> * 接下来我们计算右手边的向量。这只是介绍中对 @f$-F_h(U^{n,l})@f$ 的描述所暗示的矩阵-向量的组合。</span></div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;<span class="stringliteral"> *     system_rhs = 0.; </span></div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;<span class="stringliteral"> *     Vector&lt;double&gt; tmp_vector(solution.size()); </span></div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;<span class="stringliteral"> *     mass_matrix.vmult(system_rhs, solution); </span></div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;<span class="stringliteral"> *     laplace_matrix.vmult(tmp_vector, solution); </span></div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;<span class="stringliteral"> *     system_rhs.add(std::pow(time_step * theta, 2), tmp_vector); </span></div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;<span class="stringliteral"> *     mass_matrix.vmult(tmp_vector, old_solution); </span></div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;<span class="stringliteral"> *     system_rhs.add(-1.0, tmp_vector); </span></div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;<span class="stringliteral"> *     laplace_matrix.vmult(tmp_vector, old_solution); </span></div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;<span class="stringliteral"> *     system_rhs.add(std::pow(time_step, 2) * theta * (1 - theta), tmp_vector); </span></div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;<span class="stringliteral"> *     system_rhs.add(-time_step, M_x_velocity); </span></div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;<span class="stringliteral"> *     compute_nl_term(old_solution, solution, tmp_vector); </span></div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;<span class="stringliteral"> *     system_rhs.add(std::pow(time_step, 2) * theta, tmp_vector); </span></div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;<span class="stringliteral"> *     system_rhs *= -1.; </span></div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="stringliteral"> *   } </span></div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;<span class="stringliteral"> * &lt;a name=&quot;SineGordonProblemcompute_nl_term&quot;&gt;&lt;/a&gt; </span></div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;<span class="stringliteral"> * &lt;h4&gt;SineGordonProblem::compute_nl_term&lt;/h4&gt;</span></div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;<span class="stringliteral"> * 这个函数计算向量 @f$S(\cdot,\cdot)@f$ ，它出现在分裂公式的两个方程的非线性项中。这个函数不仅简化了这个项的重复计算，而且也是我们在时间步长为隐式时使用的非线性迭代求解器的基本组成部分（即 @f$\theta\ne 0@f$  ）。此外，我们必须允许该函数接收一个 &quot;旧 &quot;和一个 &quot;新 &quot;的解决方案作为输入。这些可能不是存储在 &lt;code&gt;old_solution&lt;/code&gt; and &lt;code&gt;solution&lt;/code&gt; 中的问题的实际解决方案，而只是我们线性化的两个函数。为了这个函数的目的，让我们在下面这个类的文档中分别调用前两个参数  @f$w_{\mathrm{old}}@f$  和  @f$w_{\mathrm{new}}@f$  。</span></div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;<span class="stringliteral"> * 作为一个旁注，也许值得研究一下什么阶次的正交公式最适合这种类型的积分。由于 @f$\sin(\cdot)@f$ 不是一个多项式，可能没有正交公式可以准确地积分这些项。通常只需确保右手边的积分达到与离散化方案相同的精度即可，但通过选择更精确的正交公式，也许可以改善渐近收敛声明中的常数。</span></div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;<span class="stringliteral"> *   template &lt;int dim&gt; </span></div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;<span class="stringliteral"> *   void SineGordonProblem&lt;dim&gt;::compute_nl_term(const Vector&lt;double&gt; &amp;old_data, </span></div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;<span class="stringliteral"> *                                                const Vector&lt;double&gt; &amp;new_data, </span></div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;<span class="stringliteral"> *                                                Vector&lt;double&gt; &amp;nl_term) const </span></div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;<span class="stringliteral"> *   { </span></div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;<span class="stringliteral"> *     nl_term = 0; </span></div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;<span class="stringliteral"> *     const QGauss&lt;dim&gt; quadrature_formula(fe.degree + 1); </span></div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;<span class="stringliteral"> *     FEValues&lt;dim&gt;     fe_values(fe, </span></div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;<span class="stringliteral"> *                             quadrature_formula, </span></div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;<span class="stringliteral"> *                             update_values | update_JxW_values | </span></div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;<span class="stringliteral"> *                               update_quadrature_points); </span></div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;<span class="stringliteral"> *     const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); </span></div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;<span class="stringliteral"> *     const unsigned int n_q_points    = quadrature_formula.size(); </span></div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;<span class="stringliteral"> *     Vector&lt;double&gt;                       local_nl_term(dofs_per_cell); </span></div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;<span class="stringliteral"> *     std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell); </span></div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;<span class="stringliteral"> *     std::vector&lt;double&gt;                  old_data_values(n_q_points); </span></div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;<span class="stringliteral"> *     std::vector&lt;double&gt;                  new_data_values(n_q_points); </span></div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;<span class="stringliteral"> *     for (const auto &amp;cell : dof_handler.active_cell_iterators()) </span></div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;<span class="stringliteral"> *       { </span></div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;<span class="stringliteral"> *         local_nl_term = 0; </span></div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;<span class="stringliteral"> * 一旦我们将 &lt;code&gt;FEValues&lt;/code&gt; 实例化重新初始化到当前单元格，我们就利用 &lt;code&gt;get_function_values&lt;/code&gt; 例程来获取 &quot;旧 &quot;数据（大概在 @f$t=t_{n-1}@f$ ）和 &quot;新 &quot;数据（大概在 @f$t=t_n@f$ ）在所选正交公式节点的值。</span></div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;<span class="stringliteral"> *         fe_values.reinit(cell); </span></div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;<span class="stringliteral"> *         fe_values.get_function_values(old_data, old_data_values); </span></div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;<span class="stringliteral"> *         fe_values.get_function_values(new_data, new_data_values); </span></div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;<span class="stringliteral"> * 现在，我们可以用所需的正交公式来评估  @f$\int_K \sin\left[\theta w_{\mathrm{new}} + (1-\theta) w_{\mathrm{old}}\right] \,\varphi_j\,\mathrm{d}x@f$  。</span></div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;<span class="stringliteral"> *         for (unsigned int q_point = 0; q_point &lt; n_q_points; ++q_point) </span></div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;<span class="stringliteral"> *           for (unsigned int i = 0; i &lt; dofs_per_cell; ++i) </span></div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;<span class="stringliteral"> *             local_nl_term(i) += </span></div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;<span class="stringliteral"> *               (std::sin(theta * new_data_values[q_point] + </span></div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;<span class="stringliteral"> *                         (1 - theta) * old_data_values[q_point]) * </span></div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;<span class="stringliteral"> *                fe_values.shape_value(i, q_point) * fe_values.JxW(q_point)); </span></div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;<span class="stringliteral"> * 我们通过将各单元的积分对全局积分的贡献相加来得出结论。</span></div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;<span class="stringliteral"> *         cell-&gt;get_dof_indices(local_dof_indices); </span></div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;<span class="stringliteral"> *         for (unsigned int i = 0; i &lt; dofs_per_cell; ++i) </span></div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;<span class="stringliteral"> *           nl_term(local_dof_indices[i]) += local_nl_term(i); </span></div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;<span class="stringliteral"> *       } </span></div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;<span class="stringliteral"> *   } </span></div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;<span class="stringliteral"> * &lt;a name=&quot;SineGordonProblemcompute_nl_matrix&quot;&gt;&lt;/a&gt; </span></div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;<span class="stringliteral"> * &lt;h4&gt;SineGordonProblem::compute_nl_matrix&lt;/h4&gt;</span></div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;<span class="stringliteral"> * 这是处理非线性方案的第二个函数。它计算矩阵  @f$N(\cdot,\cdot)@f$  ，它出现在  @f$F(\cdot)@f$  的雅各布项的非线性项中。正如 &lt;code&gt;compute_nl_term&lt;/code&gt; 一样，我们必须让这个函数接收一个 &quot;旧 &quot;和一个 &quot;新 &quot;的解决方案作为输入，我们再次将其分别称为 @f$w_{\mathrm{old}}@f$ 和 @f$w_{\mathrm{new}}@f$ ，如下。</span></div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;<span class="stringliteral"> *   template &lt;int dim&gt; </span></div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;<span class="stringliteral"> *   void SineGordonProblem&lt;dim&gt;::compute_nl_matrix( </span></div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;<span class="stringliteral"> *     const Vector&lt;double&gt; &amp;old_data, </span></div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;<span class="stringliteral"> *     const Vector&lt;double&gt; &amp;new_data, </span></div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;<span class="stringliteral"> *     SparseMatrix&lt;double&gt; &amp;nl_matrix) const </span></div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;<span class="stringliteral"> *   { </span></div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;<span class="stringliteral"> *     QGauss&lt;dim&gt;   quadrature_formula(fe.degree + 1); </span></div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;<span class="stringliteral"> *     FEValues&lt;dim&gt; fe_values(fe, </span></div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;<span class="stringliteral"> *                             quadrature_formula, </span></div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;<span class="stringliteral"> *                             update_values | update_JxW_values | </span></div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;<span class="stringliteral"> *                               update_quadrature_points); </span></div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;<span class="stringliteral"> *     const unsigned int dofs_per_cell = fe.n_dofs_per_cell(); </span></div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;<span class="stringliteral"> *     const unsigned int n_q_points    = quadrature_formula.size(); </span></div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;<span class="stringliteral"> *     FullMatrix&lt;double&gt; local_nl_matrix(dofs_per_cell, dofs_per_cell); </span></div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;<span class="stringliteral"> *     std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell); </span></div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;<span class="stringliteral"> *     std::vector&lt;double&gt;                  old_data_values(n_q_points); </span></div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;<span class="stringliteral"> *     std::vector&lt;double&gt;                  new_data_values(n_q_points); </span></div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;<span class="stringliteral"> *     for (const auto &amp;cell : dof_handler.active_cell_iterators()) </span></div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;<span class="stringliteral"> *       { </span></div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;<span class="stringliteral"> *         local_nl_matrix = 0; </span></div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;<span class="stringliteral"> * 同样，首先我们将我们的 &lt;code&gt;FEValues&lt;/code&gt; 实例化重新初始化为当前单元。</span></div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;<span class="stringliteral"> *         fe_values.reinit(cell); </span></div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;<span class="stringliteral"> *         fe_values.get_function_values(old_data, old_data_values); </span></div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;<span class="stringliteral"> *         fe_values.get_function_values(new_data, new_data_values); </span></div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;<span class="stringliteral"> * 然后，我们用所需的正交公式评估 @f$\int_K \cos\left[\theta w_{\mathrm{new}} + (1-\theta) w_{\mathrm{old}}\right]\, \varphi_i\, \varphi_j\,\mathrm{d}x@f$ 。</span></div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;<span class="stringliteral"> *         for (unsigned int q_point = 0; q_point &lt; n_q_points; ++q_point) </span></div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;<span class="stringliteral"> *           for (unsigned int i = 0; i &lt; dofs_per_cell; ++i) </span></div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;<span class="stringliteral"> *             for (unsigned int j = 0; j &lt; dofs_per_cell; ++j) </span></div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;<span class="stringliteral"> *               local_nl_matrix(i, j) += </span></div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;<span class="stringliteral"> *                 (std::cos(theta * new_data_values[q_point] + </span></div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;<span class="stringliteral"> *                           (1 - theta) * old_data_values[q_point]) * </span></div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;<span class="stringliteral"> *                  fe_values.shape_value(i, q_point) * </span></div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;<span class="stringliteral"> *                  fe_values.shape_value(j, q_point) * fe_values.JxW(q_point)); </span></div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;<span class="stringliteral"> * 最后，我们将各单元的积分对全局积分的贡献相加。</span></div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;<span class="stringliteral"> *         cell-&gt;get_dof_indices(local_dof_indices); </span></div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;<span class="stringliteral"> *         for (unsigned int i = 0; i &lt; dofs_per_cell; ++i) </span></div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;<span class="stringliteral"> *           for (unsigned int j = 0; j &lt; dofs_per_cell; ++j) </span></div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;<span class="stringliteral"> *             nl_matrix.add(local_dof_indices[i], </span></div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;<span class="stringliteral"> *                           local_dof_indices[j], </span></div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;<span class="stringliteral"> *                           local_nl_matrix(i, j)); </span></div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;<span class="stringliteral"> *       } </span></div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;<span class="stringliteral"> *   } </span></div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;<span class="stringliteral"> * &lt;a name=&quot;SineGordonProblemsolve&quot;&gt;&lt;/a&gt; </span></div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;<span class="stringliteral"> * &lt;h4&gt;SineGordonProblem::solve&lt;/h4&gt;</span></div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;<span class="stringliteral"> * 正如在介绍中所讨论的，这个函数在线性方程组上使用CG迭代求解器，该方程组是由牛顿方法的每个迭代的有限元空间离散化产生的，用于分割公式中的（非线性）第一个方程。该系统的解实际上是 @f$\delta U^{n,l}@f$ ，所以它被存储在 &lt;code&gt;solution_update&lt;/code&gt; and used to update &lt;code&gt;solution&lt;/code&gt; 的 &lt;code&gt;run&lt;/code&gt; 函数中。</span></div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;<span class="stringliteral"> * 注意，我们在求解前将解的更新值重新设置为零。这是没有必要的：迭代求解器可以从任何一点开始并收敛到正确的解。如果对线性系统的解有一个很好的估计，那么从这个向量开始可能是值得的，但是作为一个一般的观察，起点并不是很重要：它必须是一个非常非常好的猜测，以减少超过几个迭代的次数。事实证明，对于这个问题，使用之前的非线性更新作为起点实际上会损害收敛性并增加所需的迭代次数，所以我们简单地将其设置为零。</span></div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;<span class="stringliteral"> * 该函数返回收敛到一个解决方案所需的迭代次数。这个数字以后将被用来在屏幕上生成输出，显示每次非线性迭代需要多少次迭代。</span></div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;<span class="stringliteral"> *   template &lt;int dim&gt; </span></div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;<span class="stringliteral"> *   unsigned int SineGordonProblem&lt;dim&gt;::solve() </span></div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;<span class="stringliteral"> *   { </span></div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;<span class="stringliteral"> *     SolverControl            solver_control(1000, 1e-12 * system_rhs.l2_norm()); </span></div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;<span class="stringliteral"> *     SolverCG&lt;Vector&lt;double&gt;&gt; cg(solver_control); </span></div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;<span class="stringliteral"> *     PreconditionSSOR&lt;SparseMatrix&lt;double&gt;&gt; preconditioner; </span></div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;<span class="stringliteral"> *     preconditioner.initialize(system_matrix, 1.2); </span></div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;<span class="stringliteral"> *     cg.solve(system_matrix, solution_update, system_rhs, preconditioner); </span></div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;<span class="stringliteral"> *     return solver_control.last_step(); </span></div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;<span class="stringliteral"> *   } </span></div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;<span class="stringliteral"> * &lt;a name=&quot;SineGordonProblemoutput_results&quot;&gt;&lt;/a&gt; </span></div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;<span class="stringliteral"> * &lt;h4&gt;SineGordonProblem::output_results&lt;/h4&gt;</span></div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;<span class="stringliteral"> * 这个函数将结果输出到一个文件。它与  @ref step_23 &quot;step-23&quot;  和  @ref step_24 &quot;step-24&quot;  中的相应函数基本相同。</span></div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;<span class="stringliteral"> *   template &lt;int dim&gt; </span></div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;<span class="stringliteral"> *   void SineGordonProblem&lt;dim&gt;::output_results( </span></div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;<span class="stringliteral"> *     const unsigned int timestep_number) const </span></div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;<span class="stringliteral"> *   { </span></div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;<span class="stringliteral"> *     DataOut&lt;dim&gt; data_out; </span></div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;<span class="stringliteral"> *     data_out.attach_dof_handler(dof_handler); </span></div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;<span class="stringliteral"> *     data_out.add_data_vector(solution, &quot;u&quot;); </span></div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;<span class="stringliteral"> *     data_out.build_patches(); </span></div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;<span class="stringliteral"> *     const std::string filename = </span></div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;<span class="stringliteral"> *       &quot;solution-&quot; + Utilities::int_to_string(timestep_number, 3) + &quot;.vtu&quot;; </span></div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;<span class="stringliteral"> *     DataOutBase::VtkFlags vtk_flags; </span></div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;<span class="stringliteral"> *     vtk_flags.compression_level = </span></div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;<span class="stringliteral"> *       DataOutBase::VtkFlags::ZlibCompressionLevel::best_speed; </span></div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;<span class="stringliteral"> *     data_out.set_flags(vtk_flags); </span></div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;<span class="stringliteral"> *     std::ofstream output(filename); </span></div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="stringliteral"> *     data_out.write_vtu(output); </span></div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;<span class="stringliteral"> *   } </span></div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="stringliteral"> * &lt;a name=&quot;SineGordonProblemrun&quot;&gt;&lt;/a&gt; </span></div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;<span class="stringliteral"> * &lt;h4&gt;SineGordonProblem::run&lt;/h4&gt;</span></div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;<span class="stringliteral"> * 这个函数对一切都有最高级别的控制：它运行（外部）时间步长循环，（内部）非线性求解器循环，并在每个时间步长后输出解。</span></div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;<span class="stringliteral"> *   template &lt;int dim&gt; </span></div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;<span class="stringliteral"> *   void SineGordonProblem&lt;dim&gt;::run() </span></div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;<span class="stringliteral"> *   { </span></div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;<span class="stringliteral"> *     make_grid_and_dofs(); </span></div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;<span class="stringliteral"> * 为了确认初始条件，我们必须使用函数  @f$u_0(x)@f$  来计算  @f$U^0@f$  。为此，下面我们将创建一个 &lt;code&gt;InitialValues&lt;/code&gt; 类型的对象；注意，当我们创建这个对象（它来自 &lt;code&gt;Function&lt;/code&gt; 类）时，我们将其内部的时间变量设置为 @f$t_0@f$ ，以表明初始条件是在 @f$t=t_0@f$ 处评估的空间和时间的函数。</span></div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;<span class="stringliteral"> * 然后我们通过使用 &lt;code&gt;VectorTools::project&lt;/code&gt; 将 @f$u_0(x)@f$ 投影到网格上，产生 @f$U^0@f$ 。我们必须使用与 @ref step_21 &quot;step-21&quot; 相同的悬挂节点约束结构： VectorTools::project 函数需要一个悬挂节点约束对象，但为了使用它，我们首先需要关闭它。</span></div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;<span class="stringliteral"> *     { </span></div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;<span class="stringliteral"> *       AffineConstraints&lt;double&gt; constraints; </span></div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;<span class="stringliteral"> *       constraints.close(); </span></div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;<span class="stringliteral"> *       VectorTools::project(dof_handler, </span></div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;<span class="stringliteral"> *                            constraints, </span></div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;<span class="stringliteral"> *                            QGauss&lt;dim&gt;(fe.degree + 1), </span></div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;<span class="stringliteral"> *                            InitialValues&lt;dim&gt;(1, time), </span></div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;<span class="stringliteral"> *                            solution); </span></div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;<span class="stringliteral"> *     } </span></div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;<span class="stringliteral"> * 为了完整起见，我们像其他时间步长一样，将第2个时间步长输出到一个文件。</span></div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;<span class="stringliteral"> *     output_results(0); </span></div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;<span class="stringliteral"> * 现在我们进行时间步进：在每个时间步进中，我们解决与问题的有限元离散化相对应的矩阵方程，然后根据我们在介绍中讨论的时间步进公式推进我们的解决方案。</span></div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;<span class="stringliteral"> *     unsigned int timestep_number = 1; </span></div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;<span class="stringliteral"> *     for (time += time_step; time &lt;= final_time; </span></div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;<span class="stringliteral"> *          time += time_step, ++timestep_number) </span></div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;<span class="stringliteral"> *       { </span></div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;<span class="stringliteral"> *         old_solution = solution; </span></div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;<span class="stringliteral"> *         std::cout &lt;&lt; std::endl </span></div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;<span class="stringliteral"> *                   &lt;&lt; &quot;Time step #&quot; &lt;&lt; timestep_number &lt;&lt; &quot;; &quot; </span></div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;<span class="stringliteral"> *                   &lt;&lt; &quot;advancing to t = &quot; &lt;&lt; time &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; </span></div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;<span class="stringliteral"> * 在每个时间步长的开始，我们必须通过牛顿方法求解拆分公式中的非线性方程---即先求解 @f$\delta U^{n,l}@f$ ，然后再计算 @f$U^{n,l+1}@f$ ，如此反复。这种非线性迭代的停止标准是： @f$\|F_h(U^{n,l})\|_2 \le 10^{-6} \|F_h(U^{n,0})\|_2@f$  。因此，我们需要记录第一次迭代中残差的规范。</span></div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;<span class="stringliteral"> * 在每次迭代结束时，我们向控制台输出我们花了多少次线性求解器的迭代。当下面的循环完成后，我们有（一个近似的） @f$U^n@f$  。</span></div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;<span class="stringliteral"> *         double initial_rhs_norm = 0.; </span></div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;<span class="stringliteral"> *         bool   first_iteration  = true; </span></div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;<span class="stringliteral"> *         do </span></div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;<span class="stringliteral"> *           { </span></div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;<span class="stringliteral"> *             assemble_system(); </span></div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;<span class="stringliteral"> *             if (first_iteration == true) </span></div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;<span class="stringliteral"> *               initial_rhs_norm = system_rhs.l2_norm(); </span></div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;<span class="stringliteral"> *             const unsigned int n_iterations = solve(); </span></div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;<span class="stringliteral"> *             solution += solution_update; </span></div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;<span class="stringliteral"> *             if (first_iteration == true) </span></div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;<span class="stringliteral"> *               std::cout &lt;&lt; &quot;    &quot; &lt;&lt; n_iterations; </span></div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;<span class="stringliteral"> *             else </span></div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;<span class="stringliteral"> *               std::cout &lt;&lt; &#39;</span>+<span class="stringliteral">&#39; &lt;&lt; n_iterations; </span></div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;<span class="stringliteral"> *             first_iteration = false; </span></div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;<span class="stringliteral"> *           } </span></div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;<span class="stringliteral"> *         while (system_rhs.l2_norm() &gt; 1e-6 * initial_rhs_norm); </span></div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;<span class="stringliteral"> *         std::cout &lt;&lt; &quot; CG iterations per nonlinear step.&quot; &lt;&lt; std::endl; </span></div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;<span class="stringliteral"> * 在得到问题的第一个方程 @f$t=t_n@f$ 的解后，我们必须更新辅助速度变量  @f$V^n@f$  。然而，我们不计算和存储 @f$V^n@f$ ，因为它不是我们在问题中直接使用的数量。因此，为了简单起见，我们直接更新 @f$MV^n@f$ 。</span></div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;<span class="stringliteral"> *         Vector&lt;double&gt; tmp_vector(solution.size()); </span></div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;<span class="stringliteral"> *         laplace_matrix.vmult(tmp_vector, solution); </span></div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;<span class="stringliteral"> *         M_x_velocity.add(-time_step * theta, tmp_vector); </span></div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;<span class="stringliteral"> *         laplace_matrix.vmult(tmp_vector, old_solution); </span></div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;<span class="stringliteral"> *         M_x_velocity.add(-time_step * (1 - theta), tmp_vector); </span></div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;<span class="stringliteral"> *         compute_nl_term(old_solution, solution, tmp_vector); </span></div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;<span class="stringliteral"> *         M_x_velocity.add(-time_step, tmp_vector); </span></div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;<span class="stringliteral"> * 很多时候，特别是对于细网格，我们必须选择相当小的时间步长，以使方案稳定。因此，有很多时间步长，在解的过程中 &quot;没有什么有趣的事情发生&quot;。为了提高整体效率--特别是加快程序速度和节省磁盘空间--我们每隔 &lt;code&gt;output_timestep_skip&lt;/code&gt; 个时间步数才输出解。</span></div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;<span class="stringliteral"> *         if (timestep_number % output_timestep_skip == 0) </span></div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;<span class="stringliteral"> *           output_results(timestep_number); </span></div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;<span class="stringliteral"> *       } </span></div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;<span class="stringliteral"> *   } </span></div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;<span class="stringliteral"> * } // namespace Step25 </span></div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;<span class="stringliteral"> * &lt;a name=&quot;Thecodemaincodefunction&quot;&gt;&lt;/a&gt; </span></div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;<span class="stringliteral"> * &lt;h3&gt;The &lt;code&gt;main&lt;/code&gt; function&lt;/h3&gt;</span></div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;<span class="stringliteral"> * 这是该程序的主函数。它创建一个顶层类的对象并调用其主函数。如果在执行 &lt;code&gt;SineGordonProblem&lt;/code&gt; 类的运行方法时抛出了异常，我们会在这里捕获并报告它们。关于异常的更多信息，读者应该参考  @ref step_6 &quot;step-6&quot;  。</span></div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;<span class="stringliteral"> * @code</span></div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;<span class="stringliteral"> * int main() </span></div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;<span class="stringliteral"> * { </span></div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;<span class="stringliteral"> *   try </span></div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;<span class="stringliteral"> *     { </span></div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;<span class="stringliteral"> *       using namespace Step25; </span></div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;<span class="stringliteral"> *       SineGordonProblem&lt;1&gt; sg_problem; </span></div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;<span class="stringliteral"> *       sg_problem.run(); </span></div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;<span class="stringliteral"> *     } </span></div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;<span class="stringliteral"> *   catch (std::exception &amp;exc) </span></div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;<span class="stringliteral"> *     { </span></div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;<span class="stringliteral"> *       std::cerr &lt;&lt; std::endl </span></div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;<span class="stringliteral"> *                 &lt;&lt; std::endl </span></div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;<span class="stringliteral"> *                 &lt;&lt; &quot;----------------------------------------------------&quot; </span></div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;<span class="stringliteral"> *                 &lt;&lt; std::endl; </span></div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;<span class="stringliteral"> *       std::cerr &lt;&lt; &quot;Exception on processing: &quot; &lt;&lt; std::endl </span></div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;<span class="stringliteral"> *                 &lt;&lt; exc.what() &lt;&lt; std::endl </span></div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;<span class="stringliteral"> *                 &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl </span></div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;<span class="stringliteral"> *                 &lt;&lt; &quot;----------------------------------------------------&quot; </span></div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;<span class="stringliteral"> *                 &lt;&lt; std::endl; </span></div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;<span class="stringliteral"> *       return 1; </span></div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;<span class="stringliteral"> *     } </span></div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;<span class="stringliteral"> *   catch (...) </span></div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;<span class="stringliteral"> *     { </span></div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;<span class="stringliteral"> *       std::cerr &lt;&lt; std::endl </span></div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;<span class="stringliteral"> *                 &lt;&lt; std::endl </span></div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;<span class="stringliteral"> *                 &lt;&lt; &quot;----------------------------------------------------&quot; </span></div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;<span class="stringliteral"> *                 &lt;&lt; std::endl; </span></div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;<span class="stringliteral"> *       std::cerr &lt;&lt; &quot;Unknown exception!&quot; &lt;&lt; std::endl </span></div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;<span class="stringliteral"> *                 &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl </span></div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;<span class="stringliteral"> *                 &lt;&lt; &quot;----------------------------------------------------&quot; </span></div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;<span class="stringliteral"> *                 &lt;&lt; std::endl; </span></div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;<span class="stringliteral"> *       return 1; </span></div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;<span class="stringliteral"> *     } </span></div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;<span class="stringliteral"> *   return 0; </span></div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;<span class="stringliteral"> * } </span></div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;<span class="stringliteral"> * </span></div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;<span class="stringliteral"> * @endcode</span></div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;<span class="stringliteral">examples/step-25/doc/results.dox</span></div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;<span class="stringliteral">&lt;a name=&quot;Results&quot;&gt;&lt;/a&gt;&lt;h1&gt;Results&lt;/h1&gt;显式欧拉时间步长方案（ @f$\theta=0@f$ ）对于我们希望解决的问题来说表现得很充分。不幸的是，由于稳定性问题，必须选择一个相当小的时间步长 ----  @f$k\sim h/10@f$ 似乎对我们进行的大多数模拟都有效。另一方面，Crank-Nicolson方案（ @f$\theta=\frac{1}{2}@f$ ）是无条件稳定的，而且（至少对于一维呼吸器的情况）我们可以选择大到 @f$25h@f$ 的时间步长而不对解决方案产生任何不良影响。隐式欧拉方案（ @f$\theta=1@f$ ）是 &quot;指数阻尼 &quot;的，所以它不是解决正弦戈登方程的好选择，因为它是保守的。然而， @f$\theta@f$ 方法提供的连续体中的一些阻尼方案对于消除边界效应引起的虚假振荡很有用。</span></div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;<span class="stringliteral">在下面的模拟中，我们在一维的区间 @f$\Omega =</span></div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;<span class="stringliteral">[-10,10]@f$ 和二维的正方形 @f$\Omega = [-10,10]\times [-10,10]@f$ 上解决正弦-戈登方程。在每种情况下，各自的网格被均匀地细化了6次，即 @f$h\sim</span></div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;<span class="stringliteral">2^{-6}@f$  。</span></div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;<span class="stringliteral">&lt;a name=&quot;An11dSolution&quot;&gt;&lt;/a&gt;&lt;h3&gt;An (1+1)-d Solution&lt;/h3&gt; 我们讨论的第一个例子是正弦-戈登方程的所谓一维（静止的）呼吸器解。正如介绍中提到的，呼吸器有如下闭合形式的表达。</span></div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;<span class="stringliteral">\f[</span></div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;<span class="stringliteral">u_{\mathrm{breather}}(x,t) = -4\arctan \left(\frac{m}{\sqrt{1-m^2}} \frac{\sin\left(\sqrt{1-m^2}t +c_2\right)}{\cosh(mx+c_1)} \right),</span></div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;<span class="stringliteral">\f] 其中 @f$c_1@f$  ,  @f$c_2@f$  和  @f$m&lt;1@f$  是常数。在下面的模拟中，我们选择了  @f$c_1=0@f$  ,  @f$c_2=0@f$  ,  @f$m=0.5@f$  。此外，我们知道呼吸器的振荡周期是 @f$2\pi\sqrt{1-m^2}@f$ ，因此我们选择 @f$t_0=-5.4414@f$ 和 @f$t_f=2.7207@f$ ，这样我们可以观察到解决方案的三次振荡。然后，取 @f$u_0(x) = u_{\mathrm{breather}}(x,t_0)@f$ 、 @f$\theta=0@f$ 和 @f$k=h/10@f$ ，程序计算出以下解。</span></div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;<span class="stringliteral"> &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-25.1d-breather.gif&quot; alt=&quot;Animation of the 1D stationary breather.&quot;&gt; </span></div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;<span class="stringliteral">虽然程序中没有显示如何做，但另一种可视化(1+1)-d解决方案的方法是使用DataOutStack类产生的输出；它允许 &quot;堆叠 &quot;单个时间步骤的解决方案，因此我们从一维时间相关的解决方案中得到二维时空图。这就产生了下面的时空图，而不是上面的动画。</span></div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;<span class="stringliteral"> &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-25.1d-breather_stp.png&quot; alt=&quot;A space-time plot of the 1D stationary breather.&quot;&gt; </span></div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;<span class="stringliteral">此外，由于呼吸器是正弦-戈登方程的分析解，我们可以用它来验证我们的代码，尽管我们必须假设我们选择的诺伊曼边界条件引入的误差与数值误差相比是很小的。在这种假设下，可以使用 VectorTools::integrate_difference 函数来计算数值解和本程序的 &lt;code&gt;ExactSolution&lt;/code&gt; 类描述的函数之间的差异。对于上面两幅图所示的模拟，每个时间步长的有限元解的 @f$L^2@f$ 误差的规范保持在 @f$10^{-2}@f$ 的数量级。因此，我们可以得出结论，数值方法在程序中得到了正确的实现。</span></div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;<span class="stringliteral">&lt;a name=&quot;Afew21DSolutions&quot;&gt;&lt;/a&gt;&lt;h3&gt;A few (2+1)D Solutions&lt;/h3&gt;</span></div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;<span class="stringliteral">在文献中可以找到的正弦戈登方程在(2+1)D中的唯一分析解是所谓的Kink孤波。它有以下的闭合式表达。   @f[</span></div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;<span class="stringliteral">    u(x,y,t) = 4 \arctan \left[a_0 e^{s\xi}\right]</span></div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;<span class="stringliteral">  @f]</span></div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;<span class="stringliteral">与@f[</span></div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;<span class="stringliteral">    \xi = x \cos\vartheta + \sin(\vartheta) (y\cosh\lambda + t\sinh \lambda)</span></div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;<span class="stringliteral">  @f]</span></div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;<span class="stringliteral">其中 @f$a_0@f$ 、 @f$\vartheta@f$ 和 @f$\lambda@f$ 为常数。在下面的模拟中，我们选择了 @f$a_0=\lambda=1@f$  。请注意，如果 @f$\vartheta=\pi@f$ 是静止的，那么它将是一个很好的解决方案，我们可以用它来验证二维的程序，因为没有发生域边界的反射。</span></div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;<span class="stringliteral">下面显示的模拟是用 @f$u_0(x) = u_{\mathrm{kink}}(x,t_0)@f$ 、 @f$\theta=\frac{1}{2}@f$ 、 @f$k=20h@f$ 、 @f$t_0=1@f$ 和 @f$t_f=500@f$ 进行的。每个时间步长的有限元解的误差的 @f$L^2@f$ 准则保持在 @f$10^{-2}@f$ 的数量级上，表明该程序在二维和一维中都能正常工作。不幸的是，这个解决方案并不十分有趣，不过为了完整起见，我们还是在下面附上了它的快照。</span></div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;<span class="stringliteral"> &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-25.2d-kink.png&quot; alt=&quot;Stationary 2D kink.&quot;&gt; </span></div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;<span class="stringliteral">现在我们已经在一维和二维中验证了代码，我们转到一个分析解未知的问题。</span></div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;<span class="stringliteral">为此，我们围绕 @f$z@f$ 轴旋转上面讨论的扭结解：我们让 @f$\vartheta=\frac{\pi}{4}@f$  .后者的结果是一个不与网格对齐的孤波，所以反射立即发生在域的边界。对于下面所示的模拟，我们采取了 @f$u_0(x)=u_{\mathrm{kink}}(x,t_0)@f$ 、 @f$\theta=\frac{2}{3}@f$ 、 @f$k=20h@f$ 、 @f$t_0=0@f$ 和 @f$t_f=20@f$  。此外，我们不得不选择 @f$\theta=\frac{2}{3}@f$ ，因为对于任何 @f$\theta\le\frac{1}{2}@f$ 的边界都会产生振荡，这可能是由于方案而不是方程造成的，因此选择 @f$\theta@f$ 的值，在时间步进方案的 &quot;指数阻尼 &quot;频谱中，确保这些振荡不会被产生。</span></div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;<span class="stringliteral"> &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-25.2d-angled_kink.gif&quot; alt=&quot;Animation of a moving 2D kink, at 45 degrees to the axes of the grid, showing boundary effects.&quot;&gt; </span></div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;<span class="stringliteral">正弦-戈登方程的另一个有趣的解决方案（不能通过分析获得）可以通过使用两个一维呼吸器来构建以下可分离的二维初始条件来产生。</span></div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;<span class="stringliteral">\f[</span></div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;<span class="stringliteral">  u_0(x) =</span></div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;<span class="stringliteral">  u_{\mathrm{pseudobreather}}(x,t_0) =</span></div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;<span class="stringliteral">  16\arctan \left(</span></div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;<span class="stringliteral">    \frac{m}{\sqrt{1-m^2}}</span></div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;<span class="stringliteral">    \frac{\sin\left(\sqrt{1-m^2}t_0\right)}{\cosh(mx_1)} \right)</span></div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;<span class="stringliteral">  \arctan \left(</span></div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;<span class="stringliteral">    \frac{m}{\sqrt{1-m^2}}</span></div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;<span class="stringliteral">    \frac{\sin\left(\sqrt{1-m^2}t_0\right)}{\cosh(mx_2)} \right),</span></div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;<span class="stringliteral">\f] 其中 @f$x=(x_1,x_2)\in{R}^2@f$  ,  @f$m=0.5&lt;1@f$  与我们上面讨论的一维情况一样。在下面的模拟中，我们选择了 @f$\theta=\frac{1}{2}@f$ 、 @f$k=10h@f$ 、 @f$t_0=-5.4414@f$ 和 @f$t_f=2.7207@f$ 。解决方案是相当有趣的</span></div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;<span class="stringliteral"> &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-25.2d-pseudobreather.gif&quot; alt=&quot;Animation of a 2D pseudobreather.&quot;&gt; </span></div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;<span class="stringliteral">&lt;a name=&quot;extensions&quot;&gt;&lt;/a&gt;</span></div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;<span class="stringliteral">&lt;a name=&quot;Possibilitiesforextensions&quot;&gt;&lt;/a&gt;&lt;h3&gt;Possibilities for extensions&lt;/h3&gt;</span></div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;<span class="stringliteral">改变初始条件是有意义的。大多数选择不会导致保持局部的解决方案（在孤子界，这样的解决方案被称为 &quot;静止的&quot;，尽管解决方案确实随时间变化），而是导致方程的波状特征占主导地位的解决方案，并且波从局部初始条件的位置传播出去。例如，值得玩一玩 &lt;code&gt;InitialValues&lt;/code&gt; 类，把对 &lt;code&gt;ExactSolution&lt;/code&gt; 类的调用换成类似这样的函数。</span></div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;<span class="stringliteral">@f[</span></div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;<span class="stringliteral">  u_0(x,y) = \cos\left(\frac x2\right)\cos\left(\frac y2\right)</span></div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;<span class="stringliteral">@f]</span></div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;<span class="stringliteral">如果 @f$|x|,|y|\le \frac\pi 2@f$ ，和 @f$u_0(x,y)=0@f$ 在这个区域之外。</span></div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;<span class="stringliteral">第二个方面是研究该方案是否是能量保持的。对于 @ref</span></div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;<span class="stringliteral">step_23 &quot;step-23 &quot;中讨论的纯波方程，如果我们选择时间步进参数，使我们得到Crank-Nicolson方案，情况就是这样。我们可以在这里做类似的事情，注意到正弦-戈登解中的能量被定义为</span></div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;<span class="stringliteral">@f[</span></div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;<span class="stringliteral">  E(t) = \frac 12 \int_\Omega \left(\frac{\partial u}{\partial</span></div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;<span class="stringliteral">  t}\right)^2</span></div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;<span class="stringliteral">  + \left(\nabla u\right)^2 + 2 (1-\cos u) \; dx.</span></div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;<span class="stringliteral">@f]</span></div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;<span class="stringliteral">(我们在公式中使用 @f$1-\cos u@f$ 而不是 @f$-\cos u@f$ ，以确保对能量的所有贡献都是正的，从而使衰变的解在无界域上具有有限的能量。)</span></div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;<span class="stringliteral">除此以外，还有两个明显的领域。</span></div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;<span class="stringliteral">- 显然，自适应性（即时间自适应网格）会对这样的问题产生兴趣。它们的复杂性导致我们再次将其排除在本方案之外，尽管 @ref step_23 &quot;step-23 &quot;介绍中的一般评论仍然正确。</span></div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;<span class="stringliteral">- 解决这个问题的更快方案。虽然今天的计算机已经足够快，可以在不长的时间内解决二维甚至三维静止的问题，但与时间相关的问题则是完全不同的一类问题。我们在步骤48中讨论了这个问题，我们展示了如何在不组装或倒置任何矩阵的情况下并行解决这个问题。</span></div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;<span class="stringliteral"> *</span></div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;<span class="stringliteral"> *</span></div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;<span class="stringliteral">&lt;a name=&quot;PlainProg&quot;&gt;&lt;/a&gt;</span></div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;<span class="stringliteral">&lt;h1&gt; The plain program&lt;/h1&gt;</span></div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;<span class="stringliteral">@include &quot;step-25.cc&quot;</span></div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;<span class="stringliteral">*/</span></div><div class="ttc" id="vectorization_8h_html_a11c48f86a4f2adf21555e64049ecde8c"><div class="ttname"><a href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a></div><div class="ttdeci">inline ::VectorizedArray&lt; Number, width &gt; cos(const ::VectorizedArray&lt; Number, width &gt; &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="vectorization_8h_source.html#l05359">vectorization.h:5359</a></div></div>
<div class="ttc" id="classFunction_html"><div class="ttname"><a href="classFunction.html">Function</a></div><div class="ttdef"><b>Definition:</b> <a href="function_8h_source.html#l00116">function.h:116</a></div></div>
<div class="ttc" id="namespaceDifferentiation_1_1SD_html_a26c1f7a69dc8ac2e16144493d3b3b896"><div class="ttname"><a href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">Differentiation::SD::cosh</a></div><div class="ttdeci">Expression cosh(const Expression &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="symengine__math_8cc_source.html#l00189">symengine_math.cc:189</a></div></div>
<div class="ttc" id="classFunction_html_a7248c7e11dc434fb7d16cdc5e41e3770"><div class="ttname"><a href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">Function::n_components</a></div><div class="ttdeci">const unsigned int n_components</div><div class="ttdef"><b>Definition:</b> <a href="function_8h_source.html#l00132">function.h:132</a></div></div>
<div class="ttc" id="namespaceMatrixCreator_html_a7b8157122064151d414dc34a22a3ca9c"><div class="ttname"><a href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixCreator::create_laplace_matrix</a></div><div class="ttdeci">void create_laplace_matrix(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const Quadrature&lt; dim &gt; &amp;q, SparseMatrix&lt; double &gt; &amp;matrix, const Function&lt; spacedim &gt; *const a=nullptr, const AffineConstraints&lt; double &gt; &amp;constraints=AffineConstraints&lt; double &gt;())</div></div>
<div class="ttc" id="classDynamicSparsityPattern_html"><div class="ttname"><a href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="dynamic__sparsity__pattern_8h_source.html#l00296">dynamic_sparsity_pattern.h:296</a></div></div>
<div class="ttc" id="namespaceDifferentiation_1_1SD_html_a766e4d9bbfe24e99245081947db6a0c7"><div class="ttname"><a href="namespaceDifferentiation_1_1SD.html#a766e4d9bbfe24e99245081947db6a0c7">Differentiation::SD::sinh</a></div><div class="ttdeci">Expression sinh(const Expression &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="symengine__math_8cc_source.html#l00182">symengine_math.cc:182</a></div></div>
<div class="ttc" id="namespaceMatrixCreator_html"><div class="ttname"><a href="namespaceMatrixCreator.html">MatrixCreator</a></div><div class="ttdef"><b>Definition:</b> <a href="matrix__tools_8h_source.html#l00164">matrix_tools.h:164</a></div></div>
<div class="ttc" id="namespaceDifferentiation_1_1SD_html_a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c"><div class="ttname"><a href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c">Differentiation::SD::OptimizerType::lambda</a></div></div>
<div class="ttc" id="classPoint_html"><div class="ttname"><a href="classPoint.html">Point&lt; dim &gt;</a></div></div>
<div class="ttc" id="classFunctionTime_html_a8932e3ec9ed7b6f6d6a91c23f82e36d8"><div class="ttname"><a href="classFunctionTime.html#a8932e3ec9ed7b6f6d6a91c23f82e36d8">FunctionTime&lt; numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt;::time</a></div><div class="ttdeci">numbers::NumberTraits&lt; RangeNumberType &gt;::real_type time</div><div class="ttdef"><b>Definition:</b> <a href="function__time_8h_source.html#l00092">function_time.h:92</a></div></div>
<div class="ttc" id="namespaceGridTools_html_a47c293eff2ec7ce4b90ba08b35d1f2e2"><div class="ttname"><a href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a></div><div class="ttdeci">double minimal_cell_diameter(const Triangulation&lt; dim, spacedim &gt; &amp;triangulation, const Mapping&lt; dim, spacedim &gt; &amp;mapping=(ReferenceCells::get_hypercube&lt; dim &gt;() .template get_default_linear_mapping&lt; dim, spacedim &gt;()))</div><div class="ttdef"><b>Definition:</b> <a href="grid__tools_8cc_source.html#l04309">grid_tools.cc:4309</a></div></div>
<div class="ttc" id="classQGauss_html"><div class="ttname"><a href="classQGauss.html">QGauss</a></div><div class="ttdef"><b>Definition:</b> <a href="quadrature__lib_8h_source.html#l00039">quadrature_lib.h:39</a></div></div>
<div class="ttc" id="namespaceLocalIntegrators_1_1L2_html_a1c15243765304a803037988b5561627d"><div class="ttname"><a href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">LocalIntegrators::L2::mass_matrix</a></div><div class="ttdeci">void mass_matrix(FullMatrix&lt; double &gt; &amp;M, const FEValuesBase&lt; dim &gt; &amp;fe, const double factor=1.)</div><div class="ttdef"><b>Definition:</b> <a href="l2_8h_source.html#l00057">l2.h:57</a></div></div>
<div class="ttc" id="group__Exceptions_html_ga70a0bb353656e704acf927945277bbc6"><div class="ttname"><a href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a></div><div class="ttdeci">#define Assert(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01415">exceptions.h:1415</a></div></div>
<div class="ttc" id="namespaceMatrixCreator_html_aab6397f114af66efd781f7f4daba22be"><div class="ttname"><a href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">MatrixCreator::create_mass_matrix</a></div><div class="ttdeci">void create_mass_matrix(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const Quadrature&lt; dim &gt; &amp;q, SparseMatrix&lt; number &gt; &amp;matrix, const Function&lt; spacedim, number &gt; *const a=nullptr, const AffineConstraints&lt; number &gt; &amp;constraints=AffineConstraints&lt; number &gt;())</div></div>
<div class="ttc" id="namespacenumbers_html_a3e24f194a9cb9b6ff4442b8a7a877d4a"><div class="ttname"><a href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a></div><div class="ttdeci">static constexpr double PI</div><div class="ttdef"><b>Definition:</b> <a href="numbers_8h_source.html#l00223">numbers.h:223</a></div></div>
<div class="ttc" id="classDoFHandler_html"><div class="ttname"><a href="classDoFHandler.html">DoFHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00184">dof_handler.h:184</a></div></div>
<div class="ttc" id="namespaceGridGenerator_html_acea0cbcd68e52ce8113d1134b87de403"><div class="ttname"><a href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></div><div class="ttdeci">void hyper_cube(Triangulation&lt; dim, spacedim &gt; &amp;tria, const double left=0., const double right=1., const bool colorize=false)</div></div>
<div class="ttc" id="group__constraints_html_gaf78e864edbfba7e0a7477457bfb96b26"><div class="ttname"><a href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></div><div class="ttdeci">void make_sparsity_pattern(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const AffineConstraints&lt; number &gt; &amp;constraints=AffineConstraints&lt; number &gt;(), const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__sparsity_8cc_source.html#l00064">dof_tools_sparsity.cc:64</a></div></div>
<div class="ttc" id="group__Exceptions_html_ga7b52b286796c23ef9ff178faf7a4b68f"><div class="ttname"><a href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">StandardExceptions::ExcNotImplemented</a></div><div class="ttdeci">static ::ExceptionBase &amp; ExcNotImplemented()</div></div>
<div class="ttc" id="p4est__wrappers_8cc_html_ace00f2f80d9780ef9aa1007e1c22c6a4"><div class="ttname"><a href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a></div><div class="ttdeci">const ::parallel::distributed::Triangulation&lt; dim, spacedim &gt; * triangulation</div><div class="ttdef"><b>Definition:</b> <a href="p4est__wrappers_8cc_source.html#l00069">p4est_wrappers.cc:69</a></div></div>
<div class="ttc" id="classFunctionTime_html_ae7d37ddb04314b38cf67c6cba22923f6"><div class="ttname"><a href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">FunctionTime&lt; numbers::NumberTraits&lt; RangeNumberType &gt;::real_type &gt;::get_time</a></div><div class="ttdeci">numbers::NumberTraits&lt; RangeNumberType &gt;::real_type get_time() const</div></div>
<div class="ttc" id="classFunction_html_acbfcab66b2fc63bfea59268f40772bb4"><div class="ttname"><a href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function::value</a></div><div class="ttdeci">virtual RangeNumberType value(const Point&lt; dim &gt; &amp;p, const unsigned int component=0) const</div></div>
<div class="ttc" id="namespaceUtilities_1_1System_html_a76bc1cc7649cc416723f450d24fdd91d"><div class="ttname"><a href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">Utilities::System::get_time</a></div><div class="ttdeci">std::string get_time()</div><div class="ttdef"><b>Definition:</b> <a href="base_2utilities_8cc_source.html#l01019">utilities.cc:1019</a></div></div>
<div class="ttc" id="vectorization_8h_html_ad9b7aa5c50bf9ce988a0f756a3f2baa5"><div class="ttname"><a href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a></div><div class="ttdeci">inline ::VectorizedArray&lt; Number, width &gt; sin(const ::VectorizedArray&lt; Number, width &gt; &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="vectorization_8h_source.html#l05334">vectorization.h:5334</a></div></div>
<div class="ttc" id="namespaceDifferentiation_1_1SD_html_a803fcea270d7a523a91e3b7c173059f9"><div class="ttname"><a href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">Differentiation::SD::atan</a></div><div class="ttdeci">Expression atan(const Expression &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="symengine__math_8cc_source.html#l00147">symengine_math.cc:147</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
