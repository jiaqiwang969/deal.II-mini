<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceWorkStream.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: WorkStream Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">WorkStream Namespace Reference<div class="ingroups"><a class="el" href="group__Parallel.html">Parallel computing</a> &raquo; <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceWorkStream_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWorkStream_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab8ceb010811941c351803b671a19fb73"><td class="memTemplParams" colspan="2">template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </td></tr>
<tr class="memitem:ab8ceb010811941c351803b671a19fb73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">run</a> (const std::vector&lt; std::vector&lt; Iterator &gt;&gt; &amp;colored_iterators, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:ab8ceb010811941c351803b671a19fb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc1160c09f1fee6b2a5a4d0d3fa3f4e"><td class="memTemplParams" colspan="2">template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </td></tr>
<tr class="memitem:a7dc1160c09f1fee6b2a5a4d0d3fa3f4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#a7dc1160c09f1fee6b2a5a4d0d3fa3f4e">run</a> (const Iterator &amp;begin, const typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &amp;end, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:a7dc1160c09f1fee6b2a5a4d0d3fa3f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66156b45153b37bf892beef9800c87f"><td class="memTemplParams" colspan="2">template&lt;typename Worker , typename Copier , typename IteratorRangeType , typename ScratchData , typename CopyData , typename  = typename std::enable_if&lt;              has_begin_and_end&lt;IteratorRangeType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ac66156b45153b37bf892beef9800c87f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#ac66156b45153b37bf892beef9800c87f">run</a> (IteratorRangeType iterator_range, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:ac66156b45153b37bf892beef9800c87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c86b3e9c13dcf81a3eb0b81dc67b54e"><td class="memTemplParams" colspan="2">template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </td></tr>
<tr class="memitem:a3c86b3e9c13dcf81a3eb0b81dc67b54e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#a3c86b3e9c13dcf81a3eb0b81dc67b54e">run</a> (const <a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; Iterator &gt; &amp;iterator_range, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:a3c86b3e9c13dcf81a3eb0b81dc67b54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f054e2848cf513aec9e5e4eb115bef4"><td class="memTemplParams" colspan="2">template&lt;typename MainClass , typename Iterator , typename ScratchData , typename CopyData &gt; </td></tr>
<tr class="memitem:a2f054e2848cf513aec9e5e4eb115bef4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#a2f054e2848cf513aec9e5e4eb115bef4">run</a> (const Iterator &amp;begin, const typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &amp;end, MainClass &amp;main_object, void(MainClass::*worker)(const Iterator &amp;, ScratchData &amp;, CopyData &amp;), void(MainClass::*copier)(const CopyData &amp;), const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:a2f054e2848cf513aec9e5e4eb115bef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac000ad508b67209b01b45e07d7ad5f9d"><td class="memTemplParams" colspan="2">template&lt;typename MainClass , typename Iterator , typename ScratchData , typename CopyData &gt; </td></tr>
<tr class="memitem:ac000ad508b67209b01b45e07d7ad5f9d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#ac000ad508b67209b01b45e07d7ad5f9d">run</a> (const <a class="el" href="classIteratorOverIterators.html">IteratorOverIterators</a>&lt; Iterator &gt; &amp;begin, const <a class="el" href="classIteratorOverIterators.html">IteratorOverIterators</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &gt; &amp;end, MainClass &amp;main_object, void(MainClass::*worker)(const Iterator &amp;, ScratchData &amp;, CopyData &amp;), void(MainClass::*copier)(const CopyData &amp;), const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:ac000ad508b67209b01b45e07d7ad5f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae474b8a6256224409eb50ecb460a048f"><td class="memTemplParams" colspan="2">template&lt;typename MainClass , typename IteratorRangeType , typename ScratchData , typename CopyData , typename  = typename std::enable_if&lt;              has_begin_and_end&lt;IteratorRangeType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ae474b8a6256224409eb50ecb460a048f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#ae474b8a6256224409eb50ecb460a048f">run</a> (IteratorRangeType iterator_range, MainClass &amp;main_object, void(MainClass::*worker)(const typename <a class="el" href="structidentity.html">identity</a>&lt; IteratorRangeType &gt;::type::iterator &amp;, ScratchData &amp;, CopyData &amp;), void(MainClass::*copier)(const CopyData &amp;), const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:ae474b8a6256224409eb50ecb460a048f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275bfcc990de1d5e9b98db397d77a1a5"><td class="memTemplParams" colspan="2">template&lt;typename MainClass , typename Iterator , typename ScratchData , typename CopyData &gt; </td></tr>
<tr class="memitem:a275bfcc990de1d5e9b98db397d77a1a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#a275bfcc990de1d5e9b98db397d77a1a5">run</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; Iterator &gt; iterator_range, MainClass &amp;main_object, void(MainClass::*worker)(const Iterator &amp;, ScratchData &amp;, CopyData &amp;), void(MainClass::*copier)(const CopyData &amp;), const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:a275bfcc990de1d5e9b98db397d77a1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>一个命名空间，其主要的模板函数支持运行多个线程，每个线程在给定的对象范围内的一个子集上操作。该类使用英特尔线程构件（TBB）来平衡各个子范围在可用线程上的负载。关于这个类的原理的长篇讨论，见 <a class="el" href="group__threads.html">多处理器的并行计算 </a> 模块。它在教程中首先用于 <a class="el" href="step_9.html">step-9</a> ，然后在 <a class="el" href="step_13.html">step-13</a> 、 <a class="el" href="step_14.html">step-14</a> 、 <a class="el" href="step_32.html">step-32</a> 和其他地方再次使用。 该类建立在以下前提之上：人们经常有一些工作需要在一连串的对象上完成；一个典型的例子是将单元格的贡献集合到一个系统矩阵或右手边。在许多这样的例子中，部分工作可以完全独立和并行地完成，可能使用一台具有共享内存的机器上的几个处理器核心。然而，这项工作的其他部分可能需要同步进行，并按顺序完成。在组装矩阵的例子中，局部贡献的计算可以完全并行完成，但将局部贡献复制到全局矩阵中需要一些注意。首先，几个线程不能同时写入，而是需要使用mutex来同步写入；其次，我们希望本地贡献加入全局矩阵的顺序总是相同的，因为浮点加法不是换元的，以不同的顺序将本地贡献加入全局矩阵会导致微妙的不同结果，这可能会影响迭代求解器的迭代次数，以及随机的解的舍弃误差。因此，我们要确保每次只有一个线程写入全局矩阵，而且结果是以稳定和可重复的顺序复制的。 这个类实现了这种工作模式的框架。它处理一个由迭代器范围给定的对象流，在所有这些对象上并行地运行一个工作函数，然后将每个对象传递给一个后处理函数，该函数按顺序运行，并完全按照对象在输入迭代器范围中出现的顺序获得对象。所有的同步工作都不会暴露给这个类的用户。 在内部，给这个类的run()函数的范围被分割成一连串的 "项目"，然后根据一些的内部算法分配到可用线程的数量上。一个项目是我们要操作的迭代器范围中的一个元素；例如，为了组装矩阵或评估错误指标，一个项目可以是一个单元。TBB库决定了创建多少个线程（通常与处理器核心一样多），但在任何特定时间可能处于活动状态的项的数量由构造函数的参数指定。它应该大于或等于处理器内核的数量</p>
<ul>
<li>默认是当前系统中核心数量的四倍。 每当一个工作线程处于空闲状态或预计将成为空闲状态时，TBB就会根据请求创建项目。然后，它被移交给一个工作者函数，通常是一个主类的成员函数。这些工作函数在一些线程上并行运行，而且不能保证它们被要求以任何特定的顺序处理项目，特别是不一定以项目从迭代器范围生成的顺序。 通常情况下，工作者函数需要额外的数据，例如FEValues对象、输入数据向量等，其中有些数据不能在线程之间共享。为此，run()函数需要另一个模板参数ScratchData，它指定了一种类型的对象，这些对象与每个项目一起存储，线程可以将其作为私有数据使用而不必与其他线程共享。run()函数需要一个额外的参数，其中有一个ScratchData类型的对象，该对象将被复制为传递给每个工作者函数的参数。 此外，工作者函数将其结果存储在模板类型CopyData的对象中。然后，这些被移交给一个单独的函数，称为copier，它可能使用存储的结果，将它们转移到永久存储中。例如，它可以将工作函数计算的矩阵的局部贡献的结果复制到全局矩阵中。然而，与工作函数不同的是，在任何给定的时间内，只有一个复制器的实例在运行；因此，它可以安全地将本地贡献复制到全局矩阵中，而不需要使用突变器或类似手段锁定全局对象。此外，它保证复制器与CopyData对象的运行顺序与相关项目的创建顺序相同；因此，即使工作线程可能以非指定的顺序计算结果，复制器也总是以项目创建时的相同顺序接收结果。 一旦一个项目被复制器处理，它就会被删除，在其计算中使用的ScratchData和CopyData对象被认为是未使用的，并且可以在这个线程或另一个线程上的工作者函数的下一次调用中重新使用。然而，WorkStream函数没有试图将这些对象重置为任何一种原始状态</li>
<li>工作者应该假定它得到的CopyData对象有先前的内容，并以任何看起来合适的方式首先清除它，然后再把内容放进它，以后可以由复制者再次处理。 ScratchData和CopyData中的成员变量可以独立于这些数据结构副本的其他并发使用而被访问。因此，将与ScratchData和CopyData相关的辅助数据结构的大小调整到每个单元上的不同长度是完全可以的。例如，与 <a class="el" href="namespaceLocalIntegrators_1_1L2.html#a8f1bef9e8fe15148294b8ac6da83c2ae">LocalIntegrators::L2::weighted_mass_matrix()</a> 一起用于组装局部矩阵的持有每个正交点密度的向量可以被调整为具有hp-capabilities的DoFHandlers中当前单元的相应正交点的数量。同样，CopyData中的局部刚度矩阵也可以根据当前单元上的局部DoF的数量来调整大小。</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>对于单元格和面的积分，使用比当前函数更具体的方法往往是有用的（它不在乎迭代器是在单元格、向量元素还是其他类型的范围上）。 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> 函数是一个特别适合于积分的接口的实现。</dd>
<dd>
这个命名空间中的函数只有在deal.II配置时选择了多线程模式时才会真正并行工作。否则，它们只是按顺序对每个项目工作。 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ab8ceb010811941c351803b671a19fb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ceb010811941c351803b671a19fb73">&#9670;&nbsp;</a></span>run() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>colored_iterators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Worker&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Copier&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>如果你的数据对象很大，或者它们的构造函数很昂贵，记住<code>queue_length</code>拷贝的<code>ScratchData</code>对象和<code>queue_length*chunk_size</code>拷贝的<code>CopyData</code>对象是有帮助的。 </dd>
<dd>
在复制器不做任何事情的情况下，传递 <code>std::function&lt;void(const  CopyData &amp;)&gt;()</code>作为 <code>copier</code> 以确保内部使用更有效的算法。然而，重要的是要认识到，上面创建的空函数对象并不* 与具有空主体的lambda函数不同，<code>[](const CopyData &amp;){}</code>。</dd></dl>
<ul>
<li>从这个函数的角度来看，没有办法识别作为复制者提供的λ函数在其主体中是否做了什么，所以需要复制。另一方面，一个默认构造的 <code>std::function</code> 对象可以*被识别，然后被用来选择一个更有效的算法。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01151">1151</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="a7dc1160c09f1fee6b2a5a4d0d3fa3f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc1160c09f1fee6b2a5a4d0d3fa3f4e">&#9670;&nbsp;</a></span>run() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Worker&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Copier&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这是WorkStream概念的两个主要功能之一，做本命名空间介绍中描述的工作。它对应于Turcksin、Kronbichler和Bangerth的论文中的实现2（见 <a class="el" href="DEALGlossary.html#workstream_paper">workstream_paper</a> ）。 这个函数可以用于worker和copyer对象，这些对象要么是指向非成员函数的指针，要么是允许用operator()调用的对象，例如lambda函数或由 std::bind. 创建的对象。 如果copyer是一个空函数，它在管道中会被忽略。然而，一个具有空主体的lambda函数并不*等同于一个空的 <code>std::function</code> 对象，因此，不会被忽略。 作为 <code>end</code> 传递的参数必须可以转换为与 <code>开始时相同的类型，但本身不一定是相同的类型。这允许编写类似<code>WorkStream()</code>.run(dof_handler.begin_active(), <a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">dof_handler.end()</a>, ...</code>的代码，其中第一个是 <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler::active_cell_iterator</a> 类型，而第二个是 DoFHandler::raw_cell_iterator. 类型。 两个数据类型<code>ScratchData</code>和<code>CopyData</code>需要有一个工作拷贝构造器。<code>ScratchData</code>只在<code>worker</code>函数中使用，而<code>CopyData</code>是由<code>worker</code>传递给<code>copier</code>的对象。 <code>queue_length</code> 参数表示在任何给定时间内可以活用的项目数量。每个项目由输入流的 <code>chunk_size</code> 个元素组成，这些元素将被worker和copier函数在同一个线程上一个接一个地处理。 </p><dl class="section note"><dt>Note</dt><dd>如果你的数据对象很大，或者它们的构造函数很昂贵，记住<code>queue_length</code>拷贝的<code>ScratchData</code>对象和<code>queue_length*chunk_size</code>拷贝的<code>CopyData</code>对象是有帮助的。 </dd>
<dd>
在拷贝器不做任何事情的情况下，传递 <code>std::function&lt;void(const  CopyData &amp;)&gt;()</code>作为 <code>copier</code> 以确保内部使用更高效的算法。然而，重要的是要认识到，上面创建的空函数对象并不* 与具有空主体的lambda函数不同，<code>[](const CopyData &amp;){}</code>。</dd></dl>
<ul>
<li>从这个函数的角度来看，没有办法识别作为复制者提供的λ函数在其主体中是否做了什么，所以需要复制。另一方面，一个默认构造的 <code>std::function</code> 对象可以*被识别，然后被用来选择一个更有效的算法。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01001">1001</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="ac66156b45153b37bf892beef9800c87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66156b45153b37bf892beef9800c87f">&#9670;&nbsp;</a></span>run() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Worker , typename Copier , typename IteratorRangeType , typename ScratchData , typename CopyData , typename  = typename std::enable_if&lt;              has_begin_and_end&lt;IteratorRangeType&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">IteratorRangeType&#160;</td>
          <td class="paramname"><em>iterator_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Worker&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Copier&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面的函数相同，但用于迭代器范围和C风格的数组。 一个满足迭代器范围要求的类定义了 <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">IteratorRangeType::begin()</a></code> 和 <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">IteratorRangeType::end()</a></code>, 两个函数，这两个函数都返回到构成范围边界的元素的迭代器。 </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01093">1093</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="a3c86b3e9c13dcf81a3eb0b81dc67b54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c86b3e9c13dcf81a3eb0b81dc67b54e">&#9670;&nbsp;</a></span>run() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; Iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>iterator_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Worker&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Copier&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面的函数相同，但针对deal.II的IteratorRange。 </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01124">1124</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="a2f054e2848cf513aec9e5e4eb115bef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f054e2848cf513aec9e5e4eb115bef4">&#9670;&nbsp;</a></span>run() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MainClass , typename Iterator , typename ScratchData , typename CopyData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MainClass &amp;&#160;</td>
          <td class="paramname"><em>main_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const Iterator &amp;, ScratchData &amp;, CopyData &amp;)&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const CopyData &amp;)&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这是WorkStream概念的两个主要函数之一的变体，做本命名空间介绍中描述的工作。 它对应于Turcksin、Kronbichler和Bangerth的论文中的实现2（见 <a class="el" href="DEALGlossary.html#workstream_paper">workstream_paper</a> ）。 这是可以用于作为类的成员函数的工作者和复制者函数的函数。如果复制器是一个空函数，那么它在管道中会被忽略。 作为 <code>end</code> 传递的参数必须可以转换为与 <code>开始相同的类型，但本身不一定是同一类型。这允许编写类似<code>WorkStream()</code>.run(dof_handler.begin_active(), <a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">dof_handler.end()</a>, ...</code>的代码，其中第一个是 <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler::active_cell_iterator</a> 类型，而第二个是 DoFHandler::raw_cell_iterator. 类型。 <code>queue_length</code> 参数表示在任何特定时间可以直播的项目数量。每个项目由输入流的 <code>chunk_size</code> 个元素组成，这些元素将由工作者和复制者函数在同一线程上一个接一个地处理。 </p><dl class="section note"><dt>Note</dt><dd>如果你的数据对象很大，或者它们的构造函数很昂贵，记住<code>queue_length</code>拷贝的<code>ScratchData</code>对象和<code>queue_length*chunk_size</code>拷贝的<code>CopyData</code>对象是有帮助的。 </dd>
<dd>
在拷贝器不做任何事情的情况下，传递 <code>std::function&lt;void(const  CopyData &amp;)&gt;()</code>作为 <code>copier</code> 以确保内部使用更有效的算法。然而，重要的是要认识到，上面创建的空函数对象并不* 与具有空主体的lambda函数不同，<code>[](const CopyData &amp;){}</code>。</dd></dl>
<ul>
<li>从这个函数的角度来看，没有办法识别作为复制者提供的λ函数在其主体中是否做了什么，所以需要复制。另一方面，一个默认构造的 <code>std::function</code> 对象可以*被识别，然后被用来选择一个更有效的算法。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01222">1222</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="ac000ad508b67209b01b45e07d7ad5f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac000ad508b67209b01b45e07d7ad5f9d">&#9670;&nbsp;</a></span>run() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MainClass , typename Iterator , typename ScratchData , typename CopyData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIteratorOverIterators.html">IteratorOverIterators</a>&lt; Iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIteratorOverIterators.html">IteratorOverIterators</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MainClass &amp;&#160;</td>
          <td class="paramname"><em>main_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const Iterator &amp;, ScratchData &amp;, CopyData &amp;)&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const CopyData &amp;)&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01255">1255</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="ae474b8a6256224409eb50ecb460a048f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae474b8a6256224409eb50ecb460a048f">&#9670;&nbsp;</a></span>run() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MainClass , typename IteratorRangeType , typename ScratchData , typename CopyData , typename  = typename std::enable_if&lt;              has_begin_and_end&lt;IteratorRangeType&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">IteratorRangeType&#160;</td>
          <td class="paramname"><em>iterator_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MainClass &amp;&#160;</td>
          <td class="paramname"><em>main_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const typename <a class="el" href="structidentity.html">identity</a>&lt; IteratorRangeType &gt;::type::iterator &amp;, ScratchData &amp;, CopyData &amp;)&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const CopyData &amp;)&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面的函数相同，但用于迭代器范围和C风格的数组。 一个满足迭代器范围要求的类定义了 <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">IteratorRangeType::begin()</a></code> 和 <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">IteratorRangeType::end()</a></code>, 两个函数，这两个函数都返回到构成范围边界的元素的迭代器。 </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01298">1298</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="a275bfcc990de1d5e9b98db397d77a1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275bfcc990de1d5e9b98db397d77a1a5">&#9670;&nbsp;</a></span>run() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MainClass , typename Iterator , typename ScratchData , typename CopyData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; Iterator &gt;&#160;</td>
          <td class="paramname"><em>iterator_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MainClass &amp;&#160;</td>
          <td class="paramname"><em>main_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const Iterator &amp;, ScratchData &amp;, CopyData &amp;)&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const CopyData &amp;)&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面的函数相同，但针对deal.II的IteratorRange。 </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01333">1333</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
