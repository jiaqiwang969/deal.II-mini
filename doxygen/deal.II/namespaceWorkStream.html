<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceWorkStream.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: WorkStream Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">WorkStream Namespace Reference<div class="ingroups"><a class="el" href="group__Parallel.html">Parallel computing</a> &raquo; <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceWorkStream_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceWorkStream_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab8ceb010811941c351803b671a19fb73"><td class="memTemplParams" colspan="2">template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </td></tr>
<tr class="memitem:ab8ceb010811941c351803b671a19fb73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">run</a> (const std::vector&lt; std::vector&lt; Iterator &gt;&gt; &amp;colored_iterators, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:ab8ceb010811941c351803b671a19fb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc1160c09f1fee6b2a5a4d0d3fa3f4e"><td class="memTemplParams" colspan="2">template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </td></tr>
<tr class="memitem:a7dc1160c09f1fee6b2a5a4d0d3fa3f4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#a7dc1160c09f1fee6b2a5a4d0d3fa3f4e">run</a> (const Iterator &amp;begin, const typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &amp;end, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:a7dc1160c09f1fee6b2a5a4d0d3fa3f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66156b45153b37bf892beef9800c87f"><td class="memTemplParams" colspan="2">template&lt;typename Worker , typename Copier , typename IteratorRangeType , typename ScratchData , typename CopyData , typename  = typename std::enable_if&lt;              has_begin_and_end&lt;IteratorRangeType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ac66156b45153b37bf892beef9800c87f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#ac66156b45153b37bf892beef9800c87f">run</a> (IteratorRangeType iterator_range, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:ac66156b45153b37bf892beef9800c87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c86b3e9c13dcf81a3eb0b81dc67b54e"><td class="memTemplParams" colspan="2">template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </td></tr>
<tr class="memitem:a3c86b3e9c13dcf81a3eb0b81dc67b54e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#a3c86b3e9c13dcf81a3eb0b81dc67b54e">run</a> (const <a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; Iterator &gt; &amp;iterator_range, Worker worker, Copier copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:a3c86b3e9c13dcf81a3eb0b81dc67b54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f054e2848cf513aec9e5e4eb115bef4"><td class="memTemplParams" colspan="2">template&lt;typename MainClass , typename Iterator , typename ScratchData , typename CopyData &gt; </td></tr>
<tr class="memitem:a2f054e2848cf513aec9e5e4eb115bef4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#a2f054e2848cf513aec9e5e4eb115bef4">run</a> (const Iterator &amp;begin, const typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &amp;end, MainClass &amp;main_object, void(MainClass::*worker)(const Iterator &amp;, ScratchData &amp;, CopyData &amp;), void(MainClass::*copier)(const CopyData &amp;), const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:a2f054e2848cf513aec9e5e4eb115bef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac000ad508b67209b01b45e07d7ad5f9d"><td class="memTemplParams" colspan="2">template&lt;typename MainClass , typename Iterator , typename ScratchData , typename CopyData &gt; </td></tr>
<tr class="memitem:ac000ad508b67209b01b45e07d7ad5f9d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#ac000ad508b67209b01b45e07d7ad5f9d">run</a> (const <a class="el" href="classIteratorOverIterators.html">IteratorOverIterators</a>&lt; Iterator &gt; &amp;begin, const <a class="el" href="classIteratorOverIterators.html">IteratorOverIterators</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &gt; &amp;end, MainClass &amp;main_object, void(MainClass::*worker)(const Iterator &amp;, ScratchData &amp;, CopyData &amp;), void(MainClass::*copier)(const CopyData &amp;), const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:ac000ad508b67209b01b45e07d7ad5f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae474b8a6256224409eb50ecb460a048f"><td class="memTemplParams" colspan="2">template&lt;typename MainClass , typename IteratorRangeType , typename ScratchData , typename CopyData , typename  = typename std::enable_if&lt;              has_begin_and_end&lt;IteratorRangeType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ae474b8a6256224409eb50ecb460a048f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#ae474b8a6256224409eb50ecb460a048f">run</a> (IteratorRangeType iterator_range, MainClass &amp;main_object, void(MainClass::*worker)(const typename <a class="el" href="structidentity.html">identity</a>&lt; IteratorRangeType &gt;::type::iterator &amp;, ScratchData &amp;, CopyData &amp;), void(MainClass::*copier)(const CopyData &amp;), const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:ae474b8a6256224409eb50ecb460a048f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275bfcc990de1d5e9b98db397d77a1a5"><td class="memTemplParams" colspan="2">template&lt;typename MainClass , typename Iterator , typename ScratchData , typename CopyData &gt; </td></tr>
<tr class="memitem:a275bfcc990de1d5e9b98db397d77a1a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceWorkStream.html#a275bfcc990de1d5e9b98db397d77a1a5">run</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; Iterator &gt; iterator_range, MainClass &amp;main_object, void(MainClass::*worker)(const Iterator &amp;, ScratchData &amp;, CopyData &amp;), void(MainClass::*copier)(const CopyData &amp;), const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:a275bfcc990de1d5e9b98db397d77a1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A namespace whose main template function supports running multiple threads each of which operates on a subset of the given range of objects. The class uses the Intel Threading Building Blocks (TBB) to load balance the individual subranges onto the available threads. For a lengthy discussion of the rationale of this class, see the <a class="el" href="group__threads.html">Parallel computing with multiple processors</a> module. It is used in the tutorial first in step-9, and again in step-13, step-14, step-32 and others.</p>
<p>The class is built on the following premise: One frequently has some work that needs to be done on a sequence of objects; a prototypical example is assembling cell contributions to a system matrix or right hand side. In many such examples, part of the work can be done entirely independently and in parallel, possibly using several processor cores on a machine with shared memory. However, some other part of this work may need to be synchronized and be done in order. In the example of assembling a matrix, the computation of local contributions can be done entirely in parallel, but copying the local contributions into the global matrix requires some care: First, several threads can't write at the same time, but need to synchronize writing using a mutex; secondly, we want the order in which local contributions are added to the global matrix to be always the same because floating point addition is not commutative and adding local contributions to the global matrix in different orders leads to subtly different results that can affect the number of iterations for iterative solvers as well as the round-off error in the solution in random ways. Consequently, we want to ensure that only one thread at a time writes into the global matrix, and that results are copied in a stable and reproducible order.</p>
<p>This class implements a framework for this work model. It works with a stream of objects given by an iterator range, runs a worker function in parallel on all of these objects and then passes each object to a postprocessor function that runs sequentially and gets objects in exactly the order in which they appear in the input iterator range. None of the synchronization work is exposed to the user of this class.</p>
<p>Internally, the range given to the <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">run()</a> function of this class is split into a sequence of "items", which are then distributed according to some internal algorithm onto the number of available threads. An item is an element of the range of iterators on which we are to operate; for example, for the purpose of assembling matrices or evaluating error indicators, an item could be a cell. The TBB library determines how many threads are created (typically as many as there are processor cores), but the number of items that may be active at any given time is specified by the argument to the constructor. It should be bigger or equal to the number of processor cores - the default is four times the number of cores on the current system.</p>
<p>Items are created upon request by the TBB whenever one of the worker threads is idle or is expected to become idle. It is then handed off to a worker function, typically a member function of a main class. These worker functions are run in parallel on a number of threads, and there is no guarantee that they are asked to work on items in any particular order, in particular not necessarily in the order in which items are generated from the iterator range.</p>
<p>Typically, worker functions need additional data, for example <a class="el" href="classFEValues.html">FEValues</a> objects, input data vectors, etc, some of which can not be shared among threads. To this end, the <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">run()</a> function takes another template argument, ScratchData, which designates a type objects of which are stored with each item and which threads can use as private data without having to share them with other threads. The <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">run()</a> function takes an additional argument with an object of type ScratchData that is going to be copied for the arguments passed to each of the worker functions.</p>
<p>In addition, worker functions store their results in objects of template type CopyData. These are then handed off to a separate function, called copier, that may use the stored results to transfer them into permanent storage. For example, it may copy the results of local contributions to a matrix computed by a worker function into the global matrix. In contrast to the worker function, however, only one instance of the copier is run at any given time; it can therefore safely copy local contributions into the global matrix without the need to lock the global object using a mutex or similar means. Furthermore, it is guaranteed that the copier is run with CopyData objects in the same order in which their associated items were created; consequently, even if worker threads may compute results in unspecified order, the copier always receives the results in exactly the same order as the items were created.</p>
<p>Once an item is processed by the copier, it is deleted and the ScratchData and CopyData objects that were used in its computation are considered unused and may be re-used for the next invocation of the worker function, on this or another thread. However, the <a class="el" href="namespaceWorkStream.html">WorkStream</a> functions make no attempt to reset these objects to any kind of pristine state &ndash; a worker should assume that the CopyData object it gets handed has prior content and clear it first in whatever manner seems appropriate, before putting content into it that can later be processed again by the copier.</p>
<p>The member variables in ScratchData and CopyData can be accessed independently of other concurrent uses of copies of these data structures. Therefore, it is perfectly fine to resize auxiliary data structures associated with ScratchData and CopyData to different lengths on each cell. For example, a vector holding densities at each quadrature point which is used with <a class="el" href="namespaceLocalIntegrators_1_1L2.html#a8f1bef9e8fe15148294b8ac6da83c2ae">LocalIntegrators::L2::weighted_mass_matrix()</a> to assemble the local matrix could be resized to the corresponding number of quadrature points of the current cell in DoFHandlers with hp-capabilities. Similarly, local stiffness matrix in CopyData can be resized in accordance with the number of local DoFs on the current cell.</p>
<dl class="section note"><dt>Note</dt><dd>For integration over cells and faces, it is often useful to use methods more specific to the task than the current function (which doesn't care whether the iterators are over cells, vector elements, or any other kind of range). An implementation of an interface specifically suited to integration is the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> function.</dd>
<dd>
The functions in this namespace only really work in parallel when multithread mode was selected during deal.II configuration. Otherwise they simply work on each item sequentially. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ab8ceb010811941c351803b671a19fb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ceb010811941c351803b671a19fb73">&#9670;&nbsp;</a></span>run() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>colored_iterators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Worker&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Copier&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is one of two main functions of the <a class="el" href="namespaceWorkStream.html">WorkStream</a> concept, doing work as described in the introduction to this namespace. It corresponds to implementation 3 of the paper by Turcksin, Kronbichler and Bangerth, see <a class="el" href="DEALGlossary.html#workstream_paper">workstream_paper</a>. As such, it takes not a range of iterators described by a begin and end iterator, but a "colored" graph of iterators where each color represents cells for which writing the cell contributions into the global object does not conflict (in other words, these cells are not neighbors). Each "color" is represented by std::vectors of cells. The first argument to this function, a set of sets of cells (which are represent as a vector of vectors, for efficiency), is typically constructed by calling <a class="el" href="namespaceGraphColoring.html#a670720d11f544a762592112ae5213876">GraphColoring::make_graph_coloring()</a>. See there for more information.</p>
<p>This function that can be used for worker and copier objects that are either pointers to non-member functions or objects that allow to be called with an operator(), for example objects created by lambda functions or std::bind.</p>
<p>The two data types <code>ScratchData</code> and <code>CopyData</code> need to have a working copy constructor. <code>ScratchData</code> is only used in the <code>worker</code> function, while <code>CopyData</code> is the object passed from the <code>worker</code> to the <code>copier</code>.</p>
<p>The <code>queue_length</code> argument indicates the number of items that can be live at any given time. Each item consists of <code>chunk_size</code> elements of the input stream that will be worked on by the worker and copier functions one after the other on the same thread.</p>
<dl class="section note"><dt>Note</dt><dd>If your data objects are large, or their constructors are expensive, it is helpful to keep in mind that <code>queue_length</code> copies of the <code>ScratchData</code> object and <code>queue_length*chunk_size</code> copies of the <code>CopyData</code> object are generated.</dd>
<dd>
In case the copier does not do anything, pass <code>std::function&lt;void(const CopyData &amp;)&gt;()</code> as <code>copier</code> to make sure a more efficient algorithm is used internally. It is important, however, to recognize that the empty function object created above is <em>not</em> the same as a lambda function with an empty body, <code>[](const CopyData &amp;) {}</code> &ndash; from the perspective of this function, there is no way to recognize whether a lambda function provided as a copier does something or does not do something in its body, and so it needs to be copied. On the other hand, a default-constructed <code>std::function</code> object <em>can</em> be recognized, and is then used to select a more efficient algorithm. </dd></dl>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01337">1337</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="a7dc1160c09f1fee6b2a5a4d0d3fa3f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc1160c09f1fee6b2a5a4d0d3fa3f4e">&#9670;&nbsp;</a></span>run() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Worker&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Copier&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is one of two main functions of the <a class="el" href="namespaceWorkStream.html">WorkStream</a> concept, doing work as described in the introduction to this namespace. It corresponds to implementation 2 of the paper by Turcksin, Kronbichler and Bangerth (see <a class="el" href="DEALGlossary.html#workstream_paper">workstream_paper</a>).</p>
<p>This function that can be used for worker and copier objects that are either pointers to non-member functions or objects that allow to be called with an operator(), for example lambda functions or objects created by std::bind. If the copier is an empty function, it is ignored in the pipeline. (However, a lambda function with an empty body is <em>not</em> equivalent to an empty <code>std::function</code> object and will, consequently, not be ignored.</p>
<p>The argument passed as <code>end</code> must be convertible to the same type as <code>begin</code>, but doesn't have to be of the same type itself. This allows to write code like <code>WorkStream().run(dof_handler.begin_active(), <a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">dof_handler.end()</a>, ...</code> where the first is of type <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler::active_cell_iterator</a> whereas the second is of type DoFHandler::raw_cell_iterator.</p>
<p>The two data types <code>ScratchData</code> and <code>CopyData</code> need to have a working copy constructor. <code>ScratchData</code> is only used in the <code>worker</code> function, while <code>CopyData</code> is the object passed from the <code>worker</code> to the <code>copier</code>.</p>
<p>The <code>queue_length</code> argument indicates the number of items that can be live at any given time. Each item consists of <code>chunk_size</code> elements of the input stream that will be worked on by the worker and copier functions one after the other on the same thread.</p>
<dl class="section note"><dt>Note</dt><dd>If your data objects are large, or their constructors are expensive, it is helpful to keep in mind that <code>queue_length</code> copies of the <code>ScratchData</code> object and <code>queue_length*chunk_size</code> copies of the <code>CopyData</code> object are generated.</dd>
<dd>
In case the copier does not do anything, pass <code>std::function&lt;void(const CopyData &amp;)&gt;()</code> as <code>copier</code> to make sure a more efficient algorithm is used internally. It is important, however, to recognize that the empty function object created above is <em>not</em> the same as a lambda function with an empty body, <code>[](const CopyData &amp;) {}</code> &ndash; from the perspective of this function, there is no way to recognize whether a lambda function provided as a copier does something or does not do something in its body, and so it needs to be copied. On the other hand, a default-constructed <code>std::function</code> object <em>can</em> be recognized, and is then used to select a more efficient algorithm. </dd></dl>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01188">1188</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="ac66156b45153b37bf892beef9800c87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66156b45153b37bf892beef9800c87f">&#9670;&nbsp;</a></span>run() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Worker , typename Copier , typename IteratorRangeType , typename ScratchData , typename CopyData , typename  = typename std::enable_if&lt;              has_begin_and_end&lt;IteratorRangeType&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">IteratorRangeType&#160;</td>
          <td class="paramname"><em>iterator_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Worker&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Copier&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the function above, but for iterator ranges and C-style arrays. A class that fulfills the requirements of an iterator range defines the functions <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">IteratorRangeType::begin()</a></code> and <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">IteratorRangeType::end()</a></code>, both of which return iterators to elements that form the bounds of the range. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01280">1280</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="a3c86b3e9c13dcf81a3eb0b81dc67b54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c86b3e9c13dcf81a3eb0b81dc67b54e">&#9670;&nbsp;</a></span>run() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Worker , typename Copier , typename Iterator , typename ScratchData , typename CopyData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; Iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>iterator_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Worker&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Copier&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the function above, but for deal.II's <a class="el" href="classIteratorRange.html">IteratorRange</a>. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01310">1310</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="a2f054e2848cf513aec9e5e4eb115bef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f054e2848cf513aec9e5e4eb115bef4">&#9670;&nbsp;</a></span>run() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MainClass , typename Iterator , typename ScratchData , typename CopyData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MainClass &amp;&#160;</td>
          <td class="paramname"><em>main_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const Iterator &amp;, ScratchData &amp;, CopyData &amp;)&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const CopyData &amp;)&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a variant of one of the two main functions of the <a class="el" href="namespaceWorkStream.html">WorkStream</a> concept, doing work as described in the introduction to this namespace. It corresponds to implementation 2 of the paper by Turcksin, Kronbichler and Bangerth (see <a class="el" href="DEALGlossary.html#workstream_paper">workstream_paper</a>).</p>
<p>This is the function that can be used for worker and copier functions that are member functions of a class. If the copier is an empty function, it is ignored in the pipeline.</p>
<p>The argument passed as <code>end</code> must be convertible to the same type as <code>begin</code>, but doesn't have to be of the same type itself. This allows to write code like <code>WorkStream().run(dof_handler.begin_active(), <a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">dof_handler.end()</a>, ...</code> where the first is of type <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler::active_cell_iterator</a> whereas the second is of type DoFHandler::raw_cell_iterator.</p>
<p>The <code>queue_length</code> argument indicates the number of items that can be live at any given time. Each item consists of <code>chunk_size</code> elements of the input stream that will be worked on by the worker and copier functions one after the other on the same thread.</p>
<dl class="section note"><dt>Note</dt><dd>If your data objects are large, or their constructors are expensive, it is helpful to keep in mind that <code>queue_length</code> copies of the <code>ScratchData</code> object and <code>queue_length*chunk_size</code> copies of the <code>CopyData</code> object are generated.</dd>
<dd>
In case the copier does not do anything, pass <code>std::function&lt;void(const CopyData &amp;)&gt;()</code> as <code>copier</code> to make sure a more efficient algorithm is used internally. It is important, however, to recognize that the empty function object created above is <em>not</em> the same as a lambda function with an empty body, <code>[](const CopyData &amp;) {}</code> &ndash; from the perspective of this function, there is no way to recognize whether a lambda function provided as a copier does something or does not do something in its body, and so it needs to be copied. On the other hand, a default-constructed <code>std::function</code> object <em>can</em> be recognized, and is then used to select a more efficient algorithm. </dd></dl>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01426">1426</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="ac000ad508b67209b01b45e07d7ad5f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac000ad508b67209b01b45e07d7ad5f9d">&#9670;&nbsp;</a></span>run() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MainClass , typename Iterator , typename ScratchData , typename CopyData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIteratorOverIterators.html">IteratorOverIterators</a>&lt; Iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIteratorOverIterators.html">IteratorOverIterators</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Iterator &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MainClass &amp;&#160;</td>
          <td class="paramname"><em>main_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const Iterator &amp;, ScratchData &amp;, CopyData &amp;)&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const CopyData &amp;)&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01459">1459</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="ae474b8a6256224409eb50ecb460a048f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae474b8a6256224409eb50ecb460a048f">&#9670;&nbsp;</a></span>run() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MainClass , typename IteratorRangeType , typename ScratchData , typename CopyData , typename  = typename std::enable_if&lt;              has_begin_and_end&lt;IteratorRangeType&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype">IteratorRangeType&#160;</td>
          <td class="paramname"><em>iterator_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MainClass &amp;&#160;</td>
          <td class="paramname"><em>main_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const typename <a class="el" href="structidentity.html">identity</a>&lt; IteratorRangeType &gt;::type::iterator &amp;, ScratchData &amp;, CopyData &amp;)&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const CopyData &amp;)&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the function above, but for iterator ranges and C-style arrays. A class that fulfills the requirements of an iterator range defines the functions <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">IteratorRangeType::begin()</a></code> and <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">IteratorRangeType::end()</a></code>, both of which return iterators to elements that form the bounds of the range. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01502">1502</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
<a id="a275bfcc990de1d5e9b98db397d77a1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275bfcc990de1d5e9b98db397d77a1a5">&#9670;&nbsp;</a></span>run() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MainClass , typename Iterator , typename ScratchData , typename CopyData &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void WorkStream::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; Iterator &gt;&#160;</td>
          <td class="paramname"><em>iterator_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MainClass &amp;&#160;</td>
          <td class="paramname"><em>main_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const Iterator &amp;, ScratchData &amp;, CopyData &amp;)&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const CopyData &amp;)&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScratchData &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopyData &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the function above, but for deal.II's <a class="el" href="classIteratorRange.html">IteratorRange</a>. </p>

<p class="definition">Definition at line <a class="el" href="work__stream_8h_source.html#l01536">1536</a> of file <a class="el" href="work__stream_8h_source.html">work_stream.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
