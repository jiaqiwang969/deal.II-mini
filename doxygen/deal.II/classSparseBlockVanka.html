<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSparseBlockVanka.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SparseBlockVanka&lt; number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSparseBlockVanka-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SparseBlockVanka&lt; number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo;  &#124; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo; <a class="el" href="group__Preconditioners.html">Preconditioners and Relaxation Operators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sparse__vanka_8h_source.html">deal.II/lac/sparse_vanka.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SparseBlockVanka&lt; number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSparseBlockVanka__inherit__graph.svg" width="211" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abb5808d854335ef644940e5925bdc9f0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseBlockVanka.html#abb5808d854335ef644940e5925bdc9f0">BlockingStrategy</a> { <a class="el" href="classSparseBlockVanka.html#abb5808d854335ef644940e5925bdc9f0ac7c19434398878a27c9b9a9344d036ab">index_intervals</a>, 
<a class="el" href="classSparseBlockVanka.html#abb5808d854335ef644940e5925bdc9f0ae8aa2663e8d4a83673f782185c012c4b">adaptive</a>
 }</td></tr>
<tr class="separator:abb5808d854335ef644940e5925bdc9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65584bab604c4378f3fa70689c5cc8a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseBlockVanka.html#a65584bab604c4378f3fa70689c5cc8a7">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:a65584bab604c4378f3fa70689c5cc8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac01e0467c0af006f10315db7a91bf5a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseBlockVanka.html#ac01e0467c0af006f10315db7a91bf5a6">SparseBlockVanka</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;M, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;<a class="el" href="classSparseVanka.html#ab1c1073cd133bb81b5875b341eb32925">selected</a>, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classSparseBlockVanka.html#afd45c7bd085f644e45e541af3822ad00">n_blocks</a>, const <a class="el" href="classSparseBlockVanka.html#abb5808d854335ef644940e5925bdc9f0">BlockingStrategy</a> blocking_strategy, const <a class="el" href="classbool.html">bool</a> conserve_memory, const unsigned <a class="el" href="classint.html">int</a> n_threads=<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>())</td></tr>
<tr class="separator:ac01e0467c0af006f10315db7a91bf5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8cdd87a01a0d331978494d4678f433"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseBlockVanka.html#aaa8cdd87a01a0d331978494d4678f433">SparseBlockVanka</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;M, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;<a class="el" href="classSparseVanka.html#ab1c1073cd133bb81b5875b341eb32925">selected</a>, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classSparseBlockVanka.html#afd45c7bd085f644e45e541af3822ad00">n_blocks</a>, const <a class="el" href="classSparseBlockVanka.html#abb5808d854335ef644940e5925bdc9f0">BlockingStrategy</a> blocking_strategy)</td></tr>
<tr class="separator:aaa8cdd87a01a0d331978494d4678f433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3153b46e90a763ffcb18c1b25096e7b"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ad3153b46e90a763ffcb18c1b25096e7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseBlockVanka.html#ad3153b46e90a763ffcb18c1b25096e7b">vmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;src) const</td></tr>
<tr class="separator:ad3153b46e90a763ffcb18c1b25096e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bc4e285829dc632eb4bd60be156a7f"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseBlockVanka.html#aa7bc4e285829dc632eb4bd60be156a7f">memory_consumption</a> () const</td></tr>
<tr class="separator:aa7bc4e285829dc632eb4bd60be156a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2ce1949e40a2f6d09fe4d870670988"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a6e2ce1949e40a2f6d09fe4d870670988">initialize</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;M, const <a class="el" href="classSparseVanka_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data)</td></tr>
<tr class="separator:a6e2ce1949e40a2f6d09fe4d870670988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9244a620a91b61ee03f70edbf2e52ba7"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a9244a620a91b61ee03f70edbf2e52ba7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a9244a620a91b61ee03f70edbf2e52ba7">Tvmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;src) const</td></tr>
<tr class="separator:a9244a620a91b61ee03f70edbf2e52ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1161f72e2921f4cf53584ddddca91665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a1161f72e2921f4cf53584ddddca91665">m</a> () const</td></tr>
<tr class="separator:a1161f72e2921f4cf53584ddddca91665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b1fb0a899949cc4b31a61dc386ef9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a41b1fb0a899949cc4b31a61dc386ef9a">n</a> () const</td></tr>
<tr class="separator:a41b1fb0a899949cc4b31a61dc386ef9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae7569b43f4519137cc98f30ada15e1ee"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ae7569b43f4519137cc98f30ada15e1ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#ae7569b43f4519137cc98f30ada15e1ee">apply_preconditioner</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;src, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; *const dof_mask=nullptr) const</td></tr>
<tr class="separator:ae7569b43f4519137cc98f30ada15e1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8897bf5c46e8f2cbae9c94afed06af41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseBlockVanka.html#a8897bf5c46e8f2cbae9c94afed06af41">compute_dof_masks</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;M, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;<a class="el" href="classSparseVanka.html#ab1c1073cd133bb81b5875b341eb32925">selected</a>, const <a class="el" href="classSparseBlockVanka.html#abb5808d854335ef644940e5925bdc9f0">BlockingStrategy</a> blocking_strategy)</td></tr>
<tr class="separator:a8897bf5c46e8f2cbae9c94afed06af41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:afd45c7bd085f644e45e541af3822ad00"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseBlockVanka.html#afd45c7bd085f644e45e541af3822ad00">n_blocks</a></td></tr>
<tr class="separator:afd45c7bd085f644e45e541af3822ad00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50eedb7f428138af6378d798e8ba057"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseBlockVanka.html#af50eedb7f428138af6378d798e8ba057">dof_masks</a></td></tr>
<tr class="separator:af50eedb7f428138af6378d798e8ba057"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename number&gt;<br />
class SparseBlockVanka&lt; number &gt;</h3>

<p>Block version of the sparse Vanka preconditioner. This class divides the matrix into blocks and works on the diagonal blocks only, which of course reduces the efficiency as preconditioner, but is perfectly parallelizable. The constructor takes a parameter into how many blocks the matrix shall be subdivided and then lets the underlying class do the work. Division of the matrix is done in several ways which are described in detail below.</p>
<p>This class is probably useless if you don't have a multiprocessor system, since then the amount of work per preconditioning step is the same as for the <code><a class="el" href="classSparseVanka.html">SparseVanka</a></code> class, but preconditioning properties are worse. On the other hand, if you have a multiprocessor system, the worse preconditioning quality (leading to more iterations of the linear solver) usually is well balanced by the increased speed of application due to the parallelization, leading to an overall decrease in elapsed wall-time for solving your linear system. It should be noted that the quality as preconditioner reduces with growing number of blocks, so there may be an optimal value (in terms of wall-time per linear solve) for the number of blocks.</p>
<p>To facilitate writing portable code, if the number of blocks into which the matrix is to be subdivided, is set to one, then this class acts just like the <code><a class="el" href="classSparseVanka.html">SparseVanka</a></code> class. You may therefore want to set the number of blocks equal to the number of processors you have.</p>
<p>Note that the parallelization is done if <code>deal.II</code> was configured for multithread use and that the number of threads which is spawned equals the number of blocks. This is reasonable since you will not want to set the number of blocks unnecessarily large, since, as mentioned, this reduces the preconditioning properties.</p>
<h3>Splitting the matrix into blocks</h3>
<p>Splitting the matrix into blocks is always done in a way such that the blocks are not necessarily of equal size, but such that the number of selected degrees of freedom for which a local system is to be solved is equal between blocks. The reason for this strategy to subdivision is load- balancing for multithreading. There are several possibilities to actually split the matrix into blocks, which are selected by the flag <code>blocking_strategy</code> that is passed to the constructor. By a block, we will in the sequel denote a list of indices of degrees of freedom; the algorithm will work on each block separately, i.e. the solutions of the local systems corresponding to a degree of freedom of one block will only be used to update the degrees of freedom belonging to the same block, but never to update degrees of freedom of other blocks. A block can be a consecutive list of indices, as in the first alternative below, or a nonconsecutive list of indices. Of course, we assume that the intersection of each two blocks is empty and that the union of all blocks equals the interval <code>[0,N)</code>, where <code>N</code> is the number of degrees of freedom of the system of equations.</p>
<ul>
<li>
<p class="startli"><code>index_intervals:</code> Here, we chose the blocks to be intervals <code>[a_i,a_{i+1</code>)}, i.e. consecutive degrees of freedom are usually also within the same block. This is a reasonable strategy, if the degrees of freedom have, for example, be re-numbered using the Cuthill-McKee algorithm, in which spatially neighboring degrees of freedom have neighboring indices. In that case, coupling in the matrix is usually restricted to the vicinity of the diagonal as well, and we can simply cut the matrix into blocks.</p>
<p>The bounds of the intervals, i.e. the <code>a_i</code> above, are chosen such that the number of degrees of freedom on which we shall work (i.e. usually the degrees of freedom corresponding to Lagrange multipliers) is about the same in each block; this does not mean, however, that the sizes of the blocks are equal, since the blocks also comprise the other degrees of freedom for which no local system is solved. In the extreme case, consider that all Lagrange multipliers are sorted to the end of the range of DoF indices, then the first block would be very large, since it comprises all other DoFs and some Lagrange multipliers, while all other blocks are rather small and comprise only Langrange multipliers. This strategy therefore does not only depend on the order in which the Lagrange DoFs are sorted, but also on the order in which the other DoFs are sorted. It is therefore necessary to note that this almost renders the capability as preconditioner useless if the degrees of freedom are numbered by component, i.e. all Lagrange multipliers en bloc.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>adaptive:</code> This strategy is a bit more clever in cases where the Langrange DoFs are clustered, as in the example above. It works as follows: it first groups the Lagrange DoFs into blocks, using the same strategy as above. However, instead of grouping the other DoFs into the blocks of Lagrange DoFs with nearest DoF index, it decides for each non-Lagrange DoF to put it into the block of Lagrange DoFs which write to this non-Lagrange DoF most often. This makes it possible to even sort the Lagrange DoFs to the end and still associate spatially neighboring non-Lagrange DoFs to the same blocks where the respective Lagrange DoFs are, since they couple to each other while spatially distant DoFs don't couple.</p>
<p class="endli">The additional computational effort to sorting the non-Lagrange DoFs is not very large compared with the inversion of the local systems and applying the preconditioner, so this strategy might be reasonable if you want to sort your degrees of freedom by component. If the degrees of freedom are not sorted by component, the results of the both strategies outlined above does not differ much. However, unlike the first strategy, the performance of the second strategy does not deteriorate if the DoFs are renumbered by component. </p>
</li>
</ul>
<h3>Typical results</h3>
<p>As a prototypical test case, we use a nonlinear problem from optimization, which leads to a series of saddle point problems, each of which is solved using GMRES with Vanka as preconditioner. The equation had approx. 850 degrees of freedom. With the non-blocked version <code><a class="el" href="classSparseVanka.html">SparseVanka</a></code> (or <code><a class="el" href="classSparseBlockVanka.html">SparseBlockVanka</a></code> with <code>n_blocks==1</code>), the following numbers of iterations is needed to solver the linear system in each nonlinear step: </p><pre class="fragment">*   101 68 64 53 35 21
* </pre><p>With four blocks, we need the following numbers of iterations </p><pre class="fragment">*   124 88 83 66 44 28
* </pre><p> As can be seen, more iterations are needed. However, in terms of computing time, the first version needs 72 seconds wall time (and 79 seconds CPU time, which is more than wall time since some other parts of the program were parallelized as well), while the second version needed 53 second wall time (and 110 seconds CPU time) on a four processor machine. The total time is in both cases dominated by the linear solvers. In this case, it is therefore worth while using the blocked version of the preconditioner if wall time is more important than CPU time.</p>
<p>The results with the block version above were obtained with the first blocking strategy and the degrees of freedom were not numbered by component. Using the second strategy does not much change the numbers of iterations (at most by one in each step) and they also do not change when the degrees of freedom are sorted by component, while the first strategy significantly deteriorated. </p>

<p class="definition">Definition at line <a class="el" href="sparse__vanka_8h_source.html#l00499">499</a> of file <a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a65584bab604c4378f3fa70689c5cc8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65584bab604c4378f3fa70689c5cc8a7">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseBlockVanka.html">SparseBlockVanka</a>&lt; number &gt;::<a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="sparse__vanka_8h_source.html#l00505">505</a> of file <a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="abb5808d854335ef644940e5925bdc9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5808d854335ef644940e5925bdc9f0">&#9670;&nbsp;</a></span>BlockingStrategy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classSparseBlockVanka.html#abb5808d854335ef644940e5925bdc9f0">SparseBlockVanka::BlockingStrategy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of the different methods by which the DoFs are distributed to the blocks on which we are to work. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abb5808d854335ef644940e5925bdc9f0ac7c19434398878a27c9b9a9344d036ab"></a>index_intervals&#160;</td><td class="fielddoc"><p>Block by index intervals. </p>
</td></tr>
<tr><td class="fieldname"><a id="abb5808d854335ef644940e5925bdc9f0ae8aa2663e8d4a83673f782185c012c4b"></a>adaptive&#160;</td><td class="fielddoc"><p>Block with an adaptive strategy. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="sparse__vanka_8h_source.html#l00511">511</a> of file <a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac01e0467c0af006f10315db7a91bf5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01e0467c0af006f10315db7a91bf5a6">&#9670;&nbsp;</a></span>SparseBlockVanka() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseBlockVanka.html">SparseBlockVanka</a>&lt; number &gt;::<a class="el" href="classSparseBlockVanka.html">SparseBlockVanka</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseBlockVanka.html#abb5808d854335ef644940e5925bdc9f0">BlockingStrategy</a>&#160;</td>
          <td class="paramname"><em>blocking_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>conserve_memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Pass all arguments except for <code>n_blocks</code> to the base class.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000056">Deprecated:</a></b></dt><dd>This constructor is deprecated. The values passed to the last two arguments are ignored. </dd></dl>

</div>
</div>
<a id="aaa8cdd87a01a0d331978494d4678f433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8cdd87a01a0d331978494d4678f433">&#9670;&nbsp;</a></span>SparseBlockVanka() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseBlockVanka.html">SparseBlockVanka</a>&lt; number &gt;::<a class="el" href="classSparseBlockVanka.html">SparseBlockVanka</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseBlockVanka.html#abb5808d854335ef644940e5925bdc9f0">BlockingStrategy</a>&#160;</td>
          <td class="paramname"><em>blocking_strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Pass all arguments except for <code>n_blocks</code> to the base class. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad3153b46e90a763ffcb18c1b25096e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3153b46e90a763ffcb18c1b25096e7b">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="classSparseBlockVanka.html">SparseBlockVanka</a>&lt; number &gt;::vmult&lt; <a class="el" href="classdouble.html">double</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the preconditioner. </p>

</div>
</div>
<a id="aa7bc4e285829dc632eb4bd60be156a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bc4e285829dc632eb4bd60be156a7f">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classSparseBlockVanka.html">SparseBlockVanka</a>&lt; number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="a8897bf5c46e8f2cbae9c94afed06af41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8897bf5c46e8f2cbae9c94afed06af41">&#9670;&nbsp;</a></span>compute_dof_masks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseBlockVanka.html">SparseBlockVanka</a>&lt; number &gt;::compute_dof_masks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseBlockVanka.html#abb5808d854335ef644940e5925bdc9f0">BlockingStrategy</a>&#160;</td>
          <td class="paramname"><em>blocking_strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the contents of the field <code>dof_masks</code>. This function is called from the constructor. </p>

</div>
</div>
<a id="a6e2ce1949e40a2f6d09fe4d870670988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2ce1949e40a2f6d09fe4d870670988">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseVanka_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the default constructor is used then this function needs to be called before an object of this class is used as preconditioner.</p>
<p>For more detail about possible parameters, see the class documentation and the documentation of the <a class="el" href="classSparseVanka_1_1AdditionalData.html">SparseVanka::AdditionalData</a> class.</p>
<p>After this function is called the preconditioner is ready to be used (using the <code>vmult</code> function of derived classes). </p>

</div>
</div>
<a id="a9244a620a91b61ee03f70edbf2e52ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9244a620a91b61ee03f70edbf2e52ba7">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply transpose preconditioner. This function takes the residual in <code>src</code> and returns the resulting update vector in <code>dst</code>. </p>

</div>
</div>
<a id="a1161f72e2921f4cf53584ddddca91665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1161f72e2921f4cf53584ddddca91665">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a> <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the dimension of the codomain (or range) space. Note that the matrix is of dimension \(m \times n\).</p>
<dl class="section note"><dt>Note</dt><dd>This function should only be called if the preconditioner has been initialized. </dd></dl>

</div>
</div>
<a id="a41b1fb0a899949cc4b31a61dc386ef9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b1fb0a899949cc4b31a61dc386ef9a">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a> <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the dimension of the domain space. Note that the matrix is of dimension \(m \times n\).</p>
<dl class="section note"><dt>Note</dt><dd>This function should only be called if the preconditioner has been initialized. </dd></dl>

</div>
</div>
<a id="ae7569b43f4519137cc98f30ada15e1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7569b43f4519137cc98f30ada15e1ee">&#9670;&nbsp;</a></span>apply_preconditioner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::apply_preconditioner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>dof_mask</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply the inverses corresponding to those degrees of freedom that have a <code>true</code> value in <code>dof_mask</code>, to the <code>src</code> vector and move the result into <code>dst</code>. Actually, only values for allowed indices are written to <code>dst</code>, so the application of this function only does what is announced in the general documentation if the given mask sets all values to zero</p>
<p>The reason for providing the mask anyway is that in derived classes we may want to apply the preconditioner to parts of the matrix only, in order to parallelize the application. Then, it is important to only write to some slices of <code>dst</code>, in order to eliminate the dependencies of threads of each other.</p>
<p>If a null pointer is passed instead of a pointer to the <code>dof_mask</code> (as is the default value), then it is assumed that we shall work on all degrees of freedom. This is then equivalent to calling the function with a <code>vector&lt;bool&gt;(n_dofs,true)</code>.</p>
<p>The <code>vmult</code> of this class of course calls this function with a null pointer </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afd45c7bd085f644e45e541af3822ad00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd45c7bd085f644e45e541af3822ad00">&#9670;&nbsp;</a></span>n_blocks</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classSparseBlockVanka.html">SparseBlockVanka</a>&lt; number &gt;::n_blocks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the number of blocks. </p>

<p class="definition">Definition at line <a class="el" href="sparse__vanka_8h_source.html#l00563">563</a> of file <a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a>.</p>

</div>
</div>
<a id="af50eedb7f428138af6378d798e8ba057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50eedb7f428138af6378d798e8ba057">&#9670;&nbsp;</a></span>dof_masks</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; &gt; <a class="el" href="classSparseBlockVanka.html">SparseBlockVanka</a>&lt; number &gt;::dof_masks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In this field, we precompute for each block which degrees of freedom belong to it. Thus, if <code>dof_masks[i][j]==true</code>, then DoF <code>j</code> belongs to block <code>i</code>. Of course, no other <code>dof_masks[l][j]</code> may be <code>true</code> for <code>l!=i</code>. This computation is done in the constructor, to avoid recomputing each time the preconditioner is called. </p>

<p class="definition">Definition at line <a class="el" href="sparse__vanka_8h_source.html#l00572">572</a> of file <a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a></li>
<li>source/lac/<a class="el" href="sparse__vanka_8cc_source.html">sparse_vanka.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
