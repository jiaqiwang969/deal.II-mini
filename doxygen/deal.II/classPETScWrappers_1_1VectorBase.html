<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classPETScWrappers_1_1VectorBase.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: PETScWrappers::VectorBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacePETScWrappers.html">PETScWrappers</a></li><li class="navelem"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classPETScWrappers_1_1VectorBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PETScWrappers::VectorBase Class Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__PETScWrappers.html">PETScWrappers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="petsc__vector__base_8h_source.html">deal.II/lac/petsc_vector_base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PETScWrappers::VectorBase:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classPETScWrappers_1_1VectorBase__inherit__graph.svg" width="214" height="202"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a49d5cfc5012497c28255604950825729"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a49d5cfc5012497c28255604950825729">value_type</a> = PetscScalar</td></tr>
<tr class="separator:a49d5cfc5012497c28255604950825729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e5b2150479de88863461b40d87a667"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a> = PetscReal</td></tr>
<tr class="separator:ac0e5b2150479de88863461b40d87a667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1b661d8644bd55833ef6e38e0625f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:adf1b661d8644bd55833ef6e38e0625f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5f8fab8b2b2af5ad61b5bfb7915617"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4a5f8fab8b2b2af5ad61b5bfb7915617">reference</a> = internal::VectorReference</td></tr>
<tr class="separator:a4a5f8fab8b2b2af5ad61b5bfb7915617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab282addb9f8950cf5293fc051c607603"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ab282addb9f8950cf5293fc051c607603">const_reference</a> = const internal::VectorReference</td></tr>
<tr class="separator:ab282addb9f8950cf5293fc051c607603"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5e5dc1ea8725d3e51d6249fa22b1d70f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a5e5dc1ea8725d3e51d6249fa22b1d70f">VectorBase</a> ()</td></tr>
<tr class="separator:a5e5dc1ea8725d3e51d6249fa22b1d70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7567a0ee01c37a3f06eaa97442b40f4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a7567a0ee01c37a3f06eaa97442b40f4d">VectorBase</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v)</td></tr>
<tr class="separator:a7567a0ee01c37a3f06eaa97442b40f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f6d7c4850e085271c225c5c19d7502"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a08f6d7c4850e085271c225c5c19d7502">VectorBase</a> (const Vec &amp;v)</td></tr>
<tr class="separator:a08f6d7c4850e085271c225c5c19d7502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9212ce2763d285659f68a73746737231"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a9212ce2763d285659f68a73746737231">operator=</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;)=delete</td></tr>
<tr class="separator:a9212ce2763d285659f68a73746737231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a8401b18494871fac1abf344d02750"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a86a8401b18494871fac1abf344d02750">~VectorBase</a> () override</td></tr>
<tr class="separator:a86a8401b18494871fac1abf344d02750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a42a4b961706fc6f19e34b3d6126f93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a0a42a4b961706fc6f19e34b3d6126f93">clear</a> ()</td></tr>
<tr class="separator:a0a42a4b961706fc6f19e34b3d6126f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6166fa37985a73755a2982af055f1a0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a6166fa37985a73755a2982af055f1a0a">compress</a> (const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:a6166fa37985a73755a2982af055f1a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92be6cd3cb1d72445a2cf580424509ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a92be6cd3cb1d72445a2cf580424509ab">operator=</a> (const PetscScalar s)</td></tr>
<tr class="separator:a92be6cd3cb1d72445a2cf580424509ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ccdc09627c773d69a73d99de626cd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a36ccdc09627c773d69a73d99de626cd7">operator==</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:a36ccdc09627c773d69a73d99de626cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eea41fb4992579fe065a8ab4dfa5dc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a3eea41fb4992579fe065a8ab4dfa5dc5">operator!=</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:a3eea41fb4992579fe065a8ab4dfa5dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3875621a4c149265ca738d48614f053c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a3875621a4c149265ca738d48614f053c">size</a> () const</td></tr>
<tr class="separator:a3875621a4c149265ca738d48614f053c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfc89d53e2a916f1f392255b061cd4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a2dfc89d53e2a916f1f392255b061cd4e">local_size</a> () const</td></tr>
<tr class="separator:a2dfc89d53e2a916f1f392255b061cd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff4e7a74af91a2ab885cf10d0feb961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#acff4e7a74af91a2ab885cf10d0feb961">locally_owned_size</a> () const</td></tr>
<tr class="separator:acff4e7a74af91a2ab885cf10d0feb961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f8ac50f0d9950973f2a9ba11fdb31d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>, <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a59f8ac50f0d9950973f2a9ba11fdb31d">local_range</a> () const</td></tr>
<tr class="separator:a59f8ac50f0d9950973f2a9ba11fdb31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4300ee4284b89549ad2069b69c1aa939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4300ee4284b89549ad2069b69c1aa939">in_local_range</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> index) const</td></tr>
<tr class="separator:a4300ee4284b89549ad2069b69c1aa939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409d3a360896b211e459b9a44ec9b77a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a409d3a360896b211e459b9a44ec9b77a">locally_owned_elements</a> () const</td></tr>
<tr class="separator:a409d3a360896b211e459b9a44ec9b77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac825d05c684a560c996101ad0efef2c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac825d05c684a560c996101ad0efef2c6">has_ghost_elements</a> () const</td></tr>
<tr class="separator:ac825d05c684a560c996101ad0efef2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5916e10c3e54f5080512c3a4c48e0424"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a5916e10c3e54f5080512c3a4c48e0424">update_ghost_values</a> () const</td></tr>
<tr class="separator:a5916e10c3e54f5080512c3a4c48e0424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bddb6f47b5f17a9e681508518a3315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4a5f8fab8b2b2af5ad61b5bfb7915617">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a97bddb6f47b5f17a9e681508518a3315">operator()</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> index)</td></tr>
<tr class="separator:a97bddb6f47b5f17a9e681508518a3315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af780eb49cad222c3db90ef05afd66fde"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#af780eb49cad222c3db90ef05afd66fde">operator()</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> index) const</td></tr>
<tr class="separator:af780eb49cad222c3db90ef05afd66fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1142b659aefd963815ba5db0c92320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4a5f8fab8b2b2af5ad61b5bfb7915617">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#aca1142b659aefd963815ba5db0c92320">operator[]</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> index)</td></tr>
<tr class="separator:aca1142b659aefd963815ba5db0c92320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0c87b6f0920ca7a451c0977f1cd80b"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4e0c87b6f0920ca7a451c0977f1cd80b">operator[]</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> index) const</td></tr>
<tr class="separator:a4e0c87b6f0920ca7a451c0977f1cd80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ada30ff781b62d03117c435cd499d72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a7ada30ff781b62d03117c435cd499d72">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> &gt; &amp;indices, const std::vector&lt; PetscScalar &gt; &amp;values)</td></tr>
<tr class="separator:a7ada30ff781b62d03117c435cd499d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590b9a811e7fb1fd96fc4b749380b1f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a590b9a811e7fb1fd96fc4b749380b1f8">extract_subvector_to</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> &gt; &amp;indices, std::vector&lt; PetscScalar &gt; &amp;values) const</td></tr>
<tr class="separator:a590b9a811e7fb1fd96fc4b749380b1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e43a21a399d5a5e2d85758ec387695"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:af9e43a21a399d5a5e2d85758ec387695"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#af9e43a21a399d5a5e2d85758ec387695">extract_subvector_to</a> (const ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:af9e43a21a399d5a5e2d85758ec387695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a4e50d8cf8b59a13b33a39d240b5ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ab6a4e50d8cf8b59a13b33a39d240b5ca">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> &gt; &amp;indices, const std::vector&lt; PetscScalar &gt; &amp;values)</td></tr>
<tr class="separator:ab6a4e50d8cf8b59a13b33a39d240b5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe79d85af013e56c003b3dfdddcfb41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a9fe79d85af013e56c003b3dfdddcfb41">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> &gt; &amp;indices, const ::<a class="el" href="classVector.html">Vector</a>&lt; PetscScalar &gt; &amp;values)</td></tr>
<tr class="separator:a9fe79d85af013e56c003b3dfdddcfb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09de2357613ea712c747855030124aa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a09de2357613ea712c747855030124aa4">add</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> n_elements, const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> *indices, const PetscScalar *values)</td></tr>
<tr class="separator:a09de2357613ea712c747855030124aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c234d28aff8aa3ab9fdd358e4c9182"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a30c234d28aff8aa3ab9fdd358e4c9182">operator*</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;vec) const</td></tr>
<tr class="separator:a30c234d28aff8aa3ab9fdd358e4c9182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c43e5142dfa22873b0f18d7dc91a4d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a5c43e5142dfa22873b0f18d7dc91a4d1">norm_sqr</a> () const</td></tr>
<tr class="separator:a5c43e5142dfa22873b0f18d7dc91a4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232af54220bbbc75b6d1fcee45bac178"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a232af54220bbbc75b6d1fcee45bac178">mean_value</a> () const</td></tr>
<tr class="separator:a232af54220bbbc75b6d1fcee45bac178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125b9d63e15ae9e3e5fcd90d3cd0fca1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a125b9d63e15ae9e3e5fcd90d3cd0fca1">l1_norm</a> () const</td></tr>
<tr class="separator:a125b9d63e15ae9e3e5fcd90d3cd0fca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6ed136b024aeaedf9e529c29cc208d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#add6ed136b024aeaedf9e529c29cc208d">l2_norm</a> () const</td></tr>
<tr class="separator:add6ed136b024aeaedf9e529c29cc208d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9d8151b66561ccb1b5c43f509d39cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a0f9d8151b66561ccb1b5c43f509d39cf">lp_norm</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a> p) const</td></tr>
<tr class="separator:a0f9d8151b66561ccb1b5c43f509d39cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9762fc464702fa826eaff4df3779d482"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a9762fc464702fa826eaff4df3779d482">linfty_norm</a> () const</td></tr>
<tr class="separator:a9762fc464702fa826eaff4df3779d482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8412866d0e82feca003db88e061e5fe1"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a8412866d0e82feca003db88e061e5fe1">add_and_dot</a> (const PetscScalar a, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;W)</td></tr>
<tr class="separator:a8412866d0e82feca003db88e061e5fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8235403dad66e00479cca97c2f4b582c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a8235403dad66e00479cca97c2f4b582c">min</a> () const</td></tr>
<tr class="separator:a8235403dad66e00479cca97c2f4b582c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9e8e45afd7b28ffc5723e246f81016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a8c9e8e45afd7b28ffc5723e246f81016">max</a> () const</td></tr>
<tr class="separator:a8c9e8e45afd7b28ffc5723e246f81016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec2cdeb7089bd58e911d1f3f24d633a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#afec2cdeb7089bd58e911d1f3f24d633a">all_zero</a> () const</td></tr>
<tr class="separator:afec2cdeb7089bd58e911d1f3f24d633a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d76f674c4699ece5dc1107d3403aaac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4d76f674c4699ece5dc1107d3403aaac">is_non_negative</a> () const</td></tr>
<tr class="separator:a4d76f674c4699ece5dc1107d3403aaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37900779c6049418c39bacc1d44f4260"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a37900779c6049418c39bacc1d44f4260">operator*=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:a37900779c6049418c39bacc1d44f4260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4beb21a67a1231346876c5d49ebc0c4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4beb21a67a1231346876c5d49ebc0c4d">operator/=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:a4beb21a67a1231346876c5d49ebc0c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2108fd9efd4f35d17accfa3c8d52e71c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a2108fd9efd4f35d17accfa3c8d52e71c">operator+=</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V)</td></tr>
<tr class="separator:a2108fd9efd4f35d17accfa3c8d52e71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad576803857b394e28549db2cff5128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a3ad576803857b394e28549db2cff5128">operator-=</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V)</td></tr>
<tr class="separator:a3ad576803857b394e28549db2cff5128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39aacc8d16d324843f85134bb0c1675f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a39aacc8d16d324843f85134bb0c1675f">add</a> (const PetscScalar s)</td></tr>
<tr class="separator:a39aacc8d16d324843f85134bb0c1675f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2822cc5fab76c09476de60e8d7816c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ab2822cc5fab76c09476de60e8d7816c9">add</a> (const PetscScalar a, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V)</td></tr>
<tr class="separator:ab2822cc5fab76c09476de60e8d7816c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab508c4a8bbd65a945e7a0e5fcf3012c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ab508c4a8bbd65a945e7a0e5fcf3012c0">add</a> (const PetscScalar a, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V, const PetscScalar b, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;W)</td></tr>
<tr class="separator:ab508c4a8bbd65a945e7a0e5fcf3012c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a614d48c2a904e8337025706c644433"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a5a614d48c2a904e8337025706c644433">sadd</a> (const PetscScalar s, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V)</td></tr>
<tr class="separator:a5a614d48c2a904e8337025706c644433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7a9c7bf865040f5b76ec2d7a8ac3ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a0d7a9c7bf865040f5b76ec2d7a8ac3ff">sadd</a> (const PetscScalar s, const PetscScalar a, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V)</td></tr>
<tr class="separator:a0d7a9c7bf865040f5b76ec2d7a8ac3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57deb429a909bfa17e885ca20660f521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a57deb429a909bfa17e885ca20660f521">scale</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;scaling_factors)</td></tr>
<tr class="separator:a57deb429a909bfa17e885ca20660f521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80e009e532257f82980c49b70072018"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ad80e009e532257f82980c49b70072018">equ</a> (const PetscScalar a, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V)</td></tr>
<tr class="separator:ad80e009e532257f82980c49b70072018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf51494f6194764f1a0a32e97d59fb1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#abf51494f6194764f1a0a32e97d59fb1b">write_ascii</a> (const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="separator:abf51494f6194764f1a0a32e97d59fb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cf90be057a118177276a61b128d6df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a80cf90be057a118177276a61b128d6df">print</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const</td></tr>
<tr class="separator:a80cf90be057a118177276a61b128d6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab185a8ff0370c08fab553ba1e75194c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ab185a8ff0370c08fab553ba1e75194c3">swap</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v)</td></tr>
<tr class="separator:ab185a8ff0370c08fab553ba1e75194c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5e08d408ee79da10cceb7642bfa1da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ade5e08d408ee79da10cceb7642bfa1da">operator const Vec &amp;</a> () const</td></tr>
<tr class="separator:ade5e08d408ee79da10cceb7642bfa1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cd6e2cf47c7d44cbcbb9bdd44613fd"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a49cd6e2cf47c7d44cbcbb9bdd44613fd">memory_consumption</a> () const</td></tr>
<tr class="separator:a49cd6e2cf47c7d44cbcbb9bdd44613fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50ff45e9b33ed8020bc953ed1a61415"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ae50ff45e9b33ed8020bc953ed1a61415">get_mpi_communicator</a> () const</td></tr>
<tr class="separator:ae50ff45e9b33ed8020bc953ed1a61415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ada190205c9e3a51bba688969b5846eeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ada190205c9e3a51bba688969b5846eeb">do_set_add_operation</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> n_elements, const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> *indices, const PetscScalar *values, const <a class="el" href="classbool.html">bool</a> add_values)</td></tr>
<tr class="separator:ada190205c9e3a51bba688969b5846eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3a337ca41046f9e87ae2b4459e1e8a38"><td class="memItemLeft" align="right" valign="top">Vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a3a337ca41046f9e87ae2b4459e1e8a38">vector</a></td></tr>
<tr class="separator:a3a337ca41046f9e87ae2b4459e1e8a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afd34f59a5c4f754fa32a6f69e110b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a2afd34f59a5c4f754fa32a6f69e110b3">ghosted</a></td></tr>
<tr class="separator:a2afd34f59a5c4f754fa32a6f69e110b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0fa32597e5faa4ceb51bc7eb5c06ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a2c0fa32597e5faa4ceb51bc7eb5c06ad">ghost_indices</a></td></tr>
<tr class="separator:a2c0fa32597e5faa4ceb51bc7eb5c06ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7c95d791d77dcc89aecf77bd91251e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a2e7c95d791d77dcc89aecf77bd91251e">last_action</a></td></tr>
<tr class="separator:a2e7c95d791d77dcc89aecf77bd91251e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554f19155de441313cd0931c4faa5d6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a554f19155de441313cd0931c4faa5d6b">obtained_ownership</a></td></tr>
<tr class="separator:a554f19155de441313cd0931c4faa5d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4d77f4705993156218463a6698808bca"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4d77f4705993156218463a6698808bca">internal::VectorReference</a></td></tr>
<tr class="separator:a4d77f4705993156218463a6698808bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:af0dd3dea1d8fea889513f82bbe5d7f35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1VectorBase.html#af0dd3dea1d8fea889513f82bbe5d7f35">swap</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;u, <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v)</td></tr>
<tr class="separator:af0dd3dea1d8fea889513f82bbe5d7f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>所有在PETSc向量类型之上实现的向量类的基类。由于在PETSc中，所有的向量类型（即顺序和平行的）都是通过填充一个抽象对象的内容来建立的，而这个抽象对象只能通过一个独立于实际向量类型的指针来引用，所以我们可以在这个基类中实现几乎所有的向量功能。因此，这个类也可以作为任何类型的PETSc <code>Vec</code> 对象的deal.II兼容包装器使用。派生类将只需要提供创建一种或另一种矢量的功能。 这个类的接口是以deal.II中现有的Vector类为模型的。它有几乎相同的成员函数，并且通常是可交换的。然而，由于PETSc只支持单一的标量类型（要么是double，要么是float，要么是一个复杂的数据类型），所以它没有模板化，只能与你的PETSc安装时定义的数据类型 <code>PetscScalar</code> 一起工作。 请注意，只有在向量装配后调用了 <code>VecAssemblyBegin</code> 和 <code>VecAssemblyEnd</code> 这两个函数，PETSc才能保证操作符合你的期望。因此，你需要在实际使用矢量之前调用 <a class="el" href="classVector.html#a8740c5534b6dbc31f4f1503a5e2a10a3">Vector::compress()</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00243">243</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a49d5cfc5012497c28255604950825729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d5cfc5012497c28255604950825729">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1VectorBase.html#a49d5cfc5012497c28255604950825729">PETScWrappers::VectorBase::value_type</a> =  PetscScalar</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明一些在所有容器中使用的标准类型。这些类型与<code>C++</code>标准库<code><a class="el" href="classPETScWrappers_1_1VectorBase.html#a3a337ca41046f9e87ae2b4459e1e8a38">vector&lt;...&gt;</a></code>类中的类型平行。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00250">250</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="ac0e5b2150479de88863461b40d87a667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e5b2150479de88863461b40d87a667">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">PETScWrappers::VectorBase::real_type</a> =  PetscReal</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00251">251</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="adf1b661d8644bd55833ef6e38e0625f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1b661d8644bd55833ef6e38e0625f5">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">PETScWrappers::VectorBase::size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00252">252</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="a4a5f8fab8b2b2af5ad61b5bfb7915617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5f8fab8b2b2af5ad61b5bfb7915617">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1VectorBase.html#a4a5f8fab8b2b2af5ad61b5bfb7915617">PETScWrappers::VectorBase::reference</a> =  internal::VectorReference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00253">253</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="ab282addb9f8950cf5293fc051c607603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab282addb9f8950cf5293fc051c607603">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1VectorBase.html#ab282addb9f8950cf5293fc051c607603">PETScWrappers::VectorBase::const_reference</a> =  const internal::VectorReference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00254">254</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5e5dc1ea8725d3e51d6249fa22b1d70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5dc1ea8725d3e51d6249fa22b1d70f">&#9670;&nbsp;</a></span>VectorBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::VectorBase::VectorBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>默认构造函数。它不做任何事情，派生类将不得不初始化数据。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00116">116</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a7567a0ee01c37a3f06eaa97442b40f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7567a0ee01c37a3f06eaa97442b40f4d">&#9670;&nbsp;</a></span>VectorBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::VectorBase::VectorBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制构造函数。将维度设置为给定的向量，并复制所有元素。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00129">129</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a08f6d7c4850e085271c225c5c19d7502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f6d7c4850e085271c225c5c19d7502">&#9670;&nbsp;</a></span>VectorBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::VectorBase::VectorBase </td>
          <td>(</td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一个PETSc Vec对象初始化一个向量。注意，我们没有复制向量，也没有获得所有权，所以我们没有在析构函数中销毁PETSc对象。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00149">149</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a86a8401b18494871fac1abf344d02750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a8401b18494871fac1abf344d02750">&#9670;&nbsp;</a></span>~VectorBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::VectorBase::~VectorBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解构器。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00163">163</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9212ce2763d285659f68a73746737231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9212ce2763d285659f68a73746737231">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a>&amp; PETScWrappers::VectorBase::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>删除了复制赋值运算符，以避免意外的使用带来意外的行为。 </p>

</div>
</div>
<a id="a0a42a4b961706fc6f19e34b3d6126f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a42a4b961706fc6f19e34b3d6126f93">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>释放所有内存并返回到与调用默认构造函数后相同的状态。 </p>

<p>Reimplemented in <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a99916352f41d79dd048ccd00132a34b2">PETScWrappers::MPI::Vector</a>.</p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00176">176</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a6166fa37985a73755a2982af055f1a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6166fa37985a73755a2982af055f1a0a">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::compress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>压缩PETSc对象的底层表示，即刷新矢量对象的缓冲区（如果它有的话）。这个函数在逐一写入矢量元素后，在对其进行任何其他操作之前是必要的。 更多信息请参见 <a class="el" href="DEALGlossary.html#GlossCompress">压缩分布式对象</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00373">373</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a92be6cd3cb1d72445a2cf580424509ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92be6cd3cb1d72445a2cf580424509ab">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp; PETScWrappers::VectorBase::operator= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将向量的所有分量设置为给定的数字 <code>s</code>. 只需将其传递给各个块对象，但我们仍然需要声明这个函数，以使讨论中给出的关于使构造函数显式的例子发挥作用。 由于将标量分配给向量的语义并不立即明确，这个操作符实际上应该只在你想将整个向量设置为零时才使用。这样就可以使用直观的符号<code>v=0</code>。赋予其他的值是被弃用的，将来可能会被禁止使用。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00193">193</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a36ccdc09627c773d69a73d99de626cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ccdc09627c773d69a73d99de626cd7">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::VectorBase::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>检验是否相等。这个函数假定现在的向量和要比较的向量已经有相同的大小，因为比较不同大小的向量反正没有什么意义。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00221">221</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a3eea41fb4992579fe065a8ab4dfa5dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eea41fb4992579fe065a8ab4dfa5dc5">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::VectorBase::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>测试不平等。这个函数假定现在的向量和要比较的向量已经有相同的大小，因为比较不同大小的向量反正没有什么意义。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00235">235</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a3875621a4c149265ca738d48614f053c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3875621a4c149265ca738d48614f053c">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">VectorBase::size_type</a> PETScWrappers::VectorBase::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量的全局尺寸。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00249">249</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a2dfc89d53e2a916f1f392255b061cd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfc89d53e2a916f1f392255b061cd4e">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">VectorBase::size_type</a> PETScWrappers::VectorBase::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量的局部尺寸，即存储在当前MPI进程中的元素数量。对于顺序向量，这个数字与size()相同，但对于并行向量，它可能更小。 要想知道到底哪些元素是存储在本地的，可以使用local_range()或local_owned_elements()。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000050">Deprecated:</a></b></dt><dd>用local_owned_size()代替。</dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00273">273</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="acff4e7a74af91a2ab885cf10d0feb961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff4e7a74af91a2ab885cf10d0feb961">&#9670;&nbsp;</a></span>locally_owned_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">VectorBase::size_type</a> PETScWrappers::VectorBase::locally_owned_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量的本地维度，即存储在当前MPI进程中的元素数量。对于顺序向量，这个数字与size()相同，但对于并行向量，它可能更小。 要想知道哪些元素确切地存储在本地，可以使用local_range()或local_owned_elements()。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00261">261</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a59f8ac50f0d9950973f2a9ba11fdb31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f8ac50f0d9950973f2a9ba11fdb31d">&#9670;&nbsp;</a></span>local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">VectorBase::size_type</a>, <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">VectorBase::size_type</a> &gt; PETScWrappers::VectorBase::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一对指数，表明该向量的哪些元素被存储在本地。第一个数字是存储的第一个元素的索引，第二个数字是本地存储的最后一个元素之后的索引。如果这是一个顺序向量，那么结果将是一对（0,N），否则将是一对（i,i+n），其中<code>n=<a class="el" href="classPETScWrappers_1_1VectorBase.html#acff4e7a74af91a2ab885cf10d0feb961">locally_owned_size()</a></code>。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00285">285</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a4300ee4284b89549ad2069b69c1aa939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4300ee4284b89549ad2069b69c1aa939">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::VectorBase::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回 <code>index</code> 是否在本地范围内，另见local_range()。 </p>

</div>
</div>
<a id="a409d3a360896b211e459b9a44ec9b77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409d3a360896b211e459b9a44ec9b77a">&#9670;&nbsp;</a></span>locally_owned_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> PETScWrappers::VectorBase::locally_owned_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个索引集，描述这个向量的哪些元素是由当前处理器拥有的。请注意，这个索引集不包括这个向量可能在本地存储为幽灵元素，但实际上是由另一个处理器拥有的元素。因此，如果这是一个分布式向量，在不同处理器上返回的索引集将形成不相交的集合，加起来就是完整的索引集。 很明显，如果一个向量只在一个处理器上创建，那么结果将满足 </p><div class="fragment"><div class="line">vec.locally_owned_elements() == <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a> (vec.size())</div></div><!-- fragment --> 
</div>
</div>
<a id="ac825d05c684a560c996101ad0efef2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac825d05c684a560c996101ad0efef2c6">&#9670;&nbsp;</a></span>has_ghost_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::VectorBase::has_ghost_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果向量包含鬼魂元素，则返回。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">含有鬼魂元素的向量</a> </dd></dl>

</div>
</div>
<a id="a5916e10c3e54f5080512c3a4c48e0424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5916e10c3e54f5080512c3a4c48e0424">&#9670;&nbsp;</a></span>update_ghost_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::update_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数的存在只是为了与 <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a></code> 类兼容，并不做任何事情：这个类以不同的方式实现鬼魂值的更新，与底层的PETSc向量对象更加匹配。 </p>

</div>
</div>
<a id="a97bddb6f47b5f17a9e681508518a3315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97bddb6f47b5f17a9e681508518a3315">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4a5f8fab8b2b2af5ad61b5bfb7915617">reference</a> PETScWrappers::VectorBase::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提供对一个给定元素的访问，包括读和写。 </p>

</div>
</div>
<a id="af780eb49cad222c3db90ef05afd66fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af780eb49cad222c3db90ef05afd66fde">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::VectorBase::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提供对一个元素的只读访问。 </p>

</div>
</div>
<a id="aca1142b659aefd963815ba5db0c92320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1142b659aefd963815ba5db0c92320">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#a4a5f8fab8b2b2af5ad61b5bfb7915617">reference</a> PETScWrappers::VectorBase::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提供对一个给定元素的访问，包括读和写。 与operator()完全相同。 </p>

</div>
</div>
<a id="a4e0c87b6f0920ca7a451c0977f1cd80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0c87b6f0920ca7a451c0977f1cd80b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::VectorBase::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提供对一个元素的只读访问。 与operator()完全相同。 </p>

</div>
</div>
<a id="a7ada30ff781b62d03117c435cd499d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ada30ff781b62d03117c435cd499d72">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个集体的设置操作：这个函数允许一次性设置整个元素集，而不是设置一个向量的单个元素。 要设置的元素的索引在第一个参数中说明，相应的值在第二个参数中说明。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00298">298</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a590b9a811e7fb1fd96fc4b749380b1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590b9a811e7fb1fd96fc4b749380b1f8">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与通过operator()获取向量中的单个元素不同，这个函数允许一次性获取一整组元素。要读取的元素的索引在第一个参数中说明，相应的值在第二个参数中返回。 如果当前的向量被称为 <code>v</code>, ，那么这个函数就等同于代码 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;indices.size(); ++i)</div><div class="line">  <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>[i] = v[indices[i]];</div></div><!-- fragment --> <dl class="section pre"><dt>Precondition</dt><dd><code>indices</code> 和 <code>values</code> 数组的大小必须是一致的。 </dd></dl>

</div>
</div>
<a id="af9e43a21a399d5a5e2d85758ec387695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e43a21a399d5a5e2d85758ec387695">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>values_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数不是通过operator()获得向量的单个元素，而是允许一次获得整个元素集。与前一个函数不同的是，这个函数通过取消引用前两个参数提供的迭代器范围内的所有元素来获得元素的索引，并将向量的值放入通过取消引用从第三个参数指向的位置开始的迭代器范围获得的内存位置。 如果当前的向量被称为 <code>v</code>, ，那么这个函数就等同于代码 </p><div class="fragment"><div class="line">ForwardIterator indices_p = indices_begin;</div><div class="line">OutputIterator  values_p  = values_begin;</div><div class="line"><span class="keywordflow">while</span> (indices_p != indices_end)</div><div class="line">{</div><div class="line"> values_p = v[*indices_p];</div><div class="line">  ++indices_p;</div><div class="line">  ++values_p;</div><div class="line">}</div></div><!-- fragment --> <dl class="section pre"><dt>Precondition</dt><dd>必须能够写进从 <code>values_begin</code> 开始的尽可能多的内存位置，因为有 <code>indices_begin</code> 和 <code>indices_end</code>. 之间的迭代器。 </dd></dl>

</div>
</div>
<a id="ab6a4e50d8cf8b59a13b33a39d240b5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a4e50d8cf8b59a13b33a39d240b5ca">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个集体的添加操作。这个函数将存储在 <code>values</code> 中的一整组值添加到 <code>indices</code>. 指定的向量成分中。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00309">309</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a9fe79d85af013e56c003b3dfdddcfb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe79d85af013e56c003b3dfdddcfb41">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classVector.html">Vector</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这是第二次集体添加操作。作为区别，这个函数需要一个deal.II的数值向量。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00320">320</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a09de2357613ea712c747855030124aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09de2357613ea712c747855030124aa4">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>取一个<code>n_elements</code>连续存储的地址，并将其添加到向量中。处理上述其他两个<code><a class="el" href="classPETScWrappers_1_1VectorBase.html#ab6a4e50d8cf8b59a13b33a39d240b5ca">add()</a></code>函数未涵盖的所有情况。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00331">331</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a30c234d28aff8aa3ab9fdd358e4c9182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c234d28aff8aa3ab9fdd358e4c9182">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::VectorBase::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回两个向量的标量乘积。这两个向量必须有相同的大小。 对于复值向量，这将得到 \(\left(v^\ast,vec\right)\) 。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00340">340</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a5c43e5142dfa22873b0f18d7dc91a4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c43e5142dfa22873b0f18d7dc91a4d1">&#9670;&nbsp;</a></span>norm_sqr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">VectorBase::real_type</a> PETScWrappers::VectorBase::norm_sqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回 \(l_2\) -norm的平方。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00433">433</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a232af54220bbbc75b6d1fcee45bac178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232af54220bbbc75b6d1fcee45bac178">&#9670;&nbsp;</a></span>mean_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::VectorBase::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个向量的元素的平均值。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00442">442</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a125b9d63e15ae9e3e5fcd90d3cd0fca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125b9d63e15ae9e3e5fcd90d3cd0fca1">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">VectorBase::real_type</a> PETScWrappers::VectorBase::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>该向量的 \(l_1\) -norm。绝对值的总和。 </p><dl class="section note"><dt>Note</dt><dd>在3.7.0以前的复值PETSc中，这个规范被实现为复数向量元素的实部和虚部的绝对值之和。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00493">493</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="add6ed136b024aeaedf9e529c29cc208d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6ed136b024aeaedf9e529c29cc208d">&#9670;&nbsp;</a></span>l2_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">VectorBase::real_type</a> PETScWrappers::VectorBase::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_2\) - 矢量的规范。 各元素的平方根之和。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00506">506</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a0f9d8151b66561ccb1b5c43f509d39cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9d8151b66561ccb1b5c43f509d39cf">&#9670;&nbsp;</a></span>lp_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">VectorBase::real_type</a> PETScWrappers::VectorBase::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">real_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>元素绝对值的p次方之和的p次根。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00519">519</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a9762fc464702fa826eaff4df3779d482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9762fc464702fa826eaff4df3779d482">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">VectorBase::real_type</a> PETScWrappers::VectorBase::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_\infty\) -向量的规范。返回具有最大绝对值的向量元素的值。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00561">561</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a8412866d0e82feca003db88e061e5fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8412866d0e82feca003db88e061e5fe1">&#9670;&nbsp;</a></span>add_and_dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::VectorBase::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>执行一个矢量加法和后续内积的组合操作，返回内积的值。换句话说，这个函数的结果与用户调用 </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="classPETScWrappers_1_1VectorBase.html#ab6a4e50d8cf8b59a13b33a39d240b5ca">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div><div class="line">return_value =<span class="keyword">this</span> W;</div></div><!-- fragment --><p> 这个函数存在的原因是为了与deal.II自己的向量类兼容，后者可以用较少的内存传输实现这个功能。然而，对于PETSc向量来说，这样的组合操作是不被原生支持的，因此其代价完全等同于单独调用这两个方法。 对于复值向量，第二步中的标量乘积被实现为 \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\) . </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00362">362</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a8235403dad66e00479cca97c2f4b582c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8235403dad66e00479cca97c2f4b582c">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">VectorBase::real_type</a> PETScWrappers::VectorBase::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回具有最大负值的向量元素的值。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000051">Deprecated:</a></b></dt><dd>为了提高与其他继承自VectorSpaceVector的类的兼容性，这个函数已经被废弃。如果你需要使用这个功能，那么请使用PETSc函数VecMin代替。</dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00574">574</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a8c9e8e45afd7b28ffc5723e246f81016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9e8e45afd7b28ffc5723e246f81016">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html#ac0e5b2150479de88863461b40d87a667">VectorBase::real_type</a> PETScWrappers::VectorBase::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回具有最大正值的向量元素的值。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000052">Deprecated:</a></b></dt><dd>这个函数已经被废弃，以提高与其他继承自VectorSpaceVector的类的兼容性。如果你需要使用这个功能，那么请使用PETSc函数VecMax代替。</dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00587">587</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="afec2cdeb7089bd58e911d1f3f24d633a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec2cdeb7089bd58e911d1f3f24d633a">&#9670;&nbsp;</a></span>all_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::VectorBase::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量是否只包含值为0的元素。这是一个集体操作。这个函数很昂贵，因为可能所有的元素都要被检查。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00601">601</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a4d76f674c4699ece5dc1107d3403aaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d76f674c4699ece5dc1107d3403aaac">&#9670;&nbsp;</a></span>is_non_negative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::VectorBase::is_non_negative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果向量没有负的条目，即所有条目都是零或正，则返回 <code>true</code> 。例如，这个函数用于检查细化指标是否真的都是正的（或零）。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000053">Deprecated:</a></b></dt><dd>这个函数已经被废弃，以改善与其他继承自VectorSpaceVector的类的兼容性。</dd></dl>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00655">655</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a37900779c6049418c39bacc1d44f4260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37900779c6049418c39bacc1d44f4260">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp; PETScWrappers::VectorBase::operator*= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将整个向量乘以一个固定的因子。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00687">687</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a4beb21a67a1231346876c5d49ebc0c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4beb21a67a1231346876c5d49ebc0c4d">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp; PETScWrappers::VectorBase::operator/= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将整个向量除以一个固定的因子。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00701">701</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a2108fd9efd4f35d17accfa3c8d52e71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2108fd9efd4f35d17accfa3c8d52e71c">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp; PETScWrappers::VectorBase::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的向量添加到当前的向量中。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00718">718</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a3ad576803857b394e28549db2cff5128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad576803857b394e28549db2cff5128">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp; PETScWrappers::VectorBase::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从现在的向量中减去给定的向量。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00730">730</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a39aacc8d16d324843f85134bb0c1675f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39aacc8d16d324843f85134bb0c1675f">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::add </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将 <code>s</code> 加到所有组件上。注意 <code>s</code> 是一个标量而不是一个向量。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00742">742</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="ab2822cc5fab76c09476de60e8d7816c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2822cc5fab76c09476de60e8d7816c9">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::add </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个向量的倍数的简单加法，即<code>*this += a*V</code>。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00754">754</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="ab508c4a8bbd65a945e7a0e5fcf3012c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab508c4a8bbd65a945e7a0e5fcf3012c0">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::add </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>缩放向量的多重加法，即：<code>*this += a*V+b*W</code>。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00766">766</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a5a614d48c2a904e8337025706c644433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a614d48c2a904e8337025706c644433">&#9670;&nbsp;</a></span>sadd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::sadd </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>缩放和简单的向量相加，即<code>*this = s*(*this)+V</code>。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00785">785</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a0d7a9c7bf865040f5b76ec2d7a8ac3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7a9c7bf865040f5b76ec2d7a8ac3ff">&#9670;&nbsp;</a></span>sadd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::sadd </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>缩放和简单加法，即：<code>*this = s*(*this)+a*V</code>。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00797">797</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a57deb429a909bfa17e885ca20660f521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57deb429a909bfa17e885ca20660f521">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用参数中的相应元素来缩放这个向量的每个元素。这个函数主要是为了模拟对角线缩放矩阵的乘法（和立即重新分配）。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00815">815</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="ad80e009e532257f82980c49b70072018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80e009e532257f82980c49b70072018">&#9670;&nbsp;</a></span>equ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::equ </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>赋值 <code>*this = a*V</code>. </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00825">825</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="abf51494f6194764f1a0a32e97d59fb1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf51494f6194764f1a0a32e97d59fb1b">&#9670;&nbsp;</a></span>write_ascii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::write_ascii </td>
          <td>(</td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用PETSc内部矢量查看器函数<code>VecView</code>打印PETSc矢量对象的值。默认格式是打印矢量的内容，包括矢量元素的索引。对于其他有效的视图格式，请参考http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecView.html </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00844">844</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a80cf90be057a118177276a61b128d6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cf90be057a118177276a61b128d6df">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印到一个流。 <code>precision</code> 表示打印数值所需的精度， <code>scientific</code> 是否应使用科学符号。如果 <code>across</code> 是 <code>true</code> ，那么向量将被打印在一行中，而如果 <code>false</code> 则元素被打印在单独的一行中。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00861">861</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="ab185a8ff0370c08fab553ba1e75194c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab185a8ff0370c08fab553ba1e75194c3">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>交换这个向量和另一个向量的内容 <code>v</code>. 人们可以用一个临时变量和复制数据元素来完成这个操作，但是这个函数明显更有效率，因为它只交换了两个向量的数据指针，因此不需要分配临时存储和移动数据。 这个函数类似于所有C++标准容器的 <code>swap</code> 函数。此外，还有一个全局函数<code>swap(u,v)</code>，它简单地调用<code>u.swap(v)</code>，同样与标准函数相类似。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00908">908</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="ade5e08d408ee79da10cceb7642bfa1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5e08d408ee79da10cceb7642bfa1da">&#9670;&nbsp;</a></span>operator const Vec &()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::VectorBase::operator const Vec &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>转换操作符，以获得对底层PETSc类型的访问。如果你这样做，你就切断了这个类可能需要的一些信息，所以这个转换操作符应该只在你知道你要做什么的情况下使用。特别是，它应该只用于对向量的只读操作。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00916">916</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a49cd6e2cf47c7d44cbcbb9bdd44613fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49cd6e2cf47c7d44cbcbb9bdd44613fd">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t PETScWrappers::VectorBase::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对内存消耗的估计（这个类没有实现）。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00923">923</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="ae50ff45e9b33ed8020bc953ed1a61415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50ff45e9b33ed8020bc953ed1a61415">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&amp; PETScWrappers::VectorBase::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对与此对象一起使用的MPI通信器对象的引用。 </p>

<p>Reimplemented in <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html#a2be39fc0c5574e3c314d8a356b267bef">PETScWrappers::MPI::Vector</a>.</p>

</div>
</div>
<a id="ada190205c9e3a51bba688969b5846eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada190205c9e3a51bba688969b5846eeb">&#9670;&nbsp;</a></span>do_set_add_operation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::VectorBase::do_set_add_operation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html#adf1b661d8644bd55833ef6e38e0625f5">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>add_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>集合设置或添加操作。这个函数由集体 <code>set</code> 和 <code>add</code> 调用， <code>add_values</code> 标志设置为相应的值。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8cc_source.html#l00945">945</a> of file <a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a4d77f4705993156218463a6698808bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d77f4705993156218463a6698808bca">&#9670;&nbsp;</a></span>internal::VectorReference</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::VectorReference</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00759">759</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="af0dd3dea1d8fea889513f82bbe5d7f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0dd3dea1d8fea889513f82bbe5d7f35">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>全局函数 <code>swap</code> ，它重载了C++标准库的默认实现，它使用一个临时对象。该函数简单地交换了两个向量的数据。</p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00791">791</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3a337ca41046f9e87ae2b4459e1e8a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a337ca41046f9e87ae2b4459e1e8a38">&#9670;&nbsp;</a></span>vector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vec PETScWrappers::VectorBase::vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个PETSc中的通用向量对象。实际的类型，一个连续的向量，在构造函数中被设置。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00736">736</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="a2afd34f59a5c4f754fa32a6f69e110b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afd34f59a5c4f754fa32a6f69e110b3">&#9670;&nbsp;</a></span>ghosted</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::VectorBase::ghosted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>表示这个向量是否有与之相关的鬼魂索引。这意味着并行程序中至少有一个进程有至少一个幽灵索引。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00742">742</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="a2c0fa32597e5faa4ceb51bc7eb5c06ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0fa32597e5faa4ceb51bc7eb5c06ad">&#9670;&nbsp;</a></span>ghost_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> PETScWrappers::VectorBase::ghost_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个向量包含鬼魂值的全局索引。这个向量中的位置表示本地编号，在PETSc中使用。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00748">748</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="a2e7c95d791d77dcc89aecf77bd91251e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7c95d791d77dcc89aecf77bd91251e">&#9670;&nbsp;</a></span>last_action</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> PETScWrappers::VectorBase::last_action</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储最后一个动作是写操作还是加操作。这个变量是 <code>mutable</code> ，这样访问器类就可以写到它，即使它们引用的向量对象是常量。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00756">756</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<a id="a554f19155de441313cd0931c4faa5d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554f19155de441313cd0931c4faa5d6b">&#9670;&nbsp;</a></span>obtained_ownership</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::VectorBase::obtained_ownership</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指定该向量是否是PETSc Vec的所有者。如果它是由这个类创建的，这就是真的，并决定它是否在析构器中被销毁。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__vector__base_8h_source.html#l00766">766</a> of file <a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="petsc__vector__base_8h_source.html">petsc_vector_base.h</a></li>
<li>source/lac/<a class="el" href="petsc__vector__base_8cc_source.html">petsc_vector_base.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
