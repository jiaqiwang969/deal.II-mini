<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceMemoryConsumption.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MemoryConsumption Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MemoryConsumption Namespace Reference<div class="ingroups"><a class="el" href="group__utilities.html">Utility functions and classes</a> &raquo; <a class="el" href="group__memory.html">Memory handling</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8e4965ba9955f1523ca5f3d80ade65db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e4965ba9955f1523ca5f3d80ade65db"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_fundamental&lt; T &gt;::value, std::size_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMemoryConsumption.html#a8e4965ba9955f1523ca5f3d80ade65db">memory_consumption</a> (const T &amp;t)</td></tr>
<tr class="separator:a8e4965ba9955f1523ca5f3d80ade65db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9a62906f4c2c79f39f27a90b68b6f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba9a62906f4c2c79f39f27a90b68b6f7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!(std::is_fundamental&lt; T &gt;::value||std::is_pointer&lt; T &gt;::value), std::size_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMemoryConsumption.html#aba9a62906f4c2c79f39f27a90b68b6f7">memory_consumption</a> (const T &amp;t)</td></tr>
<tr class="separator:aba9a62906f4c2c79f39f27a90b68b6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8bf98d150e2c9dc7cb70f5b9494fef1"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMemoryConsumption.html#aa8bf98d150e2c9dc7cb70f5b9494fef1">memory_consumption</a> (const char *string)</td></tr>
<tr class="separator:aa8bf98d150e2c9dc7cb70f5b9494fef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433124a92b29d21d42aec93ff5748a62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a433124a92b29d21d42aec93ff5748a62"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMemoryConsumption.html#a433124a92b29d21d42aec93ff5748a62">memory_consumption</a> (const std::complex&lt; T &gt; &amp;)</td></tr>
<tr class="separator:a433124a92b29d21d42aec93ff5748a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc11d1706f6a1773d2f49b66cd623efa"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t width&gt; </td></tr>
<tr class="memitem:adc11d1706f6a1773d2f49b66cd623efa"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMemoryConsumption.html#adc11d1706f6a1773d2f49b66cd623efa">memory_consumption</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; T, width &gt; &amp;)</td></tr>
<tr class="separator:adc11d1706f6a1773d2f49b66cd623efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b2ac1b07d121e30d5ad1208532a2d5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMemoryConsumption.html#ae9b2ac1b07d121e30d5ad1208532a2d5">memory_consumption</a> (const std::string &amp;s)</td></tr>
<tr class="separator:ae9b2ac1b07d121e30d5ad1208532a2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531f112b004582d4c8a15d9ea3491901"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a531f112b004582d4c8a15d9ea3491901"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMemoryConsumption.html#a531f112b004582d4c8a15d9ea3491901">memory_consumption</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a531f112b004582d4c8a15d9ea3491901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac524143723c2ff979d4b8c849e8dc731"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ac524143723c2ff979d4b8c849e8dc731"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMemoryConsumption.html#ac524143723c2ff979d4b8c849e8dc731">memory_consumption</a> (const std::array&lt; T, N &gt; &amp;v)</td></tr>
<tr class="separator:ac524143723c2ff979d4b8c849e8dc731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83459028fe7e73ba532208aaeff63f5a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a83459028fe7e73ba532208aaeff63f5a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMemoryConsumption.html#a83459028fe7e73ba532208aaeff63f5a">memory_consumption</a> (const T(&amp;v)[N])</td></tr>
<tr class="separator:a83459028fe7e73ba532208aaeff63f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3169b806266ca169ac2bcb57dcd13695"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMemoryConsumption.html#a3169b806266ca169ac2bcb57dcd13695">memory_consumption</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a3169b806266ca169ac2bcb57dcd13695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02309d459f5627d7fd8b0109000f586"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:af02309d459f5627d7fd8b0109000f586"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMemoryConsumption.html#af02309d459f5627d7fd8b0109000f586">memory_consumption</a> (const std::pair&lt; A, B &gt; &amp;p)</td></tr>
<tr class="separator:af02309d459f5627d7fd8b0109000f586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e00a2200bc0533a1665c9bdf65f534"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a95e00a2200bc0533a1665c9bdf65f534"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMemoryConsumption.html#a95e00a2200bc0533a1665c9bdf65f534">memory_consumption</a> (const T *const)</td></tr>
<tr class="separator:a95e00a2200bc0533a1665c9bdf65f534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b23bf9a2cd17214dac7c59ae71f2ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00b23bf9a2cd17214dac7c59ae71f2ad"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMemoryConsumption.html#a00b23bf9a2cd17214dac7c59ae71f2ad">memory_consumption</a> (const std::shared_ptr&lt; T &gt; &amp;)</td></tr>
<tr class="separator:a00b23bf9a2cd17214dac7c59ae71f2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3ad3ecc4bab2eeddcd448ea56147ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf3ad3ecc4bab2eeddcd448ea56147ce"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMemoryConsumption.html#aaf3ad3ecc4bab2eeddcd448ea56147ce">memory_consumption</a> (const std::unique_ptr&lt; T &gt; &amp;)</td></tr>
<tr class="separator:aaf3ad3ecc4bab2eeddcd448ea56147ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace provides functions helping to determine the amount of memory used by objects. The goal is not necessarily to give the amount of memory used up to the last bit (what is the memory used by a <code>std::map</code> object?), but rather to aid in the search for memory bottlenecks.</p>
<p>This namespace has a single member function <a class="el" href="namespaceMemoryConsumption.html#a8e4965ba9955f1523ca5f3d80ade65db">memory_consumption()</a> and a lot of specializations. Depending on the argument type of the function, there are several modes of operation:</p>
<ol>
<li>
<p class="startli">If the argument is a fundamental C++ data type (such as <code>bool</code>, <code>float</code>, <code>double</code> or any of the integer types), then <a class="el" href="namespaceMemoryConsumption.html#a8e4965ba9955f1523ca5f3d80ade65db">memory_consumption()</a> just returns <code>sizeof</code> of its argument. The library also provides an estimate for the amount of memory occupied by a <code>std::string</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">For objects, which are neither standard types, nor vectors, <a class="el" href="namespaceMemoryConsumption.html#a8e4965ba9955f1523ca5f3d80ade65db">memory_consumption()</a> will simply call the member function of same name. It is up to the implementation of the data type to provide a good estimate of the amount of memory used. Inside this function, the use of <a class="el" href="namespaceMemoryConsumption.html#a8e4965ba9955f1523ca5f3d80ade65db">MemoryConsumption::memory_consumption()</a> for compounds of the class helps to obtain this estimate. Most classes in the deal.II library have such a member function.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">For vectors and C++ arrays of objects, <a class="el" href="namespaceMemoryConsumption.html#a8e4965ba9955f1523ca5f3d80ade65db">memory_consumption()</a> recursively calls itself for all entries and adds the results to the size of the object itself. Some optimized specializations for standard data types exist.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">For vectors of regular pointers, memory_consumption(T*) returns the size of the vector of pointers, ignoring the size of the objects.</p>
<p class="endli"></p>
</li>
</ol>
<h3>Extending this namespace</h3>
<p>The function in this namespace and the functionality provided by it relies on the assumption that there is either a function <code>memory_consumption(T)</code> in this namespace determining the amount of memory used by objects of type <code>T</code> or that the class <code>T</code> has a member function of that name. While the latter is true for almost all classes in deal.II, we have only implemented the first kind of functions for the most common data types, such as fundamental types, strings, C++ vectors, C-style arrays, and C++ pairs. These functions therefore do not cover, for example, C++ maps, lists, etc. If you need such functions feel free to implement them and send them to us for inclusion.</p>
<p>Wells </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8e4965ba9955f1523ca5f3d80ade65db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4965ba9955f1523ca5f3d80ade65db">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_fundamental&lt; T &gt;::value, std::size_t &gt;::type MemoryConsumption::memory_consumption </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the memory consumption of a fundamental type. See <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a> for a discussion on how this restriction (SFINAE) is implemented. </p>

<p class="definition">Definition at line <a class="el" href="memory__consumption_8h_source.html#l00266">266</a> of file <a class="el" href="memory__consumption_8h_source.html">memory_consumption.h</a>.</p>

</div>
</div>
<a id="aba9a62906f4c2c79f39f27a90b68b6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9a62906f4c2c79f39f27a90b68b6f7">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!(std::is_fundamental&lt; T &gt;::value||std::is_pointer&lt; T &gt;::value), std::size_t &gt;::type MemoryConsumption::memory_consumption </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Estimate the memory consumption of an object. If no further template specialization (past this one) is available for the type <code>T</code>, then this function returns the member function <code><a class="el" href="namespaceMemoryConsumption.html#aaf3ad3ecc4bab2eeddcd448ea56147ce">t.memory_consumption()</a></code>'s value. </p>

<p class="definition">Definition at line <a class="el" href="memory__consumption_8h_source.html#l00417">417</a> of file <a class="el" href="memory__consumption_8h_source.html">memory_consumption.h</a>.</p>

</div>
</div>
<a id="aa8bf98d150e2c9dc7cb70f5b9494fef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8bf98d150e2c9dc7cb70f5b9494fef1">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MemoryConsumption::memory_consumption </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the amount of memory consumed by a C-style string. The returned value does not include the size of the pointer. This function only measures up to (and including) the NUL byte; the underlying buffer may be larger. </p>

<p class="definition">Definition at line <a class="el" href="memory__consumption_8h_source.html#l00274">274</a> of file <a class="el" href="memory__consumption_8h_source.html">memory_consumption.h</a>.</p>

</div>
</div>
<a id="a433124a92b29d21d42aec93ff5748a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433124a92b29d21d42aec93ff5748a62">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MemoryConsumption::memory_consumption </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the amount of memory in bytes consumed by a <code>std::complex</code> variable. </p>

<p class="definition">Definition at line <a class="el" href="memory__consumption_8h_source.html#l00290">290</a> of file <a class="el" href="memory__consumption_8h_source.html">memory_consumption.h</a>.</p>

</div>
</div>
<a id="adc11d1706f6a1773d2f49b66cd623efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc11d1706f6a1773d2f49b66cd623efa">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MemoryConsumption::memory_consumption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; T, width &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the amount of memory in bytes consumed by a <code><a class="el" href="classVectorizedArray.html">VectorizedArray</a></code> variable. </p>

<p class="definition">Definition at line <a class="el" href="memory__consumption_8h_source.html#l00299">299</a> of file <a class="el" href="memory__consumption_8h_source.html">memory_consumption.h</a>.</p>

</div>
</div>
<a id="ae9b2ac1b07d121e30d5ad1208532a2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b2ac1b07d121e30d5ad1208532a2d5">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MemoryConsumption::memory_consumption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate of the amount of memory in bytes consumed by a <code>std::string</code> variable. </p>

<p class="definition">Definition at line <a class="el" href="memory__consumption_8h_source.html#l00307">307</a> of file <a class="el" href="memory__consumption_8h_source.html">memory_consumption.h</a>.</p>

</div>
</div>
<a id="a531f112b004582d4c8a15d9ea3491901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531f112b004582d4c8a15d9ea3491901">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MemoryConsumption::memory_consumption </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the amount of memory in bytes consumed by a <code>std::vector</code> of elements of type <code>T</code> by calling <a class="el" href="namespaceMemoryConsumption.html#a8e4965ba9955f1523ca5f3d80ade65db">memory_consumption()</a> for each entry.</p>
<p>This function loops over all entries of the vector and determines their sizes using <a class="el" href="namespaceMemoryConsumption.html#a8e4965ba9955f1523ca5f3d80ade65db">memory_consumption()</a> for each <code>v[i]</code>. If the entries are of constant size, there might be another global function <a class="el" href="namespaceMemoryConsumption.html#a8e4965ba9955f1523ca5f3d80ade65db">memory_consumption()</a> for this data type or if there is a member function of that class of that names that returns a constant value and the compiler will unroll this loop so that the operation is fast. If the size of the data elements is variable, for example if they do memory allocation themselves, then the operation will necessarily be more expensive.</p>
<p>Using the algorithm, in particular the loop over all elements, it is possible to also compute the memory consumption of vectors of vectors, vectors of strings, etc, where the individual elements may have vastly different sizes.</p>
<p>Note that this algorithm also takes into account the size of elements that are allocated by this vector but not currently used.</p>
<p>For the most commonly used vectors, there are special functions that compute the size without a loop. This also applies for the special case of vectors of bools. </p>

<p class="definition">Definition at line <a class="el" href="memory__consumption_8h_source.html#l00316">316</a> of file <a class="el" href="memory__consumption_8h_source.html">memory_consumption.h</a>.</p>

</div>
</div>
<a id="ac524143723c2ff979d4b8c849e8dc731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac524143723c2ff979d4b8c849e8dc731">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MemoryConsumption::memory_consumption </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the amount of memory in bytes consumed by a <code>std::array</code> of <code>N</code> elements of type <code>T</code> by calling <a class="el" href="namespaceMemoryConsumption.html#a8e4965ba9955f1523ca5f3d80ade65db">memory_consumption()</a> for each entry.</p>
<p>This function loops over all entries of the array and determines their sizes using <a class="el" href="namespaceMemoryConsumption.html#a8e4965ba9955f1523ca5f3d80ade65db">memory_consumption()</a> for each <code>v[i]</code>. If the entries are of constant size, there might be another global function <a class="el" href="namespaceMemoryConsumption.html#a8e4965ba9955f1523ca5f3d80ade65db">memory_consumption()</a> for this data type or if there is a member function of that class of that names that returns a constant value and the compiler will unroll this loop so that the operation is fast. If the size of the data elements is variable, for example if they do memory allocation themselves, then the operation will necessarily be more expensive.</p>
<p>Using the algorithm, in particular the loop over all elements, it is possible to also compute the memory consumption of arrays of vectors, arrays of strings, etc, where the individual elements may have vastly different sizes. </p>

<p class="definition">Definition at line <a class="el" href="memory__consumption_8h_source.html#l00339">339</a> of file <a class="el" href="memory__consumption_8h_source.html">memory_consumption.h</a>.</p>

</div>
</div>
<a id="a83459028fe7e73ba532208aaeff63f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83459028fe7e73ba532208aaeff63f5a">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MemoryConsumption::memory_consumption </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>v</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Estimate the amount of memory (in bytes) occupied by a C-style array. Since in this library we do not usually store simple data elements like <code>double</code>s in such arrays (but rather use <code>std::vector</code>s or deal.II <code><a class="el" href="classVector.html">Vector</a></code> objects), we do not provide specializations like for the <code>std::vector</code> arrays, but always use the loop over all elements. </p>

<p class="definition">Definition at line <a class="el" href="memory__consumption_8h_source.html#l00359">359</a> of file <a class="el" href="memory__consumption_8h_source.html">memory_consumption.h</a>.</p>

</div>
</div>
<a id="a3169b806266ca169ac2bcb57dcd13695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3169b806266ca169ac2bcb57dcd13695">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MemoryConsumption::memory_consumption </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of the determination of the memory consumption of a vector, here for a vector of <code>bool</code>s.</p>
<p>This is a special case, as the bools are not stored one-by-one, but as a bit field. </p>

<p class="definition">Definition at line <a class="el" href="memory__consumption_8h_source.html#l00370">370</a> of file <a class="el" href="memory__consumption_8h_source.html">memory_consumption.h</a>.</p>

</div>
</div>
<a id="af02309d459f5627d7fd8b0109000f586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02309d459f5627d7fd8b0109000f586">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MemoryConsumption::memory_consumption </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate of the amount of memory in bytes consumed by a pair of values. </p>

<p class="definition">Definition at line <a class="el" href="memory__consumption_8h_source.html#l00379">379</a> of file <a class="el" href="memory__consumption_8h_source.html">memory_consumption.h</a>.</p>

</div>
</div>
<a id="a95e00a2200bc0533a1665c9bdf65f534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e00a2200bc0533a1665c9bdf65f534">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MemoryConsumption::memory_consumption </td>
          <td>(</td>
          <td class="paramtype">const T * const&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the memory consumption of a pointer.</p>
<dl class="section note"><dt>Note</dt><dd>This function is overloaded for C-style strings; see the documentation of that function for that case.</dd>
<dd>
This returns the size of the pointer, not the size of the object pointed to. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory__consumption_8h_source.html#l00388">388</a> of file <a class="el" href="memory__consumption_8h_source.html">memory_consumption.h</a>.</p>

</div>
</div>
<a id="a00b23bf9a2cd17214dac7c59ae71f2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b23bf9a2cd17214dac7c59ae71f2ad">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MemoryConsumption::memory_consumption </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the amount of memory used by a shared pointer.</p>
<dl class="section note"><dt>Note</dt><dd>This returns the size of the pointer, not of the object pointed to. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory__consumption_8h_source.html#l00397">397</a> of file <a class="el" href="memory__consumption_8h_source.html">memory_consumption.h</a>.</p>

</div>
</div>
<a id="aaf3ad3ecc4bab2eeddcd448ea56147ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3ad3ecc4bab2eeddcd448ea56147ce">&#9670;&nbsp;</a></span>memory_consumption() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t MemoryConsumption::memory_consumption </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the amount of memory used by a std::unique_ptr object.</p>
<dl class="section note"><dt>Note</dt><dd>This returns the size of the pointer, not of the object pointed to. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memory__consumption_8h_source.html#l00406">406</a> of file <a class="el" href="memory__consumption_8h_source.html">memory_consumption.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
