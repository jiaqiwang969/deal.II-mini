<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFEFaceEvaluation.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FEFaceEvaluation&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classFEFaceEvaluation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FEFaceEvaluation&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fe__evaluation_8h_source.html">deal.II/matrix_free/fe_evaluation.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FEFaceEvaluation&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFEFaceEvaluation__inherit__graph.svg" width="1328" height="119"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae12fa0d11f28fd0825a55920497ae97d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#ae12fa0d11f28fd0825a55920497ae97d">BaseClass</a> = <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a>&lt; dim, n_components_, Number, true, VectorizedArrayType &gt;</td></tr>
<tr class="separator:ae12fa0d11f28fd0825a55920497ae97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f18f88e4e79ba7958c581884d10fd5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#aa1f18f88e4e79ba7958c581884d10fd5">number_type</a> = Number</td></tr>
<tr class="separator:aa1f18f88e4e79ba7958c581884d10fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0076169f7b0fb1fa7c197ea4325bb324"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a0076169f7b0fb1fa7c197ea4325bb324">value_type</a> = typename <a class="el" href="classFEEvaluationAccess.html#a341c39cbf9948d06561b74f9c5050d10">BaseClass::value_type</a></td></tr>
<tr class="separator:a0076169f7b0fb1fa7c197ea4325bb324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ac66f58cec9630c76cc0f29f9d497e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#ad5ac66f58cec9630c76cc0f29f9d497e">gradient_type</a> = typename <a class="el" href="classFEEvaluationAccess.html#a6167b54604de2e9022ec743267e5a25b">BaseClass::gradient_type</a></td></tr>
<tr class="separator:ad5ac66f58cec9630c76cc0f29f9d497e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acdaaf051d3f8f8ada47520efb0811acb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#acdaaf051d3f8f8ada47520efb0811acb">FEFaceEvaluation</a> (const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;matrix_free, const <a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBaseData.html#a1dc1a1074ec29081286adcbff30844fe">is_interior_face</a>=true, const unsigned <a class="el" href="classint.html">int</a> dof_no=0, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html#a533b073ea515b343f9d785da2f342066">quad_no</a>=0, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBase.html#a42f9032a1a57f19c6e21915eaee09716">first_selected_component</a>=0, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html#afa5f9995bfa3e160a8e111837e4293c9">active_fe_index</a>=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html#a15d55c8a88a0a393b7eec7a2843cc9bd">active_quad_index</a>=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const unsigned <a class="el" href="classint.html">int</a> face_type=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:acdaaf051d3f8f8ada47520efb0811acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fedfdec25287e183f1fb3d625a08cd6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a9fedfdec25287e183f1fb3d625a08cd6">FEFaceEvaluation</a> (const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;matrix_free, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;range, const <a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBaseData.html#a1dc1a1074ec29081286adcbff30844fe">is_interior_face</a>=true, const unsigned <a class="el" href="classint.html">int</a> dof_no=0, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html#a533b073ea515b343f9d785da2f342066">quad_no</a>=0, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBase.html#a42f9032a1a57f19c6e21915eaee09716">first_selected_component</a>=0)</td></tr>
<tr class="separator:a9fedfdec25287e183f1fb3d625a08cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45172115b15c8139f34216ceee323d5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a45172115b15c8139f34216ceee323d5b">reinit</a> (const unsigned <a class="el" href="classint.html">int</a> face_batch_number)</td></tr>
<tr class="separator:a45172115b15c8139f34216ceee323d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5036f0b01658df30ff653edd863ba6bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a5036f0b01658df30ff653edd863ba6bf">reinit</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_number, const unsigned <a class="el" href="classint.html">int</a> face_number)</td></tr>
<tr class="separator:a5036f0b01658df30ff653edd863ba6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f84b8ad276ca9866f30c6f789cf3a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a92f84b8ad276ca9866f30c6f789cf3a4">evaluate</a> (const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a> evaluation_flag)</td></tr>
<tr class="separator:a92f84b8ad276ca9866f30c6f789cf3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a0e593e62982eb64b29da34529af11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8h.html#a8ce3607a2c3e9ba0f1d553bff4a3b588">DEAL_II_DEPRECATED_EARLY</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a97a0e593e62982eb64b29da34529af11">evaluate</a> (const <a class="el" href="classbool.html">bool</a> evaluate_values, const <a class="el" href="classbool.html">bool</a> evaluate_gradients)</td></tr>
<tr class="separator:a97a0e593e62982eb64b29da34529af11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688c3dd3a1bba5d50ed3b714c56e6c14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a688c3dd3a1bba5d50ed3b714c56e6c14">evaluate</a> (const VectorizedArrayType *values_array, const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a> evaluation_flag)</td></tr>
<tr class="separator:a688c3dd3a1bba5d50ed3b714c56e6c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741af7619c41978865d9ff6bc7cb57c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8h.html#a8ce3607a2c3e9ba0f1d553bff4a3b588">DEAL_II_DEPRECATED_EARLY</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a741af7619c41978865d9ff6bc7cb57c5">evaluate</a> (const VectorizedArrayType *values_array, const <a class="el" href="classbool.html">bool</a> evaluate_values, const <a class="el" href="classbool.html">bool</a> evaluate_gradients)</td></tr>
<tr class="separator:a741af7619c41978865d9ff6bc7cb57c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac53fde2eab227ef45c7d29a5ed33fe"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a4ac53fde2eab227ef45c7d29a5ed33fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a4ac53fde2eab227ef45c7d29a5ed33fe">gather_evaluate</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;input_vector, const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a> evaluation_flag)</td></tr>
<tr class="separator:a4ac53fde2eab227ef45c7d29a5ed33fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab246fddd0d6472a1b8d68293965c47c5"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:ab246fddd0d6472a1b8d68293965c47c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="config_8h.html#a8ce3607a2c3e9ba0f1d553bff4a3b588">DEAL_II_DEPRECATED_EARLY</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#ab246fddd0d6472a1b8d68293965c47c5">gather_evaluate</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;input_vector, const <a class="el" href="classbool.html">bool</a> evaluate_values, const <a class="el" href="classbool.html">bool</a> evaluate_gradients)</td></tr>
<tr class="separator:ab246fddd0d6472a1b8d68293965c47c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d6ed6254b4d18ef4357ed6aa0974ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#ad5d6ed6254b4d18ef4357ed6aa0974ae">integrate</a> (const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a> evaluation_flag)</td></tr>
<tr class="separator:ad5d6ed6254b4d18ef4357ed6aa0974ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9ff7adf08f4b628d818b867886b347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8h.html#a8ce3607a2c3e9ba0f1d553bff4a3b588">DEAL_II_DEPRECATED_EARLY</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#aef9ff7adf08f4b628d818b867886b347">integrate</a> (const <a class="el" href="classbool.html">bool</a> integrate_values, const <a class="el" href="classbool.html">bool</a> integrate_gradients)</td></tr>
<tr class="separator:aef9ff7adf08f4b628d818b867886b347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62960edf0c3d1b80cb785696314a353"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#af62960edf0c3d1b80cb785696314a353">integrate</a> (const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a> evaluation_flag, VectorizedArrayType *values_array)</td></tr>
<tr class="separator:af62960edf0c3d1b80cb785696314a353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233e74614b6dad83a9eedffaf7b0595c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8h.html#a8ce3607a2c3e9ba0f1d553bff4a3b588">DEAL_II_DEPRECATED_EARLY</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a233e74614b6dad83a9eedffaf7b0595c">integrate</a> (const <a class="el" href="classbool.html">bool</a> integrate_values, const <a class="el" href="classbool.html">bool</a> integrate_gradients, VectorizedArrayType *values_array)</td></tr>
<tr class="separator:a233e74614b6dad83a9eedffaf7b0595c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8963360c30a43aca90a764443fc954f"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:ad8963360c30a43aca90a764443fc954f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#ad8963360c30a43aca90a764443fc954f">integrate_scatter</a> (const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a> evaluation_flag, <a class="el" href="classVectorType.html">VectorType</a> &amp;output_vector)</td></tr>
<tr class="separator:ad8963360c30a43aca90a764443fc954f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65f5f0e0f741ac7305e6cbda5c524aa"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:ae65f5f0e0f741ac7305e6cbda5c524aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#ae65f5f0e0f741ac7305e6cbda5c524aa">integrate_scatter</a> (const <a class="el" href="classbool.html">bool</a> integrate_values, const <a class="el" href="classbool.html">bool</a> integrate_gradients, <a class="el" href="classVectorType.html">VectorType</a> &amp;output_vector)</td></tr>
<tr class="separator:ae65f5f0e0f741ac7305e6cbda5c524aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6d0dc13e7e10c558170af34f53db19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim, VectorizedArrayType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#abd6d0dc13e7e10c558170af34f53db19">quadrature_point</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:abd6d0dc13e7e10c558170af34f53db19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68204d97bb4207d522522f0d624213dc"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a68204d97bb4207d522522f0d624213dc">get_first_selected_component</a> () const</td></tr>
<tr class="separator:a68204d97bb4207d522522f0d624213dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b715f55152c25bf40e8a588f2d71e3"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a41b715f55152c25bf40e8a588f2d71e3">get_mapping_data_index_offset</a> () const</td></tr>
<tr class="separator:a41b715f55152c25bf40e8a588f2d71e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377d660719169078d812bf611bd75f13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__matrixfree.html#gae024b29b6819e727d47016c6b6b53d8c">internal::MatrixFreeFunctions::GeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a377d660719169078d812bf611bd75f13">get_cell_type</a> () const</td></tr>
<tr class="separator:a377d660719169078d812bf611bd75f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3795cfb954ce2b37a130265c51eba552"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt; VectorizedArrayType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a3795cfb954ce2b37a130265c51eba552">get_shape_info</a> () const</td></tr>
<tr class="separator:a3795cfb954ce2b37a130265c51eba552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664645e91bbe5f972a1d9b6c64ab5e9b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a664645e91bbe5f972a1d9b6c64ab5e9b">get_dof_info</a> () const</td></tr>
<tr class="separator:a664645e91bbe5f972a1d9b6c64ab5e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ed5a4e84edf92e69f1474d5f035a92"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a56ed5a4e84edf92e69f1474d5f035a92">JxW</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:a56ed5a4e84edf92e69f1474d5f035a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad456112f01b19291e7781fb5efee55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, VectorizedArrayType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#adad456112f01b19291e7781fb5efee55">inverse_jacobian</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:adad456112f01b19291e7781fb5efee55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264ced911d2818b0a04b8855bb482b45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, VectorizedArrayType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a264ced911d2818b0a04b8855bb482b45">get_normal_vector</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:a264ced911d2818b0a04b8855bb482b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c966665f040d92b055833c8011b395a"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a7c966665f040d92b055833c8011b395a">read_cell_data</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; &amp;array) const</td></tr>
<tr class="separator:a7c966665f040d92b055833c8011b395a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6891d7f5fe2282a3ff1ca56042d57d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6891d7f5fe2282a3ff1ca56042d57d6"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, VectorizedArrayType::size()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#ae6891d7f5fe2282a3ff1ca56042d57d6">read_cell_data</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; std::array&lt; T, VectorizedArrayType::size()&gt;&gt; &amp;array) const</td></tr>
<tr class="separator:ae6891d7f5fe2282a3ff1ca56042d57d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152c28d13aca3d409052d7f7a0634eb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a152c28d13aca3d409052d7f7a0634eb0">set_cell_data</a> (<a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; &amp;array, const VectorizedArrayType &amp;value) const</td></tr>
<tr class="separator:a152c28d13aca3d409052d7f7a0634eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7feb6cd1b095d992c54dd5fac244586"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7feb6cd1b095d992c54dd5fac244586"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#ac7feb6cd1b095d992c54dd5fac244586">set_cell_data</a> (<a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; std::array&lt; T, VectorizedArrayType::size()&gt;&gt; &amp;array, const std::array&lt; T, VectorizedArrayType::size()&gt; &amp;value) const</td></tr>
<tr class="separator:ac7feb6cd1b095d992c54dd5fac244586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2729f97a9d471169afe63cede6596a74"><td class="memItemLeft" align="right" valign="top">std::array&lt; unsigned <a class="el" href="classint.html">int</a>, VectorizedArrayType::size()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a2729f97a9d471169afe63cede6596a74">get_cell_ids</a> () const</td></tr>
<tr class="separator:a2729f97a9d471169afe63cede6596a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d73c4fd5e79970f465b603adf116d6"><td class="memItemLeft" align="right" valign="top">std::array&lt; unsigned <a class="el" href="classint.html">int</a>, VectorizedArrayType::size()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a77d73c4fd5e79970f465b603adf116d6">get_cell_or_face_ids</a> () const</td></tr>
<tr class="separator:a77d73c4fd5e79970f465b603adf116d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575a078b24cb2107fce967db6ebedb1f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a575a078b24cb2107fce967db6ebedb1f">get_internal_dof_numbering</a> () const</td></tr>
<tr class="separator:a575a078b24cb2107fce967db6ebedb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68af54c4af89af574d1304bfc59f2637"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrayView.html">ArrayView</a>&lt; VectorizedArrayType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a68af54c4af89af574d1304bfc59f2637">get_scratch_data</a> () const</td></tr>
<tr class="separator:a68af54c4af89af574d1304bfc59f2637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a6490549baa849bf4aaaab72ed4ecb"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#aa1a6490549baa849bf4aaaab72ed4ecb">get_quadrature_index</a> () const</td></tr>
<tr class="separator:aa1a6490549baa849bf4aaaab72ed4ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6874c90c1c3f54737636cd30b46ffe47"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a6874c90c1c3f54737636cd30b46ffe47">get_current_cell_index</a> () const</td></tr>
<tr class="separator:a6874c90c1c3f54737636cd30b46ffe47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed217341425d1b85c6d2e67932af9853"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#aed217341425d1b85c6d2e67932af9853">get_active_fe_index</a> () const</td></tr>
<tr class="separator:aed217341425d1b85c6d2e67932af9853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f979d70d5d3e16037ed0f3ae36f6b6f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a6f979d70d5d3e16037ed0f3ae36f6b6f">get_active_quadrature_index</a> () const</td></tr>
<tr class="separator:a6f979d70d5d3e16037ed0f3ae36f6b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0c8e96fd4c18b29c6cddb1e648c66d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a8b0c8e96fd4c18b29c6cddb1e648c66d">get_matrix_free</a> () const</td></tr>
<tr class="separator:a8b0c8e96fd4c18b29c6cddb1e648c66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">1: Reading from and writing to vectors</div></td></tr>
<tr class="memitem:a5c3bf28ebceb0271addfba5b92f475ce"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a5c3bf28ebceb0271addfba5b92f475ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a5c3bf28ebceb0271addfba5b92f475ce">read_dof_values</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;src, const unsigned <a class="el" href="classint.html">int</a> first_index=0)</td></tr>
<tr class="separator:a5c3bf28ebceb0271addfba5b92f475ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd35a59ccde6eaab46d1264450b93f5"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a5bd35a59ccde6eaab46d1264450b93f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">read_dof_values_plain</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;src, const unsigned <a class="el" href="classint.html">int</a> first_index=0)</td></tr>
<tr class="separator:a5bd35a59ccde6eaab46d1264450b93f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c9d8eac4ca7b3f7d45eda97ea8e2fb"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a13c9d8eac4ca7b3f7d45eda97ea8e2fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a13c9d8eac4ca7b3f7d45eda97ea8e2fb">distribute_local_to_global</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const unsigned <a class="el" href="classint.html">int</a> first_index=0, const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;mask=std::bitset&lt; VectorizedArrayType::size()&gt;().flip()) const</td></tr>
<tr class="separator:a13c9d8eac4ca7b3f7d45eda97ea8e2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459813036810fbdc3c5487309b118fd8"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a459813036810fbdc3c5487309b118fd8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a459813036810fbdc3c5487309b118fd8">set_dof_values</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const unsigned <a class="el" href="classint.html">int</a> first_index=0, const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;mask=std::bitset&lt; VectorizedArrayType::size()&gt;().flip()) const</td></tr>
<tr class="separator:a459813036810fbdc3c5487309b118fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc923ce61f6399bcd717ab9f99f62ca0"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:afc923ce61f6399bcd717ab9f99f62ca0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#afc923ce61f6399bcd717ab9f99f62ca0">set_dof_values_plain</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const unsigned <a class="el" href="classint.html">int</a> first_index=0, const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;mask=std::bitset&lt; VectorizedArrayType::size()&gt;().flip()) const</td></tr>
<tr class="separator:afc923ce61f6399bcd717ab9f99f62ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">2: Access to data at quadrature points or the gather vector data</div></td></tr>
<tr class="memitem:a0660b27a2a592994dfd2fc917305a3ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a0660b27a2a592994dfd2fc917305a3ac">get_dof_value</a> (const unsigned <a class="el" href="classint.html">int</a> dof) const</td></tr>
<tr class="separator:a0660b27a2a592994dfd2fc917305a3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afd9d62f5762c41973aa0f037dc5099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a3afd9d62f5762c41973aa0f037dc5099">submit_dof_value</a> (const <a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> val_in, const unsigned <a class="el" href="classint.html">int</a> dof)</td></tr>
<tr class="separator:a3afd9d62f5762c41973aa0f037dc5099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecc76ffeff6b36816f6af20af1398a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">get_value</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:aeecc76ffeff6b36816f6af20af1398a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0efc6f70b305c0585001632063c98b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a2c0efc6f70b305c0585001632063c98b">submit_value</a> (const <a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> val_in, const unsigned <a class="el" href="classint.html">int</a> q_point)</td></tr>
<tr class="separator:a2c0efc6f70b305c0585001632063c98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132c024aa9243845d3777b227607da6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEEvaluationBase.html#a7850917bacc47dc16fb1e5bd491f8e04">gradient_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">get_gradient</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:a132c024aa9243845d3777b227607da6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee54d24ac9e0dcfe9a4571a6b047cd03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#aee54d24ac9e0dcfe9a4571a6b047cd03">get_normal_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:aee54d24ac9e0dcfe9a4571a6b047cd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a78655d119bd1bde992619c52b2d2f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">submit_gradient</a> (const <a class="el" href="classFEEvaluationBase.html#a7850917bacc47dc16fb1e5bd491f8e04">gradient_type</a> grad_in, const unsigned <a class="el" href="classint.html">int</a> q_point)</td></tr>
<tr class="separator:a2a78655d119bd1bde992619c52b2d2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e7e621190fb28eeeffa58311f711ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#ad6e7e621190fb28eeeffa58311f711ce">submit_normal_derivative</a> (const <a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> grad_in, const unsigned <a class="el" href="classint.html">int</a> q_point)</td></tr>
<tr class="separator:ad6e7e621190fb28eeeffa58311f711ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af637d7fcd92a58cf1e8597269a13e9bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, n_components_, <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, VectorizedArrayType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#af637d7fcd92a58cf1e8597269a13e9bd">get_hessian</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:af637d7fcd92a58cf1e8597269a13e9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba7f7af4354a4bad6bcf7364978ebf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEEvaluationBase.html#a7850917bacc47dc16fb1e5bd491f8e04">gradient_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#aaba7f7af4354a4bad6bcf7364978ebf2">get_hessian_diagonal</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:aaba7f7af4354a4bad6bcf7364978ebf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c652a4de885613efc5e02dd3754342b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a0c652a4de885613efc5e02dd3754342b">get_laplacian</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:a0c652a4de885613efc5e02dd3754342b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6a0959de5c408072c48ee3fd2ca057"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a7f6a0959de5c408072c48ee3fd2ca057">get_divergence</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:a7f6a0959de5c408072c48ee3fd2ca057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6fe306f7501a59940bfffab2550e6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorizedArrayType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a2b6fe306f7501a59940bfffab2550e6a">get_symmetric_gradient</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:a2b6fe306f7501a59940bfffab2550e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae036687570ee408ffa461f9c7ae685cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1,(dim==2 ? 1 :dim), VectorizedArrayType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#ae036687570ee408ffa461f9c7ae685cc">get_curl</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:ae036687570ee408ffa461f9c7ae685cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a45432b87f3a6fc20ca91b02d2654d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#aa0a45432b87f3a6fc20ca91b02d2654d">submit_divergence</a> (const VectorizedArrayType div_in, const unsigned <a class="el" href="classint.html">int</a> q_point)</td></tr>
<tr class="separator:aa0a45432b87f3a6fc20ca91b02d2654d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b29b531d2d7bfc8596b34f68b6abf91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a5b29b531d2d7bfc8596b34f68b6abf91">submit_symmetric_gradient</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorizedArrayType &gt; grad_in, const unsigned <a class="el" href="classint.html">int</a> q_point)</td></tr>
<tr class="separator:a5b29b531d2d7bfc8596b34f68b6abf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af317b2c1e630b328f7738287d3b07ae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#af317b2c1e630b328f7738287d3b07ae6">submit_curl</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim==2 ? 1 :dim, VectorizedArrayType &gt; curl_in, const unsigned <a class="el" href="classint.html">int</a> q_point)</td></tr>
<tr class="separator:af317b2c1e630b328f7738287d3b07ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada523fada873497b00071b8b0bc35005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#ada523fada873497b00071b8b0bc35005">integrate_value</a> () const</td></tr>
<tr class="separator:ada523fada873497b00071b8b0bc35005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">3: Access to internal data</div></td></tr>
<tr class="memitem:a6998ba7c39eeed60574b25f366184d0b"><td class="memItemLeft" align="right" valign="top">const VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a6998ba7c39eeed60574b25f366184d0b">begin_dof_values</a> () const</td></tr>
<tr class="separator:a6998ba7c39eeed60574b25f366184d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54213aa80599acf803a3b7c4c487fd38"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a54213aa80599acf803a3b7c4c487fd38">begin_dof_values</a> ()</td></tr>
<tr class="separator:a54213aa80599acf803a3b7c4c487fd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0738826a83db1d28cad958e478f3e27"><td class="memItemLeft" align="right" valign="top">const VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#ac0738826a83db1d28cad958e478f3e27">begin_values</a> () const</td></tr>
<tr class="separator:ac0738826a83db1d28cad958e478f3e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e58470a54179126fe601d26f0088bdb"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a8e58470a54179126fe601d26f0088bdb">begin_values</a> ()</td></tr>
<tr class="separator:a8e58470a54179126fe601d26f0088bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9651d02f2fe8a7133867c92fc8f327b"><td class="memItemLeft" align="right" valign="top">const VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#ac9651d02f2fe8a7133867c92fc8f327b">begin_gradients</a> () const</td></tr>
<tr class="separator:ac9651d02f2fe8a7133867c92fc8f327b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f03eb49fe21f5a2eda31c07d3052330"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a1f03eb49fe21f5a2eda31c07d3052330">begin_gradients</a> ()</td></tr>
<tr class="separator:a1f03eb49fe21f5a2eda31c07d3052330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bce79fd87c41b7fee59627b4a452125"><td class="memItemLeft" align="right" valign="top">const VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a7bce79fd87c41b7fee59627b4a452125">begin_hessians</a> () const</td></tr>
<tr class="separator:a7bce79fd87c41b7fee59627b4a452125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0a3def7f22c396ce2884e37b4aa788"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a2b0a3def7f22c396ce2884e37b4aa788">begin_hessians</a> ()</td></tr>
<tr class="separator:a2b0a3def7f22c396ce2884e37b4aa788"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abc9958a53c2aaad1cf773fff6d104ff2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#abc9958a53c2aaad1cf773fff6d104ff2">fast_evaluation_supported</a> (const unsigned <a class="el" href="classint.html">int</a> given_degree, const unsigned <a class="el" href="classint.html">int</a> give_n_q_points_1d)</td></tr>
<tr class="separator:abc9958a53c2aaad1cf773fff6d104ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3dab1f1daf6390da8bf0588a0ed76e58"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a3dab1f1daf6390da8bf0588a0ed76e58">dofs_per_component</a></td></tr>
<tr class="separator:a3dab1f1daf6390da8bf0588a0ed76e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e6e04ad9c15e5a3fe169d2df17d6e2"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a74e6e04ad9c15e5a3fe169d2df17d6e2">dofs_per_cell</a></td></tr>
<tr class="separator:a74e6e04ad9c15e5a3fe169d2df17d6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451f10fa5579763dd6b88dfa2460f0ba"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a451f10fa5579763dd6b88dfa2460f0ba">n_q_points</a></td></tr>
<tr class="separator:a451f10fa5579763dd6b88dfa2460f0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ad1d38cd5e7305b581d300929ff5e8200"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#ad1d38cd5e7305b581d300929ff5e8200">dimension</a> = dim</td></tr>
<tr class="separator:ad1d38cd5e7305b581d300929ff5e8200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83225922c17f801c889680eff0da9b07"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a83225922c17f801c889680eff0da9b07">n_components</a> = n_components_</td></tr>
<tr class="separator:a83225922c17f801c889680eff0da9b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42a1c7210f76b69310d3f5990821a22"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#ac42a1c7210f76b69310d3f5990821a22">static_n_q_points</a></td></tr>
<tr class="separator:ac42a1c7210f76b69310d3f5990821a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2317dcbb9306d670a8a508c0b96183ba"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a2317dcbb9306d670a8a508c0b96183ba">static_n_q_points_cell</a></td></tr>
<tr class="separator:a2317dcbb9306d670a8a508c0b96183ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e4f5c52b3319399cf1730e400ac01c"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#ab3e4f5c52b3319399cf1730e400ac01c">static_dofs_per_component</a></td></tr>
<tr class="separator:ab3e4f5c52b3319399cf1730e400ac01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dff67ddc5cc5ffff02701650b0917b0"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a2dff67ddc5cc5ffff02701650b0917b0">tensor_dofs_per_cell</a></td></tr>
<tr class="separator:a2dff67ddc5cc5ffff02701650b0917b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15a90d3571fe443e1460b71e7e0effa"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#af15a90d3571fe443e1460b71e7e0effa">static_dofs_per_cell</a></td></tr>
<tr class="separator:af15a90d3571fe443e1460b71e7e0effa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a27779f5e7ac08bcc8c3fd1d78698ad45"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename VectorOperation &gt; </td></tr>
<tr class="memitem:a27779f5e7ac08bcc8c3fd1d78698ad45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a27779f5e7ac08bcc8c3fd1d78698ad45">read_write_operation</a> (const <a class="el" href="structVectorOperation.html">VectorOperation</a> &amp;operation, const std::array&lt; <a class="el" href="classVectorType.html">VectorType</a> *, n_components_ &gt; &amp;vectors, const std::array&lt; const std::vector&lt; <a class="el" href="classArrayView.html">ArrayView</a>&lt; const typename VectorType::value_type &gt;&gt; *, n_components_ &gt; &amp;vectors_sm, const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;mask, const <a class="el" href="classbool.html">bool</a> apply_constraints=true) const</td></tr>
<tr class="separator:a27779f5e7ac08bcc8c3fd1d78698ad45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427af54345534f8d734230ad56d4a367"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename VectorOperation &gt; </td></tr>
<tr class="memitem:a427af54345534f8d734230ad56d4a367"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a427af54345534f8d734230ad56d4a367">read_write_operation_contiguous</a> (const <a class="el" href="structVectorOperation.html">VectorOperation</a> &amp;operation, const std::array&lt; <a class="el" href="classVectorType.html">VectorType</a> *, n_components_ &gt; &amp;vectors, const std::array&lt; const std::vector&lt; <a class="el" href="classArrayView.html">ArrayView</a>&lt; const typename VectorType::value_type &gt;&gt; *, n_components_ &gt; &amp;vectors_sm, const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;mask) const</td></tr>
<tr class="separator:a427af54345534f8d734230ad56d4a367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b9198e9b8d3306e7b9fc7ebffb7077"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename VectorOperation &gt; </td></tr>
<tr class="memitem:a06b9198e9b8d3306e7b9fc7ebffb7077"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a06b9198e9b8d3306e7b9fc7ebffb7077">read_write_operation_global</a> (const <a class="el" href="structVectorOperation.html">VectorOperation</a> &amp;operation, const std::array&lt; <a class="el" href="classVectorType.html">VectorType</a> *, n_components_ &gt; &amp;vectors) const</td></tr>
<tr class="separator:a06b9198e9b8d3306e7b9fc7ebffb7077"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aacafd9861301674853b127a115d4de1e"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#aacafd9861301674853b127a115d4de1e">values_dofs</a> [<a class="el" href="classFEFaceEvaluation.html#a83225922c17f801c889680eff0da9b07">n_components</a>]</td></tr>
<tr class="separator:aacafd9861301674853b127a115d4de1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b01fcfb319697ad15319c44d635358"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#aa2b01fcfb319697ad15319c44d635358">values_quad</a></td></tr>
<tr class="separator:aa2b01fcfb319697ad15319c44d635358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c0240702f8a5f1bcd102ef69919b54"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a01c0240702f8a5f1bcd102ef69919b54">gradients_quad</a></td></tr>
<tr class="separator:a01c0240702f8a5f1bcd102ef69919b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7ce5837713e301d3e8c4718fdcce67"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#aca7ce5837713e301d3e8c4718fdcce67">hessians_quad</a></td></tr>
<tr class="separator:aca7ce5837713e301d3e8c4718fdcce67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad363fb71770ee9f1b521e5a539993ef3"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#ad363fb71770ee9f1b521e5a539993ef3">n_fe_components</a></td></tr>
<tr class="separator:ad363fb71770ee9f1b521e5a539993ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4931bf96a90394aa552231bfc3d4bb80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a4931bf96a90394aa552231bfc3d4bb80">dof_values_initialized</a></td></tr>
<tr class="separator:a4931bf96a90394aa552231bfc3d4bb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2634b8199be6e9fdec0b0ad715209a39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a2634b8199be6e9fdec0b0ad715209a39">values_quad_initialized</a></td></tr>
<tr class="separator:a2634b8199be6e9fdec0b0ad715209a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15f3fb86bd795ee059be4accef81ca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#af15f3fb86bd795ee059be4accef81ca8">gradients_quad_initialized</a></td></tr>
<tr class="separator:af15f3fb86bd795ee059be4accef81ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510ed69b6143a1a497c41c93a200a39d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a510ed69b6143a1a497c41c93a200a39d">hessians_quad_initialized</a></td></tr>
<tr class="separator:a510ed69b6143a1a497c41c93a200a39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53e482c5d5eb5b156e79d322f7fdf12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#ad53e482c5d5eb5b156e79d322f7fdf12">values_quad_submitted</a></td></tr>
<tr class="separator:ad53e482c5d5eb5b156e79d322f7fdf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747a9ff4cbaedd9b48f7aa1378e2682c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a747a9ff4cbaedd9b48f7aa1378e2682c">gradients_quad_submitted</a></td></tr>
<tr class="separator:a747a9ff4cbaedd9b48f7aa1378e2682c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f9032a1a57f19c6e21915eaee09716"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a42f9032a1a57f19c6e21915eaee09716">first_selected_component</a></td></tr>
<tr class="separator:a42f9032a1a57f19c6e21915eaee09716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd8d38b99b2e85efbc37570c76d0def"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a3cd8d38b99b2e85efbc37570c76d0def">local_dof_indices</a></td></tr>
<tr class="separator:a3cd8d38b99b2e85efbc37570c76d0def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c8dcc076400f538a3c85a5cbec9cb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#ad9c8dcc076400f538a3c85a5cbec9cb3">scratch_data_array</a></td></tr>
<tr class="separator:ad9c8dcc076400f538a3c85a5cbec9cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35283bcccba5587bff326a245d322e7"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#af35283bcccba5587bff326a245d322e7">scratch_data</a></td></tr>
<tr class="separator:af35283bcccba5587bff326a245d322e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533b073ea515b343f9d785da2f342066"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a533b073ea515b343f9d785da2f342066">quad_no</a></td></tr>
<tr class="separator:a533b073ea515b343f9d785da2f342066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d19d2e454832346b9ae547f0330533"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#af0d19d2e454832346b9ae547f0330533">matrix_info</a></td></tr>
<tr class="separator:af0d19d2e454832346b9ae547f0330533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa7522a2f5003b7aefa14209ccd4723"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#adfa7522a2f5003b7aefa14209ccd4723">dof_info</a></td></tr>
<tr class="separator:adfa7522a2f5003b7aefa14209ccd4723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c31ae7463c9952de2b8edb01a942938"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfoStorage.html">internal::MatrixFreeFunctions::MappingInfoStorage</a>&lt;(is_face ? dim - 1 :dim), dim, Number, VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a8c31ae7463c9952de2b8edb01a942938">mapping_data</a></td></tr>
<tr class="separator:a8c31ae7463c9952de2b8edb01a942938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5f9995bfa3e160a8e111837e4293c9"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#afa5f9995bfa3e160a8e111837e4293c9">active_fe_index</a></td></tr>
<tr class="separator:afa5f9995bfa3e160a8e111837e4293c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d55c8a88a0a393b7eec7a2843cc9bd"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a15d55c8a88a0a393b7eec7a2843cc9bd">active_quad_index</a></td></tr>
<tr class="separator:a15d55c8a88a0a393b7eec7a2843cc9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0ee194a86f8af161dbb74c8580fc30"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfoStorage.html">internal::MatrixFreeFunctions::MappingInfoStorage</a>&lt;(is_face ? dim - 1 :dim), dim, Number, VectorizedArrayType &gt;::QuadratureDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a0d0ee194a86f8af161dbb74c8580fc30">descriptor</a></td></tr>
<tr class="separator:a0d0ee194a86f8af161dbb74c8580fc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748b05799b1fdcda8e1bef6ac563b119"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a748b05799b1fdcda8e1bef6ac563b119">n_quadrature_points</a></td></tr>
<tr class="separator:a748b05799b1fdcda8e1bef6ac563b119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9ba9049f2df1bc4ef95ae789faf12e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt; VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a5d9ba9049f2df1bc4ef95ae789faf12e">data</a></td></tr>
<tr class="separator:a5d9ba9049f2df1bc4ef95ae789faf12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421376c6f8ddefa1797a58e8f9003e7b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a421376c6f8ddefa1797a58e8f9003e7b">jacobian</a></td></tr>
<tr class="separator:a421376c6f8ddefa1797a58e8f9003e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb54ca45a7f4e02fc77d8651f08af427"><td class="memItemLeft" align="right" valign="top">const VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#abb54ca45a7f4e02fc77d8651f08af427">J_value</a></td></tr>
<tr class="separator:abb54ca45a7f4e02fc77d8651f08af427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd6146dc538c94a881eb0a6b216f313"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a7cd6146dc538c94a881eb0a6b216f313">normal_vectors</a></td></tr>
<tr class="separator:a7cd6146dc538c94a881eb0a6b216f313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b06df026ae07f6b6a0b96c7395985d9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a2b06df026ae07f6b6a0b96c7395985d9">normal_x_jacobian</a></td></tr>
<tr class="separator:a2b06df026ae07f6b6a0b96c7395985d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b872287e6c00c65b77919e58c2fe64c"><td class="memItemLeft" align="right" valign="top">const Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a5b872287e6c00c65b77919e58c2fe64c">quadrature_weights</a></td></tr>
<tr class="separator:a5b872287e6c00c65b77919e58c2fe64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2db8170a4e834313fa1775d50c26a2"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#aba2db8170a4e834313fa1775d50c26a2">cell</a></td></tr>
<tr class="separator:aba2db8170a4e834313fa1775d50c26a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc1a1074ec29081286adcbff30844fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a1dc1a1074ec29081286adcbff30844fe">is_interior_face</a></td></tr>
<tr class="separator:a1dc1a1074ec29081286adcbff30844fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c4f195d4895c0b57af17a71ee6718c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744e">internal::MatrixFreeFunctions::DoFInfo::DoFAccessIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#ab5c4f195d4895c0b57af17a71ee6718c">dof_access_index</a></td></tr>
<tr class="separator:ab5c4f195d4895c0b57af17a71ee6718c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04643788ab09d99f9d107c4b6879d6b1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a04643788ab09d99f9d107c4b6879d6b1">face_no</a></td></tr>
<tr class="separator:a04643788ab09d99f9d107c4b6879d6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a69d8b541c14cc64cc2626d3884dfb3"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a4a69d8b541c14cc64cc2626d3884dfb3">face_orientation</a></td></tr>
<tr class="separator:a4a69d8b541c14cc64cc2626d3884dfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170d149afc7b1e8d7315c3038ddd0aec"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a170d149afc7b1e8d7315c3038ddd0aec">subface_index</a></td></tr>
<tr class="separator:a170d149afc7b1e8d7315c3038ddd0aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c75f69107df221620b6dcbc292065d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__matrixfree.html#gae024b29b6819e727d47016c6b6b53d8c">internal::MatrixFreeFunctions::GeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a50c75f69107df221620b6dcbc292065d">cell_type</a></td></tr>
<tr class="separator:a50c75f69107df221620b6dcbc292065d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc1956583b69b8f1010da1dbce26403"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinternal_1_1MatrixFreeFunctions_1_1MappingDataOnTheFly.html">internal::MatrixFreeFunctions::MappingDataOnTheFly</a>&lt; dim, Number, VectorizedArrayType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a6bc1956583b69b8f1010da1dbce26403">mapped_geometry</a></td></tr>
<tr class="separator:a6bc1956583b69b8f1010da1dbce26403"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8389733d86acb11c57206655ba9814ee"><td class="memItemLeft" align="right" valign="top">std::array&lt; unsigned <a class="el" href="classint.html">int</a>, VectorizedArrayType::size()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a8389733d86acb11c57206655ba9814ee">compute_face_no_data</a> ()</td></tr>
<tr class="separator:a8389733d86acb11c57206655ba9814ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982d5af751002552023151b030a2bb0c"><td class="memItemLeft" align="right" valign="top">std::array&lt; unsigned <a class="el" href="classint.html">int</a>, VectorizedArrayType::size()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEFaceEvaluation.html#a982d5af751002552023151b030a2bb0c">compute_face_orientations</a> ()</td></tr>
<tr class="separator:a982d5af751002552023151b030a2bb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt;<br />
class FEFaceEvaluation&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;</h3>

<p>The class that provides all functions necessary to evaluate functions at quadrature points and face integrations. The design of the class is similar to <a class="el" href="classFEEvaluation.html">FEEvaluation</a> and most of the interfaces are shared with that class, in particular most access functions that come from the common base classes <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a> and <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>. Furthermore, the relation of this class to <a class="el" href="classFEEvaluation.html">FEEvaluation</a> is similar to the relation between <a class="el" href="classFEValues.html">FEValues</a> and <a class="el" href="classFEFaceValues.html">FEFaceValues</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>Dimension in which this class is to be used</td></tr>
    <tr><td class="paramname">fe_degree</td><td>Degree of the tensor product finite element with fe_degree+1 degrees of freedom per coordinate direction. If set to -1, the degree of the underlying element will be used, which acts as a run time constant rather than a compile time constant that slows down the execution.</td></tr>
    <tr><td class="paramname">n_q_points_1d</td><td>Number of points in the quadrature formula in 1D, usually chosen as fe_degree+1</td></tr>
    <tr><td class="paramname">n_components</td><td>Number of vector components when solving a system of PDEs. If the same operation is applied to several components of a PDE (e.g. a vector Laplace equation), they can be applied simultaneously with one call (and often more efficiently)</td></tr>
    <tr><td class="paramname">Number</td><td>Number format, usually <code>double</code> or <code>float</code> </td></tr>
    <tr><td class="paramname">VectorizedArrayType</td><td>Type of array to be woked on in a vectorized fashion, defaults to <a class="el" href="classVectorizedArray.html">VectorizedArray&lt;Number&gt;</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Currently only VectorizedArray&lt;Number, width&gt; is supported as VectorizedArrayType. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l03006">3006</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae12fa0d11f28fd0825a55920497ae97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12fa0d11f28fd0825a55920497ae97d">&#9670;&nbsp;</a></span>BaseClass</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEFaceEvaluation.html#ae12fa0d11f28fd0825a55920497ae97d">BaseClass</a> =  <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a>&lt;dim, n_components_, Number, true, VectorizedArrayType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias to the base class. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l03021">3021</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="aa1f18f88e4e79ba7958c581884d10fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f18f88e4e79ba7958c581884d10fd5">&#9670;&nbsp;</a></span>number_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEEvaluationBase.html#a155a4a32adfd4c256bcac84b13c8a368">number_type</a> =  Number</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A underlying number type specified as template argument. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l03026">3026</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a0076169f7b0fb1fa7c197ea4325bb324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0076169f7b0fb1fa7c197ea4325bb324">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> =  typename <a class="el" href="classFEEvaluationAccess.html#a341c39cbf9948d06561b74f9c5050d10">BaseClass::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of function values, e.g. <code>VectorizedArrayType</code> for <code>n_components=1</code> or <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim,VectorizedArrayType &gt;</code> for <code>n_components=dim</code>. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l03033">3033</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="ad5ac66f58cec9630c76cc0f29f9d497e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ac66f58cec9630c76cc0f29f9d497e">&#9670;&nbsp;</a></span>gradient_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEEvaluationBase.html#a7850917bacc47dc16fb1e5bd491f8e04">gradient_type</a> =  typename <a class="el" href="classFEEvaluationAccess.html#a6167b54604de2e9022ec743267e5a25b">BaseClass::gradient_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of gradients, e.g. <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim,VectorizedArrayType&gt;</code> for <code>n_components=1</code> or <code><a class="el" href="classTensor.html">Tensor</a>&lt;2,dim,VectorizedArrayType &gt;</code> for <code>n_components=dim</code>. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l03040">3040</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acdaaf051d3f8f8ada47520efb0811acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdaaf051d3f8f8ada47520efb0811acb">&#9670;&nbsp;</a></span>FEFaceEvaluation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_free</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_interior_face</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_no</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_no</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_selected_component</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>active_fe_index</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>active_quad_index</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_type</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Takes all data stored in <a class="el" href="classMatrixFree.html">MatrixFree</a>. If applied to problems with more than one finite element or more than one quadrature formula selected during construction of <code>matrix_free</code>, the appropriate component can be selected by the optional arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix_free</td><td>Data object that contains all data</td></tr>
    <tr><td class="paramname">is_interior_face</td><td>This selects which of the two cells of an internal face the current evaluator will be based upon. The interior face is the main face along which the normal vectors are oriented. The exterior face coming from the other side provides the same normal vector as the interior side, so if the outer normal vector to that side is desired, it must be multiplied by -1.</td></tr>
    <tr><td class="paramname">dof_no</td><td>If matrix_free was set up with multiple <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, this parameter selects to which DoFHandler/AffineConstraints pair the given evaluator should be attached to.</td></tr>
    <tr><td class="paramname">quad_no</td><td>If matrix_free was set up with multiple <a class="el" href="classQuadrature.html">Quadrature</a> objects, this parameter selects the appropriate number of the quadrature formula.</td></tr>
    <tr><td class="paramname">first_selected_component</td><td>If the dof_handler selected by dof_no uses an <a class="el" href="classFESystem.html">FESystem</a> consisting of more than one base element, this parameter selects the number of the base element in <a class="el" href="classFESystem.html">FESystem</a>. Note that this does not directly relate to the component of the respective element due to the possibility for a multiplicity in the element.</td></tr>
    <tr><td class="paramname">active_fe_index</td><td>If matrix_free was set up with <a class="el" href="classDoFHandler.html">DoFHandler</a> objects with hp::FECollections, this parameter selects to which DoFHandler/AffineConstraints pair the given evaluator should be attached to.</td></tr>
    <tr><td class="paramname">face_type</td><td>In the case of a face, indicate its reference-cell type (0 for line or quadrilateral 1 for triangle).</td></tr>
    <tr><td class="paramname">active_quad_index</td><td>If matrix_free was set up with <a class="el" href="classhp_1_1Collection.html">hp::Collection</a> objects, this parameter selects the appropriate number of the quadrature formula. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fedfdec25287e183f1fb3d625a08cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fedfdec25287e183f1fb3d625a08cd6">&#9670;&nbsp;</a></span>FEFaceEvaluation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_free</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_interior_face</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_no</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_no</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_selected_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Takes all data stored in <a class="el" href="classMatrixFree.html">MatrixFree</a> for a given face range, which allows to automatically identify the active_fe_index and active_quad_index in case of a p-adaptive strategy.</p>
<p>The rest of the arguments are the same as in the constructor above. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a45172115b15c8139f34216ceee323d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45172115b15c8139f34216ceee323d5b">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_batch_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the operation pointer to the current face. This method is the default choice for face integration as the data stored in MappingInfo is stored according to this numbering. Unlike the reinit functions taking a cell iterator as argument below and the <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> methods, where the information related to a particular cell is generated in the reinit call, this function is very cheap since all data is pre-computed in <code>matrix_free</code>, and only a few indices and pointers have to be set appropriately. </p>

</div>
</div>
<a id="a5036f0b01658df30ff653edd863ba6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5036f0b01658df30ff653edd863ba6bf">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As opposed to the <a class="el" href="classFEFaceEvaluation.html#a45172115b15c8139f34216ceee323d5b">reinit()</a> method from the base class, this <a class="el" href="classFEFaceEvaluation.html#a45172115b15c8139f34216ceee323d5b">reinit()</a> method initializes for a given number of cells and a face number. This method is less efficient than the other <a class="el" href="classFEFaceEvaluation.html#a45172115b15c8139f34216ceee323d5b">reinit()</a> method taking a numbering of the faces because it needs to copy the data associated with the faces to the cells in this call. </p>

</div>
</div>
<a id="abc9958a53c2aaad1cf773fff6d104ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9958a53c2aaad1cf773fff6d104ff2">&#9670;&nbsp;</a></span>fast_evaluation_supported()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::fast_evaluation_supported </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>given_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>give_n_q_points_1d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if face evaluation/integration is supported. </p>

</div>
</div>
<a id="a92f84b8ad276ca9866f30c6f789cf3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f84b8ad276ca9866f30c6f789cf3a4">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>evaluation_flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluates the function values, the gradients, and the Laplacians of the FE function given at the DoF values stored in the internal data field <code>dof_values</code> (that is usually filled by the <a class="el" href="classFEEvaluationBase.html#a5c3bf28ebceb0271addfba5b92f475ce">read_dof_values()</a> method) at the quadrature points on the unit cell. The function arguments specify which parts shall actually be computed. Needs to be called before the functions <a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">get_value()</a>, <a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">get_gradient()</a> or <a class="el" href="classFEEvaluationBase.html#aee54d24ac9e0dcfe9a4571a6b047cd03">get_normal_derivative()</a> give useful information (unless these values have been set manually by accessing the internal data pointers). </p>

</div>
</div>
<a id="a97a0e593e62982eb64b29da34529af11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a0e593e62982eb64b29da34529af11">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8h.html#a8ce3607a2c3e9ba0f1d553bff4a3b588">DEAL_II_DEPRECATED_EARLY</a> void <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>evaluate_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>evaluate_gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000065">Deprecated:</a></b></dt><dd>Please use the <a class="el" href="classFEFaceEvaluation.html#a92f84b8ad276ca9866f30c6f789cf3a4">evaluate()</a> function with the <a class="el" href="namespaceEvaluationFlags.html" title="The namespace for the EvaluationFlags enum. ">EvaluationFlags</a> argument. </dd></dl>

</div>
</div>
<a id="a688c3dd3a1bba5d50ed3b714c56e6c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688c3dd3a1bba5d50ed3b714c56e6c14">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const VectorizedArrayType *&#160;</td>
          <td class="paramname"><em>values_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>evaluation_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluates the function values, the gradients, and the Laplacians of the FE function given at the DoF values in the input array <code>values_array</code> at the quadrature points on the unit cell. If multiple components are involved in the current <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object, the sorting in values_array is such that all degrees of freedom for the first component come first, then all degrees of freedom for the second, and so on. The function arguments specify which parts shall actually be computed. Needs to be called before the functions <a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">get_value()</a>, <a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">get_gradient()</a>, or <a class="el" href="classFEEvaluationBase.html#aee54d24ac9e0dcfe9a4571a6b047cd03">get_normal_derivative()</a> give useful information (unless these values have been set manually). </p>

</div>
</div>
<a id="a741af7619c41978865d9ff6bc7cb57c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741af7619c41978865d9ff6bc7cb57c5">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8h.html#a8ce3607a2c3e9ba0f1d553bff4a3b588">DEAL_II_DEPRECATED_EARLY</a> void <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const VectorizedArrayType *&#160;</td>
          <td class="paramname"><em>values_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>evaluate_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>evaluate_gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000066">Deprecated:</a></b></dt><dd>Please use the <a class="el" href="classFEFaceEvaluation.html#a92f84b8ad276ca9866f30c6f789cf3a4">evaluate()</a> function with the <a class="el" href="namespaceEvaluationFlags.html" title="The namespace for the EvaluationFlags enum. ">EvaluationFlags</a> argument. </dd></dl>

</div>
</div>
<a id="a4ac53fde2eab227ef45c7d29a5ed33fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac53fde2eab227ef45c7d29a5ed33fe">&#9670;&nbsp;</a></span>gather_evaluate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::gather_evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>input_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>evaluation_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads from the input vector and evaluates the function values, the gradients, and the Laplacians of the FE function at the quadrature points on the unit cell. The function arguments specify which parts shall actually be computed. Needs to be called before the functions <a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">get_value()</a>, <a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">get_gradient()</a>, or <a class="el" href="classFEEvaluationBase.html#aee54d24ac9e0dcfe9a4571a6b047cd03">get_normal_derivative()</a> give useful information.</p>
<p>This call is equivalent to calling <a class="el" href="classFEEvaluationBase.html#a5c3bf28ebceb0271addfba5b92f475ce">read_dof_values()</a> followed by <a class="el" href="classFEFaceEvaluation.html#a92f84b8ad276ca9866f30c6f789cf3a4">evaluate()</a>, but might internally use some additional optimizations. </p>

</div>
</div>
<a id="ab246fddd0d6472a1b8d68293965c47c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab246fddd0d6472a1b8d68293965c47c5">&#9670;&nbsp;</a></span>gather_evaluate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8h.html#a8ce3607a2c3e9ba0f1d553bff4a3b588">DEAL_II_DEPRECATED_EARLY</a> void <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::gather_evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>input_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>evaluate_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>evaluate_gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000067">Deprecated:</a></b></dt><dd>Please use the <a class="el" href="classFEFaceEvaluation.html#a4ac53fde2eab227ef45c7d29a5ed33fe">gather_evaluate()</a> function with the <a class="el" href="namespaceEvaluationFlags.html" title="The namespace for the EvaluationFlags enum. ">EvaluationFlags</a> argument. </dd></dl>

</div>
</div>
<a id="ad5d6ed6254b4d18ef4357ed6aa0974ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d6ed6254b4d18ef4357ed6aa0974ae">&#9670;&nbsp;</a></span>integrate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>evaluation_flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function takes the values and/or gradients that are stored on quadrature points, tests them by all the basis functions/gradients on the cell and performs the cell integration. The two function arguments <code>integrate_val</code> and <code>integrate_grad</code> are used to enable/disable some of values or gradients. The result is written into the internal data field <code>dof_values</code> (that is usually written into the result vector by the <a class="el" href="classFEEvaluationBase.html#a13c9d8eac4ca7b3f7d45eda97ea8e2fb">distribute_local_to_global()</a> or <a class="el" href="classFEEvaluationBase.html#a459813036810fbdc3c5487309b118fd8">set_dof_values()</a> methods). </p>

</div>
</div>
<a id="aef9ff7adf08f4b628d818b867886b347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9ff7adf08f4b628d818b867886b347">&#9670;&nbsp;</a></span>integrate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8h.html#a8ce3607a2c3e9ba0f1d553bff4a3b588">DEAL_II_DEPRECATED_EARLY</a> void <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>integrate_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>integrate_gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000068">Deprecated:</a></b></dt><dd>Please use the <a class="el" href="classFEFaceEvaluation.html#ad5d6ed6254b4d18ef4357ed6aa0974ae">integrate()</a> function with the <a class="el" href="namespaceEvaluationFlags.html" title="The namespace for the EvaluationFlags enum. ">EvaluationFlags</a> argument. </dd></dl>

</div>
</div>
<a id="af62960edf0c3d1b80cb785696314a353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62960edf0c3d1b80cb785696314a353">&#9670;&nbsp;</a></span>integrate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>evaluation_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorizedArrayType *&#160;</td>
          <td class="paramname"><em>values_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function takes the values and/or gradients that are stored on quadrature points, tests them by all the basis functions/gradients on the cell and performs the cell integration. The two function arguments <code>integrate_val</code> and <code>integrate_grad</code> are used to enable/disable some of values or gradients. As opposed to the other <a class="el" href="classFEFaceEvaluation.html#ad5d6ed6254b4d18ef4357ed6aa0974ae">integrate()</a> method, this call stores the result of the testing in the given array <code>values_array</code>. </p>

</div>
</div>
<a id="a233e74614b6dad83a9eedffaf7b0595c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233e74614b6dad83a9eedffaf7b0595c">&#9670;&nbsp;</a></span>integrate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8h.html#a8ce3607a2c3e9ba0f1d553bff4a3b588">DEAL_II_DEPRECATED_EARLY</a> void <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>integrate_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>integrate_gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorizedArrayType *&#160;</td>
          <td class="paramname"><em>values_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000069">Deprecated:</a></b></dt><dd>Please use the <a class="el" href="classFEFaceEvaluation.html#ad5d6ed6254b4d18ef4357ed6aa0974ae">integrate()</a> function with the <a class="el" href="namespaceEvaluationFlags.html" title="The namespace for the EvaluationFlags enum. ">EvaluationFlags</a> argument. </dd></dl>

</div>
</div>
<a id="ad8963360c30a43aca90a764443fc954f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8963360c30a43aca90a764443fc954f">&#9670;&nbsp;</a></span>integrate_scatter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::integrate_scatter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>evaluation_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>output_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function takes the values and/or gradients that are stored on quadrature points, tests them by all the basis functions/gradients on the cell and performs the cell integration. The two function arguments <code>integrate_val</code> and <code>integrate_grad</code> are used to enable/disable some of values or gradients.</p>
<p>This call is equivalent to calling <a class="el" href="classFEFaceEvaluation.html#ad5d6ed6254b4d18ef4357ed6aa0974ae">integrate()</a> followed by <a class="el" href="classFEEvaluationBase.html#a13c9d8eac4ca7b3f7d45eda97ea8e2fb">distribute_local_to_global()</a>, but might internally use some additional optimizations. </p>

</div>
</div>
<a id="ae65f5f0e0f741ac7305e6cbda5c524aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65f5f0e0f741ac7305e6cbda5c524aa">&#9670;&nbsp;</a></span>integrate_scatter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::integrate_scatter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>integrate_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>integrate_gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>output_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000070">Deprecated:</a></b></dt><dd>Please use the <a class="el" href="classFEFaceEvaluation.html#ad8963360c30a43aca90a764443fc954f">integrate_scatter()</a> function with the <a class="el" href="namespaceEvaluationFlags.html" title="The namespace for the EvaluationFlags enum. ">EvaluationFlags</a> argument. </dd></dl>

</div>
</div>
<a id="abd6d0dc13e7e10c558170af34f53db19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6d0dc13e7e10c558170af34f53db19">&#9670;&nbsp;</a></span>quadrature_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;dim, VectorizedArrayType&gt; <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::quadrature_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the q-th quadrature point on the face in real coordinates stored in MappingInfo. </p>

</div>
</div>
<a id="a8389733d86acb11c57206655ba9814ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8389733d86acb11c57206655ba9814ee">&#9670;&nbsp;</a></span>compute_face_no_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;unsigned <a class="el" href="classint.html">int</a>, VectorizedArrayType::size()&gt; <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::compute_face_no_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return face number of each face of the current face batch. </p>

</div>
</div>
<a id="a982d5af751002552023151b030a2bb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982d5af751002552023151b030a2bb0c">&#9670;&nbsp;</a></span>compute_face_orientations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;unsigned <a class="el" href="classint.html">int</a>, VectorizedArrayType::size()&gt; <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::compute_face_orientations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the orientation of each face of the current face batch. </p>

</div>
</div>
<a id="a5c3bf28ebceb0271addfba5b92f475ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3bf28ebceb0271addfba5b92f475ce">&#9670;&nbsp;</a></span>read_dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::read_dof_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For the vector <code>src</code>, read out the values on the degrees of freedom of the current cell, and store them internally. Similar functionality as the function DoFAccessor::get_interpolated_dof_values when no constraints are present, but it also includes constraints from hanging nodes, so one can see it as a similar function to AffineConstraints::read_dof_values as well. Note that if vectorization is enabled, the DoF values for several cells are set.</p>
<p>If some constraints on the vector are inhomogeneous, use the function read_dof_values_plain instead and provide the vector with useful data also in constrained positions by calling <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute</a>. When accessing vector entries during the solution of linear systems, the temporary solution should always have homogeneous constraints and this method is the correct one.</p>
<p>If the given vector template class is a block vector (determined through the template function '<a class="el" href="group__Vectors.html#gaf1aa9207795db77aaa6d5d0f23e8dbe7">IsBlockVector&lt;VectorType&gt;::value</a>', which checks for vectors derived from <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>) or an std::vector&lt;VectorType&gt; or std::vector&lt;VectorType *&gt;, this function reads <code>n_components</code> blocks from the block vector starting at the index <code>first_index</code>. For non-block vectors, <code>first_index</code> is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>If this class was constructed without a <a class="el" href="classMatrixFree.html">MatrixFree</a> object and the information is acquired on the fly through a <a class="el" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;dim&gt;::cell_iterator</a>, only one single cell is used by this class and this function extracts the values of the underlying components on the given cell. This call is slower than the ones done through a <a class="el" href="classMatrixFree.html">MatrixFree</a> object and lead to a structure that does not effectively use vectorization in the evaluate routines based on these values (instead, <a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray::size()</a> same copies are worked on). </dd></dl>

</div>
</div>
<a id="a5bd35a59ccde6eaab46d1264450b93f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd35a59ccde6eaab46d1264450b93f5">&#9670;&nbsp;</a></span>read_dof_values_plain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::read_dof_values_plain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For the vector <code>src</code>, read out the values on the degrees of freedom of the current cell, and store them internally. Similar functionality as the function DoFAccessor::get_interpolated_dof_values. As opposed to the read_dof_values function, this function reads out the plain entries from vectors, without taking stored constraints into account. This way of access is appropriate when the constraints have been distributed on the vector by a call to <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute</a> previously. This function is also necessary when inhomogeneous constraints are to be used, as <a class="el" href="classMatrixFree.html">MatrixFree</a> can only handle homogeneous constraints. Note that if vectorization is enabled, the DoF values for several cells are set.</p>
<p>If the given vector template class is a block vector (determined through the template function '<a class="el" href="group__Vectors.html#gaf1aa9207795db77aaa6d5d0f23e8dbe7">IsBlockVector&lt;VectorType&gt;::value</a>', which checks for vectors derived from <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>) or an std::vector&lt;VectorType&gt; or std::vector&lt;VectorType *&gt;, this function reads <code>n_components</code> blocks from the block vector starting at the index <code>first_index</code>. For non-block vectors, <code>first_index</code> is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>If this class was constructed without a <a class="el" href="classMatrixFree.html">MatrixFree</a> object and the information is acquired on the fly through a <a class="el" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;dim&gt;::cell_iterator</a>, only one single cell is used by this class and this function extracts the values of the underlying components on the given cell. This call is slower than the ones done through a <a class="el" href="classMatrixFree.html">MatrixFree</a> object and lead to a structure that does not effectively use vectorization in the evaluate routines based on these values (instead, <a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray::size()</a> same copies are worked on). </dd></dl>

</div>
</div>
<a id="a13c9d8eac4ca7b3f7d45eda97ea8e2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c9d8eac4ca7b3f7d45eda97ea8e2fb">&#9670;&nbsp;</a></span>distribute_local_to_global()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>std::bitset&lt;&#160;VectorizedArrayType::size()&gt;().flip()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes the values stored internally on dof values of the current cell and sums them into the vector <code>dst</code>. The function also applies constraints during the write operation. The functionality is hence similar to the function <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a>. If vectorization is enabled, the DoF values for several cells are used.</p>
<p>If the given vector template class is a block vector (determined through the template function '<a class="el" href="group__Vectors.html#gaf1aa9207795db77aaa6d5d0f23e8dbe7">IsBlockVector&lt;VectorType&gt;::value</a>', which checks for vectors derived from <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>) or an std::vector&lt;VectorType&gt; or std::vector&lt;VectorType *&gt;, this function writes to <code>n_components</code> blocks of the block vector starting at the index <code>first_index</code>. For non-block vectors, <code>first_index</code> is ignored.</p>
<p>The <code>mask</code> can be used to suppress the write access for some of the cells contained in the current cell vectorization batch, e.g. in case of local time stepping, where some cells are excluded from a call. A value of <code>true</code> in the bitset means that the respective lane index will be processed, whereas a value of <code>false</code> skips this index. The default setting is a bitset that contains all ones, which will write the accumulated integrals to all cells in the batch.</p>
<dl class="section note"><dt>Note</dt><dd>If this class was constructed without a <a class="el" href="classMatrixFree.html">MatrixFree</a> object and the information is acquired on the fly through a <a class="el" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;dim&gt;::cell_iterator</a>, only one single cell is used by this class and this function extracts the values of the underlying components on the given cell. This call is slower than the ones done through a <a class="el" href="classMatrixFree.html">MatrixFree</a> object and lead to a structure that does not effectively use vectorization in the evaluate routines based on these values (instead, <a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray::size()</a> same copies are worked on). </dd></dl>

</div>
</div>
<a id="a459813036810fbdc3c5487309b118fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459813036810fbdc3c5487309b118fd8">&#9670;&nbsp;</a></span>set_dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::set_dof_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>std::bitset&lt;&#160;VectorizedArrayType::size()&gt;().flip()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes the values stored internally on dof values of the current cell and writes them into the vector <code>dst</code>. The function skips the degrees of freedom which are constrained. As opposed to the distribute_local_to_global method, the old values at the position given by the current cell are overwritten. Thus, if a degree of freedom is associated to more than one cell (as usual in continuous finite elements), the values will be overwritten and only the value written last is retained. Please note that in a parallel context this function might also touch degrees of freedom owned by other MPI processes, so that a subsequent update or accumulation of ghost values as done by <a class="el" href="classMatrixFree.html#a0e9669e4a5cfaceac78f5e26c285c2ea">MatrixFree::loop()</a> might invalidate the degrees of freedom set by this function.</p>
<p>If the given vector template class is a block vector (determined through the template function '<a class="el" href="group__Vectors.html#gaf1aa9207795db77aaa6d5d0f23e8dbe7">IsBlockVector&lt;VectorType&gt;::value</a>', which checks for vectors derived from <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>) or an std::vector&lt;VectorType&gt; or std::vector&lt;VectorType *&gt;, this function writes to <code>n_components</code> blocks of the block vector starting at the index <code>first_index</code>. For non-block vectors, <code>first_index</code> is ignored.</p>
<p>The <code>mask</code> can be used to suppress the write access for some of the cells contained in the current cell vectorization batch, e.g. in case of local time stepping, where some cells are excluded from a call. A value of <code>true</code> in the bitset means that the respective lane index will be processed, whereas a value of <code>false</code> skips this index. The default setting is a bitset that contains all ones, which will write the accumulated integrals to all cells in the batch.</p>
<dl class="section note"><dt>Note</dt><dd>If this class was constructed without a <a class="el" href="classMatrixFree.html">MatrixFree</a> object and the information is acquired on the fly through a <a class="el" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;dim&gt;::cell_iterator</a>, only one single cell is used by this class and this function extracts the values of the underlying components on the given cell. This call is slower than the ones done through a <a class="el" href="classMatrixFree.html">MatrixFree</a> object and lead to a structure that does not effectively use vectorization in the evaluate routines based on these values (instead, <a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray::size()</a> same copies are worked on). </dd></dl>

</div>
</div>
<a id="afc923ce61f6399bcd717ab9f99f62ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc923ce61f6399bcd717ab9f99f62ca0">&#9670;&nbsp;</a></span>set_dof_values_plain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::set_dof_values_plain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>std::bitset&lt;&#160;VectorizedArrayType::size()&gt;().flip()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classFEEvaluationBase.html#a459813036810fbdc3c5487309b118fd8">set_dof_values()</a>, but without resolving constraints. </p>

</div>
</div>
<a id="a0660b27a2a592994dfd2fc917305a3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0660b27a2a592994dfd2fc917305a3ac">&#9670;&nbsp;</a></span>get_dof_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_dof_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value stored for the local degree of freedom with index <code>dof</code>. If the object is vector-valued, a vector-valued return argument is given. Thus, the argument <code>dof</code> can at most run until <code>dofs_per_component</code> rather than <code>dofs_per_cell</code> since the different components of a vector-valued FE are return together. Note that when vectorization is enabled, values from several cells are grouped together. If <code>set_dof_values</code> was called last, the value corresponds to the one set there. If <code>integrate</code> was called last, it instead corresponds to the value of the integrated function with the test function of the given index.</p>
<p>Note that the derived class <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a> overloads this operation with specializations for the scalar case (n_components == 1) and for the vector-valued case (n_components == dim). </p>

</div>
</div>
<a id="a3afd9d62f5762c41973aa0f037dc5099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afd9d62f5762c41973aa0f037dc5099">&#9670;&nbsp;</a></span>submit_dof_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::submit_dof_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td>
          <td class="paramname"><em>val_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a value to the field containing the degrees of freedom with component <code>dof</code>. Writes to the same field as is accessed through <code>get_dof_value</code>. Therefore, the original data that was read from a vector is overwritten as soon as a value is submitted.</p>
<p>Note that the derived class <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a> overloads this operation with specializations for the scalar case (n_components == 1) and for the vector-valued case (n_components == dim). </p>

</div>
</div>
<a id="aeecc76ffeff6b36816f6af20af1398a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecc76ffeff6b36816f6af20af1398a8">&#9670;&nbsp;</a></span>get_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of a finite element function at quadrature point number <code>q_point</code> after a call to <a class="el" href="classFEEvaluation.html#a710c252e9dccc0c4ce07044cac3bdd9b">FEEvaluation::evaluate()</a> with <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> set, or the value that has been stored there with a call to <a class="el" href="classFEEvaluationBase.html#a2c0efc6f70b305c0585001632063c98b">FEEvaluationBase::submit_value()</a>. If the object is vector-valued, a vector-valued return argument is given. Note that when vectorization is enabled, values from several cells are grouped together.</p>
<p>Note that the derived class <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a> overloads this operation with specializations for the scalar case (n_components == 1) and for the vector-valued case (n_components == dim). </p>

</div>
</div>
<a id="a2c0efc6f70b305c0585001632063c98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0efc6f70b305c0585001632063c98b">&#9670;&nbsp;</a></span>submit_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::submit_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td>
          <td class="paramname"><em>val_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a value to the field containing the values on quadrature points with component <code>q_point</code>. Access to the same field as through <a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">get_value()</a>. If applied before the function <a class="el" href="classFEEvaluation.html#ad61cbe0d7d6138be040d46ae06a268f1">FEEvaluation::integrate()</a> with <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> set is called, this specifies the value which is tested by all basis function on the current cell and integrated over.</p>
<p>Note that the derived class <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a> overloads this operation with specializations for the scalar case (n_components == 1) and for the vector-valued case (n_components == dim). </p>

</div>
</div>
<a id="a132c024aa9243845d3777b227607da6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132c024aa9243845d3777b227607da6b">&#9670;&nbsp;</a></span>get_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluationBase.html#a7850917bacc47dc16fb1e5bd491f8e04">gradient_type</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_gradient </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of a finite element function at quadrature point number <code>q_point</code> after a call to <a class="el" href="classFEEvaluation.html#a710c252e9dccc0c4ce07044cac3bdd9b">FEEvaluation::evaluate()</a> with <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>, or the value that has been stored there with a call to <a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">FEEvaluationBase::submit_gradient()</a>.</p>
<p>Note that the derived class <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a> overloads this operation with specializations for the scalar case (n_components == 1) and for the vector-valued case (n_components == dim). </p>

</div>
</div>
<a id="aee54d24ac9e0dcfe9a4571a6b047cd03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee54d24ac9e0dcfe9a4571a6b047cd03">&#9670;&nbsp;</a></span>get_normal_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_normal_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the derivative of a finite element function at quadrature point number <code>q_point</code> after a call to FEEvaluation::evaluate(EvaluationFlags::gradients) the direction normal to the face: \(\boldsymbol \nabla u(\mathbf x_q) \cdot \mathbf n(\mathbf x_q)\)</p>
<p>This call is equivalent to calling <a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">get_gradient()</a> * <a class="el" href="classFEEvaluationBaseData.html#a264ced911d2818b0a04b8855bb482b45">get_normal_vector()</a> but will use a more efficient internal representation of data.</p>
<p>Note that the derived class <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a> overloads this operation with specializations for the scalar case (n_components == 1) and for the vector-valued case (n_components == dim). </p>

</div>
</div>
<a id="a2a78655d119bd1bde992619c52b2d2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a78655d119bd1bde992619c52b2d2f8">&#9670;&nbsp;</a></span>submit_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::submit_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFEEvaluationBase.html#a7850917bacc47dc16fb1e5bd491f8e04">gradient_type</a>&#160;</td>
          <td class="paramname"><em>grad_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a contribution that is tested by the gradient to the field containing the values on quadrature points with component <code>q_point</code>. Access to the same field as through <a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">get_gradient()</a>. If applied before the function FEEvaluation::integrate(EvaluationFlags::gradients) is called, this specifies what is tested by all basis function gradients on the current cell and integrated over.</p>
<p>Note that the derived class <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a> overloads this operation with specializations for the scalar case (n_components == 1) and for the vector-valued case (n_components == dim). </p>

</div>
</div>
<a id="ad6e7e621190fb28eeeffa58311f711ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e7e621190fb28eeeffa58311f711ce">&#9670;&nbsp;</a></span>submit_normal_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::submit_normal_derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td>
          <td class="paramname"><em>grad_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a contribution that is tested by the gradient to the field containing the values on quadrature points with component <code>q_point</code>. Access to the same field as through <a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">get_gradient()</a> or <a class="el" href="classFEEvaluationBase.html#aee54d24ac9e0dcfe9a4571a6b047cd03">get_normal_derivative()</a>. If applied before the function FEEvaluation::integrate(EvaluationFlags::gradients) is called, this specifies what is tested by all basis function gradients on the current cell and integrated over.</p>
<dl class="section note"><dt>Note</dt><dd>This operation writes the data to the same field as <a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">submit_gradient()</a>. As a consequence, only one of these two can be used. Usually, the contribution of a potential call to this function must be added into the contribution for <a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">submit_gradient()</a>.</dd>
<dd>
The derived class <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a> overloads this operation with specializations for the scalar case (n_components == 1) and for the vector-valued case (n_components == dim). </dd></dl>

</div>
</div>
<a id="af637d7fcd92a58cf1e8597269a13e9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af637d7fcd92a58cf1e8597269a13e9bd">&#9670;&nbsp;</a></span>get_hessian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, n_components_, <a class="el" href="classTensor.html">Tensor</a>&lt;2, dim, VectorizedArrayType&gt; &gt; <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_hessian </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the Hessian of a finite element function at quadrature point number <code>q_point</code> after a call to FEEvaluation::evaluate(EvaluationFlags::hessians). If only the diagonal or even the trace of the Hessian, the Laplacian, is needed, use the other functions below.</p>
<p>Note that the derived class <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a> overloads this operation with specializations for the scalar case (n_components == 1) and for the vector-valued case (n_components == dim). </p>

</div>
</div>
<a id="aaba7f7af4354a4bad6bcf7364978ebf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba7f7af4354a4bad6bcf7364978ebf2">&#9670;&nbsp;</a></span>get_hessian_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluationBase.html#a7850917bacc47dc16fb1e5bd491f8e04">gradient_type</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_hessian_diagonal </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the diagonal of the Hessian of a finite element function at quadrature point number <code>q_point</code> after a call to FEEvaluation::evaluate(EvaluationFlags::hessians).</p>
<p>Note that the derived class <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a> overloads this operation with specializations for the scalar case (n_components == 1) and for the vector-valued case (n_components == dim). </p>

</div>
</div>
<a id="a0c652a4de885613efc5e02dd3754342b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c652a4de885613efc5e02dd3754342b">&#9670;&nbsp;</a></span>get_laplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_laplacian </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the Laplacian (i.e., the trace of the Hessian) of a finite element function at quadrature point number <code>q_point</code> after a call to FEEvaluation::evaluate(EvaluationFlags::hessians). Compared to the case when computing the full Hessian, some operations can be saved when only the Laplacian is requested.</p>
<p>Note that the derived class <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a> overloads this operation with specializations for the scalar case (n_components == 1) and for the vector-valued case (n_components == dim). </p>

</div>
</div>
<a id="a7f6a0959de5c408072c48ee3fd2ca057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6a0959de5c408072c48ee3fd2ca057">&#9670;&nbsp;</a></span>get_divergence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_divergence </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the divergence of a vector-valued finite element at quadrature point number <code>q_point</code> after a call to <code>evaluate</code>(...,true,...).</p>
<dl class="section note"><dt>Note</dt><dd>Only available for n_components_==dim. </dd></dl>

</div>
</div>
<a id="a2b6fe306f7501a59940bfffab2550e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6fe306f7501a59940bfffab2550e6a">&#9670;&nbsp;</a></span>get_symmetric_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim, VectorizedArrayType&gt; <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_symmetric_gradient </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the symmetric gradient of a vector-valued finite element at quadrature point number <code>q_point</code> after a call to <code>evaluate</code>(...,true,...). It corresponds to <code>0.5 (grad+grad<sup>T</sup>)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Only available for n_components_==dim. </dd></dl>

</div>
</div>
<a id="ae036687570ee408ffa461f9c7ae685cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae036687570ee408ffa461f9c7ae685cc">&#9670;&nbsp;</a></span>get_curl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, (dim == 2 ? 1 : dim), VectorizedArrayType&gt; <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_curl </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the curl of the vector field, \(\nabla \times v\) after a call to <code>evaluate</code>(...,true,...).</p>
<dl class="section note"><dt>Note</dt><dd>Only available for n_components_==dim. </dd></dl>

</div>
</div>
<a id="aa0a45432b87f3a6fc20ca91b02d2654d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a45432b87f3a6fc20ca91b02d2654d">&#9670;&nbsp;</a></span>submit_divergence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::submit_divergence </td>
          <td>(</td>
          <td class="paramtype">const VectorizedArrayType&#160;</td>
          <td class="paramname"><em>div_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a contribution that is tested by the divergence to the field containing the values on quadrature points with component <code>q_point</code>. Access to the same field as through <code>get_gradient</code>. If applied before the function <code>integrate</code>(...,true) is called, this specifies what is tested by all basis function gradients on the current cell and integrated over.</p>
<dl class="section note"><dt>Note</dt><dd>Only available for n_components_==dim.</dd>
<dd>
This operation writes the data to the same field as <a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">submit_gradient()</a>. As a consequence, only one of these two can be used. Usually, the contribution of a potential call to this function must be added into the diagonal of the contribution for <a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">submit_gradient()</a>. </dd></dl>

</div>
</div>
<a id="a5b29b531d2d7bfc8596b34f68b6abf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b29b531d2d7bfc8596b34f68b6abf91">&#9670;&nbsp;</a></span>submit_symmetric_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::submit_symmetric_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorizedArrayType &gt;&#160;</td>
          <td class="paramname"><em>grad_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a contribution that is tested by the symmetric gradient to the field containing the values on quadrature points with component <code>q_point</code>. Access to the same field as through <code>get_symmetric_gradient</code>. If applied before the function <code>integrate</code>(...,true) is called, this specifies the symmetric gradient which is tested by all basis function symmetric gradients on the current cell and integrated over.</p>
<dl class="section note"><dt>Note</dt><dd>Only available for n_components_==dim.</dd>
<dd>
This operation writes the data to the same field as <a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">submit_gradient()</a>. As a consequence, only one of these two can be used. Usually, the contribution of a potential call to this function must be added to the respective entries of the rank-2 tensor for <a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">submit_gradient()</a>. </dd></dl>

</div>
</div>
<a id="af317b2c1e630b328f7738287d3b07ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af317b2c1e630b328f7738287d3b07ae6">&#9670;&nbsp;</a></span>submit_curl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::submit_curl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim==2 ? 1 :dim, VectorizedArrayType &gt;&#160;</td>
          <td class="paramname"><em>curl_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the components of a curl containing the values on quadrature point <code>q_point</code>. Access to the same data field as through <code>get_gradient</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Only available for n_components_==dim.</dd>
<dd>
This operation writes the data to the same field as <a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">submit_gradient()</a>. As a consequence, only one of these two can be used. Usually, the contribution of a potential call to this function must be added to the respective entries of the rank-2 tensor for <a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">submit_gradient()</a>. </dd></dl>

</div>
</div>
<a id="ada523fada873497b00071b8b0bc35005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada523fada873497b00071b8b0bc35005">&#9670;&nbsp;</a></span>integrate_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::integrate_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes values at quadrature points, multiplies by the Jacobian determinant and quadrature weights (JxW) and sums the values for all quadrature points on the cell. The result is a scalar, representing the integral over the function over the cell. If a vector-element is used, the resulting components are still separated. Moreover, if vectorization is enabled, the integral values of several cells are contained in the slots of the returned <a class="el" href="classVectorizedArray.html">VectorizedArray</a> field.</p>
<dl class="section note"><dt>Note</dt><dd>In case the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object is initialized with a batch of cells where not all lanes in the SIMD vector <a class="el" href="classVectorizedArray.html">VectorizedArray</a> are representing actual data, this method performs computations on dummy data (that is copied from the last valid lane) that will not make sense. Thus, the user needs to make sure that it is not used in any computation explicitly, like when summing the results of several cells. </dd></dl>

</div>
</div>
<a id="a6998ba7c39eeed60574b25f366184d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6998ba7c39eeed60574b25f366184d0b">&#9670;&nbsp;</a></span>begin_dof_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_dof_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read-only pointer to the first field of the dof values. This is the data field the <a class="el" href="classFEEvaluationBase.html#a5c3bf28ebceb0271addfba5b92f475ce">read_dof_values()</a> functions write into. First come the dof values for the first component, then all values for the second component, and so on. This is related to the internal data structures used in this class. In general, it is safer to use the <a class="el" href="classFEEvaluationBase.html#a0660b27a2a592994dfd2fc917305a3ac">get_dof_value()</a> function instead. </p>

</div>
</div>
<a id="a54213aa80599acf803a3b7c4c487fd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54213aa80599acf803a3b7c4c487fd38">&#9670;&nbsp;</a></span>begin_dof_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_dof_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read and write pointer to the first field of the dof values. This is the data field the <a class="el" href="classFEEvaluationBase.html#a5c3bf28ebceb0271addfba5b92f475ce">read_dof_values()</a> functions write into. First come the dof values for the first component, then all values for the second component, and so on. This is related to the internal data structures used in this class. In general, it is safer to use the <a class="el" href="classFEEvaluationBase.html#a0660b27a2a592994dfd2fc917305a3ac">get_dof_value()</a> function instead. </p>

</div>
</div>
<a id="ac0738826a83db1d28cad958e478f3e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0738826a83db1d28cad958e478f3e27">&#9670;&nbsp;</a></span>begin_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read-only pointer to the first field of function values on quadrature points. First come the function values on all quadrature points for the first component, then all values for the second component, and so on. This is related to the internal data structures used in this class. The raw data after a call to <code>evaluate</code> only contains unit cell operations, so possible transformations, quadrature weights etc. must be applied manually. In general, it is safer to use the <a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">get_value()</a> function instead, which does all the transformation internally. </p>

</div>
</div>
<a id="a8e58470a54179126fe601d26f0088bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e58470a54179126fe601d26f0088bdb">&#9670;&nbsp;</a></span>begin_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read and write pointer to the first field of function values on quadrature points. First come the function values on all quadrature points for the first component, then all values for the second component, and so on. This is related to the internal data structures used in this class. The raw data after a call to <code>evaluate</code> only contains unit cell operations, so possible transformations, quadrature weights etc. must be applied manually. In general, it is safer to use the <a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">get_value()</a> function instead, which does all the transformation internally. </p>

</div>
</div>
<a id="ac9651d02f2fe8a7133867c92fc8f327b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9651d02f2fe8a7133867c92fc8f327b">&#9670;&nbsp;</a></span>begin_gradients() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_gradients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read-only pointer to the first field of function gradients on quadrature points. First comes the x-component of the gradient for the first component on all quadrature points, then the y-component, and so on. Next comes the x-component of the second component, and so on. This is related to the internal data structures used in this class. The raw data after a call to <code>evaluate</code> only contains unit cell operations, so possible transformations, quadrature weights etc. must be applied manually. In general, it is safer to use the <a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">get_gradient()</a> function instead, which does all the transformation internally. </p>

</div>
</div>
<a id="a1f03eb49fe21f5a2eda31c07d3052330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f03eb49fe21f5a2eda31c07d3052330">&#9670;&nbsp;</a></span>begin_gradients() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_gradients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read and write pointer to the first field of function gradients on quadrature points. First comes the x-component of the gradient for the first component on all quadrature points, then the y-component, and so on. Next comes the x-component of the second component, and so on. This is related to the internal data structures used in this class. The raw data after a call to <code>evaluate</code> only contains unit cell operations, so possible transformations, quadrature weights etc. must be applied manually. In general, it is safer to use the <a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">get_gradient()</a> function instead, which does all the transformation internally. </p>

</div>
</div>
<a id="a7bce79fd87c41b7fee59627b4a452125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bce79fd87c41b7fee59627b4a452125">&#9670;&nbsp;</a></span>begin_hessians() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_hessians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read-only pointer to the first field of function hessians on quadrature points. First comes the xx-component of the hessian for the first component on all quadrature points, then the yy-component, zz- component in (3D), then the xy-component, and so on. Next comes the xx- component of the second component, and so on. This is related to the internal data structures used in this class. The raw data after a call to <code>evaluate</code> only contains unit cell operations, so possible transformations, quadrature weights etc. must be applied manually. In general, it is safer to use the <a class="el" href="classFEEvaluationBase.html#a0c652a4de885613efc5e02dd3754342b">get_laplacian()</a> or <a class="el" href="classFEEvaluationBase.html#af637d7fcd92a58cf1e8597269a13e9bd">get_hessian()</a> functions instead, which does all the transformation internally. </p>

</div>
</div>
<a id="a2b0a3def7f22c396ce2884e37b4aa788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0a3def7f22c396ce2884e37b4aa788">&#9670;&nbsp;</a></span>begin_hessians() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_hessians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a read and write pointer to the first field of function hessians on quadrature points. First comes the xx-component of the hessian for the first component on all quadrature points, then the yy-component, zz- component in (3D), then the xy-component, and so on. Next comes the xx- component of the second component, and so on. This is related to the internal data structures used in this class. The raw data after a call to <code>evaluate</code> only contains unit cell operations, so possible transformations, quadrature weights etc. must be applied manually. In general, it is safer to use the <a class="el" href="classFEEvaluationBase.html#a0c652a4de885613efc5e02dd3754342b">get_laplacian()</a> or <a class="el" href="classFEEvaluationBase.html#af637d7fcd92a58cf1e8597269a13e9bd">get_hessian()</a> functions instead, which does all the transformation internally. </p>

</div>
</div>
<a id="a68204d97bb4207d522522f0d624213dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68204d97bb4207d522522f0d624213dc">&#9670;&nbsp;</a></span>get_first_selected_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_first_selected_component </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the first selected component. </p>

</div>
</div>
<a id="a27779f5e7ac08bcc8c3fd1d78698ad45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27779f5e7ac08bcc8c3fd1d78698ad45">&#9670;&nbsp;</a></span>read_write_operation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType , typename VectorOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::read_write_operation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html">VectorOperation</a> &amp;&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classVectorType.html">VectorType</a> *, n_components_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; const std::vector&lt; <a class="el" href="classArrayView.html">ArrayView</a>&lt; const typename VectorType::value_type &gt;&gt; *, n_components_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors_sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>apply_constraints</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A unified function to read from and write into vectors based on the given template operation. It can perform the operation for <code>read_dof_values</code>, <code>distribute_local_to_global</code>, and <code>set_dof_values</code>. It performs the operation for several vectors at a time. </p>

</div>
</div>
<a id="a427af54345534f8d734230ad56d4a367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427af54345534f8d734230ad56d4a367">&#9670;&nbsp;</a></span>read_write_operation_contiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType , typename VectorOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::read_write_operation_contiguous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html">VectorOperation</a> &amp;&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classVectorType.html">VectorType</a> *, n_components_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; const std::vector&lt; <a class="el" href="classArrayView.html">ArrayView</a>&lt; const typename VectorType::value_type &gt;&gt; *, n_components_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors_sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A unified function to read from and write into vectors based on the given template operation for DG-type schemes where all degrees of freedom on cells are contiguous. It can perform the operation for <a class="el" href="classFEEvaluationBase.html#a5c3bf28ebceb0271addfba5b92f475ce">read_dof_values()</a>, <a class="el" href="classFEEvaluationBase.html#a13c9d8eac4ca7b3f7d45eda97ea8e2fb">distribute_local_to_global()</a>, and <a class="el" href="classFEEvaluationBase.html#a459813036810fbdc3c5487309b118fd8">set_dof_values()</a> for several vectors at a time, depending on n_components. </p>

</div>
</div>
<a id="a06b9198e9b8d3306e7b9fc7ebffb7077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b9198e9b8d3306e7b9fc7ebffb7077">&#9670;&nbsp;</a></span>read_write_operation_global()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType , typename VectorOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::read_write_operation_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html">VectorOperation</a> &amp;&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classVectorType.html">VectorType</a> *, n_components_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A unified function to read from and write into vectors based on the given template operation for the case when we do not have an underlying <a class="el" href="classMatrixFree.html">MatrixFree</a> object. It can perform the operation for <code>read_dof_values</code>, <code>distribute_local_to_global</code>, and <code>set_dof_values</code>. It performs the operation for several vectors at a time, depending on n_components. </p>

</div>
</div>
<a id="a41b715f55152c25bf40e8a588f2d71e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b715f55152c25bf40e8a588f2d71e3">&#9670;&nbsp;</a></span>get_mapping_data_index_offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_mapping_data_index_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the index offset within the geometry fields for the cell the <code><a class="el" href="classFEFaceEvaluation.html#a45172115b15c8139f34216ceee323d5b">reinit()</a></code> function has been called for. This index can be used to access an index into a field that has the same compression behavior as the Jacobian of the geometry, e.g., to store an effective coefficient tensors that combines a coefficient with the geometry for lower memory transfer as the available data fields. </p>

</div>
</div>
<a id="a377d660719169078d812bf611bd75f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377d660719169078d812bf611bd75f13">&#9670;&nbsp;</a></span>get_cell_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__matrixfree.html#gae024b29b6819e727d47016c6b6b53d8c">internal::MatrixFreeFunctions::GeometryType</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_cell_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the type of the cell the <code><a class="el" href="classFEFaceEvaluation.html#a45172115b15c8139f34216ceee323d5b">reinit()</a></code> function has been called for. Valid values are <code>cartesian</code> for Cartesian cells (which allows for considerable data compression), <code>affine</code> for cells with affine mappings, and <code>general</code> for general cells without any compressed storage applied. </p>

</div>
</div>
<a id="a3795cfb954ce2b37a130265c51eba552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3795cfb954ce2b37a130265c51eba552">&#9670;&nbsp;</a></span>get_shape_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt;VectorizedArrayType&gt;&amp; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_shape_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the ShapeInfo object currently in use. </p>

</div>
</div>
<a id="a664645e91bbe5f972a1d9b6c64ab5e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664645e91bbe5f972a1d9b6c64ab5e9b">&#9670;&nbsp;</a></span>get_dof_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a>&amp; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_dof_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the DoFInfo object currently in use. </p>

</div>
</div>
<a id="a56ed5a4e84edf92e69f1474d5f035a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ed5a4e84edf92e69f1474d5f035a92">&#9670;&nbsp;</a></span>JxW()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::JxW </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the determinant of the Jacobian from the unit to the real cell times the quadrature weight. </p>

</div>
</div>
<a id="adad456112f01b19291e7781fb5efee55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad456112f01b19291e7781fb5efee55">&#9670;&nbsp;</a></span>inverse_jacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;2, dim, VectorizedArrayType&gt; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::inverse_jacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the inverse and transposed version \(J^{-\mathrm T}\) of the Jacobian of the mapping between the unit to the real cell defined as \(J_{ij} = d x_i / d\hat x_j\). The \((i,j)\) entry of the returned tensor contains \(d\hat x_j/dx_i\), i.e., columns refer to reference space coordinates and rows to real cell coordinates. Thus, the returned tensor represents a covariant transformation, which is used in the <a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">FEEvaluationBase::get_gradient()</a> function to transform the unit cell gradients to gradients on the real cell by a multiplication \(J^{-\mathrm T} \hat{\nabla} u_h\). </p>

</div>
</div>
<a id="a264ced911d2818b0a04b8855bb482b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264ced911d2818b0a04b8855bb482b45">&#9670;&nbsp;</a></span>get_normal_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, dim, VectorizedArrayType&gt; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_normal_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the unit normal vector on a face. Note that both sides of a face use the same orientation of the normal vector: For the faces enumerated as <code>interior</code> in FaceToCellTopology and selected with the <code>is_interior_face=true</code> flag of the constructor, this corresponds to the outer normal vector, whereas for faces enumerated as <code>exterior</code> in FaceToCellTopology and selected with the <code>is_interior_face=false</code> flag of the constructor, the normal points into the element as a consequence of the single normal vector.</p>
<dl class="section note"><dt>Note</dt><dd>Only implemented in case <code>is_face == true</code>. </dd></dl>

</div>
</div>
<a id="a7c966665f040d92b055833c8011b395a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c966665f040d92b055833c8011b395a">&#9670;&nbsp;</a></span>read_cell_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::read_cell_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provides a unified interface to access data in a vector of <a class="el" href="classVectorizedArray.html">VectorizedArray</a> fields of length <a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">MatrixFree::n_cell_batches()</a> + <a class="el" href="classMatrixFree.html#a0c08e4ba63acbb93d0f3a1441b88d61c">MatrixFree::n_ghost_cell_batches()</a> for both cells (plain read) and faces (indirect addressing). </p>

</div>
</div>
<a id="ae6891d7f5fe2282a3ff1ca56042d57d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6891d7f5fe2282a3ff1ca56042d57d6">&#9670;&nbsp;</a></span>read_cell_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, VectorizedArrayType::size()&gt; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::read_cell_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; std::array&lt; T, VectorizedArrayType::size()&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as above, just for std::array of length of VectorizedArrayType for arbitrary data type. </p>

</div>
</div>
<a id="a152c28d13aca3d409052d7f7a0634eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152c28d13aca3d409052d7f7a0634eb0">&#9670;&nbsp;</a></span>set_cell_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::set_cell_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorizedArrayType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provides a unified interface to set data in a vector of <a class="el" href="classVectorizedArray.html">VectorizedArray</a> fields of length <a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">MatrixFree::n_cell_batches()</a> + <a class="el" href="classMatrixFree.html#a0c08e4ba63acbb93d0f3a1441b88d61c">MatrixFree::n_ghost_cell_batches()</a> for both cells (plain read) and faces (indirect addressing). </p>

</div>
</div>
<a id="ac7feb6cd1b095d992c54dd5fac244586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7feb6cd1b095d992c54dd5fac244586">&#9670;&nbsp;</a></span>set_cell_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::set_cell_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; std::array&lt; T, VectorizedArrayType::size()&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, VectorizedArrayType::size()&gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as above, just for std::array of length of VectorizedArrayType for arbitrary data type. </p>

</div>
</div>
<a id="a2729f97a9d471169afe63cede6596a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2729f97a9d471169afe63cede6596a74">&#9670;&nbsp;</a></span>get_cell_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;unsigned <a class="el" href="classint.html">int</a>, VectorizedArrayType::size()&gt; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_cell_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the id of the cells this <a class="el" href="classFEEvaluation.html">FEEvaluation</a> or <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a> is associated with. </p>

</div>
</div>
<a id="a77d73c4fd5e79970f465b603adf116d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d73c4fd5e79970f465b603adf116d6">&#9670;&nbsp;</a></span>get_cell_or_face_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;unsigned <a class="el" href="classint.html">int</a>, VectorizedArrayType::size()&gt; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_cell_or_face_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the id of the cells/faces this FEEvaluation/FEFaceEvaluation is associated with. </p>

</div>
</div>
<a id="a575a078b24cb2107fce967db6ebedb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575a078b24cb2107fce967db6ebedb1f">&#9670;&nbsp;</a></span>get_internal_dof_numbering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt;&amp; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_internal_dof_numbering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the numbering of local degrees of freedom within the evaluation routines of <a class="el" href="classFEEvaluation.html">FEEvaluation</a> in terms of the standard numbering on finite elements. </p>

</div>
</div>
<a id="a68af54c4af89af574d1304bfc59f2637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68af54c4af89af574d1304bfc59f2637">&#9670;&nbsp;</a></span>get_scratch_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrayView.html">ArrayView</a>&lt;VectorizedArrayType&gt; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_scratch_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an <a class="el" href="classArrayView.html">ArrayView</a> to internal memory for temporary use. Note that some of this memory is overwritten during <a class="el" href="classFEFaceEvaluation.html#a92f84b8ad276ca9866f30c6f789cf3a4">evaluate()</a> and <a class="el" href="classFEFaceEvaluation.html#ad5d6ed6254b4d18ef4357ed6aa0974ae">integrate()</a> calls so do not assume it to be stable over those calls. The maximum size you can write into is 3*dofs_per_cell+2*n_q_points. </p>

</div>
</div>
<a id="aa1a6490549baa849bf4aaaab72ed4ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a6490549baa849bf4aaaab72ed4ecb">&#9670;&nbsp;</a></span>get_quadrature_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_quadrature_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of the quadrature formula of the present cell. </p>

</div>
</div>
<a id="a6874c90c1c3f54737636cd30b46ffe47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6874c90c1c3f54737636cd30b46ffe47">&#9670;&nbsp;</a></span>get_current_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_current_cell_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return index of the current cell or face. </p>

</div>
</div>
<a id="aed217341425d1b85c6d2e67932af9853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed217341425d1b85c6d2e67932af9853">&#9670;&nbsp;</a></span>get_active_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_active_fe_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the active FE index for this class for efficient indexing in the hp- case. </p>

</div>
</div>
<a id="a6f979d70d5d3e16037ed0f3ae36f6b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f979d70d5d3e16037ed0f3ae36f6b6f">&#9670;&nbsp;</a></span>get_active_quadrature_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_active_quadrature_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the active quadrature index for this class for efficient indexing in the hp-case. </p>

</div>
</div>
<a id="a8b0c8e96fd4c18b29c6cddb1e648c66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0c8e96fd4c18b29c6cddb1e648c66d">&#9670;&nbsp;</a></span>get_matrix_free()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt;dim, Number, VectorizedArrayType&gt;&amp; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_matrix_free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the underlying <a class="el" href="classMatrixFree.html">MatrixFree</a> object. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad1d38cd5e7305b581d300929ff5e8200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d38cd5e7305b581d300929ff5e8200">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dimension given as template argument. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l03045">3045</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a83225922c17f801c889680eff0da9b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83225922c17f801c889680eff0da9b07">&#9670;&nbsp;</a></span>n_components</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::n_components = n_components_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of solution components of the evaluator given as template argument. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l03051">3051</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="ac42a1c7210f76b69310d3f5990821a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42a1c7210f76b69310d3f5990821a22">&#9670;&nbsp;</a></span>static_n_q_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::static_n_q_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(n_q_points_1d, dim - 1)</div></div><!-- fragment --><p>The static number of quadrature points determined from the given template argument <code>n_q_points_1d</code> taken to the power of dim-1. Note that the actual number of quadrature points, <code>n_q_points</code>, can be different if <code>fe_degree=-1</code> is given and run-time loop lengths are used rather than compile time ones. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l03060">3060</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a2317dcbb9306d670a8a508c0b96183ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2317dcbb9306d670a8a508c0b96183ba">&#9670;&nbsp;</a></span>static_n_q_points_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::static_n_q_points_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(n_q_points_1d, dim)</div></div><!-- fragment --><p>The static number of quadrature points on a cell with the same quadrature formula. Note that this value is only present for simpler comparison with the cell quadrature, as the actual number of points is given to a face by the <code>static_n_q_points</code> variable. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l03069">3069</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="ab3e4f5c52b3319399cf1730e400ac01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e4f5c52b3319399cf1730e400ac01c">&#9670;&nbsp;</a></span>static_dofs_per_component</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::static_dofs_per_component</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(fe_degree + 1, dim)</div></div><!-- fragment --><p>The static number of degrees of freedom of a scalar component determined from the given template argument <code>fe_degree</code>. Note that the actual number of degrees of freedom <code>dofs_per_component</code> can be different if <code>fe_degree=-1</code> is given. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l03078">3078</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a2dff67ddc5cc5ffff02701650b0917b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dff67ddc5cc5ffff02701650b0917b0">&#9670;&nbsp;</a></span>tensor_dofs_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::tensor_dofs_per_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="classFEFaceEvaluation.html#ab3e4f5c52b3319399cf1730e400ac01c">static_dofs_per_component</a> * <a class="code" href="classFEFaceEvaluation.html#a83225922c17f801c889680eff0da9b07">n_components</a></div></div><!-- fragment --><p>The static number of degrees of freedom of all components determined from the given template argument <code>fe_degree</code>. Note that the actual number of degrees of freedom <code>dofs_per_cell</code> can be different if <code>fe_degree=-1</code> is given. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l03087">3087</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="af15a90d3571fe443e1460b71e7e0effa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15a90d3571fe443e1460b71e7e0effa">&#9670;&nbsp;</a></span>static_dofs_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::static_dofs_per_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="classFEFaceEvaluation.html#ab3e4f5c52b3319399cf1730e400ac01c">static_dofs_per_component</a> * <a class="code" href="classFEFaceEvaluation.html#a83225922c17f801c889680eff0da9b07">n_components</a></div></div><!-- fragment --><p>The static number of degrees of freedom of all components determined from the given template argument <code>fe_degree</code>. Note that the actual number of degrees of freedom <code>dofs_per_cell</code> can be different if <code>fe_degree=-1</code> is given. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l03096">3096</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a3dab1f1daf6390da8bf0588a0ed76e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dab1f1daf6390da8bf0588a0ed76e58">&#9670;&nbsp;</a></span>dofs_per_component</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::dofs_per_component</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of degrees of freedom of a single component on the cell for the underlying evaluation object. Usually close to static_dofs_per_component, but the number depends on the actual element selected and is thus not static. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l03339">3339</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a74e6e04ad9c15e5a3fe169d2df17d6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e6e04ad9c15e5a3fe169d2df17d6e2">&#9670;&nbsp;</a></span>dofs_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::dofs_per_cell</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of degrees of freedom on the cell accumulated over all components in the current evaluation object. Usually close to static_dofs_per_cell = static_dofs_per_component*n_components, but the number depends on the actual element selected and is thus not static. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l03347">3347</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a451f10fa5579763dd6b88dfa2460f0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451f10fa5579763dd6b88dfa2460f0ba">&#9670;&nbsp;</a></span>n_q_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d = fe_degree + 1, int n_components_ = 1, typename Number  = double, typename VectorizedArrayType  = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::n_q_points</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of quadrature points in use. If the number of quadrature points in 1d is given as a template, this number is simply the <code>dim-1</code>-th power of that value. If the element degree is set to -1 (dynamic selection of element degree), the static value of quadrature points is inaccurate and this value must be used instead. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l03356">3356</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="aacafd9861301674853b127a115d4de1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacafd9861301674853b127a115d4de1e">&#9670;&nbsp;</a></span>values_dofs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::values_dofs[<a class="el" href="classFEFaceEvaluation.html#a83225922c17f801c889680eff0da9b07">n_components</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This field stores the values for local degrees of freedom (e.g. after reading out from a vector but before applying unit cell transformations or before distributing them into a result vector). The methods <a class="el" href="classFEEvaluationBase.html#a0660b27a2a592994dfd2fc917305a3ac">get_dof_value()</a> and <a class="el" href="classFEEvaluationBase.html#a3afd9d62f5762c41973aa0f037dc5099">submit_dof_value()</a> read from or write to this field.</p>
<p>The values of this array are stored in the start section of <code>scratch_data_array</code>. Due to its access as a thread local memory, the memory can get reused between different calls. As opposed to requesting memory on the stack, this approach allows for very large polynomial degrees. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01270">1270</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="aa2b01fcfb319697ad15319c44d635358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b01fcfb319697ad15319c44d635358">&#9670;&nbsp;</a></span>values_quad</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::values_quad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This field stores the values of the finite element function on quadrature points after applying unit cell transformations or before integrating. The methods <a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">get_value()</a> and <a class="el" href="classFEEvaluationBase.html#a2c0efc6f70b305c0585001632063c98b">submit_value()</a> access this field.</p>
<p>The values of this array are stored in the start section of <code>scratch_data_array</code>. Due to its access as a thread local memory, the memory can get reused between different calls. As opposed to requesting memory on the stack, this approach allows for very large polynomial degrees. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01283">1283</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a01c0240702f8a5f1bcd102ef69919b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c0240702f8a5f1bcd102ef69919b54">&#9670;&nbsp;</a></span>gradients_quad</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::gradients_quad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This field stores the gradients of the finite element function on quadrature points after applying unit cell transformations or before integrating. The methods <a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">get_gradient()</a> and <a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">submit_gradient()</a> (as well as some specializations like <a class="el" href="classFEEvaluationBase.html#a2b6fe306f7501a59940bfffab2550e6a">get_symmetric_gradient()</a> or <a class="el" href="classFEEvaluationBase.html#a7f6a0959de5c408072c48ee3fd2ca057">get_divergence()</a>) access this field.</p>
<p>The values of this array are stored in the start section of <code>scratch_data_array</code>. Due to its access as a thread local memory, the memory can get reused between different calls. As opposed to requesting memory on the stack, this approach allows for very large polynomial degrees. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01298">1298</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="aca7ce5837713e301d3e8c4718fdcce67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7ce5837713e301d3e8c4718fdcce67">&#9670;&nbsp;</a></span>hessians_quad</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::hessians_quad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This field stores the Hessians of the finite element function on quadrature points after applying unit cell transformations. The methods <a class="el" href="classFEEvaluationBase.html#af637d7fcd92a58cf1e8597269a13e9bd">get_hessian()</a>, <a class="el" href="classFEEvaluationBase.html#a0c652a4de885613efc5e02dd3754342b">get_laplacian()</a>, <a class="el" href="classFEEvaluationBase.html#aaba7f7af4354a4bad6bcf7364978ebf2">get_hessian_diagonal()</a> access this field.</p>
<p>The values of this array are stored in the start section of <code>scratch_data_array</code>. Due to its access as a thread local memory, the memory can get reused between different calls. As opposed to requesting memory on the stack, this approach allows for very large polynomial degrees. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01311">1311</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="ad363fb71770ee9f1b521e5a539993ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad363fb71770ee9f1b521e5a539993ef3">&#9670;&nbsp;</a></span>n_fe_components</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::n_fe_components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the number of components in the finite element as detected in the <a class="el" href="classMatrixFree.html">MatrixFree</a> storage class for comparison with the template argument. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01317">1317</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a4931bf96a90394aa552231bfc3d4bb80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4931bf96a90394aa552231bfc3d4bb80">&#9670;&nbsp;</a></span>dof_values_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::dof_values_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Debug information to track whether dof values have been initialized before accessed. Used to control exceptions when uninitialized data is used. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01324">1324</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a2634b8199be6e9fdec0b0ad715209a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2634b8199be6e9fdec0b0ad715209a39">&#9670;&nbsp;</a></span>values_quad_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::values_quad_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Debug information to track whether values on quadrature points have been initialized before accessed. Used to control exceptions when uninitialized data is used. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01331">1331</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="af15f3fb86bd795ee059be4accef81ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15f3fb86bd795ee059be4accef81ca8">&#9670;&nbsp;</a></span>gradients_quad_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::gradients_quad_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Debug information to track whether gradients on quadrature points have been initialized before accessed. Used to control exceptions when uninitialized data is used. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01338">1338</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a510ed69b6143a1a497c41c93a200a39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510ed69b6143a1a497c41c93a200a39d">&#9670;&nbsp;</a></span>hessians_quad_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::hessians_quad_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Debug information to track whether Hessians on quadrature points have been initialized before accessed. Used to control exceptions when uninitialized data is used. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01345">1345</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="ad53e482c5d5eb5b156e79d322f7fdf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53e482c5d5eb5b156e79d322f7fdf12">&#9670;&nbsp;</a></span>values_quad_submitted</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::values_quad_submitted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Debug information to track whether values on quadrature points have been submitted for integration before the integration is actually stared. Used to control exceptions when uninitialized data is used. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01352">1352</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a747a9ff4cbaedd9b48f7aa1378e2682c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747a9ff4cbaedd9b48f7aa1378e2682c">&#9670;&nbsp;</a></span>gradients_quad_submitted</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::gradients_quad_submitted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Debug information to track whether gradients on quadrature points have been submitted for integration before the integration is actually stared. Used to control exceptions when uninitialized data is used. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01359">1359</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a42f9032a1a57f19c6e21915eaee09716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f9032a1a57f19c6e21915eaee09716">&#9670;&nbsp;</a></span>first_selected_component</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::first_selected_component</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For a <a class="el" href="classFiniteElement.html">FiniteElement</a> with more than one base element, select at which component this data structure should start. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01365">1365</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a3cd8d38b99b2e85efbc37570c76d0def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd8d38b99b2e85efbc37570c76d0def">&#9670;&nbsp;</a></span>local_dof_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&gt; <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::local_dof_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A temporary data structure necessary to read degrees of freedom when no <a class="el" href="classMatrixFree.html">MatrixFree</a> object was given at initialization. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01371">1371</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="ad9c8dcc076400f538a3c85a5cbec9cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c8dcc076400f538a3c85a5cbec9cb3">&#9670;&nbsp;</a></span>scratch_data_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;VectorizedArrayType&gt;* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::scratch_data_array</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the general array for all data fields. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00337">337</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="af35283bcccba5587bff326a245d322e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35283bcccba5587bff326a245d322e7">&#9670;&nbsp;</a></span>scratch_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::scratch_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the user-visible part of scratch_data_array, only showing the last part of scratch_data_array. The first part is consumed by values_dofs, values_quad, etc. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00344">344</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a533b073ea515b343f9d785da2f342066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533b073ea515b343f9d785da2f342066">&#9670;&nbsp;</a></span>quad_no</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::quad_no</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of the quadrature formula of the present cell. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00349">349</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="af0d19d2e454832346b9ae547f0330533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d19d2e454832346b9ae547f0330533">&#9670;&nbsp;</a></span>matrix_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt;dim, Number, VectorizedArrayType&gt;* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::matrix_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the underlying data. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00354">354</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="adfa7522a2f5003b7aefa14209ccd4723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa7522a2f5003b7aefa14209ccd4723">&#9670;&nbsp;</a></span>dof_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a>* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::dof_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the underlying DoF indices and constraint description for the component specified at construction. Also contained in matrix_info, but it simplifies code if we store a reference to it. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00361">361</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a8c31ae7463c9952de2b8edb01a942938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c31ae7463c9952de2b8edb01a942938">&#9670;&nbsp;</a></span>mapping_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfoStorage.html">internal::MatrixFreeFunctions::MappingInfoStorage</a>&lt; (is_face ? dim - 1 : dim), dim, Number, VectorizedArrayType&gt;* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::mapping_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the underlying transformation data from unit to real cells for the given quadrature formula specified at construction. Also contained in matrix_info, but it simplifies code if we store a reference to it. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00373">373</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="afa5f9995bfa3e160a8e111837e4293c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5f9995bfa3e160a8e111837e4293c9">&#9670;&nbsp;</a></span>active_fe_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::active_fe_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The active FE index for this class for efficient indexing in the hp-case. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00378">378</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a15d55c8a88a0a393b7eec7a2843cc9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d55c8a88a0a393b7eec7a2843cc9bd">&#9670;&nbsp;</a></span>active_quad_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::active_quad_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The active quadrature index for this class for efficient indexing in the hp-case. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00384">384</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a0d0ee194a86f8af161dbb74c8580fc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0ee194a86f8af161dbb74c8580fc30">&#9670;&nbsp;</a></span>descriptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfoStorage.html">internal::MatrixFreeFunctions::MappingInfoStorage</a>&lt; (is_face ? dim - 1 : dim), dim, Number, VectorizedArrayType&gt;::QuadratureDescriptor* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::descriptor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the underlying quadrature formula specified at construction. Also contained in matrix_info, but it simplifies code if we store a reference to it. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00395">395</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a748b05799b1fdcda8e1bef6ac563b119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748b05799b1fdcda8e1bef6ac563b119">&#9670;&nbsp;</a></span>n_quadrature_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::n_quadrature_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of quadrature points in the current evaluation context. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00400">400</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a5d9ba9049f2df1bc4ef95ae789faf12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9ba9049f2df1bc4ef95ae789faf12e">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt;VectorizedArrayType&gt;* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the unit cell shape data, i.e., values, gradients and Hessians in 1D at the quadrature points that constitute the tensor product. Also contained in matrix_info, but it simplifies code if we store a reference to it. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00408">408</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a421376c6f8ddefa1797a58e8f9003e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421376c6f8ddefa1797a58e8f9003e7b">&#9670;&nbsp;</a></span>jacobian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;2, dim, VectorizedArrayType&gt;* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::jacobian</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the Jacobian information of the present cell. Only set to a useful value if on a non-Cartesian cell. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00414">414</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="abb54ca45a7f4e02fc77d8651f08af427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb54ca45a7f4e02fc77d8651f08af427">&#9670;&nbsp;</a></span>J_value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VectorizedArrayType* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::J_value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the Jacobian determinant of the present cell. If on a Cartesian cell or on a cell with constant Jacobian, this is just the Jacobian determinant, otherwise the Jacobian determinant times the quadrature weight. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00422">422</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a7cd6146dc538c94a881eb0a6b216f313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd6146dc538c94a881eb0a6b216f313">&#9670;&nbsp;</a></span>normal_vectors</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim, VectorizedArrayType&gt;* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::normal_vectors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the normal vectors at faces. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00427">427</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a2b06df026ae07f6b6a0b96c7395985d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b06df026ae07f6b6a0b96c7395985d9">&#9670;&nbsp;</a></span>normal_x_jacobian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim, VectorizedArrayType&gt;* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::normal_x_jacobian</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the normal vectors times the jacobian at faces. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00432">432</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a5b872287e6c00c65b77919e58c2fe64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b872287e6c00c65b77919e58c2fe64c">&#9670;&nbsp;</a></span>quadrature_weights</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Number* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::quadrature_weights</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the quadrature weights of the underlying quadrature formula. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00437">437</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="aba2db8170a4e834313fa1775d50c26a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2db8170a4e834313fa1775d50c26a2">&#9670;&nbsp;</a></span>cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After a call to <a class="el" href="classFEFaceEvaluation.html#a45172115b15c8139f34216ceee323d5b">reinit()</a>, stores the number of the cell we are currently working with. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00443">443</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a1dc1a1074ec29081286adcbff30844fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc1a1074ec29081286adcbff30844fe">&#9670;&nbsp;</a></span>is_interior_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::is_interior_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag holding information whether a face is an interior or exterior face according to the defined direction of the normal. Not used for cells. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00449">449</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="ab5c4f195d4895c0b57af17a71ee6718c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c4f195d4895c0b57af17a71ee6718c">&#9670;&nbsp;</a></span>dof_access_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744e">internal::MatrixFreeFunctions::DoFInfo::DoFAccessIndex</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::dof_access_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the index an <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a> object is currently pointing into (interior face, exterior face, data associated with cell). </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00455">455</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a04643788ab09d99f9d107c4b6879d6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04643788ab09d99f9d107c4b6879d6b1">&#9670;&nbsp;</a></span>face_no</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::face_no</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the current number of a face within the given cell in case <code>is_face==true</code>, using values between <code>0</code> and <code>2*dim</code>. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00461">461</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a4a69d8b541c14cc64cc2626d3884dfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a69d8b541c14cc64cc2626d3884dfb3">&#9670;&nbsp;</a></span>face_orientation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::face_orientation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the orientation of the given face with respect to the standard orientation, 0 if in standard orientation. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00467">467</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a170d149afc7b1e8d7315c3038ddd0aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170d149afc7b1e8d7315c3038ddd0aec">&#9670;&nbsp;</a></span>subface_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::subface_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the subface index of the given face. Usually, this variable takes the value <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> to indicate integration over the full face, but in case the current physical face has a neighbor that is more refined, it is a subface and must scale the entries in ShapeInfo appropriately. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00476">476</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a50c75f69107df221620b6dcbc292065d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c75f69107df221620b6dcbc292065d">&#9670;&nbsp;</a></span>cell_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__matrixfree.html#gae024b29b6819e727d47016c6b6b53d8c">internal::MatrixFreeFunctions::GeometryType</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::cell_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the type of the cell we are currently working with after a call to <a class="el" href="classFEFaceEvaluation.html#a45172115b15c8139f34216ceee323d5b">reinit()</a>. Valid values are <code>cartesian</code>, <code>affine</code> and <code>general</code>, which have different implications on how the Jacobian transformations are stored internally in MappingInfo. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00484">484</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a6bc1956583b69b8f1010da1dbce26403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc1956583b69b8f1010da1dbce26403">&#9670;&nbsp;</a></span>mapped_geometry</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;internal::MatrixFreeFunctions:: MappingDataOnTheFly&lt;dim, Number, VectorizedArrayType&gt; &gt; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::mapped_geometry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Geometry data that can be generated <a class="el" href="classFEValues.html">FEValues</a> on the fly with the respective constructor. </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00492">492</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/matrix_free/<a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
