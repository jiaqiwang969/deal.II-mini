<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/CodingConventions.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Coding conventions used throughout deal.II</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Coding conventions used throughout deal.II </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Throughout deal.II, we strive to keep our programming style and the kind of interfaces we provide as consistent as possible. To this end, we have adopted a set of coding conventions that we attempt to follow wherever possible. They have two parts: style issues, and something we call "defensive programming", the latter being an attempt to let our code help us find bugs. When reading through them, it is important to remember that styles are not god given or better than any other set of conventions; their purpose is merely to keep deal.II as uniform as possible. Uniformity reduces the number of bugs we produce because we can, for example, always assume that input arguments come before output arguments of a function call. They also simplify reading code because some things become clear already by looking at the style a piece of code is written, without having to look up the exact definition of something.</p>
<h3>Notes on deal.II indentation</h3>
<p>deal.II uses <code>clang-format</code> 6.0 to normalize indentation. A style file is provided at </p><div class="fragment"><div class="line">${SOURCE_DIR}/.clang-<a class="code" href="namespaceredbud_1_1io.html#ab8890fea026811b784d243bc8bee5727">format</a></div></div><!-- fragment --><p>Before a commit, you should run </p><div class="fragment"><div class="line">clang-<a class="code" href="namespaceredbud_1_1io.html#ab8890fea026811b784d243bc8bee5727">format</a> -i &lt;file&gt;</div></div><!-- fragment --><p> on each of your files. This will make sure indentation is conforming to the style guidelines outlined in this page.</p>
<p>This is cumbersome. Consequently, and more easily, you can just run </p><div class="fragment"><div class="line">make indent</div></div><!-- fragment --><p> in whatever directory you set up the library to be compiled in, to indent all source files that have been changed recently. If you want to make sure that the indenting is correct for all your commits, you might want to set up a pre-commit hook. One way to do so, is to copy <code>${SOURCE_DIR}/contrib/git-hooks/pre-commit</code> to <code>${SOURCE_DIR}/.git/hooks/pre-commit</code> and make sure it is executable. </p>
<h3>Style issues</h3>
<ol>
<li>
<p class="startli">Functions which return the number of something (number of cells, degrees of freedom, etc) should start with <code>n_*</code>. Example: <a class="el" href="classSparsityPatternBase.html#a0707927053081fd6c46dac186e63c543">SparsityPatternBase::n_nonzero_elements()</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Functions which set a bit or flag should start with <code>set_*</code>; functions which clear bits or flags should be named <code>clear_*</code>. Example: <a class="el" href="classCellAccessor.html#a8c8359d5342b4ae7ae8b74fc3f4a1558">CellAccessor::set_refine_flag()</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Traditional logical operators should be used instead of their English equivalents (i.e., use <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code> instead of <code>and</code>, <code>or</code>, and <code>not</code>).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">In the implementation files, after each function, three empty lines are expected to enable better readability. One empty line occurs in functions to group blocks of code, since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Whenever an integer variable can only assume nonnegative values, it is marked as unsigned. The same applies to functions that can only return positive or zero values. Example: <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Whenever an argument to a function will not be changed, it should be marked const, even if passed by value. Generally, we mark input parameters as const. This aids as an additional documentation tool to clarify the intent of a parameter (input, output, or both) and lets the compiler issue warnings if such a parameter is changed, which is often either involuntarily or poor style.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Whenever a function does not change any of the member variable of the embedding class/object, it should be marked as const.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Function and variable names may not consist of only one or two letters, unless the variable is a pure counting index.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Type aliases (<code>using</code>-declarations) are preferred to <code>typedef</code>-declarations.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Use the geometry information in <a class="el" href="structGeometryInfo.html">GeometryInfo</a> to get the number of faces per cell, the number of children per cell, the child indices of the child cells adjacent to face 3, etc, rather than writing them into the code directly as <code>2*dim</code>, <code>(1&lt;&lt;dim)</code> and <code>{0,3}</code>. This reduces the possibilities for errors and enhances readability of code.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The layout of class declarations is the following: first the block of public functions, beginning with the constructors, then the destructors. If there are public member variables, these have to occur before the constructor. Public variables shall only be used if constant (in particular if they are static and constant) or unavoidable. <br />
 After the public members, the protected and finally the private members are to be listed. The order is as above: first variables then functions. <br />
 <a class="el" href="namespaceExceptions.html">Exceptions</a> shall be declared at the end of the public section before the non-public sections start. <br />
 We do not use the C++11-style class member initialization for member variables that are neither <code>static const</code> nor <code>static constexpr</code>; i.e., instead of </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> a = 42;</div><div class="line">  <span class="keywordtype">int</span> *<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a> = <span class="keyword">nullptr</span>;</div><div class="line">};</div></div><!-- fragment --><p> write </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo</div><div class="line">{</div><div class="line">  Foo();</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> a;</div><div class="line">  <span class="keywordtype">int</span> *<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">inline</span> Foo::Foo()</div><div class="line">: a(42)</div><div class="line">, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>(nullptr)</div><div class="line">{}</div></div><!-- fragment --> <p class="endli"></p>
</li>
<li>
<p class="startli">If a function has both input and output parameters, usually the input parameters shall precede the output parameters, unless there are good reasons to change this order. (The most common reason is trailing input parameters with default values.) </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="namespaceExceptions.html">Exceptions</a> are used for internal parameter checking and for consistency checks through the Assert macro. Exception handling like done by the C++ language (<code>try/throw/catch</code>, and using the AssertThrow macro) are used to handle run time errors (like I/O failures) which must be on in any case, not only in debug mode.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Sometimes it makes sense to implement a class by using several non-member functions that are not part of the public interface and are only meant to be called in the current source file. Such free functions should be put in an internal namespace structured in the following way: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceinternal.html">internal</a></div><div class="line">{</div><div class="line">  <span class="keyword">namespace </span>ClassNameImplementation</div><div class="line">  {</div><div class="line">    <span class="comment">// free functions go here</span></div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p> where <code>ClassName</code> is the name of the calling class.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Classes, namespaces and types generally are named using uppercase letters to denote word beginnings (e.g. <a class="el" href="classTriaIterator.html">TriaIterator</a>) &mdash; sometimes called <a href="http://en.wikipedia.org/wiki/Camel_case"><em>camel case</em></a> &mdash; while functions and variables use lowercase letters and underscores to separate words. The only exception are the iterator alias in <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classDoFHandler.html">DoFHandler</a> (named cell_iterator, active_line_iterator, etc) to make the connection to the standard library container classes clear.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">For classes with multiple template arguments, the dimension is usually put before the data type specifier, i.e., we use Point&lt;dim,number&gt; and not Point&lt;number,dim&gt;.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">There are several places in deal.II where we use forward declarations in header files. The reason for this is that we can, hopefully, improve compilation speeds by not using headers when we just need to mark a certain type as an argument to a function. The convention used in deal.II is that, if all we need is a type name, then the type may be forward declared in the header where we need it; if a function (or member function) can return a value then a declaration of that value's type should be available (by including the necessary header). For example, <code>deal.II/dofs/dof_handler.h</code> includes <code>deal.II/dofs/dof_accessor.h</code> so that one can write something like <code>dof_handler.begin_active()-&gt;is_active()</code> without explicitly including the header declaring the type of the object returned by <code>begin_active()</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Each class has to have at least 200 pages of documentation ;-)</p>
<p class="endli"></p>
</li>
</ol>
<h3>Instantiation of templated functions/classes</h3>
<p>The majority of classes and functions in deal.II are templated. This brings a question of how and where such objects are instantiated, if at all. Throughout deal.II we adopt the following convention:</p>
<ol>
<li>
<p class="startli">If we can enumerate all possible template arguments (e.g., the dimension can only be 1, 2, or 3), then a function template goes into the <code>.cc</code> file and we explicitly instantiate all possibilities. Users will not have any need to ever see these function templates because they will not want to instantiate these functions for any other template arguments anyway. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If we can not enumerate all possible template arguments (e.g., vector types &ndash; because users might want to define their own vector kinds) but at least know a few common usage cases, then the function is put into a <code>.templates.h</code> file. We #include it into the <code>.cc</code> file and instantiate the functions for all of the common arguments. For almost all users, this will be just fine &ndash; they only use the (vector, matrix, ...) types we already instantiate, and for them the <code>.templates.h</code> file will not be of any interest. It will also not slow down their compilations because nothing they see will #include the <code>.templates.h</code> file. But users who define their own (vector, matrix, ...) types can instantiate the template functions with their own user-defined types by including the <code>.templates.h</code> files.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Finally, if we can not assume in advance which values template arguments will take (e.g., any class derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> can be used as an argument), the definitions of functions are provided at the bottom of the header file with declarations. The definitions should be guarded with <code>#ifndef DOXYGEN ... #endif</code> to prevent Doxygen from picking them up.</p>
<p class="endli"></p>
</li>
</ol>
<p>For the first two cases, instantiation instructions are defined in <code>.inst.in</code> files. They are processed by a binary called expand_instantiations (built from <code>cmake/scripts/expand_instantiations.cc</code>) and the parameters are defined dynamically through cmake depending on your configuration (see <code>cmake/config/template-arguments.in</code> in your build directory). It is those <code>.inst</code> files that are eventually included from the corresponding <code>.cc</code> files. </p>
<h3>Defensive programming</h3>
<p>Defensive programming is a term that we use frequently when we talk about writing code while in the mindset that errors will happen. Here, errors can come in two ways: first, I can make a mistake myself while writing a functions; and secondly, someone else can make a mistake while calling my function. In either case, I would like to write my code in such a way that errors are (i) as unlikely as possible, (ii) that the compiler can already find some of the mistakes, and (iii) that the remaining mistakes are relatively easy to find, for example because the program aborts. Defensive programming is then a set of strategies that make these goals more likely. </p>
<p>Over time, we have learned a number of techniques to this end, some of which we list here: </p><ol>
<li>
<p class="startli"><em>Assert preconditions on parameters:</em> People call functions with wrong or nonsensical parameters, all the time. As the prototypical example, consider a trivial implementation of vector addition: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector</a> &amp;</div><div class="line">operator+=(<a class="code" href="classVector.html">Vector</a>       &amp;lhs,</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;rhs)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(); ++i)</div><div class="line">    lhs(i) += rhs(i);</div><div class="line">  <span class="keywordflow">return</span> lhs;</div><div class="line">}</div></div><!-- fragment --><p> While correct, this function will get into trouble if the two vectors do not have the same size. You think it is silly to call this function with vectors of different size? Yes, of course it is. But it happens all the time: people forget to reinitialize a vector, or it is reset in a different function, etc. It happens. So if you are in such an unlucky case, it can take a long time to figure out what's going on because you are likely to just read uninitialized memory, or maybe you are writing to memory the <code>lhs</code> vector doesn't actually own. Neither is going to lead to immediate termination of the program, but you'll probably get random errors at a later time. It would be much easier if the program just stopped here right away. The following implementation will do exactly this: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector</a> &amp;</div><div class="line">operator+=(<a class="code" href="classVector.html">Vector</a>       &amp;lhs,</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;rhs)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>() == rhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(),</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), rhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(); ++i)</div><div class="line">    lhs(i) += rhs(i);</div><div class="line">  <span class="keywordflow">return</span> lhs;</div><div class="line">}</div></div><!-- fragment --><p> The <code>Assert</code> macro ensures that the condition is true at run time, and otherwise prints a string containing information encoded by the second argument and aborts the program. This way, when you write a new program that happens to call this function, you will learn of your error right away and have the opportunity to fix it without ever having to seriously debug anything. </p>
<p>As a general guideline, whenever you implement a new function, think about the <em>preconditions</em> on parameter, i.e. what does the function expect to be true about each of them, or their combination. Then write assertions for all of these preconditions. This may be half a dozen assertions in some cases but remember that each assertion is a potential bug already found through trivial means. </p>
<p>In a final note, let us remark that assertions are of course expensive: they may make a program 3 or 5 times slower when you link it against the debug version of the library. But if you consider your <em>overall</em> development time, the ability to find bugs quickly probably far outweighs the time you spend waiting for your program to finish. Furthermore, calls to the Assert macro are removed from the program in optimized mode (which you presumably only use once you know that everything runs just fine in debug mode. The optimized libraries are faster by a factor of 3-5 than the debug libraries, at the price that it's much harder to find bugs. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><em>Assert postconditions:</em> If a function computes something non-trivial there may be a bug in the code. To find these, use postconditions: just like you have certain knowledge about useful values for input parameters, you have knowledge about what you expect possible return values to be. For example, a function that computes the norm of a vector would expect the norm to be positive. You can write this as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>(<span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;v)</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> s = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;v.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(); ++i)</div><div class="line">    s += v(i) * v(i);</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (s &gt;= 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(s);</div><div class="line">}</div></div><!-- fragment --><p> This function is too simple to really justify this assertion, but imagine the computation to be lengthier and you can see how the assertion helps you ensure (or <em>hedge</em>) yourself against mistakes. Note that one could argue that the assertion should be removed once we've run the program a number of times and found that the condition never triggers. But it's better to leave it right where it is: it encodes for the future (and for readers) knowledge you have about the function; if someone comes along and replaced the implementation of the function by a more efficient algorithm, the assertion can help make sure that the function continues to do what it is supposed to do. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><em>Assert internal states:</em> In a similar vein, if you have a complex algorithm, use assertions to ensure that your mental model of what is going on matches what is indeed true. For example, assume you are writing a function that ensures that mesh sizes do not change too much locally. You may end up with a code of the following kind: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = triangulation.active_cell_iterators())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; ...)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (something)</div><div class="line">        { ... }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          <span class="comment">// we have a cell whose neighbor must</span></div><div class="line">          <span class="comment">// be at the boundary if we got here</span></div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p> The conditions that got us into the else-branch may be complicated, and while it may be true that we believed that the only possibility we got here is that the neighbor is at the boundary, there may have been a bug in our implementation. There may also have been a bug in our thinking, or someone changes the code way above in the same function and forgets about the issue here, or a change at a completely different location in the library makes the assumption untenable. In all of these cases, the explicit statement of our assertion makes sure that these problems are easily found. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><em>Initialize variables at the point of their declaration if they live on the stack:</em> Traditional C required that variables are declared at the beginning of the function even if they are only used further below. This leads to code like this that we may imagine in a 1d code: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> foo ()</div><div class="line">{</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> cell_center;</div><div class="line">  ... <span class="comment">// something lengthy and complicated</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = dof_handler.active_cell_iterators())</div><div class="line">    {</div><div class="line">      cell_center = (cell-&gt;vertex(0) + cell-&gt;vertex(1)) / 2;</div><div class="line">      ...</div><div class="line">    }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p> The problem is that if the code between the declaration and initialization is long and complicated, you can't look up on one page what the type of a variable is and what it's value may be. In fact, it may not even be quite clear that the variable is used initialized at all, or whether it is accidentally left uninitialized. </p>
<p>A better way to do this would be as follows: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> foo ()</div><div class="line">{</div><div class="line">  ... <span class="comment">// something lengthy and complicated</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = dof_handler.active_cell_iterators())</div><div class="line">    {</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> cell_center = (cell-&gt;vertex(0) + cell-&gt;vertex(1)) / 2;</div><div class="line">      ...</div><div class="line">    }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p> This makes it much clearer what the type of the variable is and that it is in fact only ever used when initialized. Furthermore, if someone wants to read the code to see what the variable is in fact doing, declaring and initializing it in the innermost possible scope makes this task easier: we don't have to look upwards for it beyond the declaration, and we don't have to look downward beyond the end of the current scope since this is where the variable dies. </p>
<p>As a final note, it is clear that you can only do this sort of stuff for variables that completely live on the stack without allocating memory on the heap. Within deal.II, this is only true for builtin types like <code>int, double, char</code>, etc, as well as the <a class="el" href="classPoint.html">Point</a> and <a class="el" href="classTensor.html">Tensor</a> classes. Everything else has something like a <code>std::vector</code> as a member variable, which requires memory allocation &mdash; you don't want to declare these inside loops, at least not if the loop is traversed frequently. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><em>Make variables const:</em> To pick up on the example above, note that in most cases we will never change the variable so initialized any more. In other words, if this is the case, we may as well write things as follows: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> foo ()</div><div class="line">{</div><div class="line">  ... <span class="comment">// something lengthy and complicated</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = dof_handler.active_cell_iterators())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> cell_center = (cell-&gt;vertex(0) +</div><div class="line">                                      cell-&gt;vertex(1)) / 2;</div><div class="line">      ...</div><div class="line">    }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p> By marking the variable as constant we make sure that we don't accidentally change it. For example, the compiler could catch code like this: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell_center[0] = 0)</div><div class="line">  ...</div></div><!-- fragment --><p> This was most likely meant to be a <code>==</code> rather than an assignment. By marking the variable as const, the compiler would have told us about this bug. Maybe equally importantly, human readers of the code need not look further down whether the value of the variable may actually be changed somewhere between declaration and use &mdash; it can't be if it is marked as const. </p>
<p class="endli"></p>
</li>
<li>
<em>Make input arguments of functions const:</em> The same essentially holds true as well as for function arguments: If you have no intention of changing a variable (which is typically the case for input arguments), then mark it as constant. For example, the following function should take its argument as a constant value: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a></div><div class="line"><a class="code" href="classCellAccessor.html#abacf4d5819d5f9e96d0e597cd92ce41e">CellAccessor&lt;dim&gt;::child</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> child_no)</div><div class="line">{</div><div class="line">  ...</div><div class="line">  <span class="keywordflow">return</span> something;</div><div class="line">}</div></div><!-- fragment --> Here, the user calls <code>cell-&gt;child(3)</code>, for example. There really is no reason why the function would ever want to change the value of the <code>child_no</code> argument &mdash; so mark it as constant: this both helps the reader of the code understand that this is an input argument of the function for which we need not search below whether it is ever changed, and it helps the compiler help us finding bugs if we ever accidentally change the value. </li>
</ol>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
