<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/symmetric__tensor_8h.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: include/deal.II/base/symmetric_tensor.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_ee90d91a514b839c31faec7a1d916f67.html">deal.II</a></li><li class="navelem"><a class="el" href="dir_90a2ad6518b731f1dc196d14153b8b6b.html">base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">symmetric_tensor.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="config_8h_source.html">deal.II/base/config.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="numbers_8h_source.html">deal.II/base/numbers.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="table__indices_8h_source.html">deal.II/base/table_indices.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="template__constraints_8h_source.html">deal.II/base/template_constraints.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="tensor_8h_source.html">deal.II/base/tensor.h</a>&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;array&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
</div>
<p><a href="symmetric__tensor_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1ProductTypeImpl_3_01SymmetricTensor_3_01rank_00_01dim_00_01T_01_4_00_01std_1_1complex_3_01U_01_4_01_4.html">internal::ProductTypeImpl&lt; SymmetricTensor&lt; rank, dim, T &gt;, std::complex&lt; U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1ProductTypeImpl_3_01SymmetricTensor_3_01rank_00_01dim_00_01std_1_1complex_3_01b98505714054550cfc7b1774b64b43a3.html">internal::ProductTypeImpl&lt; SymmetricTensor&lt; rank, dim, std::complex&lt; T &gt; &gt;, std::complex&lt; U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1ProductTypeImpl_3_01std_1_1complex_3_01T_01_4_00_01SymmetricTensor_3_01rank_00_01dim_00_01U_01_4_01_4.html">internal::ProductTypeImpl&lt; std::complex&lt; T &gt;, SymmetricTensor&lt; rank, dim, U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1ProductTypeImpl_3_01std_1_1complex_3_01T_01_4_00_01SymmetricTensor_3_01rank_00dacfb99e136ba51e96566fcb9f15d43b.html">internal::ProductTypeImpl&lt; std::complex&lt; T &gt;, SymmetricTensor&lt; rank, dim, std::complex&lt; U &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1SymmetricTensorImplementation_1_1Inverse.html">internal::SymmetricTensorImplementation::Inverse&lt; rank, dim, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1double__contraction__result.html">internal::SymmetricTensorAccessors::double_contraction_result&lt; rank1, rank2, dim, Number, OtherNumber &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1double__contraction__result_3_012_00_012_00_01dim_bde24087db8a52ec06f500b41dd95304.html">internal::SymmetricTensorAccessors::double_contraction_result&lt; 2, 2, dim, Number, OtherNumber &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1StorageType.html">internal::SymmetricTensorAccessors::StorageType&lt; rank, dim, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1StorageType_3_012_00_01dim_00_01Number_01_4.html">internal::SymmetricTensorAccessors::StorageType&lt; 2, dim, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1StorageType_3_014_00_01dim_00_01Number_01_4.html">internal::SymmetricTensorAccessors::StorageType&lt; 4, dim, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1AccessorTypes.html">internal::SymmetricTensorAccessors::AccessorTypes&lt; rank, dim, constness, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1AccessorTypes_3_01rank_00_01dim_00_01true_00_01Number_01_4.html">internal::SymmetricTensorAccessors::AccessorTypes&lt; rank, dim, true, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1AccessorTypes_3_01rank_00_01dim_00_01false_00_01Number_01_4.html">internal::SymmetricTensorAccessors::AccessorTypes&lt; rank, dim, false, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinternal_1_1SymmetricTensorAccessors_1_1Accessor.html">internal::SymmetricTensorAccessors::Accessor&lt; rank, dim, constness, P, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinternal_1_1SymmetricTensorAccessors_1_1Accessor_3_01rank_00_01dim_00_01constness_00_011_00_01Number_01_4.html">internal::SymmetricTensorAccessors::Accessor&lt; rank, dim, constness, 1, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html">SymmetricTensor&lt; rank_, dim, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinternal_1_1SymmetricTensorImplementation_1_1SortEigenValuesVectors.html">internal::SymmetricTensorImplementation::SortEigenValuesVectors&lt; dim, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceinternal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinternal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceinternal_1_1SymmetricTensorImplementation"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinternal_1_1SymmetricTensorImplementation.html">internal::SymmetricTensorImplementation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceinternal_1_1SymmetricTensorAccessors"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinternal_1_1SymmetricTensorAccessors.html">internal::SymmetricTensorAccessors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac535cfc6fdfc0e23150b97e877e44e88"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#ac535cfc6fdfc0e23150b97e877e44e88">SymmetricTensorEigenvectorMethod</a> { <a class="el" href="symmetric__tensor_8h.html#ac535cfc6fdfc0e23150b97e877e44e88af7befc67e4b1ddf3a03d496537760671">SymmetricTensorEigenvectorMethod::hybrid</a>, 
<a class="el" href="symmetric__tensor_8h.html#ac535cfc6fdfc0e23150b97e877e44e88a65b4954581b684416cb84c7aecbf0482">SymmetricTensorEigenvectorMethod::ql_implicit_shifts</a>, 
<a class="el" href="symmetric__tensor_8h.html#ac535cfc6fdfc0e23150b97e877e44e88a1606457c201437c4f914a83939e25722">SymmetricTensorEigenvectorMethod::jacobi</a>
 }</td></tr>
<tr class="separator:ac535cfc6fdfc0e23150b97e877e44e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae2782a4382d7dece7e38560f5f56e641"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ae2782a4382d7dece7e38560f5f56e641"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a> ()</td></tr>
<tr class="separator:ae2782a4382d7dece7e38560f5f56e641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566ce211102218813f79b8122e2a6787"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number  = double&gt; </td></tr>
<tr class="memitem:a566ce211102218813f79b8122e2a6787"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a566ce211102218813f79b8122e2a6787">deviator_tensor</a> ()</td></tr>
<tr class="separator:a566ce211102218813f79b8122e2a6787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e890348aa219805e84f7d367e098c3"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number  = double&gt; </td></tr>
<tr class="memitem:ab3e890348aa219805e84f7d367e098c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#ab3e890348aa219805e84f7d367e098c3">identity_tensor</a> ()</td></tr>
<tr class="separator:ab3e890348aa219805e84f7d367e098c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3656e2f6095f612536b06139a6a2ca39"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a3656e2f6095f612536b06139a6a2ca39"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;)</td></tr>
<tr class="separator:a3656e2f6095f612536b06139a6a2ca39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a259475ad1982cdde73222567d49180"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a1a259475ad1982cdde73222567d49180"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a1a259475ad1982cdde73222567d49180">invert</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; &amp;)</td></tr>
<tr class="separator:a1a259475ad1982cdde73222567d49180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4248760c880275bab1f288fc80f27039"><td class="memTemplParams" colspan="2">template&lt;int dim2, typename Number &gt; </td></tr>
<tr class="memitem:a4248760c880275bab1f288fc80f27039"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number &gt; &amp;)</td></tr>
<tr class="separator:a4248760c880275bab1f288fc80f27039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022faa691137ee8c1f65dacc47d94a04"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a022faa691137ee8c1f65dacc47d94a04"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a022faa691137ee8c1f65dacc47d94a04">deviator</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;)</td></tr>
<tr class="separator:a022faa691137ee8c1f65dacc47d94a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fa20712aae4f3b8ab9f62729b464d3"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a31fa20712aae4f3b8ab9f62729b464d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;)</td></tr>
<tr class="separator:a31fa20712aae4f3b8ab9f62729b464d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3080af8704b3a9882a6fab3eecc63568"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classTableIndices.html">TableIndices</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinternal_1_1SymmetricTensorAccessors.html#a3080af8704b3a9882a6fab3eecc63568">internal::SymmetricTensorAccessors::merge</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; 2 &gt; &amp;previous_indices, const unsigned <a class="el" href="classint.html">int</a> new_index, const unsigned <a class="el" href="classint.html">int</a> position)</td></tr>
<tr class="separator:a3080af8704b3a9882a6fab3eecc63568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7ee862e5e6f5757190ab3f64aff2b0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classTableIndices.html">TableIndices</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinternal_1_1SymmetricTensorAccessors.html#a8c7ee862e5e6f5757190ab3f64aff2b0">internal::SymmetricTensorAccessors::merge</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; 4 &gt; &amp;previous_indices, const unsigned <a class="el" href="classint.html">int</a> new_index, const unsigned <a class="el" href="classint.html">int</a> position)</td></tr>
<tr class="separator:a8c7ee862e5e6f5757190ab3f64aff2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfe82642874a4a3b1e666f7276d512b"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:abbfe82642874a4a3b1e666f7276d512b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#abbfe82642874a4a3b1e666f7276d512b">operator+</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;left, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;right)</td></tr>
<tr class="separator:abbfe82642874a4a3b1e666f7276d512b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9eafd3162685be6f5991c38a6199bb8"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ab9eafd3162685be6f5991c38a6199bb8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#ab9eafd3162685be6f5991c38a6199bb8">operator-</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;left, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;right)</td></tr>
<tr class="separator:ab9eafd3162685be6f5991c38a6199bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdc8c6eb5007e04da9b235545dbb96e"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a6fdc8c6eb5007e04da9b235545dbb96e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a6fdc8c6eb5007e04da9b235545dbb96e">operator+</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;left, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;right)</td></tr>
<tr class="separator:a6fdc8c6eb5007e04da9b235545dbb96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6823d7f78f3d0737d360d5a6dc8f90"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ade6823d7f78f3d0737d360d5a6dc8f90"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#ade6823d7f78f3d0737d360d5a6dc8f90">operator+</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt; &amp;left, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;right)</td></tr>
<tr class="separator:ade6823d7f78f3d0737d360d5a6dc8f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb478cabb9ad51cffa2b931b96b0fa6"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a2cb478cabb9ad51cffa2b931b96b0fa6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a2cb478cabb9ad51cffa2b931b96b0fa6">operator-</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;left, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;right)</td></tr>
<tr class="separator:a2cb478cabb9ad51cffa2b931b96b0fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1d36aa343ad77fdcdd60e5957621af"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a3f1d36aa343ad77fdcdd60e5957621af"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a3f1d36aa343ad77fdcdd60e5957621af">operator-</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt; &amp;left, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;right)</td></tr>
<tr class="separator:a3f1d36aa343ad77fdcdd60e5957621af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27e65a266c0c962bfa90adbeb35d313"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:aa27e65a266c0c962bfa90adbeb35d313"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#aa27e65a266c0c962bfa90adbeb35d313">third_invariant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:aa27e65a266c0c962bfa90adbeb35d313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9137b6052702150e8e5b1188d1971906"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a9137b6052702150e8e5b1188d1971906"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a9137b6052702150e8e5b1188d1971906">trace</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;d)</td></tr>
<tr class="separator:a9137b6052702150e8e5b1188d1971906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04efa71ed514a17d8769c21019cca4e8"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a04efa71ed514a17d8769c21019cca4e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a04efa71ed514a17d8769c21019cca4e8">first_invariant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a04efa71ed514a17d8769c21019cca4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f5794e514a7f53b8073575d4675c84"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:aa1f5794e514a7f53b8073575d4675c84"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#aa1f5794e514a7f53b8073575d4675c84">second_invariant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;)</td></tr>
<tr class="separator:aa1f5794e514a7f53b8073575d4675c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a406452573ef4f85351abd4a4bc4c0"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ae1a406452573ef4f85351abd4a4bc4c0"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#ae1a406452573ef4f85351abd4a4bc4c0">second_invariant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;t)</td></tr>
<tr class="separator:ae1a406452573ef4f85351abd4a4bc4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0be28be5368b57ee743a74afae2328"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:abf0be28be5368b57ee743a74afae2328"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#abf0be28be5368b57ee743a74afae2328">second_invariant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;t)</td></tr>
<tr class="separator:abf0be28be5368b57ee743a74afae2328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c9cd0a3fecbd58ae133dfdd104f9f9"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a45c9cd0a3fecbd58ae133dfdd104f9f9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; Number, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;T)</td></tr>
<tr class="separator:a45c9cd0a3fecbd58ae133dfdd104f9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae9aa1b6a4dba7eccf55e4e4209a39e"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a3ae9aa1b6a4dba7eccf55e4e4209a39e"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; Number, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a3ae9aa1b6a4dba7eccf55e4e4209a39e">eigenvalues</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;T)</td></tr>
<tr class="separator:a3ae9aa1b6a4dba7eccf55e4e4209a39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea72b50f6a2a250829813fd7ead954c"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:aeea72b50f6a2a250829813fd7ead954c"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; Number, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#aeea72b50f6a2a250829813fd7ead954c">eigenvalues</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;T)</td></tr>
<tr class="separator:aeea72b50f6a2a250829813fd7ead954c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839c683c2f3d5789886a16ff505cd159"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a839c683c2f3d5789886a16ff505cd159"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinternal_1_1SymmetricTensorImplementation.html#a839c683c2f3d5789886a16ff505cd159">internal::SymmetricTensorImplementation::tridiagonalize</a> (const ::<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;A, ::<a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;Q, std::array&lt; Number, dim &gt; &amp;d, std::array&lt; Number, dim - 1 &gt; &amp;e)</td></tr>
<tr class="separator:a839c683c2f3d5789886a16ff505cd159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa565cb33f7fbd1fa9cecad9aa5d4ecd7"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:aa565cb33f7fbd1fa9cecad9aa5d4ecd7"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::pair&lt; Number, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinternal_1_1SymmetricTensorImplementation.html#aa565cb33f7fbd1fa9cecad9aa5d4ecd7">internal::SymmetricTensorImplementation::ql_implicit_shifts</a> (const ::<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;A)</td></tr>
<tr class="separator:aa565cb33f7fbd1fa9cecad9aa5d4ecd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfbc2a74523e9cf070f25dfdd98f4e0"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a5bfbc2a74523e9cf070f25dfdd98f4e0"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::pair&lt; Number, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &gt;, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinternal_1_1SymmetricTensorImplementation.html#a5bfbc2a74523e9cf070f25dfdd98f4e0">internal::SymmetricTensorImplementation::jacobi</a> (::<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; A)</td></tr>
<tr class="separator:a5bfbc2a74523e9cf070f25dfdd98f4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19906847b7ca1fa629cb5883511293f"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ab19906847b7ca1fa629cb5883511293f"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::pair&lt; Number, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2, Number &gt; &gt;, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinternal_1_1SymmetricTensorImplementation.html#ab19906847b7ca1fa629cb5883511293f">internal::SymmetricTensorImplementation::hybrid</a> (const ::<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;A)</td></tr>
<tr class="separator:ab19906847b7ca1fa629cb5883511293f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583a0dbdc8dcf51183452e57dbd23782"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a583a0dbdc8dcf51183452e57dbd23782"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::pair&lt; Number, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3, Number &gt; &gt;, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinternal_1_1SymmetricTensorImplementation.html#a583a0dbdc8dcf51183452e57dbd23782">internal::SymmetricTensorImplementation::hybrid</a> (const ::<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;A)</td></tr>
<tr class="separator:a583a0dbdc8dcf51183452e57dbd23782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18a9d623fcd520f022421fd1d6c7a14"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:aa18a9d623fcd520f022421fd1d6c7a14"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::pair&lt; Number, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &gt;, std::integral_constant&lt; <a class="el" href="classint.html">int</a>, dim &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#aa18a9d623fcd520f022421fd1d6c7a14">eigenvectors</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;T, const <a class="el" href="symmetric__tensor_8h.html#ac535cfc6fdfc0e23150b97e877e44e88">SymmetricTensorEigenvectorMethod</a> method=<a class="el" href="symmetric__tensor_8h.html#ac535cfc6fdfc0e23150b97e877e44e88a65b4954581b684416cb84c7aecbf0482">SymmetricTensorEigenvectorMethod::ql_implicit_shifts</a>)</td></tr>
<tr class="separator:aa18a9d623fcd520f022421fd1d6c7a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3fa57d53292237b465d0575a788353"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number &gt; </td></tr>
<tr class="memitem:ace3fa57d53292237b465d0575a788353"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#ace3fa57d53292237b465d0575a788353">transpose</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:ace3fa57d53292237b465d0575a788353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c727eebb2d3d1870cbf4e77a3f45a6b"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a8c727eebb2d3d1870cbf4e77a3f45a6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t1, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t2)</td></tr>
<tr class="separator:a8c727eebb2d3d1870cbf4e77a3f45a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2101a1d45267f1fd4664ed178cb636"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a1b2101a1d45267f1fd4664ed178cb636"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a1b2101a1d45267f1fd4664ed178cb636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6cce115919f046d183a86603c3460c"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number &gt; </td></tr>
<tr class="memitem:abf6cce115919f046d183a86603c3460c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#abf6cce115919f046d183a86603c3460c">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;t, const Number &amp;factor)</td></tr>
<tr class="separator:abf6cce115919f046d183a86603c3460c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e4986da5cf401499d62712eba3c37b"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number &gt; </td></tr>
<tr class="memitem:aa9e4986da5cf401499d62712eba3c37b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#aa9e4986da5cf401499d62712eba3c37b">operator*</a> (const Number &amp;factor, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:aa9e4986da5cf401499d62712eba3c37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7c8f95f229b4bb758a47cedc53170b"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:aae7c8f95f229b4bb758a47cedc53170b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#aae7c8f95f229b4bb758a47cedc53170b">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;t, const OtherNumber &amp;factor)</td></tr>
<tr class="separator:aae7c8f95f229b4bb758a47cedc53170b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a8714feb8754f7a87c18b4a14d0638"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a64a8714feb8754f7a87c18b4a14d0638"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; OtherNumber, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; Number &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a64a8714feb8754f7a87c18b4a14d0638">operator*</a> (const Number &amp;factor, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;t)</td></tr>
<tr class="separator:a64a8714feb8754f7a87c18b4a14d0638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f75191f4cdcae990782e6f83ffc0cf"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a66f75191f4cdcae990782e6f83ffc0cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a66f75191f4cdcae990782e6f83ffc0cf">operator/</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;t, const OtherNumber &amp;factor)</td></tr>
<tr class="separator:a66f75191f4cdcae990782e6f83ffc0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1347bf48878316f3405d1693ef12bf38"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim&gt; </td></tr>
<tr class="memitem:a1347bf48878316f3405d1693ef12bf38"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a1347bf48878316f3405d1693ef12bf38">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; &amp;t, const <a class="el" href="classdouble.html">double</a> factor)</td></tr>
<tr class="separator:a1347bf48878316f3405d1693ef12bf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f29408c63a14728ce101b02958f4f3"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim&gt; </td></tr>
<tr class="memitem:ad7f29408c63a14728ce101b02958f4f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#ad7f29408c63a14728ce101b02958f4f3">operator*</a> (const <a class="el" href="classdouble.html">double</a> factor, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; &amp;t)</td></tr>
<tr class="separator:ad7f29408c63a14728ce101b02958f4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb639496012bec64ed8d5f045e7d9111"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim&gt; </td></tr>
<tr class="memitem:aeb639496012bec64ed8d5f045e7d9111"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#aeb639496012bec64ed8d5f045e7d9111">operator/</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; &amp;t, const <a class="el" href="classdouble.html">double</a> factor)</td></tr>
<tr class="separator:aeb639496012bec64ed8d5f045e7d9111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14ac27fc9ab74d4de531698b492d8de"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ab14ac27fc9ab74d4de531698b492d8de"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t1, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, OtherNumber &gt; &amp;t2)</td></tr>
<tr class="separator:ab14ac27fc9ab74d4de531698b492d8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b3e17cd6ee5502c5a1118ddc751306"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a69b3e17cd6ee5502c5a1118ddc751306"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a69b3e17cd6ee5502c5a1118ddc751306">scalar_product</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t1, const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, OtherNumber &gt; &amp;t2)</td></tr>
<tr class="separator:a69b3e17cd6ee5502c5a1118ddc751306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4624be3a3f38c1fad53951437a22e1"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a0b4624be3a3f38c1fad53951437a22e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a0b4624be3a3f38c1fad53951437a22e1">scalar_product</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t1, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, OtherNumber &gt; &amp;t2)</td></tr>
<tr class="separator:a0b4624be3a3f38c1fad53951437a22e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b7c41cb9adfb6a07c0e3824cd7cb8b"><td class="memTemplParams" colspan="2">template&lt;typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a07b7c41cb9adfb6a07c0e3824cd7cb8b"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a07b7c41cb9adfb6a07c0e3824cd7cb8b">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 1, Number &gt; &amp;t, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, OtherNumber &gt; &amp;s)</td></tr>
<tr class="separator:a07b7c41cb9adfb6a07c0e3824cd7cb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b8985f18da4c5e5285eb50fe0e9c99"><td class="memTemplParams" colspan="2">template&lt;typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a63b8985f18da4c5e5285eb50fe0e9c99"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a63b8985f18da4c5e5285eb50fe0e9c99">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;s, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 1, OtherNumber &gt; &amp;t)</td></tr>
<tr class="separator:a63b8985f18da4c5e5285eb50fe0e9c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311b5f5b5f0300cccff82ea0a9f0d287"><td class="memTemplParams" colspan="2">template&lt;typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a311b5f5b5f0300cccff82ea0a9f0d287"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a311b5f5b5f0300cccff82ea0a9f0d287">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 2, Number &gt; &amp;t, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, OtherNumber &gt; &amp;s)</td></tr>
<tr class="separator:a311b5f5b5f0300cccff82ea0a9f0d287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056f3cc5935e09a867c57e7621d3d903"><td class="memTemplParams" colspan="2">template&lt;typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a056f3cc5935e09a867c57e7621d3d903"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a056f3cc5935e09a867c57e7621d3d903">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;s, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 2, OtherNumber &gt; &amp;t)</td></tr>
<tr class="separator:a056f3cc5935e09a867c57e7621d3d903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7030ec2c90ce924cbe6cbe1f43a9bd2"><td class="memTemplParams" colspan="2">template&lt;typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ab7030ec2c90ce924cbe6cbe1f43a9bd2"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#ab7030ec2c90ce924cbe6cbe1f43a9bd2">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, Number &gt; &amp;t, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, OtherNumber &gt; &amp;s)</td></tr>
<tr class="separator:ab7030ec2c90ce924cbe6cbe1f43a9bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac1f945176731e373edfed09dd3f130"><td class="memTemplParams" colspan="2">template&lt;typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:afac1f945176731e373edfed09dd3f130"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#afac1f945176731e373edfed09dd3f130">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;s, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, OtherNumber &gt; &amp;t)</td></tr>
<tr class="separator:afac1f945176731e373edfed09dd3f130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a75bb465d862924f76849afcf6efac4"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a1a75bb465d862924f76849afcf6efac4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a1a75bb465d862924f76849afcf6efac4">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a1a75bb465d862924f76849afcf6efac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3825730970f8dede85b5698f150d50d8"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a3825730970f8dede85b5698f150d50d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a3825730970f8dede85b5698f150d50d8">operator*</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &amp;src1, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a3825730970f8dede85b5698f150d50d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21368b7527565a28d154f98622128db1"><td class="memTemplParams" colspan="2">template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a21368b7527565a28d154f98622128db1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::tensor_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a21368b7527565a28d154f98622128db1">operator*</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;src1, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a21368b7527565a28d154f98622128db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6015ed09fffc0b77fc2f2e38a59cf2"><td class="memTemplParams" colspan="2">template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ada6015ed09fffc0b77fc2f2e38a59cf2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::tensor_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#ada6015ed09fffc0b77fc2f2e38a59cf2">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_1, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:ada6015ed09fffc0b77fc2f2e38a59cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cd683fd58a42e393c546cc4abedeed"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:aa5cd683fd58a42e393c546cc4abedeed"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#aa5cd683fd58a42e393c546cc4abedeed">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:aa5cd683fd58a42e393c546cc4abedeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351a3d35263baee19d033e5c68bc8539"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a351a3d35263baee19d033e5c68bc8539"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="symmetric__tensor_8h.html#a351a3d35263baee19d033e5c68bc8539">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a351a3d35263baee19d033e5c68bc8539"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac535cfc6fdfc0e23150b97e877e44e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac535cfc6fdfc0e23150b97e877e44e88">&#9670;&nbsp;</a></span>SymmetricTensorEigenvectorMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="symmetric__tensor_8h.html#ac535cfc6fdfc0e23150b97e877e44e88">SymmetricTensorEigenvectorMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An enumeration for the algorithm to be employed when performing the computation of normalized eigenvectors and their corresponding eigenvalues by the <a class="el" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues()</a> and <a class="el" href="classSymmetricTensor.html#aa18a9d623fcd520f022421fd1d6c7a14">eigenvectors()</a> methods operating on <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> objects.</p>
<p>The specialized algorithms utilized in computing the eigenvectors are presented in </p><div class="fragment"><div class="line">@article{Kopp2008,</div><div class="line">  title       = {Efficient numerical diagonalization of hermitian 3x3</div><div class="line">                 matrices},</div><div class="line">  author      = {Kopp, J.},</div><div class="line">  journal     = {International Journal of Modern Physics C},</div><div class="line">  year        = {2008},</div><div class="line">  volume      = {19},</div><div class="line">  number      = {3},</div><div class="line">  pages       = {523--548},</div><div class="line">  doi         = {10.1142/S0129183108012303},</div><div class="line">  eprinttype  = {arXiv},</div><div class="line">  eprint      = {physics/0610206v3},</div><div class="line">  eprintclass = {physics.comp-ph},</div><div class="line">  url         =</div><div class="line">{https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html}</div><div class="line">}</div></div><!-- fragment --> <table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac535cfc6fdfc0e23150b97e877e44e88af7befc67e4b1ddf3a03d496537760671"></a>hybrid&#160;</td><td class="fielddoc"><p>A hybrid approach that preferentially uses the characteristic equation to compute eigenvalues and an analytical approach based on the cross-product for the eigenvectors. If the computations are deemed too inaccurate then the method falls back to ql_implicit_shifts.</p>
<p>This method potentially offers the quickest computation if the pathological case is not encountered. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac535cfc6fdfc0e23150b97e877e44e88a65b4954581b684416cb84c7aecbf0482"></a>ql_implicit_shifts&#160;</td><td class="fielddoc"><p>The iterative QL algorithm with implicit shifts applied after tridiagonalization of the tensor using the householder method.</p>
<p>This method offers a compromise between speed of computation and its robustness. This method is particularly useful when the elements of \(T\) have greatly varying magnitudes, which would typically lead to a loss of accuracy when computing the smaller eigenvalues. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac535cfc6fdfc0e23150b97e877e44e88a1606457c201437c4f914a83939e25722"></a>jacobi&#160;</td><td class="fielddoc"><p>The iterative Jacobi algorithm.</p>
<p>This method offers is the most robust of the available options, with reliable results obtained for even the most pathological cases. It is, however, the slowest algorithm of all of those implemented. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03160">3160</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae2782a4382d7dece7e38560f5f56e641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2782a4382d7dece7e38560f5f56e641">&#9670;&nbsp;</a></span>unit_symmetric_tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; unit_symmetric_tensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a unit symmetric tensor of rank 2, i.e., the \(\text{dim}\times\text{dim}\) identity matrix \(\mathbf I\). </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03276">3276</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a566ce211102218813f79b8122e2a6787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566ce211102218813f79b8122e2a6787">&#9670;&nbsp;</a></span>deviator_tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; deviator_tensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of rank 4 that, when multiplied by a symmetric rank 2 tensor \(\mathbf T\) returns the deviator \(\text{dev}\ \mathbf T\). It is the operator representation of the linear deviator operator \(\mathbb P\), also known as the volumetric projection tensor, calculated as: </p><p class="formulaDsp">
\begin{align*} \mathbb{P} &amp;=\mathbb{I} -\frac{1}{\text{dim}} \mathbf I \otimes \mathbf I \\ \mathcal{P}_{ijkl} &amp;= \frac 12 \left(\delta_{ik} \delta_{jl} + \delta_{il} \delta_{jk} \right) - \frac{1}{\text{dim}} \delta_{ij} \delta_{kl} \end{align*}
</p>
<p>For every tensor <code>T</code>, there holds the identity <code>deviator&lt;dim,Number&gt;(T) == <a class="el" href="symmetric__tensor_8h.html#a566ce211102218813f79b8122e2a6787">deviator_tensor&lt;dim,Number&gt;()</a> * T</code>, up to numerical round-off. </p><p class="formulaDsp">
\[ \text{dev}\mathbf T = \mathbb P : \mathbf T \]
</p>
<dl class="section note"><dt>Note</dt><dd>The reason this operator representation is provided is to simplify taking derivatives of the deviatoric part of tensors: <p class="formulaDsp">
\[ \frac{\partial \text{dev}\mathbf{T}}{\partial \mathbf T} = \mathbb P. \]
</p>
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03304">3304</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ab3e890348aa219805e84f7d367e098c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e890348aa219805e84f7d367e098c3">&#9670;&nbsp;</a></span>identity_tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; identity_tensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the fourth-order symmetric identity tensor \(\mathbb I\) which maps symmetric second-order tensors, such as \(\mathbf A\), to themselves. </p><p class="formulaDsp">
\[ \mathbb I : \mathbf A = \mathbf A \]
</p>
<p>Note that this tensor, even though it is the identity, has a somewhat funny form, and in particular does not only consist of zeros and ones. For example, for <code>dim=2</code>, the identity tensor has all zero entries except for </p><p class="formulaDsp">
\[ \mathcal{I}_{0000} = \mathcal{I}_{1111} = 1 \]
</p>
 <p class="formulaDsp">
\[ \mathcal{I}_{0101} = \mathcal{I}_{0110} = \mathcal{I}_{1001} = \mathcal{I}_{1010} = \frac 12. \]
</p>
<p> In index notation, we can write the general form </p><p class="formulaDsp">
\[ \mathcal{I}_{ijkl} = \frac 12 \left( \delta_{ik} \delta_{jl} + \delta_{il} \delta_{jl} \right). \]
</p>
<p> To see why this factor of \(1 / 2\) is necessary, consider computing \(\mathbf A= \mathbb I : \mathbf B\). For the element \(A_{01}\) we have \(A_{01} = \mathcal{I}_{0100} B_{00} + \mathcal{I}_{0111} B_{11} + \mathcal{I}_{0101} B_{01} + \mathcal{I}_{0110} B_{10}\). On the other hand, we need to have \(A_{01} = B_{01}\), and symmetry implies \(B_{01}=B_{10}\), leading to \(A_{01} = (\mathcal{I}_{0101} + \mathcal{I}_{0110}) B_{01}\), or, again by symmetry, \(\mathcal{I}_{0101} = \mathcal{I}_{0110} = \frac 12\). Similar considerations hold for the three-dimensional case.</p>
<p>This issue is also explained in the introduction to step-44. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03332">3332</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a3656e2f6095f612536b06139a6a2ca39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3656e2f6095f612536b06139a6a2ca39">&#9670;&nbsp;</a></span>invert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invert a symmetric rank-2 tensor.</p>
<dl class="section note"><dt>Note</dt><dd>If a tensor is not invertible, then the result is unspecified, but will likely contain the results of a division by zero or a very small number at the very least. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03367">3367</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a1a259475ad1982cdde73222567d49180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a259475ad1982cdde73222567d49180">&#9670;&nbsp;</a></span>invert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invert a symmetric rank-4 tensor. Since symmetric rank-4 tensors are mappings from and to symmetric rank-2 tensors, they can have an inverse.</p>
<p>If a tensor is not invertible, then the result is unspecified, but will likely contain the results of a division by zero or a very small number at the very least. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03387">3387</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a4248760c880275bab1f288fc80f27039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4248760c880275bab1f288fc80f27039">&#9670;&nbsp;</a></span>trace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim2, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a022faa691137ee8c1f65dacc47d94a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022faa691137ee8c1f65dacc47d94a04">&#9670;&nbsp;</a></span>deviator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; deviator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the deviator of a symmetric tensor, which is defined as \(\text{dev} \mathbf T = \mathbf T - \frac{1}{\text{dim}} \text{tr}\mathbf T \; \mathbf I\), where \(\mathbf I\) is the identity operator. This quantity equals the original tensor minus its contractive or dilative component and refers to the shear in, for example, elasticity. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03260">3260</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a31fa20712aae4f3b8ab9f62729b464d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fa20712aae4f3b8ab9f62729b464d3">&#9670;&nbsp;</a></span>determinant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the determinant of a rank 2 symmetric tensor. The determinant is also commonly referred to as the third invariant of rank-2 tensors.</p>
<p>For a one-dimensional tensor, the determinant equals the only element and is therefore equivalent to the trace.</p>
<p>For greater notational simplicity, there is also a <code><a class="el" href="classSymmetricTensor.html#aa27e65a266c0c962bfa90adbeb35d313">third_invariant()</a></code> function that returns the determinant of a tensor. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02693">2693</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="abbfe82642874a4a3b1e666f7276d512b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfe82642874a4a3b1e666f7276d512b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition of two symmetric tensors of equal rank. The result is another <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> that has a number type that is compatible with the operation.</p>
<p>If possible (e.g. when <code>Number</code> and <code>OtherNumber</code> are of the same type, or if the result of <code>Number() + OtherNumber()</code> is another <code>Number</code>), you should use <code>operator+=</code> instead since this does not require the creation of a temporary variable. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02574">2574</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ab9eafd3162685be6f5991c38a6199bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9eafd3162685be6f5991c38a6199bb8">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction of two symmetric tensors of equal rank. The result is another <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> that has a number type that is compatible with the operation.</p>
<p>If possible (e.g. when <code>Number</code> and <code>OtherNumber</code> are of the same type, or if the result of <code>Number() - OtherNumber()</code> is another <code>Number</code>), you should use <code>operator-=</code> instead since this does not require the creation of a temporary variable. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02599">2599</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a6fdc8c6eb5007e04da9b235545dbb96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdc8c6eb5007e04da9b235545dbb96e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition of a <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> and a general <a class="el" href="classTensor.html">Tensor</a> of equal rank. The result is a general <a class="el" href="classTensor.html">Tensor</a> that has a number type that is compatible with the operation. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02619">2619</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ade6823d7f78f3d0737d360d5a6dc8f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6823d7f78f3d0737d360d5a6dc8f90">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition of a general <a class="el" href="classTensor.html">Tensor</a> with a <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> of equal rank. The result is a general <a class="el" href="classTensor.html">Tensor</a> that has a number type that is compatible with the operation. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02636">2636</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a2cb478cabb9ad51cffa2b931b96b0fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb478cabb9ad51cffa2b931b96b0fa6">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtraction of a general <a class="el" href="classTensor.html">Tensor</a> from a <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> of equal rank. The result is a general <a class="el" href="classTensor.html">Tensor</a> that has a number type that is compatible with the operation. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02653">2653</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a3f1d36aa343ad77fdcdd60e5957621af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1d36aa343ad77fdcdd60e5957621af">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtraction of a <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> from a general <a class="el" href="classTensor.html">Tensor</a> of equal rank. The result is a general <a class="el" href="classTensor.html">Tensor</a> that has a number type that is compatible with the operation. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02670">2670</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="aa27e65a266c0c962bfa90adbeb35d313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27e65a266c0c962bfa90adbeb35d313">&#9670;&nbsp;</a></span>third_invariant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number third_invariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the determinant of a rank 2 symmetric tensor. This function therefore computes the same value as the <code><a class="el" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant()</a></code> functions and is only provided for greater notational simplicity (since there are also functions <a class="el" href="classSymmetricTensor.html#a04efa71ed514a17d8769c21019cca4e8">first_invariant()</a> and <a class="el" href="classSymmetricTensor.html#aa1f5794e514a7f53b8073575d4675c84">second_invariant()</a>). </p><p class="formulaDsp">
\[ I_3 (\mathbf A) = III (\mathbf A) = \det (\mathbf A) \]
</p>
 
<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02733">2733</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a9137b6052702150e8e5b1188d1971906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9137b6052702150e8e5b1188d1971906">&#9670;&nbsp;</a></span>trace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute and return the trace of a tensor of rank 2, i.e. the sum of its diagonal entries. The trace is the first invariant of a rank-2 tensor. </p><p class="formulaDsp">
\[ \text{tr} \mathbf A = \sum_i A_{ii} \]
</p>
 
<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02751">2751</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a04efa71ed514a17d8769c21019cca4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04efa71ed514a17d8769c21019cca4e8">&#9670;&nbsp;</a></span>first_invariant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number first_invariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the trace of a rank 2 symmetric tensor. This function therefore computes the same value as the <code><a class="el" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace()</a></code> functions and is only provided for greater notational simplicity (since there are also functions <a class="el" href="classSymmetricTensor.html#aa1f5794e514a7f53b8073575d4675c84">second_invariant()</a> and <a class="el" href="classSymmetricTensor.html#aa27e65a266c0c962bfa90adbeb35d313">third_invariant()</a>). </p><p class="formulaDsp">
\[ I_1 (\mathbf A) = I (\mathbf A) = \text{tr} \mathbf A = \sum_i A_{ii} \]
</p>
 
<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02773">2773</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="aa1f5794e514a7f53b8073575d4675c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f5794e514a7f53b8073575d4675c84">&#9670;&nbsp;</a></span>second_invariant() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number second_invariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the second invariant of a tensor of rank 2. The second invariant of a tensor \(\mathbf A\) is defined as \(I_2 (\mathbf A) = II(\mathbf A) = \frac 12 \left[ (\text{tr} \mathbf A)^2 - \text{tr} (\mathbf{A}^2) \right]\).</p>
<p>For the kind of arguments to this function, i.e., a rank-2 tensor of size 1, the result is simply zero. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02792">2792</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ae1a406452573ef4f85351abd4a4bc4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a406452573ef4f85351abd4a4bc4c0">&#9670;&nbsp;</a></span>second_invariant() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number second_invariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the second invariant of a tensor of rank 2. The second invariant of a tensor \(\mathbf A\) is defined as \(I_2 (\mathbf A) = II(\mathbf A) = \frac 12 \left[ (\text{tr} \mathbf A)^2 - \text{tr} (\mathbf{A}^2) \right]\).</p>
<p>For the kind of arguments to this function, i.e., a symmetric rank-2 tensor of size 2, the result is (counting indices starting at one) \(I_2(\mathbf A) = II(\mathbf A) = \frac 12 \left[ (A_{11} + A_{22})^2 - (A_{11}^2+2 A_{12}^2+ A_{22}^2) \right] = A_{11} A_{22} - A_{12}^2\). As expected, for the \(2\times 2\) symmetric tensors this function handles, this equals the determinant of the tensor. (This is so because for \(2\times 2\) symmetric tensors, there really are only two invariants, so the second and third invariant are the same; the determinant is the third invariant.) </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02819">2819</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="abf0be28be5368b57ee743a74afae2328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0be28be5368b57ee743a74afae2328">&#9670;&nbsp;</a></span>second_invariant() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number second_invariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the second invariant of a tensor of rank 2. The second invariant of a tensor \(\mathbf A\) is defined as \(I_2 (\mathbf A) = II(\mathbf A) = \frac 12 \left[ (\text{tr} \mathbf A)^2 - \text{tr} (\mathbf{A}^2) \right]\). </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02836">2836</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a45c9cd0a3fecbd58ae133dfdd104f9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c9cd0a3fecbd58ae133dfdd104f9f9">&#9670;&nbsp;</a></span>eigenvalues() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; Number, 1 &gt; eigenvalues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the eigenvalues of a symmetric \(1 \times 1\) tensor. The (single) entry of the tensor is, of course, equal to the (single) eigenvalue. </p>

</div>
</div>
<a id="a3ae9aa1b6a4dba7eccf55e4e4209a39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae9aa1b6a4dba7eccf55e4e4209a39e">&#9670;&nbsp;</a></span>eigenvalues() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; Number, 2 &gt; eigenvalues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the eigenvalues of a symmetric \(2\times 2\) tensor. The array of eigenvalues is sorted in descending order.</p>
<p>For \(2\times 2\) tensors, the eigenvalues of tensor \(\mathbf T\) are the roots of <a href="https://en.wikipedia.org/wiki/Eigenvalue_algorithm#2.C3.972_matrices">the characteristic polynomial</a> \(0 = \lambda^2 - \lambda\;\text{tr}\mathbf{T} + \det \mathbf{T}\) as given by \(\lambda_1, \lambda_2 = \frac{1}{2} \left[ \text{tr} \mathbf{T} \pm \sqrt{(\text{tr} \mathbf{T})^2 - 4 \det \mathbf{T}} \right]\).</p>
<dl class="section warning"><dt>Warning</dt><dd>The algorithm employed here determines the eigenvalues by computing the roots of the characteristic polynomial. In the case that there exists a common root (the eigenvalues are equal), the computation is <a href="https://scicomp.stackexchange.com/q/23686">subject to round-off errors</a> of order \(\sqrt{\epsilon}\). As an alternative, the <a class="el" href="classSymmetricTensor.html#aa18a9d623fcd520f022421fd1d6c7a14">eigenvectors()</a> function provides a more robust, but costly, method to compute the eigenvalues of a symmetric tensor. </dd></dl>

</div>
</div>
<a id="aeea72b50f6a2a250829813fd7ead954c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea72b50f6a2a250829813fd7ead954c">&#9670;&nbsp;</a></span>eigenvalues() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; Number, 3 &gt; eigenvalues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the eigenvalues of a symmetric \(3\times 3\) tensor. The array of eigenvalues is sorted in descending order.</p>
<p>For \(3\times 3\) tensors, the eigenvalues of tensor \(\mathbf T\) are the roots of <a href="https://en.wikipedia.org/wiki/Eigenvalue_algorithm#3.C3.973_matrices">the characteristic polynomial</a> \(0 = \lambda^3 - \lambda^2\;\text{tr}\mathbf T - \frac{1}{2} \lambda \left[\text{tr}(\mathbf{T}^2) - (\text{tr}\mathbf T)^2\right] - \det \mathbf T\).</p>
<dl class="section warning"><dt>Warning</dt><dd>The algorithm employed here determines the eigenvalues by computing the roots of the characteristic polynomial. In the case that there exists a common root (the eigenvalues are equal), the computation is <a href="https://scicomp.stackexchange.com/q/23686">subject to round-off errors</a> of order \(\sqrt{\epsilon}\). As an alternative, the <a class="el" href="classSymmetricTensor.html#aa18a9d623fcd520f022421fd1d6c7a14">eigenvectors()</a> function provides a more robust, but costly, method to compute the eigenvalues of a symmetric tensor. </dd></dl>

</div>
</div>
<a id="aa18a9d623fcd520f022421fd1d6c7a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18a9d623fcd520f022421fd1d6c7a14">&#9670;&nbsp;</a></span>eigenvectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::pair&lt; Number, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &gt;, std::integral_constant&lt; <a class="el" href="classint.html">int</a>, dim &gt;::value &gt; eigenvectors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="symmetric__tensor_8h.html#ac535cfc6fdfc0e23150b97e877e44e88">SymmetricTensorEigenvectorMethod</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code><a class="el" href="symmetric__tensor_8h.html#ac535cfc6fdfc0e23150b97e877e44e88a65b4954581b684416cb84c7aecbf0482">SymmetricTensorEigenvectorMethod::ql_implicit_shifts</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the eigenvalues and eigenvectors of a real-valued rank-2 symmetric tensor \(\mathbf T\). The array of matched eigenvalue and eigenvector pairs is sorted in descending order (determined by the eigenvalues).</p>
<p>The specialized algorithms utilized in computing the eigenvectors are presented in </p><div class="fragment"><div class="line">@article{Kopp2008,</div><div class="line">  title       = {Efficient numerical diagonalization of hermitian 3x3</div><div class="line">                 matrices},</div><div class="line">  author      = {Kopp, J.},</div><div class="line">  journal     = {International Journal of Modern Physics C},</div><div class="line">  year        = {2008},</div><div class="line">  volume      = {19},</div><div class="line">  number      = {3},</div><div class="line">  pages       = {523--548},</div><div class="line">  doi         = {10.1142/S0129183108012303},</div><div class="line">  eprinttype  = {arXiv},</div><div class="line">  eprint      = {physics/0610206v3},</div><div class="line">  eprintclass = {physics.comp-ph},</div><div class="line">  url         =</div><div class="line">{https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html}</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="ace3fa57d53292237b465d0575a788353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3fa57d53292237b465d0575a788353">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the transpose of the given symmetric tensor. Since we are working with symmetric objects, the transpose is of course the same as the original tensor. This function mainly exists for compatibility with the <a class="el" href="classTensor.html">Tensor</a> class. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03241">3241</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a8c727eebb2d3d1870cbf4e77a3f45a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c727eebb2d3d1870cbf4e77a3f45a6b">&#9670;&nbsp;</a></span>outer_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; outer_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of rank 4 that is the outer product of the two tensors given as arguments, i.e. the result \(\mathbb A = \mathbf{T}_1 \otimes \mathbf{T}_2\) satisfies \(\mathbb A : \mathbf B = (\mathbf{T}_2 : \mathbf B) \mathbf{T}_1\) for all symmetric tensors \(\mathbf B\). In index notation </p><p class="formulaDsp">
\[ \mathcal{A}_{ijkl} = (T_1)_{ij} (T_2)_{kl} \]
</p>
<p>For example, the deviator tensor \(\mathbb P = \mathbb I - \frac{1}{\text{dim}} \mathbf I \otimes \mathbf I\) can be computed as <code><a class="el" href="symmetric__tensor_8h.html#ab3e890348aa219805e84f7d367e098c3">identity_tensor&lt;dim&gt;()</a> - 1/d * outer_product (<a class="el" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor&lt;dim&gt;()</a>, <a class="el" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor&lt;dim&gt;()</a>)</code>, since the (double) contraction with the unit tensor yields the trace of a symmetric tensor ( \(\mathbf I : \mathbf B = \text{tr} \mathbf B\)). </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03418">3418</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a1b2101a1d45267f1fd4664ed178cb636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2101a1d45267f1fd4664ed178cb636">&#9670;&nbsp;</a></span>symmetrize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; symmetrize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the symmetrized version of a full rank-2 tensor, i.e. \(\text{sym}\mathbf A = \frac 12 \left(\mathbf A + \mathbf{A}^T\right)\), as a symmetric rank-2 tensor. This is the version for general dimensions. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03444">3444</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="abf6cce115919f046d183a86603c3460c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6cce115919f046d183a86603c3460c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor of general rank with a scalar from the right. This version of the operator is used if the scalar has the same data type as is used to store the elements of the symmetric tensor. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03468">3468</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="aa9e4986da5cf401499d62712eba3c37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e4986da5cf401499d62712eba3c37b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor of general rank with a scalar from the left. This version of the operator is used if the scalar has the same data type as is used to store the elements of the symmetric tensor. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03486">3486</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="aae7c8f95f229b4bb758a47cedc53170b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7c8f95f229b4bb758a47cedc53170b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor with a scalar number from the right.</p>
<p>The purpose of this operator is to enable only multiplication of a tensor by a scalar number (i.e., a floating point number, a complex floating point number, etc.). The function is written in a way that only allows the compiler to consider the function if the second argument is indeed a scalar number &ndash; in other words, <code>OtherNumber</code> will not match, for example <code>std::vector&lt;double&gt;</code> as the product of a tensor and a vector clearly would make no sense. The mechanism by which the compiler is prohibited of considering this operator for multiplication with non-scalar types are explained in the documentation of the <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a> class.</p>
<p>The return type of the function is chosen so that it matches the types of both the tensor and the scalar argument. For example, if you multiply a <code><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2,dim,double&gt;</code> by <code>std::complex&lt;double&gt;</code>, then the result will be a <code><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2,dim,std::complex&lt;double&gt;&gt;</code>. In other words, the type with which the returned tensor stores its components equals the type you would get if you multiplied an individual component of the input tensor by the scalar factor. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03525">3525</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a64a8714feb8754f7a87c18b4a14d0638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a8714feb8754f7a87c18b4a14d0638">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; OtherNumber, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; Number &gt;::type &gt;::type &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor with a scalar number from the left. See the discussion with the operator with switched arguments for more information about template arguments and the return type. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03555">3555</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a66f75191f4cdcae990782e6f83ffc0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f75191f4cdcae990782e6f83ffc0cf">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Division of a symmetric tensor of general rank by a scalar. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03575">3575</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a1347bf48878316f3405d1693ef12bf38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1347bf48878316f3405d1693ef12bf38">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor of general rank with a scalar from the right. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03594">3594</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ad7f29408c63a14728ce101b02958f4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f29408c63a14728ce101b02958f4f3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor of general rank with a scalar from the left. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03611">3611</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="aeb639496012bec64ed8d5f045e7d9111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb639496012bec64ed8d5f045e7d9111">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Division of a symmetric tensor of general rank by a scalar. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03627">3627</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ab14ac27fc9ab74d4de531698b492d8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14ac27fc9ab74d4de531698b492d8de">&#9670;&nbsp;</a></span>scalar_product() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the scalar product \(\mathbf A: \mathbf B=\sum_{i,j} A_{ij}B_{ij}\) between two tensors \(\mathbf A, \mathbf B\) of rank 2. In the current case where both arguments are symmetric tensors, this is equivalent to calling the expression <code>A*B</code> which uses <code><a class="el" href="classSymmetricTensor.html#aac8604f3b216d416f02e64c91293c09b">SymmetricTensor::operator*()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03645">3645</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a69b3e17cd6ee5502c5a1118ddc751306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b3e17cd6ee5502c5a1118ddc751306">&#9670;&nbsp;</a></span>scalar_product() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the scalar product \(\mathbf A: \mathbf B=\sum_{i,j} A_{ij}B_{ij}\) between two tensors \(\mathbf A, \mathbf B\) of rank 2. We don't use <code>operator*</code> for this operation since the product between two tensors is usually assumed to be the contraction over the last index of the first tensor and the first index of the second tensor. For example, if <code>B</code> is a <a class="el" href="classTensor.html">Tensor</a>, calling <code>A*B</code> (instead of <code>scalar_product(A,B)</code>) provides \((\mathbf A \cdot\mathbf B)_{ij}=\sum_k A_{ik}B_{kj}\). </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03668">3668</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a0b4624be3a3f38c1fad53951437a22e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4624be3a3f38c1fad53951437a22e1">&#9670;&nbsp;</a></span>scalar_product() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the scalar product \(\mathbf A:\mathbf B=\sum_{i,j} A_{ij}B_{ij}\) between two tensors \(\mathbf A, \mathbf B\) of rank 2. We don't use <code>operator*</code> for this operation since the product between two tensors is usually assumed to be the contraction over the last index of the first tensor and the first index of the second tensor. For example, if <code>A</code> is a <a class="el" href="classTensor.html">Tensor</a>, calling <code>A*B</code> (instead of <code>scalar_product(A,B)</code>) provides \((\mathbf A \cdot\mathbf B)_{ij}=\sum_k A_{ik}B_{kj}\). </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03695">3695</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a07b7c41cb9adfb6a07c0e3824cd7cb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b7c41cb9adfb6a07c0e3824cd7cb8b">&#9670;&nbsp;</a></span>double_contract() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as <a class="el" href="classSymmetricTensor.html#aac8604f3b216d416f02e64c91293c09b">SymmetricTensor::operator*()</a>. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general <a class="el" href="classTensor.html">Tensor</a> class. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03717">3717</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a63b8985f18da4c5e5285eb50fe0e9c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b8985f18da4c5e5285eb50fe0e9c99">&#9670;&nbsp;</a></span>double_contract() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 1, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as <a class="el" href="classSymmetricTensor.html#aac8604f3b216d416f02e64c91293c09b">SymmetricTensor::operator*()</a>. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general <a class="el" href="classTensor.html">Tensor</a> class. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03742">3742</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a311b5f5b5f0300cccff82ea0a9f0d287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311b5f5b5f0300cccff82ea0a9f0d287">&#9670;&nbsp;</a></span>double_contract() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as <a class="el" href="classSymmetricTensor.html#aac8604f3b216d416f02e64c91293c09b">SymmetricTensor::operator*()</a>. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general <a class="el" href="classTensor.html">Tensor</a> class. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03767">3767</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a056f3cc5935e09a867c57e7621d3d903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056f3cc5935e09a867c57e7621d3d903">&#9670;&nbsp;</a></span>double_contract() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 2, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as <a class="el" href="classSymmetricTensor.html#aac8604f3b216d416f02e64c91293c09b">SymmetricTensor::operator*()</a>. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general <a class="el" href="classTensor.html">Tensor</a> class. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03797">3797</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ab7030ec2c90ce924cbe6cbe1f43a9bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7030ec2c90ce924cbe6cbe1f43a9bd2">&#9670;&nbsp;</a></span>double_contract() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as <a class="el" href="classSymmetricTensor.html#aac8604f3b216d416f02e64c91293c09b">SymmetricTensor::operator*()</a>. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general <a class="el" href="classTensor.html">Tensor</a> class. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03827">3827</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="afac1f945176731e373edfed09dd3f130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac1f945176731e373edfed09dd3f130">&#9670;&nbsp;</a></span>double_contract() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as <a class="el" href="classSymmetricTensor.html#aac8604f3b216d416f02e64c91293c09b">SymmetricTensor::operator*()</a>. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general <a class="el" href="classTensor.html">Tensor</a> class. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03858">3858</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a1a75bb465d862924f76849afcf6efac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a75bb465d862924f76849afcf6efac4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply a symmetric rank-2 tensor (i.e., a matrix) by a rank-1 tensor (i.e., a vector). The result is a rank-1 tensor (i.e., a vector). </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03882">3882</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a3825730970f8dede85b5698f150d50d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3825730970f8dede85b5698f150d50d8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply a rank-1 tensor (i.e., a vector) by a symmetric rank-2 tensor (i.e., a matrix). The result is a rank-1 tensor (i.e., a vector). </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03901">3901</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a21368b7527565a28d154f98622128db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21368b7527565a28d154f98622128db1">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::tensor_type operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The dot product (single contraction) for tensors: Return a tensor of rank \((\text{rank}_1 + \text{rank}_2 - 2)\) that is the contraction of the last index of a tensor <code>src1</code> of rank <code>rank_1</code> with the first index of a tensor <code>src2</code> of rank <code>rank_2:</code> </p><p class="formulaDsp">
\[ \text{result}_{i_1,\ldots,i_{r1},j_1,\ldots,j_{r2}} = \sum_{k} \text{left}_{i_1,\ldots,i_{r1}, k} \text{right}_{k, j_1,\ldots,j_{r2}} \]
</p>
<dl class="section note"><dt>Note</dt><dd>As one operand is a <a class="el" href="classTensor.html">Tensor</a>, the multiplication operator only performs a contraction over a single pair of indices. This is in contrast to the multiplication operator for <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>, which does the double contraction. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03938">3938</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ada6015ed09fffc0b77fc2f2e38a59cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6015ed09fffc0b77fc2f2e38a59cf2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::tensor_type operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The dot product (single contraction) for tensors: Return a tensor of rank \((\text{rank}_1 + \text{rank}_2 - 2)\) that is the contraction of the last index of a tensor <code>src1</code> of rank <code>rank_1</code> with the first index of a tensor <code>src2</code> of rank <code>rank_2:</code> </p><p class="formulaDsp">
\[ \text{result}_{i_1,\ldots,i_{r1},j_1,\ldots,j_{r2}} = \sum_{k} \text{left}_{i_1,\ldots,i_{r1}, k} \text{right}_{k, j_1,\ldots,j_{r2}} \]
</p>
<dl class="section note"><dt>Note</dt><dd>As one operand is a <a class="el" href="classTensor.html">Tensor</a>, the multiplication operator only performs a contraction over a single pair of indices. This is in contrast to the multiplication operator for <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>, which does the double contraction. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03974">3974</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="aa5cd683fd58a42e393c546cc4abedeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cd683fd58a42e393c546cc4abedeed">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator for symmetric tensors of rank 2. Print the elements consecutively, with a space in between, two spaces between rank 1 subtensors, three between rank 2 and so on. No special amends are made to represents the symmetry in the output, for example by outputting only the unique entries. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03993">3993</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a351a3d35263baee19d033e5c68bc8539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351a3d35263baee19d033e5c68bc8539">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator for symmetric tensors of rank 4. Print the elements consecutively, with a space in between, two spaces between rank 1 subtensors, three between rank 2 and so on. No special amends are made to represents the symmetry in the output, for example by outputting only the unique entries. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l04020">4020</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
