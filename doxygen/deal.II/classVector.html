<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classVector.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Vector&lt; Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Vector&lt; Number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Vectors.html">Vector classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="mapping__q1__eulerian_8h_source.html">deal.II/fe/mapping_q1_eulerian.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Vector&lt; Number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classVector__inherit__graph.svg" width="672" height="206"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af239d5c3249bbed95fbabec1d17b9827"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> = Number</td></tr>
<tr class="separator:af239d5c3249bbed95fbabec1d17b9827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7ef5265cbcae4d30f7e3fcde61a7f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a> = <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:a8f7ef5265cbcae4d30f7e3fcde61a7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1be85b8a5e0669f9034cf8e4421a11"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a> = const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:a0a1be85b8a5e0669f9034cf8e4421a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8006e49918faaffeccd151669d0934"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a> = <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:acb8006e49918faaffeccd151669d0934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d7e7b4278a3fa08a6e5ceec3deb0fb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> = const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td></tr>
<tr class="separator:a31d7e7b4278a3fa08a6e5ceec3deb0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adace73f5502652dce7656ae891ddcc43"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#adace73f5502652dce7656ae891ddcc43">reference</a> = <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td></tr>
<tr class="separator:adace73f5502652dce7656ae891ddcc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7a89720422deb00992571e3e7cf1ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a3b7a89720422deb00992571e3e7cf1ce">const_reference</a> = const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td></tr>
<tr class="separator:a3b7a89720422deb00992571e3e7cf1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5927fb109e04d1d4988dae5c910fc32d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:a5927fb109e04d1d4988dae5c910fc32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02452a5983fd0e8c956ab9278213bd2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; Number &gt;::<a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a></td></tr>
<tr class="separator:a02452a5983fd0e8c956ab9278213bd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af9346dea762db798546a29954227ba84"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af9346dea762db798546a29954227ba84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classint.html">int</a> &gt;::<a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#af9346dea762db798546a29954227ba84">lp_norm</a> (const <a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>) const</td></tr>
<tr class="separator:af9346dea762db798546a29954227ba84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic object handling</div></td></tr>
<tr class="memitem:a5424155269bd22011e9ff796e0c77e69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5424155269bd22011e9ff796e0c77e69">Vector</a> ()</td></tr>
<tr class="separator:a5424155269bd22011e9ff796e0c77e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f3a1869eafb7680e44c3fe5c0f6d39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a55f3a1869eafb7680e44c3fe5c0f6d39">Vector</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a55f3a1869eafb7680e44c3fe5c0f6d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac466762a351e7d9c48c05705730070e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ac466762a351e7d9c48c05705730070e3">Vector</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;v) noexcept=default</td></tr>
<tr class="separator:ac466762a351e7d9c48c05705730070e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9f407c4064e4d83796c5f5149aa1c0"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a9b9f407c4064e4d83796c5f5149aa1c0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a9b9f407c4064e4d83796c5f5149aa1c0">Vector</a> (const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;v)</td></tr>
<tr class="separator:a9b9f407c4064e4d83796c5f5149aa1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb43a268341d826272c4255b46b4b14b"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:afb43a268341d826272c4255b46b4b14b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#afb43a268341d826272c4255b46b4b14b">Vector</a> (const std::initializer_list&lt; OtherNumber &gt; &amp;v)</td></tr>
<tr class="separator:afb43a268341d826272c4255b46b4b14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6478b634eb646ffaa11f6f82b91d92a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a6478b634eb646ffaa11f6f82b91d92a9">Vector</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;v)</td></tr>
<tr class="separator:a6478b634eb646ffaa11f6f82b91d92a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb6efe58ff7587ec88b542fe705bba6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a1bb6efe58ff7587ec88b542fe705bba6">Vector</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;v)</td></tr>
<tr class="separator:a1bb6efe58ff7587ec88b542fe705bba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de475367d8e8440fc32564a9178216f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a2de475367d8e8440fc32564a9178216f">Vector</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> n)</td></tr>
<tr class="separator:a2de475367d8e8440fc32564a9178216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af441b2c23134f8e6e08c833f918888a2"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:af441b2c23134f8e6e08c833f918888a2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#af441b2c23134f8e6e08c833f918888a2">Vector</a> (const InputIterator first, const InputIterator last)</td></tr>
<tr class="separator:af441b2c23134f8e6e08c833f918888a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2ad8f9f15b0fa4b207fe053c81c050"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a9a2ad8f9f15b0fa4b207fe053c81c050">~Vector</a> () override=default</td></tr>
<tr class="separator:a9a2ad8f9f15b0fa4b207fe053c81c050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8740c5534b6dbc31f4f1503a5e2a10a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a8740c5534b6dbc31f4f1503a5e2a10a3">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation=::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964ca9c7dc8036a5632e9ed2a183c3c2812e6">VectorOperation::unknown</a>) const</td></tr>
<tr class="separator:a8740c5534b6dbc31f4f1503a5e2a10a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a4dbef7dd65ef8ad35ae56b57d7c05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> N, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:ac4a4dbef7dd65ef8ad35ae56b57d7c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99737189c3f716cf97cb1aba667ff7b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a99737189c3f716cf97cb1aba667ff7b2">grow_or_shrink</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> N)</td></tr>
<tr class="separator:a99737189c3f716cf97cb1aba667ff7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae296943fe1f9cc5ada1d98761d0a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#abae296943fe1f9cc5ada1d98761d0a19">apply_givens_rotation</a> (const std::array&lt; Number, 3 &gt; &amp;csr, const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i, const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> k)</td></tr>
<tr class="separator:abae296943fe1f9cc5ada1d98761d0a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4724e0d85120bda42159be96c493a702"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a4724e0d85120bda42159be96c493a702"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a4724e0d85120bda42159be96c493a702">reinit</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:a4724e0d85120bda42159be96c493a702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9818314bd7dc4e66849559f429e06151"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a9818314bd7dc4e66849559f429e06151">swap</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a9818314bd7dc4e66849559f429e06151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e835da7c35928e87f425f41ba30c2f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a9e835da7c35928e87f425f41ba30c2f1">operator=</a> (const Number s)</td></tr>
<tr class="separator:a9e835da7c35928e87f425f41ba30c2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd12a193b97aa945190a9ce19a81e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5cd12a193b97aa945190a9ce19a81e18">operator=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a5cd12a193b97aa945190a9ce19a81e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5aba516443a99330968b4dbda6d12ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ae5aba516443a99330968b4dbda6d12ac">operator=</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;v) noexcept=default</td></tr>
<tr class="separator:ae5aba516443a99330968b4dbda6d12ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40c43480e8d2c50d0bb0a13421b7264"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:aa40c43480e8d2c50d0bb0a13421b7264"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#aa40c43480e8d2c50d0bb0a13421b7264">operator=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v)</td></tr>
<tr class="separator:aa40c43480e8d2c50d0bb0a13421b7264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b25ae266b150f897762592e56e5e649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5b25ae266b150f897762592e56e5e649">operator=</a> (const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a5b25ae266b150f897762592e56e5e649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e25dfec5386326daa1e3a7eea06c6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a75e25dfec5386326daa1e3a7eea06c6c">operator=</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;v)</td></tr>
<tr class="separator:a75e25dfec5386326daa1e3a7eea06c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d21d0e4ddcd2e645180487745e56692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4d21d0e4ddcd2e645180487745e56692">operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;v)</td></tr>
<tr class="separator:a4d21d0e4ddcd2e645180487745e56692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a226204eb09ef133f124ad2137c17f4"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a7a226204eb09ef133f124ad2137c17f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a7a226204eb09ef133f124ad2137c17f4">operator==</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v) const</td></tr>
<tr class="separator:a7a226204eb09ef133f124ad2137c17f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082ee1076dfadf9933073247e56e80c7"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a082ee1076dfadf9933073247e56e80c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a082ee1076dfadf9933073247e56e80c7">operator!=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;v) const</td></tr>
<tr class="separator:a082ee1076dfadf9933073247e56e80c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scalar products, norms and related operations</div></td></tr>
<tr class="memitem:a2371854d97a2f717da3170b72e2a58e8"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a2371854d97a2f717da3170b72e2a58e8"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a2371854d97a2f717da3170b72e2a58e8">operator*</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;V) const</td></tr>
<tr class="separator:a2371854d97a2f717da3170b72e2a58e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5a995087a003f81fa5b74513e13677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aad5a995087a003f81fa5b74513e13677">norm_sqr</a> () const</td></tr>
<tr class="separator:aad5a995087a003f81fa5b74513e13677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d47f6cd8a2b9ec62f133e7d303b745"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a33d47f6cd8a2b9ec62f133e7d303b745">mean_value</a> () const</td></tr>
<tr class="separator:a33d47f6cd8a2b9ec62f133e7d303b745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa8fc05dd5a8a8f9560a5de096ebb4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aeaa8fc05dd5a8a8f9560a5de096ebb4e">l1_norm</a> () const</td></tr>
<tr class="separator:aeaa8fc05dd5a8a8f9560a5de096ebb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee1b8309a7a9ecf109c8a7116733ef8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a> () const</td></tr>
<tr class="separator:a8ee1b8309a7a9ecf109c8a7116733ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708e76373444e3b1d12dbee72f5d32b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a708e76373444e3b1d12dbee72f5d32b9">lp_norm</a> (const <a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> p) const</td></tr>
<tr class="separator:a708e76373444e3b1d12dbee72f5d32b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6b7f7afb05aaff7e1ab8f9942b6dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a9f6b7f7afb05aaff7e1ab8f9942b6dae">linfty_norm</a> () const</td></tr>
<tr class="separator:a9f6b7f7afb05aaff7e1ab8f9942b6dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3659971dfc5e53759da2be27d702d078"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a3659971dfc5e53759da2be27d702d078">add_and_dot</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;W)</td></tr>
<tr class="separator:a3659971dfc5e53759da2be27d702d078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data access</div></td></tr>
<tr class="memitem:a46010ca9f43c93431f7ee66817e670ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a46010ca9f43c93431f7ee66817e670ca">data</a> ()</td></tr>
<tr class="separator:a46010ca9f43c93431f7ee66817e670ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24916f568e015cc783628a2c9664c666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a24916f568e015cc783628a2c9664c666">data</a> () const</td></tr>
<tr class="separator:a24916f568e015cc783628a2c9664c666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34b888fe493ef2ed188179de69ad7ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#af34b888fe493ef2ed188179de69ad7ed">begin</a> ()</td></tr>
<tr class="separator:af34b888fe493ef2ed188179de69ad7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710df6df8902b609158fa277f216d146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a710df6df8902b609158fa277f216d146">begin</a> () const</td></tr>
<tr class="separator:a710df6df8902b609158fa277f216d146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2a770cb19d3e5b0b69b08ffc88184f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a7a2a770cb19d3e5b0b69b08ffc88184f">end</a> ()</td></tr>
<tr class="separator:a7a2a770cb19d3e5b0b69b08ffc88184f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9d45917e1f6cd2ba60dc4aef430ce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#abc9d45917e1f6cd2ba60dc4aef430ce9">end</a> () const</td></tr>
<tr class="separator:abc9d45917e1f6cd2ba60dc4aef430ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3af32d65459fad49b43d41ec7e848c3"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ad3af32d65459fad49b43d41ec7e848c3">operator()</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i) const</td></tr>
<tr class="separator:ad3af32d65459fad49b43d41ec7e848c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1268a6b336ee46bd8b2ac746cbe82643"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a1268a6b336ee46bd8b2ac746cbe82643">operator()</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i)</td></tr>
<tr class="separator:a1268a6b336ee46bd8b2ac746cbe82643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c137f6bd56f1fad54a13a8cc46f5b12"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5c137f6bd56f1fad54a13a8cc46f5b12">operator[]</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i) const</td></tr>
<tr class="separator:a5c137f6bd56f1fad54a13a8cc46f5b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7bafc88c457dbc2e7db6a533d35391"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4d7bafc88c457dbc2e7db6a533d35391">operator[]</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> i)</td></tr>
<tr class="separator:a4d7bafc88c457dbc2e7db6a533d35391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae406cc28ed782932504a186ba1c5f9e8"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ae406cc28ed782932504a186ba1c5f9e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#ae406cc28ed782932504a186ba1c5f9e8">extract_subvector_to</a> (const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;indices, std::vector&lt; OtherNumber &gt; &amp;<a class="el" href="classVector.html#ab392612c190ffa0dd4daa4eea36507c4">values</a>) const</td></tr>
<tr class="separator:ae406cc28ed782932504a186ba1c5f9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ae7a1b9cf454549e0925103208cc5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a079ae7a1b9cf454549e0925103208cc5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a079ae7a1b9cf454549e0925103208cc5">extract_subvector_to</a> (ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:a079ae7a1b9cf454549e0925103208cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification of vectors</div></td></tr>
<tr class="memitem:a0b2abb4f2a3a722b30165373ea982a50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a0b2abb4f2a3a722b30165373ea982a50">operator+=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a0b2abb4f2a3a722b30165373ea982a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603f91549c76b084a88e47d8824997ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a603f91549c76b084a88e47d8824997ab">operator-=</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a603f91549c76b084a88e47d8824997ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b0336c485e36c7b4b105dd2a926002"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a10b0336c485e36c7b4b105dd2a926002"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a> (const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;indices, const std::vector&lt; OtherNumber &gt; &amp;<a class="el" href="classVector.html#ab392612c190ffa0dd4daa4eea36507c4">values</a>)</td></tr>
<tr class="separator:a10b0336c485e36c7b4b105dd2a926002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5a1e611de68e9631791cebf3736c86"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:aeb5a1e611de68e9631791cebf3736c86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#aeb5a1e611de68e9631791cebf3736c86">add</a> (const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;indices, const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;<a class="el" href="classVector.html#ab392612c190ffa0dd4daa4eea36507c4">values</a>)</td></tr>
<tr class="separator:aeb5a1e611de68e9631791cebf3736c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1770cabeceaf722763742cdc1e10ba"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:acd1770cabeceaf722763742cdc1e10ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#acd1770cabeceaf722763742cdc1e10ba">add</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> n_elements, const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> *indices, const OtherNumber *<a class="el" href="classVector.html#ab392612c190ffa0dd4daa4eea36507c4">values</a>)</td></tr>
<tr class="separator:acd1770cabeceaf722763742cdc1e10ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b264924f2c8dc130e0be826f40e0da0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a2b264924f2c8dc130e0be826f40e0da0">add</a> (const Number s)</td></tr>
<tr class="separator:a2b264924f2c8dc130e0be826f40e0da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141369afc3169fc80597a7d70fa7b7a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a141369afc3169fc80597a7d70fa7b7a6">add</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V, const Number b, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;W)</td></tr>
<tr class="separator:a141369afc3169fc80597a7d70fa7b7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0643f15938ef8dc4727d90405cf83f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aae0643f15938ef8dc4727d90405cf83f">add</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:aae0643f15938ef8dc4727d90405cf83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7126299241702719e409f59c0ec07d51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a7126299241702719e409f59c0ec07d51">sadd</a> (const Number s, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a7126299241702719e409f59c0ec07d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2bb04de50473779d407149dec7be9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a2d2bb04de50473779d407149dec7be9f">sadd</a> (const Number s, const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a2d2bb04de50473779d407149dec7be9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3e7e9460e7395dd67b95e61dd87d37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4f3e7e9460e7395dd67b95e61dd87d37">operator*=</a> (const Number factor)</td></tr>
<tr class="separator:a4f3e7e9460e7395dd67b95e61dd87d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4263fde23b0a636562ca9751d51b5e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4263fde23b0a636562ca9751d51b5e4a">operator/=</a> (const Number factor)</td></tr>
<tr class="separator:a4263fde23b0a636562ca9751d51b5e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa956ed8a13546e788464672e88057b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aa956ed8a13546e788464672e88057b65">scale</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;scaling_factors)</td></tr>
<tr class="separator:aa956ed8a13546e788464672e88057b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a0a3d0f3f7fb1a7d6196a0def1bacf371">scale</a> (const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;scaling_factors)</td></tr>
<tr class="separator:a0a3d0f3f7fb1a7d6196a0def1bacf371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5feedb1e66657dcc91855748c936879a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a5feedb1e66657dcc91855748c936879a">equ</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;u)</td></tr>
<tr class="separator:a5feedb1e66657dcc91855748c936879a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59511c3b4ce9b3fe8454c8657234a25"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ab59511c3b4ce9b3fe8454c8657234a25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#ab59511c3b4ce9b3fe8454c8657234a25">equ</a> (const Number a, const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;u)</td></tr>
<tr class="separator:ab59511c3b4ce9b3fe8454c8657234a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50dd04b204d8ebf6be467c3ebe2234f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ae50dd04b204d8ebf6be467c3ebe2234f">update_ghost_values</a> () const</td></tr>
<tr class="separator:ae50dd04b204d8ebf6be467c3ebe2234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input and output</div></td></tr>
<tr class="memitem:a4d43302d459c7cb6ae4b5bad13d31507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a4d43302d459c7cb6ae4b5bad13d31507">print</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const</td></tr>
<tr class="separator:a4d43302d459c7cb6ae4b5bad13d31507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f18ed7d00d429247dc3127ba496e42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a31f18ed7d00d429247dc3127ba496e42">block_write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a31f18ed7d00d429247dc3127ba496e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d77409b8591a13d5ee10c2e705593a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a57d77409b8591a13d5ee10c2e705593a">block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a57d77409b8591a13d5ee10c2e705593a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a9c9b9333d11630bf0fc82a7957e0d1c1">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:a9c9b9333d11630bf0fc82a7957e0d1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7a75b54cfee3d921a467f2ca126b54"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a3b7a75b54cfee3d921a467f2ca126b54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a3b7a75b54cfee3d921a467f2ca126b54">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a3b7a75b54cfee3d921a467f2ca126b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6121484e53939ed6ad6024141ee0cd50"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a6121484e53939ed6ad6024141ee0cd50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a6121484e53939ed6ad6024141ee0cd50">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a6121484e53939ed6ad6024141ee0cd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information about the object</div></td></tr>
<tr class="memitem:a21bdbe031534857b865272b4e986b830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a21bdbe031534857b865272b4e986b830">in_local_range</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> global_index) const</td></tr>
<tr class="separator:a21bdbe031534857b865272b4e986b830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6b216c32fbf2cddb2466a8033ad3e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aac6b216c32fbf2cddb2466a8033ad3e6">locally_owned_elements</a> () const</td></tr>
<tr class="separator:aac6b216c32fbf2cddb2466a8033ad3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dcfa5c77bdd426603386c0844149ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a> () const</td></tr>
<tr class="separator:a81dcfa5c77bdd426603386c0844149ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2508c8f07d54ab6a69fba59daf6df2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ad2508c8f07d54ab6a69fba59daf6df2c">locally_owned_size</a> () const</td></tr>
<tr class="separator:ad2508c8f07d54ab6a69fba59daf6df2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72a04de37cc5ba8f0263809a59ec99e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ae72a04de37cc5ba8f0263809a59ec99e">all_zero</a> () const</td></tr>
<tr class="separator:ae72a04de37cc5ba8f0263809a59ec99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e23a22888630c9874cbddf8bcccdf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ad8e23a22888630c9874cbddf8bcccdf5">is_non_negative</a> () const</td></tr>
<tr class="separator:ad8e23a22888630c9874cbddf8bcccdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea73d2cb54e87b69a9b7cdb17ed274df"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aea73d2cb54e87b69a9b7cdb17ed274df">memory_consumption</a> () const</td></tr>
<tr class="separator:aea73d2cb54e87b69a9b7cdb17ed274df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca33f52511daa54531089f98b316458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a0ca33f52511daa54531089f98b316458">has_ghost_elements</a> () const</td></tr>
<tr class="separator:a0ca33f52511daa54531089f98b316458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aab49b815c8f8e5394cd0ed96a687270c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aab49b815c8f8e5394cd0ed96a687270c">maybe_reset_thread_partitioner</a> ()</td></tr>
<tr class="separator:aab49b815c8f8e5394cd0ed96a687270c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b879d09291ecb28bb0ea39d7a181b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a27b879d09291ecb28bb0ea39d7a181b6">do_reinit</a> (const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> new_size, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries, const <a class="el" href="classbool.html">bool</a> reset_partitioner)</td></tr>
<tr class="separator:a27b879d09291ecb28bb0ea39d7a181b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab392612c190ffa0dd4daa4eea36507c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ab392612c190ffa0dd4daa4eea36507c4">values</a></td></tr>
<tr class="separator:ab392612c190ffa0dd4daa4eea36507c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566a66df753d0a75121aa84fa4164d56"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classparallel_1_1internal_1_1TBBPartitioner.html">parallel::internal::TBBPartitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a566a66df753d0a75121aa84fa4164d56">thread_loop_partitioner</a></td></tr>
<tr class="separator:a566a66df753d0a75121aa84fa4164d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a879f896329da9659f538e8dc9d386087"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a879f896329da9659f538e8dc9d386087"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a879f896329da9659f538e8dc9d386087">Vector</a></td></tr>
<tr class="separator:a879f896329da9659f538e8dc9d386087"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a14359ecc2fbab6f70b322e53b1d1fd19"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a14359ecc2fbab6f70b322e53b1d1fd19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a14359ecc2fbab6f70b322e53b1d1fd19">swap</a> (<a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>&lt; Number &gt; &amp;u, <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a14359ecc2fbab6f70b322e53b1d1fd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1885633ec0ef8fc398d6a28a226d6176"><td class="memTemplParams" colspan="2">template&lt;typename Number , typename MemorySpace &gt; </td></tr>
<tr class="memitem:a1885633ec0ef8fc398d6a28a226d6176"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a1885633ec0ef8fc398d6a28a226d6176">swap</a> (<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt; &amp;u, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt; &amp;v)</td></tr>
<tr class="separator:a1885633ec0ef8fc398d6a28a226d6176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e52ed1088f622c49c50dc4bf9638863"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a2e52ed1088f622c49c50dc4bf9638863"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVector.html#a2e52ed1088f622c49c50dc4bf9638863">swap</a> (<a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;u, <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a2e52ed1088f622c49c50dc4bf9638863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77cffd135b29b32a9d77a1bcdef4b95a"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ga77cffd135b29b32a9d77a1bcdef4b95a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga77cffd135b29b32a9d77a1bcdef4b95a">swap</a> (<a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;u, <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ga77cffd135b29b32a9d77a1bcdef4b95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga809f9fb92ff19a343c238f3de52416e2"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:ga809f9fb92ff19a343c238f3de52416e2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Vectors.html#ga809f9fb92ff19a343c238f3de52416e2">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;v)</td></tr>
<tr class="separator:ga809f9fb92ff19a343c238f3de52416e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Number&gt;<br />
class Vector&lt; Number &gt;</h3>

<p>A class that represents a vector of numerical elements. As for the other classes, in the <a class="el" href="group__Vectors.html">Vector classes</a> group, this class has a substantial number of member functions. These include:</p><ul>
<li>functions that initialize the vector or change its size;</li>
<li>functions that compute properties of the vector, such as a variety of norms;</li>
<li>functions that allow reading from or writing to individual elements of the vector;</li>
<li>functions that implement algebraic operations for vectors, such as addition of vectors; and</li>
<li>functions that allow inputting and outputting the data stored by vectors.</li>
</ul>
<p>In contrast to the C++ standard library class <code>std::vector</code>, this class intends to implement not simply an array that allows access to its elements, but indeed a vector that is a member of the mathematical concept of a "vector space" suitable for numerical computations.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for <code>&lt;float&gt;, &lt;double&gt;, &lt;std::complex&lt;float&gt;&gt;, &lt;std::complex&lt;double&gt;&gt;</code>; others can be generated in application programs (see the section on <a class="el" href="Instantiations.html">Template instantiations</a> in the manual). </dd></dl>

<p class="definition">Definition at line <a class="el" href="mapping__q1__eulerian_8h_source.html#l00032">32</a> of file <a class="el" href="mapping__q1__eulerian_8h_source.html">mapping_q1_eulerian.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af239d5c3249bbed95fbabec1d17b9827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af239d5c3249bbed95fbabec1d17b9827">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> =  Number</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare standard types used in all containers. These types parallel those in the <code>C++</code> standard libraries <code>vector&lt;...&gt;</code> class. </p>

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00122">122</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a8f7ef5265cbcae4d30f7e3fcde61a7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7ef5265cbcae4d30f7e3fcde61a7f9">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a> =  <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00123">123</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a0a1be85b8a5e0669f9034cf8e4421a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1be85b8a5e0669f9034cf8e4421a11">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a> =  const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00124">124</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="acb8006e49918faaffeccd151669d0934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8006e49918faaffeccd151669d0934">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a> =  <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00125">125</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a31d7e7b4278a3fa08a6e5ceec3deb0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d7e7b4278a3fa08a6e5ceec3deb0fb">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> =  const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00126">126</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="adace73f5502652dce7656ae891ddcc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adace73f5502652dce7656ae891ddcc43">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#adace73f5502652dce7656ae891ddcc43">reference</a> =  <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00127">127</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a3b7a89720422deb00992571e3e7cf1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7a89720422deb00992571e3e7cf1ce">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a3b7a89720422deb00992571e3e7cf1ce">const_reference</a> =  const <a class="el" href="classVector.html#af239d5c3249bbed95fbabec1d17b9827">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00128">128</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a5927fb109e04d1d4988dae5c910fc32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5927fb109e04d1d4988dae5c910fc32d">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00129">129</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a02452a5983fd0e8c956ab9278213bd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02452a5983fd0e8c956ab9278213bd2c">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;Number&gt;::<a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a type that has holds real-valued numbers with the same precision as the template argument to this class. If the template argument of this class is a real data type, then real_type equals the template argument. If the template argument is a std::complex type then real_type equals the type underlying the complex numbers.</p>
<p>This alias is used to represent the return type of norms. </p>

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l00140">140</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5424155269bd22011e9ff796e0c77e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5424155269bd22011e9ff796e0c77e69">&#9670;&nbsp;</a></span>Vector() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Create a vector of dimension zero. </p>

</div>
</div>
<a id="a55f3a1869eafb7680e44c3fe5c0f6d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f3a1869eafb7680e44c3fe5c0f6d39">&#9670;&nbsp;</a></span>Vector() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Sets the dimension to that of the given vector, and copies all elements.</p>
<p>We would like to make this constructor explicit, but standard containers insist on using it implicitly.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ac466762a351e7d9c48c05705730070e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac466762a351e7d9c48c05705730070e3">&#9670;&nbsp;</a></span>Vector() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Creates a new vector by stealing the internal data of the vector <code>v</code>. </p>

</div>
</div>
<a id="a9b9f407c4064e4d83796c5f5149aa1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9f407c4064e4d83796c5f5149aa1c0">&#9670;&nbsp;</a></span>Vector() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor taking a vector of another data type.</p>
<p>This constructor will fail to compile if there is no conversion path from <code>OtherNumber</code> to <code>Number</code>. You may lose accuracy when copying to a vector with data elements with less accuracy. </p>

</div>
</div>
<a id="afb43a268341d826272c4255b46b4b14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb43a268341d826272c4255b46b4b14b">&#9670;&nbsp;</a></span>Vector() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor taking an object of type <code>std::initializer_list</code>. This constructor can be used to initialize a vector using a brace-enclosed list of numbers, such as in the following example: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> v({1,2,3});</div></div><!-- fragment --><p> This creates a vector of size 3, whose (double precision) elements have values 1.0, 2.0, and 3.0.</p>
<p>This constructor will fail to compile if there is no conversion path from <code>OtherNumber</code> to <code>Number</code>. You may lose accuracy when copying to a vector with data elements with less accuracy. </p>

</div>
</div>
<a id="a6478b634eb646ffaa11f6f82b91d92a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6478b634eb646ffaa11f6f82b91d92a9">&#9670;&nbsp;</a></span>Vector() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Another copy constructor: copy the values from a PETSc vector class. This copy constructor is only available if PETSc was detected during configuration time.</p>
<p>Note that due to the communication model used in MPI, this operation can only succeed if all processes do it at the same time when <code>v</code> is a distributed vector: It is not possible for only one process to obtain a copy of a parallel vector while the other jobs do something else. </p>

</div>
</div>
<a id="a1bb6efe58ff7587ec88b542fe705bba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb6efe58ff7587ec88b542fe705bba6">&#9670;&nbsp;</a></span>Vector() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Another copy constructor: copy the values from a Trilinos wrapper vector. This copy constructor is only available if Trilinos was detected during configuration time.</p>
<dl class="section note"><dt>Note</dt><dd>Due to the communication model used in MPI, this operation can only succeed if all processes that have knowledge of <code>v</code> (i.e. those given by <code>v.get_mpi_communicator()</code>) do it at the same time. This means that unless you use a split MPI communicator then it is not normally possible for only one or a subset of processes to obtain a copy of a parallel vector while the other jobs do something else. In other words, calling this function is a 'collective operation' that needs to be executed by all MPI processes that jointly share <code>v</code>. </dd></dl>

</div>
</div>
<a id="a2de475367d8e8440fc32564a9178216f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de475367d8e8440fc32564a9178216f">&#9670;&nbsp;</a></span>Vector() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Set dimension to <code>n</code> and initialize all elements with zero.</p>
<p>The constructor is made explicit to avoid accidents like this: <code>v=0;</code>. Presumably, the user wants to set every element of the vector to zero, but instead, what happens is this call: <code>v=<a class="el" href="classVector.html">Vector</a>&lt;number&gt;(0);</code>, i.e. the vector is replaced by one of length zero. </p>

</div>
</div>
<a id="af441b2c23134f8e6e08c833f918888a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af441b2c23134f8e6e08c833f918888a2">&#9670;&nbsp;</a></span>Vector() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the vector with a given range of values pointed to by the iterators. This function is there in analogy to the <code>std::vector</code> class. </p>

</div>
</div>
<a id="a9a2ad8f9f15b0fa4b207fe053c81c050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2ad8f9f15b0fa4b207fe053c81c050">&#9670;&nbsp;</a></span>~Vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::~<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor, deallocates memory. Made virtual to allow for derived classes to behave properly. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8740c5534b6dbc31f4f1503a5e2a10a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8740c5534b6dbc31f4f1503a5e2a10a3">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em> = <code>::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964ca9c7dc8036a5632e9ed2a183c3c2812e6">VectorOperation::unknown</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does nothing but exists for compatibility with the parallel vector classes.</p>
<p>For the parallel vector wrapper class, this function compresses the underlying representation of the vector, i.e. flushes the buffers of the vector object if it has any. This function is necessary after writing into a vector element-by-element and before anything else can be done on it.</p>
<p>However, for the implementation of this class, it is immaterial and thus an empty function. </p>

</div>
</div>
<a id="ac4a4dbef7dd65ef8ad35ae56b57d7c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a4dbef7dd65ef8ad35ae56b57d7c05">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the dimension of the vector to <code>N</code>. The reserved memory for this vector remains unchanged if possible, to make things faster; this may waste some memory, so keep this in mind. However, if <code>N==0</code> all memory is freed, i.e. if you want to resize the vector and release the memory not needed, you have to first call <code>reinit(0)</code> and then <code>reinit(N)</code>. This cited behavior is analogous to that of the standard library containers.</p>
<p>If <code>omit_zeroing_entries</code> is false, the vector is filled by zeros. Otherwise, the elements are left an unspecified state.</p>
<p>This function is virtual in order to allow for derived classes to handle memory separately. </p>

</div>
</div>
<a id="a99737189c3f716cf97cb1aba667ff7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99737189c3f716cf97cb1aba667ff7b2">&#9670;&nbsp;</a></span>grow_or_shrink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::grow_or_shrink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but will preserve the values of vector upon resizing. If we new size is bigger, we will have </p><p class="formulaDsp">
\[ \mathbf V \rightarrow \left( \begin{array}{c} \mathbf V \\ \mathbf 0 \end{array} \right) \]
</p>
<p> whereas if the desired size is smaller, then </p><p class="formulaDsp">
\[ \left( \begin{array}{c} \mathbf V_1 \\ \mathbf V_2 \end{array} \right) \rightarrow \mathbf V_1 \]
</p>
 
</div>
</div>
<a id="abae296943fe1f9cc5ada1d98761d0a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae296943fe1f9cc5ada1d98761d0a19">&#9670;&nbsp;</a></span>apply_givens_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::apply_givens_rotation </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; Number, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>csr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply <a href="https://en.wikipedia.org/wiki/Givens_rotation">Givens rotation</a> <code>csr</code> (a triplet of cosine, sine and radius, see <a class="el" href="namespaceUtilities_1_1LinearAlgebra.html#a22a928b284f7a00ad77fc52bca120835">Utilities::LinearAlgebra::givens_rotation()</a>) to the vector in the plane spanned by the <code>i'th</code> and <code>k'th</code> unit vectors. </p>

</div>
</div>
<a id="a4724e0d85120bda42159be96c493a702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4724e0d85120bda42159be96c493a702">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the dimension to that of the vector <code>V</code>. The same applies as for the other <code>reinit</code> function.</p>
<p>The elements of <code>V</code> are not copied, i.e. this function is the same as calling <code>reinit (V.size(), omit_zeroing_entries)</code>. </p>

</div>
</div>
<a id="a9818314bd7dc4e66849559f429e06151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9818314bd7dc4e66849559f429e06151">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the contents of this vector and the other vector <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around.</p>
<p>This function is analogous to the <code>swap</code> function of all C++ standard containers. Also, there is a global function <code>swap(u,v)</code> that simply calls <code>u.swap(v)</code>, again in analogy to standard functions.</p>
<p>This function is virtual in order to allow for derived classes to handle memory separately. </p>

</div>
</div>
<a id="a9e835da7c35928e87f425f41ba30c2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e835da7c35928e87f425f41ba30c2f1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all components of the vector to the given number <code>s</code>.</p>
<p>Since the semantics of assigning a scalar to a vector are not immediately clear, this operator should really only be used if you want to set the entire vector to zero. This allows the intuitive notation <code>v=0</code>. Assigning other values is deprecated and may be disallowed in the future.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a5cd12a193b97aa945190a9ce19a81e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd12a193b97aa945190a9ce19a81e18">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given vector. Resize the present vector if necessary.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ae5aba516443a99330968b4dbda6d12ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5aba516443a99330968b4dbda6d12ac">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move the given vector. This operator replaces the present vector with the internal data of the vector <code>v</code> and resets <code>v</code> to the state it would have after being newly default-constructed. </p>

</div>
</div>
<a id="aa40c43480e8d2c50d0bb0a13421b7264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40c43480e8d2c50d0bb0a13421b7264">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given vector. Resize the present vector if necessary.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a5b25ae266b150f897762592e56e5e649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b25ae266b150f897762592e56e5e649">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator for assigning a block vector to a regular vector. </p>

</div>
</div>
<a id="a75e25dfec5386326daa1e3a7eea06c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e25dfec5386326daa1e3a7eea06c6c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another copy operator: copy the values from a PETSc wrapper vector class. This operator is only available if PETSc was detected during configuration time.</p>
<p>Note that due to the communication model used in MPI, this operation can only succeed if all processes do it at the same time when <code>v</code> is a distributed vector: It is not possible for only one process to obtain a copy of a parallel vector while the other jobs do something else. </p>

</div>
</div>
<a id="a4d21d0e4ddcd2e645180487745e56692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d21d0e4ddcd2e645180487745e56692">&#9670;&nbsp;</a></span>operator=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another copy operator: copy the values from a (sequential or parallel, depending on the underlying compiler) Trilinos wrapper vector class. This operator is only available if Trilinos was detected during configuration time.</p>
<dl class="section note"><dt>Note</dt><dd>Due to the communication model used in MPI, this operation can only succeed if all processes that have knowledge of <code>v</code> (i.e. those given by <code>v.get_mpi_communicator()</code>) do it at the same time. This means that unless you use a split MPI communicator then it is not normally possible for only one or a subset of processes to obtain a copy of a parallel vector while the other jobs do something else. In other words, calling this function is a 'collective operation' that needs to be executed by all MPI processes that jointly share <code>v</code>. </dd></dl>

</div>
</div>
<a id="a7a226204eb09ef133f124ad2137c17f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a226204eb09ef133f124ad2137c17f4">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for equality. This function assumes that the present vector and the one to compare with have the same size already, since comparing vectors of different sizes makes not much sense anyway. </p>

</div>
</div>
<a id="a082ee1076dfadf9933073247e56e80c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082ee1076dfadf9933073247e56e80c7">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for inequality. This function assumes that the present vector and the one to compare with have the same size already, since comparing vectors of different sizes makes not much sense anyway. </p>

</div>
</div>
<a id="a2371854d97a2f717da3170b72e2a58e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2371854d97a2f717da3170b72e2a58e8">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the scalar product of two vectors. The return type is the underlying type of <code>this</code> vector, so the return type and the accuracy with which it the result is computed depend on the order of the arguments of this vector.</p>
<p>For complex vectors, the scalar product is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\).</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="aad5a995087a003f81fa5b74513e13677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5a995087a003f81fa5b74513e13677">&#9670;&nbsp;</a></span>norm_sqr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::norm_sqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the \(l_2\)-norm.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a33d47f6cd8a2b9ec62f133e7d303b745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d47f6cd8a2b9ec62f133e7d303b745">&#9670;&nbsp;</a></span>mean_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mean value of the elements of this vector.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="aeaa8fc05dd5a8a8f9560a5de096ebb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa8fc05dd5a8a8f9560a5de096ebb4e">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_1\)-norm of the vector. The sum of the absolute values.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a8ee1b8309a7a9ecf109c8a7116733ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee1b8309a7a9ecf109c8a7116733ef8">&#9670;&nbsp;</a></span>l2_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_2\)-norm of the vector. The square root of the sum of the squares of the elements.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a708e76373444e3b1d12dbee72f5d32b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708e76373444e3b1d12dbee72f5d32b9">&#9670;&nbsp;</a></span>lp_norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_p\)-norm of the vector. The pth root of the sum of the pth powers of the absolute values of the elements.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a9f6b7f7afb05aaff7e1ab8f9942b6dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6b7f7afb05aaff7e1ab8f9942b6dae">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum absolute value of the elements. </p>

</div>
</div>
<a id="a3659971dfc5e53759da2be27d702d078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3659971dfc5e53759da2be27d702d078">&#9670;&nbsp;</a></span>add_and_dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a combined operation of a vector addition and a subsequent inner product, returning the value of the inner product. In other words, the result of this function is the same as if the user called </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div><div class="line">return_value = *<span class="keyword">this</span> * W;</div></div><!-- fragment --><p>The reason this function exists is that this operation involves less memory transfer than calling the two functions separately. This method only needs to load three vectors, <code>this</code>, <code>V</code>, <code>W</code>, whereas calling separate methods means to load the calling vector <code>this</code> twice. Since most vector operations are memory transfer limited, this reduces the time by 25% (or 50% if <code>W</code> equals <code>this</code>).</p>
<p>For complex-valued vectors, the scalar product in the second step is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\).</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). The algorithm uses pairwise summation with the same order of summation in every run, which gives fully repeatable results from one run to another. </dd></dl>

</div>
</div>
<a id="a46010ca9f43c93431f7ee66817e670ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46010ca9f43c93431f7ee66817e670ca">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a8f7ef5265cbcae4d30f7e3fcde61a7f9">pointer</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the underlying data buffer. </p>

</div>
</div>
<a id="a24916f568e015cc783628a2c9664c666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24916f568e015cc783628a2c9664c666">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a0a1be85b8a5e0669f9034cf8e4421a11">const_pointer</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const pointer to the underlying data buffer. </p>

</div>
</div>
<a id="af34b888fe493ef2ed188179de69ad7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34b888fe493ef2ed188179de69ad7ed">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the <code><a class="el" href="classVector.html">Vector</a></code> class a bit like the <code>vector&lt;&gt;</code> class of the C++ standard library by returning iterators to the start and end of the elements of this vector. </p>

</div>
</div>
<a id="a710df6df8902b609158fa277f216d146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710df6df8902b609158fa277f216d146">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return constant iterator to the start of the vectors. </p>

</div>
</div>
<a id="a7a2a770cb19d3e5b0b69b08ffc88184f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2a770cb19d3e5b0b69b08ffc88184f">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#acb8006e49918faaffeccd151669d0934">iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the element past the end of the array. </p>

</div>
</div>
<a id="abc9d45917e1f6cd2ba60dc4aef430ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9d45917e1f6cd2ba60dc4aef430ce9">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a31d7e7b4278a3fa08a6e5ceec3deb0fb">const_iterator</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant iterator pointing to the element past the end of the array. </p>

</div>
</div>
<a id="ad3af32d65459fad49b43d41ec7e848c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3af32d65459fad49b43d41ec7e848c3">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the value of the <code>ith</code> component. </p>

</div>
</div>
<a id="a1268a6b336ee46bd8b2ac746cbe82643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1268a6b336ee46bd8b2ac746cbe82643">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the <code>ith</code> component as a writeable reference. </p>

</div>
</div>
<a id="a5c137f6bd56f1fad54a13a8cc46f5b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c137f6bd56f1fad54a13a8cc46f5b12">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the value of the <code>ith</code> component.</p>
<p>Exactly the same as operator(). </p>

</div>
</div>
<a id="a4d7bafc88c457dbc2e7db6a533d35391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7bafc88c457dbc2e7db6a533d35391">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the <code>ith</code> component as a writeable reference.</p>
<p>Exactly the same as operator(). </p>

</div>
</div>
<a id="ae406cc28ed782932504a186ba1c5f9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae406cc28ed782932504a186ba1c5f9e8">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. The indices of the elements to be read are stated in the first argument, the corresponding values are returned in the second.</p>
<p>If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; indices.size(); ++i)</div><div class="line">  <a class="code" href="classVector.html#ab392612c190ffa0dd4daa4eea36507c4">values</a>[i] = v[indices[i]];</div></div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>The sizes of the <code>indices</code> and <code>values</code> arrays must be identical. </dd></dl>

</div>
</div>
<a id="a079ae7a1b9cf454549e0925103208cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079ae7a1b9cf454549e0925103208cc5">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>values_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. In contrast to the previous function, this function obtains the indices of the elements by dereferencing all elements of the iterator range provided by the first two arguments, and puts the vector values into memory locations obtained by dereferencing a range of iterators starting at the location pointed to by the third argument.</p>
<p>If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line">ForwardIterator indices_p = indices_begin;</div><div class="line">OutputIterator  values_p  = values_begin;</div><div class="line"><span class="keywordflow">while</span> (indices_p != indices_end)</div><div class="line">  {</div><div class="line">    *values_p = v[*indices_p];</div><div class="line">    ++indices_p;</div><div class="line">    ++values_p;</div><div class="line">  }</div></div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>It must be possible to write into as many memory locations starting at <code>values_begin</code> as there are iterators between <code>indices_begin</code> and <code>indices_end</code>. </dd></dl>

</div>
</div>
<a id="a0b2abb4f2a3a722b30165373ea982a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2abb4f2a3a722b30165373ea982a50">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the given vector to the present one.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a603f91549c76b084a88e47d8824997ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603f91549c76b084a88e47d8824997ab">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract the given vector from the present one.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a10b0336c485e36c7b4b105dd2a926002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b0336c485e36c7b4b105dd2a926002">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A collective add operation: This function adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="aeb5a1e611de68e9631791cebf3736c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5a1e611de68e9631791cebf3736c86">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a second collective add operation. As a difference, this function takes a deal.II vector of values. </p>

</div>
</div>
<a id="acd1770cabeceaf722763742cdc1e10ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1770cabeceaf722763742cdc1e10ba">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take an address where <code>n_elements</code> are stored contiguously and add them into the vector. Handles all cases which are not covered by the other two <code><a class="el" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add()</a></code> functions above. </p>

</div>
</div>
<a id="a2b264924f2c8dc130e0be826f40e0da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b264924f2c8dc130e0be826f40e0da0">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition of <code>s</code> to all components. Note that <code>s</code> is a scalar and not a vector.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a141369afc3169fc80597a7d70fa7b7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141369afc3169fc80597a7d70fa7b7a6">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiple addition of scaled vectors, i.e. <code>*this += a*V+b*W</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="aae0643f15938ef8dc4727d90405cf83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0643f15938ef8dc4727d90405cf83f">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple addition of a multiple of a vector, i.e. <code>*this += a*V</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a7126299241702719e409f59c0ec07d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7126299241702719e409f59c0ec07d51">&#9670;&nbsp;</a></span>sadd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple vector addition, i.e. <code>*this = s*(*this)+V</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a2d2bb04de50473779d407149dec7be9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2bb04de50473779d407149dec7be9f">&#9670;&nbsp;</a></span>sadd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple addition, i.e. <code>*this = s*(*this)+a*V</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a4f3e7e9460e7395dd67b95e61dd87d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3e7e9460e7395dd67b95e61dd87d37">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of the vector by a constant value.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a4263fde23b0a636562ca9751d51b5e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4263fde23b0a636562ca9751d51b5e4a">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;Number&gt;&amp; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of the vector by the inverse of the given value.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="aa956ed8a13546e788464672e88057b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa956ed8a13546e788464672e88057b65">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a0a3d0f3f7fb1a7d6196a0def1bacf371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3d0f3f7fb1a7d6196a0def1bacf371">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix. </p>

</div>
</div>
<a id="a5feedb1e66657dcc91855748c936879a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5feedb1e66657dcc91855748c936879a">&#9670;&nbsp;</a></span>equ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*u</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ab59511c3b4ce9b3fe8454c8657234a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59511c3b4ce9b3fe8454c8657234a25">&#9670;&nbsp;</a></span>equ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*u</code>. </p>

</div>
</div>
<a id="ae50dd04b204d8ebf6be467c3ebe2234f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50dd04b204d8ebf6be467c3ebe2234f">&#9670;&nbsp;</a></span>update_ghost_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::update_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does nothing but exists for compatibility with the <code>parallel</code> vector classes (e.g., <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> class). </p>

</div>
</div>
<a id="a4d43302d459c7cb6ae4b5bad13d31507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d43302d459c7cb6ae4b5bad13d31507">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print to a stream. <code>precision</code> denotes the desired precision with which values shall be printed, <code>scientific</code> whether scientific notation shall be used. If <code>across</code> is <code>true</code> then the vector is printed in a line, while if <code>false</code> then the elements are printed on a separate line each. </p>

</div>
</div>
<a id="a31f18ed7d00d429247dc3127ba496e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f18ed7d00d429247dc3127ba496e42">&#9670;&nbsp;</a></span>block_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::block_write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the vector en bloc to a file. This is done in a binary mode, so the output is neither readable by humans nor (probably) by other computers using a different operating system or number format. </p>

</div>
</div>
<a id="a57d77409b8591a13d5ee10c2e705593a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d77409b8591a13d5ee10c2e705593a">&#9670;&nbsp;</a></span>block_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::block_read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a vector en block from a file. This is done using the inverse operations to the above function, so it is reasonably fast because the bitstream is not interpreted.</p>
<p>The vector is resized if necessary.</p>
<p>A primitive form of error checking is performed which will recognize the bluntest attempts to interpret some data as a vector stored bitwise to a file, but not more. </p>

</div>
</div>
<a id="a9c9b9333d11630bf0fc82a7957e0d1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9b9333d11630bf0fc82a7957e0d1c1">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="a3b7a75b54cfee3d921a467f2ca126b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7a75b54cfee3d921a467f2ca126b54">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="a6121484e53939ed6ad6024141ee0cd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6121484e53939ed6ad6024141ee0cd50">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="a21bdbe031534857b865272b4e986b830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bdbe031534857b865272b4e986b830">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the given global index is in the local range of this processor. Since this is not a distributed vector the method always returns true. </p>

</div>
</div>
<a id="aac6b216c32fbf2cddb2466a8033ad3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6b216c32fbf2cddb2466a8033ad3e6">&#9670;&nbsp;</a></span>locally_owned_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::locally_owned_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an index set that describes which elements of this vector are owned by the current processor. Note that this index set does not include elements this vector may store locally as ghost elements but that are in fact owned by another processor. As a consequence, the index sets returned on different processors if this is a distributed vector will form disjoint sets that add up to the complete index set. Obviously, if a vector is created on only one processor, then the result would satisfy </p><div class="fragment"><div class="line">vec.locally_owned_elements() == <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a> (vec.size())</div></div><!-- fragment --><p>Since the current data type does not support parallel data storage across different processors, the returned index set is the complete index set. </p>

</div>
</div>
<a id="a81dcfa5c77bdd426603386c0844149ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81dcfa5c77bdd426603386c0844149ae">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return dimension of the vector. </p>

</div>
</div>
<a id="ad2508c8f07d54ab6a69fba59daf6df2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2508c8f07d54ab6a69fba59daf6df2c">&#9670;&nbsp;</a></span>locally_owned_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::locally_owned_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return local dimension of the vector. Since this vector does not support distributed data this is always the same value as <a class="el" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function exists for compatibility with <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>. </dd></dl>

</div>
</div>
<a id="ae72a04de37cc5ba8f0263809a59ec99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72a04de37cc5ba8f0263809a59ec99e">&#9670;&nbsp;</a></span>all_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the vector contains only elements with value zero. This function is mainly for internal consistency checks and should seldom be used when not in debug mode since it uses quite some time. </p>

</div>
</div>
<a id="ad8e23a22888630c9874cbddf8bcccdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e23a22888630c9874cbddf8bcccdf5">&#9670;&nbsp;</a></span>is_non_negative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::is_non_negative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <code>true</code> if the vector has no negative entries, i.e. all entries are zero or positive. This function is used, for example, to check whether refinement indicators are really all positive (or zero).</p>
<p>The function obviously only makes sense if the template argument of this class is a real type. If it is a complex type, then an exception is thrown. </p>

</div>
</div>
<a id="aea73d2cb54e87b69a9b7cdb17ed274df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea73d2cb54e87b69a9b7cdb17ed274df">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="a0ca33f52511daa54531089f98b316458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca33f52511daa54531089f98b316458">&#9670;&nbsp;</a></span>has_ghost_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::has_ghost_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function exists for compatibility with the <code>parallel</code> vector classes (e.g., <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> class). Always returns false since this implementation is serial. </p>

</div>
</div>
<a id="aab49b815c8f8e5394cd0ed96a687270c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab49b815c8f8e5394cd0ed96a687270c">&#9670;&nbsp;</a></span>maybe_reset_thread_partitioner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::maybe_reset_thread_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function used at the end of initialization or reinitialization. Resets (if necessary) the loop partitioner to the correct state, based on its current state and the length of the vector. </p>

</div>
</div>
<a id="a27b879d09291ecb28bb0ea39d7a181b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b879d09291ecb28bb0ea39d7a181b6">&#9670;&nbsp;</a></span>do_reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::do_reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a5927fb109e04d1d4988dae5c910fc32d">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>reset_partitioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Actual implementation of the reinit functions. </p>

</div>
</div>
<a id="af9346dea762db798546a29954227ba84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9346dea762db798546a29954227ba84">&#9670;&nbsp;</a></span>lp_norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classint.html">int</a> &gt;::<a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a> <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classint.html">int</a> &gt;::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html#a02452a5983fd0e8c956ab9278213bd2c">real_type</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector_8cc_source.html#l00082">82</a> of file <a class="el" href="vector_8cc_source.html">vector.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a879f896329da9659f538e8dc9d386087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879f896329da9659f538e8dc9d386087">&#9670;&nbsp;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classVector.html">Vector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef for the vector type used</p>
<p>Typedef for the vector type used. </p>

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l01033">1033</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a14359ecc2fbab6f70b322e53b1d1fd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14359ecc2fbab6f70b322e53b1d1fd19">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global function <code>swap</code> which overloads the default implementation of the C++ standard library which uses a temporary object. The function simply exchanges the data of the two vectors. </p>

<p class="definition">Definition at line <a class="el" href="cuda__vector_8h_source.html#l00360">360</a> of file <a class="el" href="cuda__vector_8h_source.html">cuda_vector.h</a>.</p>

</div>
</div>
<a id="a1885633ec0ef8fc398d6a28a226d6176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1885633ec0ef8fc398d6a28a226d6176">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename MemorySpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global function <code>swap</code> which overloads the default implementation of the C++ standard library which uses a temporary object. The function simply exchanges the data of the two vectors. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01853">1853</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a2e52ed1088f622c49c50dc4bf9638863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e52ed1088f622c49c50dc4bf9638863">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global function <code>swap</code> which overloads the default implementation of the C++ standard library which uses a temporary object. The function simply exchanges the data of the two vectors. </p>

<p class="definition">Definition at line <a class="el" href="read__write__vector_8h_source.html#l01087">1087</a> of file <a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab392612c190ffa0dd4daa4eea36507c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab392612c190ffa0dd4daa4eea36507c4">&#9670;&nbsp;</a></span>values</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;Number&gt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of elements owned by this vector. </p>

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l01006">1006</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<a id="a566a66df753d0a75121aa84fa4164d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566a66df753d0a75121aa84fa4164d56">&#9670;&nbsp;</a></span>thread_loop_partitioner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classparallel_1_1internal_1_1TBBPartitioner.html">parallel::internal::TBBPartitioner</a>&gt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt;::thread_loop_partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For parallel loops with TBB, this member variable stores the affinity information of loops. </p>

<p class="definition">Definition at line <a class="el" href="lac_2vector_8h_source.html#l01029">1029</a> of file <a class="el" href="lac_2vector_8h_source.html">vector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/fe/<a class="el" href="mapping__q1__eulerian_8h_source.html">mapping_q1_eulerian.h</a></li>
<li>include/deal.II/lac/<a class="el" href="lac_2vector_8h_source.html">vector.h</a></li>
<li>include/deal.II/lac/<a class="el" href="cuda__vector_8h_source.html">cuda_vector.h</a></li>
<li>include/deal.II/lac/<a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a></li>
<li>include/deal.II/lac/<a class="el" href="read__write__vector_8h_source.html">read_write_vector.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
