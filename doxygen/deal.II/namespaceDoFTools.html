<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceDoFTools.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DoFTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DoFTools Namespace Reference<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDoFTools_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDoFTools_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad31df71a29dd76de9b4ab241b2527160"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> { <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">none</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">always</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a155b9e72113d7008c60732d350bfbb7a">nonzero</a>
 }</td></tr>
<tr class="separator:ad31df71a29dd76de9b4ab241b2527160"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a495fa975b1d6b81f0875bf641f266ce5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a495fa975b1d6b81f0875bf641f266ce5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a495fa975b1d6b81f0875bf641f266ce5">map_dofs_to_support_points</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;support_points, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask)</td></tr>
<tr class="separator:a495fa975b1d6b81f0875bf641f266ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85610f8869cebbc3be41aed240ea4b0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab85610f8869cebbc3be41aed240ea4b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ab85610f8869cebbc3be41aed240ea4b0">map_dofs_to_support_points</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;support_points, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask)</td></tr>
<tr class="separator:ab85610f8869cebbc3be41aed240ea4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730347c0582a281b1fbea079d7906e6a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a730347c0582a281b1fbea079d7906e6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a730347c0582a281b1fbea079d7906e6a">make_periodicity_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id1, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id2, const unsigned <a class="el" href="classint.html">int</a> direction, ::<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, const number periodicity_factor)</td></tr>
<tr class="separator:a730347c0582a281b1fbea079d7906e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DoF耦合 @{</div></td></tr>
<tr class="memitem:a4d7f078a8e828165a7a1ca42570fec22"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4d7f078a8e828165a7a1ca42570fec22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a4d7f078a8e828165a7a1ca42570fec22">convert_couplings_to_blocks</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;table_by_component, std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt;&gt; &amp;tables_by_block)</td></tr>
<tr class="separator:a4d7f078a8e828165a7a1ca42570fec22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c28189ed143dc13fd899c32e62cbcf"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad2c28189ed143dc13fd899c32e62cbcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad2c28189ed143dc13fd899c32e62cbcf">dof_couplings_from_component_couplings</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;component_couplings)</td></tr>
<tr class="separator:ad2c28189ed143dc13fd899c32e62cbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e19a58dc4282f650a822c2f8450c76"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab3e19a58dc4282f650a822c2f8450c76"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ab3e19a58dc4282f650a822c2f8450c76">dof_couplings_from_component_couplings</a> (const <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;component_couplings)</td></tr>
<tr class="separator:ab3e19a58dc4282f650a822c2f8450c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">稀疏模式生成</div></td></tr>
<tr class="memitem:gaf78e864edbfba7e0a7477457bfb96b26"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType , typename number  = double&gt; </td></tr>
<tr class="memitem:gaf78e864edbfba7e0a7477457bfb96b26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">make_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;(), const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:gaf78e864edbfba7e0a7477457bfb96b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20db030885dbb33cb55f9a92d5e7804b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType , typename number  = double&gt; </td></tr>
<tr class="memitem:ga20db030885dbb33cb55f9a92d5e7804b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga20db030885dbb33cb55f9a92d5e7804b">make_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;coupling, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;(), const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:ga20db030885dbb33cb55f9a92d5e7804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0600dbcf28ec5bf58de34e21e1fb4b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga5a0600dbcf28ec5bf58de34e21e1fb4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga5a0600dbcf28ec5bf58de34e21e1fb4b">make_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_row, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_col, SparsityPatternType &amp;sparsity)</td></tr>
<tr class="separator:ga5a0600dbcf28ec5bf58de34e21e1fb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b2627e9bde96b98d4fcf95b629e4fd4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga7b2627e9bde96b98d4fcf95b629e4fd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">make_flux_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern)</td></tr>
<tr class="separator:ga7b2627e9bde96b98d4fcf95b629e4fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee18d72bf380f091c0fe21081e35768d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType , typename number &gt; </td></tr>
<tr class="memitem:gaee18d72bf380f091c0fe21081e35768d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaee18d72bf380f091c0fe21081e35768d">make_flux_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:gaee18d72bf380f091c0fe21081e35768d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebdabb3b4e2882a6ee130c7d8115a0df"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:gaebdabb3b4e2882a6ee130c7d8115a0df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaebdabb3b4e2882a6ee130c7d8115a0df">make_flux_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, SparsityPatternType &amp;sparsity, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;cell_integrals_mask, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;face_integrals_mask, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:gaebdabb3b4e2882a6ee130c7d8115a0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52de1b60d79f9ef5e0c642d7da16f0a8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType , typename number &gt; </td></tr>
<tr class="memitem:ga52de1b60d79f9ef5e0c642d7da16f0a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga52de1b60d79f9ef5e0c642d7da16f0a8">make_flux_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, SparsityPatternType &amp;sparsity, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;couplings, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;face_couplings, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;face_has_flux_coupling=&amp;internal::always_couple_on_faces&lt; dim, spacedim &gt;)</td></tr>
<tr class="separator:ga52de1b60d79f9ef5e0c642d7da16f0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f970db3b035e9813fc7201a2d18d032"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga9f970db3b035e9813fc7201a2d18d032"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga9f970db3b035e9813fc7201a2d18d032">make_boundary_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, SparsityPatternType &amp;sparsity_pattern)</td></tr>
<tr class="separator:ga9f970db3b035e9813fc7201a2d18d032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3dd70fabd9fe942ce3c127e6510024e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType , typename number &gt; </td></tr>
<tr class="memitem:gab3dd70fabd9fe942ce3c127e6510024e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gab3dd70fabd9fe942ce3c127e6510024e">make_boundary_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_ids, const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, SparsityPatternType &amp;sparsity)</td></tr>
<tr class="separator:gab3dd70fabd9fe942ce3c127e6510024e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">悬空节点和其他约束</div></td></tr>
<tr class="memitem:ga3b4ea7dfd313e388d868c4e4aa685799"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga3b4ea7dfd313e388d868c4e4aa685799"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">make_hanging_node_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints)</td></tr>
<tr class="separator:ga3b4ea7dfd313e388d868c4e4aa685799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae648a4b093f351b25eba50e8567b6ef"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:gaae648a4b093f351b25eba50e8567b6ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaae648a4b093f351b25eba50e8567b6ef">compute_intergrid_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;coarse_grid, const unsigned <a class="el" href="classint.html">int</a> coarse_component, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;fine_grid, const unsigned <a class="el" href="classint.html">int</a> fine_component, const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;&gt; &amp;coarse_to_fine_grid_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints)</td></tr>
<tr class="separator:gaae648a4b093f351b25eba50e8567b6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1126ff8e1542c36e6fcc2d825006d7f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:gae1126ff8e1542c36e6fcc2d825006d7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gae1126ff8e1542c36e6fcc2d825006d7f">compute_intergrid_transfer_representation</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;coarse_grid, const unsigned <a class="el" href="classint.html">int</a> coarse_component, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;fine_grid, const unsigned <a class="el" href="classint.html">int</a> fine_component, const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;&gt; &amp;coarse_to_fine_grid_map, std::vector&lt; std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, float &gt;&gt; &amp;transfer_representation)</td></tr>
<tr class="separator:gae1126ff8e1542c36e6fcc2d825006d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">周期性的边界条件</div></td></tr>
<tr class="memitem:a929249499b1e5624728d212e90a8e037"><td class="memTemplParams" colspan="2">template&lt;typename FaceIterator , typename number &gt; </td></tr>
<tr class="memitem:a929249499b1e5624728d212e90a8e037"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">make_periodicity_constraints</a> (const FaceIterator &amp;face_1, const typename <a class="el" href="structidentity.html">identity</a>&lt; FaceIterator &gt;::type &amp;face_2, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;(), const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;first_vector_components=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;(), const number periodicity_factor=1.)</td></tr>
<tr class="separator:a929249499b1e5624728d212e90a8e037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7025d513a21d3d3804f89fdc9c3824a9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a7025d513a21d3d3804f89fdc9c3824a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a7025d513a21d3d3804f89fdc9c3824a9">make_periodicity_constraints</a> (const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::cell_iterator &gt;&gt; &amp;periodic_faces, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;first_vector_components=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;(), const number periodicity_factor=1.)</td></tr>
<tr class="separator:a7025d513a21d3d3804f89fdc9c3824a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918a8dc3733662a03c0113296567564f"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename number &gt; </td></tr>
<tr class="memitem:a918a8dc3733662a03c0113296567564f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a918a8dc3733662a03c0113296567564f">make_periodicity_constraints</a> (const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; typename DoFHandlerType::cell_iterator &gt;&gt; &amp;periodic_faces, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;first_vector_components=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;(), const number periodicity_factor=1.)</td></tr>
<tr class="separator:a918a8dc3733662a03c0113296567564f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa354b2b7e406e68c04c6e6ea07931f2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:aaa354b2b7e406e68c04c6e6ea07931f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#aaa354b2b7e406e68c04c6e6ea07931f2">make_periodicity_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id1, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id2, const unsigned <a class="el" href="classint.html">int</a> direction, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const number periodicity_factor=1.)</td></tr>
<tr class="separator:aaa354b2b7e406e68c04c6e6ea07931f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa423b8e89505de76ca7d2ca0f53faa1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:afa423b8e89505de76ca7d2ca0f53faa1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#afa423b8e89505de76ca7d2ca0f53faa1">make_periodicity_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id, const unsigned <a class="el" href="classint.html">int</a> direction, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const number periodicity_factor=1.)</td></tr>
<tr class="separator:afa423b8e89505de76ca7d2ca0f53faa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">识别具有特殊性质的自由度子集</div></td></tr>
<tr class="memitem:aed6928cb7bdb5a85e8670d6bd5c90e24"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aed6928cb7bdb5a85e8670d6bd5c90e24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#aed6928cb7bdb5a85e8670d6bd5c90e24">extract_hanging_node_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:aed6928cb7bdb5a85e8670d6bd5c90e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f4d01f1c4c6337e4be6f10a81fbdab"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a45f4d01f1c4c6337e4be6f10a81fbdab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">extract_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask)</td></tr>
<tr class="separator:a45f4d01f1c4c6337e4be6f10a81fbdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ec0cf2cf5feceaddf484a5d72126ab"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a63ec0cf2cf5feceaddf484a5d72126ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a63ec0cf2cf5feceaddf484a5d72126ab">extract_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;block_mask)</td></tr>
<tr class="separator:a63ec0cf2cf5feceaddf484a5d72126ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b041e2441000ccd13f2dad06537678"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a86b041e2441000ccd13f2dad06537678"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a86b041e2441000ccd13f2dad06537678">extract_level_dofs</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:a86b041e2441000ccd13f2dad06537678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f492fd7f9f9511f3b5c38dc5d9fefa"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af4f492fd7f9f9511f3b5c38dc5d9fefa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#af4f492fd7f9f9511f3b5c38dc5d9fefa">extract_level_dofs</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;component_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:af4f492fd7f9f9511f3b5c38dc5d9fefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b3c33925c1a1f15de20deda20b4d21"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a06b3c33925c1a1f15de20deda20b4d21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">extract_boundary_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids={})</td></tr>
<tr class="separator:a06b3c33925c1a1f15de20deda20b4d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05eb3b759a0491c2087cf3befcc39cc4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a05eb3b759a0491c2087cf3befcc39cc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a05eb3b759a0491c2087cf3befcc39cc4">extract_boundary_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids={})</td></tr>
<tr class="separator:a05eb3b759a0491c2087cf3befcc39cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905daad9c1cf1db522610811cd555b56"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a905daad9c1cf1db522610811cd555b56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a905daad9c1cf1db522610811cd555b56">extract_boundary_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, <a class="el" href="classIndexSet.html">IndexSet</a> &amp;selected_dofs, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids={})</td></tr>
<tr class="separator:a905daad9c1cf1db522610811cd555b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b97e816b29ecf963370a9d8b349828f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8b97e816b29ecf963370a9d8b349828f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a8b97e816b29ecf963370a9d8b349828f">extract_dofs_with_support_on_boundary</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a8b97e816b29ecf963370a9d8b349828f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097aa54937055733af934542b5c76e35"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number  = double&gt; </td></tr>
<tr class="memitem:a097aa54937055733af934542b5c76e35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a097aa54937055733af934542b5c76e35">extract_dofs_with_support_contained_within</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;)&gt; &amp;predicate, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;())</td></tr>
<tr class="separator:a097aa54937055733af934542b5c76e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc96893388fe1a55c6ae5ae19ba52c6d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:afc96893388fe1a55c6ae5ae19ba52c6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">extract_constant_modes</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, std::vector&lt; std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&gt; &amp;constant_modes)</td></tr>
<tr class="separator:afc96893388fe1a55c6ae5ae19ba52c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">并行化和域分解</div></td></tr>
<tr class="memitem:a6f9a91bfa884faa7a62acc8ff789f40e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a6f9a91bfa884faa7a62acc8ff789f40e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a6f9a91bfa884faa7a62acc8ff789f40e">extract_subdomain_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:a6f9a91bfa884faa7a62acc8ff789f40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f745d25d2397a91dc65b9158b8d77a6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5f745d25d2397a91dc65b9158b8d77a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a5f745d25d2397a91dc65b9158b8d77a6">extract_locally_active_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, <a class="el" href="classIndexSet.html">IndexSet</a> &amp;dof_set)</td></tr>
<tr class="separator:a5f745d25d2397a91dc65b9158b8d77a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af778defeb024f32c1e3500963936639f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af778defeb024f32c1e3500963936639f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#af778defeb024f32c1e3500963936639f">extract_locally_active_level_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, <a class="el" href="classIndexSet.html">IndexSet</a> &amp;dof_set, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</td></tr>
<tr class="separator:af778defeb024f32c1e3500963936639f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad7e0841b9046eaafddc4c617ab1d9d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acad7e0841b9046eaafddc4c617ab1d9d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">extract_locally_relevant_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, <a class="el" href="classIndexSet.html">IndexSet</a> &amp;dof_set)</td></tr>
<tr class="separator:acad7e0841b9046eaafddc4c617ab1d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6378e20da50d4bda1050db19ce43d5ed"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a6378e20da50d4bda1050db19ce43d5ed"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a6378e20da50d4bda1050db19ce43d5ed">locally_owned_dofs_per_component</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;components=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a6378e20da50d4bda1050db19ce43d5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180d7118ecf27d72afbfecb7978c5e09"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a180d7118ecf27d72afbfecb7978c5e09"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a180d7118ecf27d72afbfecb7978c5e09">locally_owned_dofs_per_subdomain</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:a180d7118ecf27d72afbfecb7978c5e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f9b39d216419f46312417550dbdd20"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa2f9b39d216419f46312417550dbdd20"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#aa2f9b39d216419f46312417550dbdd20">locally_relevant_dofs_per_subdomain</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:aa2f9b39d216419f46312417550dbdd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fef7be07cf379b661646e39b9354e17"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1fef7be07cf379b661646e39b9354e17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">extract_locally_relevant_level_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, <a class="el" href="classIndexSet.html">IndexSet</a> &amp;dof_set)</td></tr>
<tr class="separator:a1fef7be07cf379b661646e39b9354e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0429b3117b2ab1f5a1fd0d55de26ad81"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0429b3117b2ab1f5a1fd0d55de26ad81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a0429b3117b2ab1f5a1fd0d55de26ad81">get_subdomain_association</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &amp;subdomain)</td></tr>
<tr class="separator:a0429b3117b2ab1f5a1fd0d55de26ad81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac704c6d311cd0f289d625427e03708ac"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac704c6d311cd0f289d625427e03708ac"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ac704c6d311cd0f289d625427e03708ac">count_dofs_with_subdomain_association</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain)</td></tr>
<tr class="separator:ac704c6d311cd0f289d625427e03708ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38e53eb1c27d67f5e341399356edb55"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad38e53eb1c27d67f5e341399356edb55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad38e53eb1c27d67f5e341399356edb55">count_dofs_with_subdomain_association</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;n_dofs_on_subdomain)</td></tr>
<tr class="separator:ad38e53eb1c27d67f5e341399356edb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a84027251b470f94bcaf1f00e04e722"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0a84027251b470f94bcaf1f00e04e722"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a0a84027251b470f94bcaf1f00e04e722">dof_indices_with_subdomain_association</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain)</td></tr>
<tr class="separator:a0a84027251b470f94bcaf1f00e04e722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">细胞斑块上的DoF指数 为小块的细胞斑块创建包含大量自由度的结构。由此产生的对象可用于RelaxationBlockSOR和相关类，以实现Schwarz预处理和平滑器，其中子域仅由少量单元组成。</div></td></tr>
<tr class="memitem:aba4315ae585ff3b55ba9e6d2c26825a3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aba4315ae585ff3b55ba9e6d2c26825a3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#aba4315ae585ff3b55ba9e6d2c26825a3">get_dofs_on_patch</a> (const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;patch)</td></tr>
<tr class="separator:aba4315ae585ff3b55ba9e6d2c26825a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4d7fd8aba5cbf92b6f24c757cf9f23"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:adf4d7fd8aba5cbf92b6f24c757cf9f23"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#adf4d7fd8aba5cbf92b6f24c757cf9f23">get_dofs_on_patch</a> (const std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;patch)</td></tr>
<tr class="separator:adf4d7fd8aba5cbf92b6f24c757cf9f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ee44769769065bc594d1730477a4b9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a43ee44769769065bc594d1730477a4b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a43ee44769769065bc594d1730477a4b9">make_cell_patches</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs={}, const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> offset=0)</td></tr>
<tr class="separator:a43ee44769769065bc594d1730477a4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7947b3175eb0d455cd2e875df09c9385"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7947b3175eb0d455cd2e875df09c9385"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a7947b3175eb0d455cd2e875df09c9385">make_vertex_patches</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, const <a class="el" href="classbool.html">bool</a> interior_dofs_only, const <a class="el" href="classbool.html">bool</a> boundary_patches=false, const <a class="el" href="classbool.html">bool</a> level_boundary_patches=false, const <a class="el" href="classbool.html">bool</a> single_cell_patches=false, const <a class="el" href="classbool.html">bool</a> invert_vertex_mapping=false)</td></tr>
<tr class="separator:a7947b3175eb0d455cd2e875df09c9385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4300fb13f111c1292fa146b8eb756274"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4300fb13f111c1292fa146b8eb756274"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a4300fb13f111c1292fa146b8eb756274">make_vertex_patches</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;exclude_boundary_dofs=<a class="el" href="classBlockMask.html">BlockMask</a>(), const <a class="el" href="classbool.html">bool</a> boundary_patches=false, const <a class="el" href="classbool.html">bool</a> level_boundary_patches=false, const <a class="el" href="classbool.html">bool</a> single_cell_patches=false, const <a class="el" href="classbool.html">bool</a> invert_vertex_mapping=false)</td></tr>
<tr class="separator:a4300fb13f111c1292fa146b8eb756274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fef09370d666eccd7f811d6df8d748"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a97fef09370d666eccd7f811d6df8d748"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a97fef09370d666eccd7f811d6df8d748">make_child_patches</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, const <a class="el" href="classbool.html">bool</a> interior_dofs_only, const <a class="el" href="classbool.html">bool</a> boundary_dofs=false)</td></tr>
<tr class="separator:a97fef09370d666eccd7f811d6df8d748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab270041c339a188ba4cb050f0c561737"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab270041c339a188ba4cb050f0c561737"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ab270041c339a188ba4cb050f0c561737">make_single_patch</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, const <a class="el" href="classbool.html">bool</a> interior_dofs_only=false)</td></tr>
<tr class="separator:ab270041c339a188ba4cb050f0c561737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">计算自由度和相关函数</div></td></tr>
<tr class="memitem:a956ac5c6aab03ec1c04f1ad955301db9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a956ac5c6aab03ec1c04f1ad955301db9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a956ac5c6aab03ec1c04f1ad955301db9">count_dofs_per_fe_component</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classbool.html">bool</a> vector_valued_once=false, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;target_component={})</td></tr>
<tr class="separator:a956ac5c6aab03ec1c04f1ad955301db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796721b56b3a90e4e3973c7caae4c3d8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a796721b56b3a90e4e3973c7caae4c3d8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">count_dofs_per_fe_block</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;target_block=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;())</td></tr>
<tr class="separator:a796721b56b3a90e4e3973c7caae4c3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e30887d7a90dc1422a9bb9e90ee1a05"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3e30887d7a90dc1422a9bb9e90ee1a05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a3e30887d7a90dc1422a9bb9e90ee1a05">get_active_fe_indices</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;active_fe_indices)</td></tr>
<tr class="separator:a3e30887d7a90dc1422a9bb9e90ee1a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3d202ccd39aea458a476dd0928fb15"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acf3d202ccd39aea458a476dd0928fb15"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#acf3d202ccd39aea458a476dd0928fb15">count_dofs_on_patch</a> (const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;patch)</td></tr>
<tr class="separator:acf3d202ccd39aea458a476dd0928fb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d249bd0c6f5ccb1ea86d498fd7e936"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a99d249bd0c6f5ccb1ea86d498fd7e936"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a99d249bd0c6f5ccb1ea86d498fd7e936">count_dofs_on_patch</a> (const std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;patch)</td></tr>
<tr class="separator:a99d249bd0c6f5ccb1ea86d498fd7e936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">返回不同DoF映射的函数</div></td></tr>
<tr class="memitem:aa243d4c45775077c674ef6800e5ce215"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa243d4c45775077c674ef6800e5ce215"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;mapping)</td></tr>
<tr class="separator:aa243d4c45775077c674ef6800e5ce215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e367cf4d8590470cc136bec082b216b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a2e367cf4d8590470cc136bec082b216b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a2e367cf4d8590470cc136bec082b216b">map_dof_to_boundary_indices</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;mapping)</td></tr>
<tr class="separator:a2e367cf4d8590470cc136bec082b216b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5514e4f59ea659f63953d62ca429eaff"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5514e4f59ea659f63953d62ca429eaff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">map_dofs_to_support_points</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;support_points, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a5514e4f59ea659f63953d62ca429eaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d68b6352f00a6e6c26eb728040284e6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8d68b6352f00a6e6c26eb728040284e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a8d68b6352f00a6e6c26eb728040284e6">map_dofs_to_support_points</a> (const ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;support_points, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a8d68b6352f00a6e6c26eb728040284e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297ef923ee03f234fc09ee4dcdd01140"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a297ef923ee03f234fc09ee4dcdd01140"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a297ef923ee03f234fc09ee4dcdd01140">map_dofs_to_support_points</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;support_points, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a297ef923ee03f234fc09ee4dcdd01140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18da75343daf4b14fa0588445627eab"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad18da75343daf4b14fa0588445627eab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad18da75343daf4b14fa0588445627eab">map_dofs_to_support_points</a> (const ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;support_points, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ad18da75343daf4b14fa0588445627eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3540ceb577e65414bde1b6b14808da2c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class Comp &gt; </td></tr>
<tr class="memitem:a3540ceb577e65414bde1b6b14808da2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a3540ceb577e65414bde1b6b14808da2c">map_support_points_to_dofs</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::map&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, Comp &gt; &amp;point_to_index_map)</td></tr>
<tr class="separator:a3540ceb577e65414bde1b6b14808da2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">杂项</div></td></tr>
<tr class="memitem:a952f50bcd4f8fbb09924626ecc60c605"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a952f50bcd4f8fbb09924626ecc60c605"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a952f50bcd4f8fbb09924626ecc60c605">distribute_cell_to_dof_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;cell_data, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;dof_data, const unsigned <a class="el" href="classint.html">int</a> component=0)</td></tr>
<tr class="separator:a952f50bcd4f8fbb09924626ecc60c605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1747081ebc1846a5b9ca3aa4bc2ee73d"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a1747081ebc1846a5b9ca3aa4bc2ee73d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a1747081ebc1846a5b9ca3aa4bc2ee73d">write_gnuplot_dof_support_point_info</a> (std::ostream &amp;out, const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;support_points)</td></tr>
<tr class="separator:a1747081ebc1846a5b9ca3aa4bc2ee73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06c0301bc74dd4c67a3d1db1000647f3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga06c0301bc74dd4c67a3d1db1000647f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">make_zero_boundary_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_id, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;zero_boundary_constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga06c0301bc74dd4c67a3d1db1000647f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga326f0868782800e5fa9d8e90c9cef135"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga326f0868782800e5fa9d8e90c9cef135"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga326f0868782800e5fa9d8e90c9cef135">make_zero_boundary_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;zero_boundary_constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga326f0868782800e5fa9d8e90c9cef135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">异常情况</div></td></tr>
<tr class="memitem:a51c93a81b48b0879730f2ec459af9783"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a51c93a81b48b0879730f2ec459af9783">DeclException0</a> (ExcFiniteElementsDontMatch)</td></tr>
<tr class="separator:a51c93a81b48b0879730f2ec459af9783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga044394ead1b6613f5eb7a4c0e74b2b5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga044394ead1b6613f5eb7a4c0e74b2b5d">DeclException0</a> (ExcGridNotCoarser)</td></tr>
<tr class="separator:ga044394ead1b6613f5eb7a4c0e74b2b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56ee9b282be48fdc83565a67c64674c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga56ee9b282be48fdc83565a67c64674c7">DeclException0</a> (ExcGridsDontMatch)</td></tr>
<tr class="separator:ga56ee9b282be48fdc83565a67c64674c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga336e8e90cc9cda7a8542ed8f5fc55029"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga336e8e90cc9cda7a8542ed8f5fc55029">DeclException0</a> (ExcNoFESelected)</td></tr>
<tr class="separator:ga336e8e90cc9cda7a8542ed8f5fc55029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bef6c1580e69f6e07a10a719b4af1af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3bef6c1580e69f6e07a10a719b4af1af">DeclException0</a> (ExcInvalidBoundaryIndicator)</td></tr>
<tr class="separator:ga3bef6c1580e69f6e07a10a719b4af1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>这是一个对自由度进行操作的函数集合，并对自由度的数量进行操作。成员函数的文档将提供更多的信息，但是对于存在于多个版本的函数，在这个全局文档中有一些章节说明了一些共同点。 </p><h3>Setting up sparsity patterns</h3>
<p>当组装系统矩阵时，条目通常是 \(a_{ij} = a(\phi_i, \phi_j)\) 的形式，其中 \(a\) 是一个双线性函数，通常是一个积分。因此，当使用稀疏矩阵时，我们只需要为那些 \(a_{ij}\) 保留空间，它们是非零的，这等于说基函数 \(\phi_i\) 和 \(\phi_j\) 的支持有一个非空交点。由于基函数的支持只约束在它们所在的单元或与之相邻的单元上，为了确定稀疏模式，只需在所有单元上循环，并将每个单元上的所有基函数与该单元上的所有其他基函数连接起来。 可能有一些有限元，其单元上的所有基函数并不相互连接，但由于作者不知道有这种情况发生，所以没有使用这种情况。</p>
<h3>DoF numberings on boundaries</h3>
<p>当把函数的轨迹投射到边界或部分边界时，我们需要建立只作用于位于边界上的自由度的矩阵和向量，而不是作用于所有自由度。我们可以通过简单地建立所有内部自由度的条目为零的矩阵来做到这一点，但是这样的矩阵总是有很大的等级缺陷，而且在工作中不是很实用。 在这种情况下，需要的是对边界自由度进行编号，也就是说，我们应该列举所有位于边界的自由度，并排除所有其他（内部）自由度。map_dof_to_boundary_indices()函数正是这样做的：它提供一个矢量，其条目数与整个域上的自由度一样多，每个条目是边界编号中的数字，如果自由度不在边界上，则为 <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a> 。 有了这个向量，对于任何给定的自由度，可以在那些位于边界上的自由度中得到一个唯一的数字；或者，如果你的自由度在域的内部，结果就是 <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a>. 我们需要这个映射，例如，在边界上建立质量矩阵（关于这一点，见make_boundary_sparsity_pattern()函数，下面相应部分，以及MatrixCreator命名空间文档）。 实际上，有两个map_dof_to_boundary_indices()函数，一个产生所有边界自由度的编号，另一个只产生边界部分的编号，即那些边界指标被列在给函数的指标集中的部分。后一种情况是需要的，例如，我们只想投射边界的Dirichlet部分的边界值。然后，你给函数一个边界指标的列表，指的是要进行投影的Dirichlet部分。你想投射的边界部分不需要是连续的；但是，不保证每个边界部分的指数是连续的，也就是说，不同部分的自由度指数可能是混合的。 边界上的自由度但不在指定的边界部分之一的自由度被赋予指数 <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a>, ，就像它们在内部一样。如果没有给出边界指标，或者如果一个单元格的任何面都没有包含在给定列表中的边界指标，那么新指数的向量仅由 <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a>. 组成。 （作为一个附带说明，对于角落的情况。边界上的自由度是什么，这个问题不是那么容易。 它实际上应该是一个自由度，其各自的基础函数在边界上有非零值。至少对于拉格朗日元素来说，这个定义等于说形状函数的离点，或者deal.II所说的支持点，即函数承担其名义值的点（对于拉格朗日元素来说，这是函数值为1的点），是位于边界上。我们并不直接检查这一点，这个标准是通过有限元类给出的信息来定义的：有限元类定义了每个顶点、每条线等的基函数数量，基函数是根据这些信息来编号的；一个基函数被认为是在一个单元的面上（如果该单元在边界上，也就在边界上），根据它属于一个顶点、线等，但不属于单元的内部。有限元使用相同的单元编号，因此我们可以说，如果一个自由度被编号为线上的一个道夫，我们就认为它位于线上。偏离点究竟在哪里，是有限元的秘密（好吧，你可以问，但我们在这里不做），在此不作讨论。</p>
<h3>Setting up sparsity patterns for boundary matrices</h3>
<p>在某些情况下，人们只想处理位于边界上的DoF。例如，一个应用是，如果不是插值非同质的边界值，而是想投影它们。为此，我们需要两样东西：一种识别位于边界上（部分）的节点的方法，以及一种只用边界上的自由度建立矩阵的方法（即更小的矩阵，在其中我们甚至不建立大的零块，因为大多数自由度在域的边界上没有支持）。这些任务中的第一部分由map_dof_to_boundary_indices()函数完成（如上所述）。 第二部分要求我们首先为边界节点之间的耦合建立一个稀疏模式，然后实际建立这个矩阵的组成部分。虽然实际计算这些小边界矩阵的条目在MatrixCreator命名空间中讨论，但创建稀疏模式是由create_boundary_sparsity_pattern()函数完成的。对于它的工作，它需要有一个所有这些自由度的编号，这些自由度在我们感兴趣的边界的那些部分。你可以从map_dof_to_boundary_indices()函数中得到这个数字。然后它建立对应于 \(\int_\Gamma \varphi_{b2d(i)} \varphi_{b2d(j)} dx\) 这样的积分的稀疏模式，其中 \(i\) 和 \(j\) 是矩阵的索引， \(b2d(i)\) 是位于边界上的自由度的全局DoF编号（即 \(b2d\) 是map_dof_to_boundary_indices() 函数返回的映射的逆值）。 </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad31df71a29dd76de9b4ab241b2527160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31df71a29dd76de9b4ab241b2527160">&#9670;&nbsp;</a></span>Coupling</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">DoFTools::Coupling</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>某些<code>make_*_pattern</code>函数在表格中使用的标志，用于描述解的两个分量是否在对应于单元项或面项的双线性形式中耦合。一个使用这些标志的例子在 <a class="el" href="step_46.html">step-46</a> 的介绍中显示。 在下面对各个元素的描述中，请记住这些标志是作为大小为 <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components</a> 乘以 <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components</a> 的表格的元素使用的，其中每个元素表示两个组件是否耦合。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba"></a>none&#160;</td><td class="fielddoc"><p>两个组件不耦合。 </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec"></a>always&#160;</td><td class="fielddoc"><p>两个组件是耦合的。 </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160a155b9e72113d7008c60732d350bfbb7a"></a>nonzero&#160;</td><td class="fielddoc"><p>只有当两个组件的形状函数在一个给定的面上都不为零时，它们才会耦合。这个标志只在计算单元格面上的积分时使用，例如，在 <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern()</a>. 中 使用 Coupling::always 在一般情况下，梯度等发生在面上的积分。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="dof__tools_8h_source.html#l00143">143</a> of file <a class="el" href="dof__tools_8h_source.html">dof_tools.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4d7f078a8e828165a7a1ca42570fec22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7f078a8e828165a7a1ca42570fec22">&#9670;&nbsp;</a></span>convert_couplings_to_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::convert_couplings_to_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>table_by_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tables_by_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将一个耦合表从用户友好的按组件组织映射到按块组织。 返回的向量将被初始化为该函数中的正确长度。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02358">2358</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="ad2c28189ed143dc13fd899c32e62cbcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c28189ed143dc13fd899c32e62cbcf">&#9670;&nbsp;</a></span>dof_couplings_from_component_couplings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; DoFTools::dof_couplings_from_component_couplings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_couplings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个有限元和它的向量分量如何相互耦合的表，计算并返回一个描述各个形状函数如何相互耦合的表。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00708">708</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="ab3e19a58dc4282f650a822c2f8450c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e19a58dc4282f650a822c2f8450c76">&#9670;&nbsp;</a></span>dof_couplings_from_component_couplings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &gt; DoFTools::dof_couplings_from_component_couplings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_couplings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述有限元集合的函数相同，返回一个表格的集合。 该函数目前对 DoFTools::Couplings::nonzero 的处理与 DoFTools::Couplings::always 相同。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00749">749</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="a929249499b1e5624728d212e90a8e037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929249499b1e5624728d212e90a8e037">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceIterator , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; FaceIterator &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>face_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_vector_components</em> = <code>std::vector&lt;unsigned&#160;<a class="el" href="classint.html">int</a>&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>periodicity_factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将周期性边界条件引起的（代数）约束插入AffineConstraints对象 <code>constraints</code>. 给定一对不一定活动的边界面 <code>face_1</code> 和 <code>face_2，这个函数将与</code> <code>face_1</code> 描述的边界相关的所有DoF约束到 <code>face_2</code>. 描述的边界的各自DoF 更确切地说。 如果 <code>face_1</code> 和 <code>face_2</code> 都是活动面，它将 <code>面_1的DoFs添加到</code> <code>constraints</code> 的约束DoFs列表中，并添加条目将它们约束到 <code>面_2的相应DoFs值。这发生在一个纯粹的代数层面上，意味着</code> <code>face_1</code> 上具有（局部面）索引<code>i</code>的全局DoF被约束到 <code>face_2</code> 上具有（局部面）索引<code>i</code>的DoF（可能被纠正方向，见下文）。 否则，如果 <code>face_1</code> 和 <code>face_2</code> 不是活动面，这个函数就会递归地在 <code>face_1</code> 和 <code>face_2</code>. 的子代上循环，如果两个面中只有一个是活动的，那么我们就会递归地迭代非活动面的子代，并确保精炼面的解函数与非精炼面的解函数相等，这与我们在不同的精炼单元聚集的地方执行悬挂节点约束一样的方式。然而，与悬挂节点不同的是，我们并不强制要求域的两边只能有一个细化级别的差异，你希望是周期性的）。 这个程序只约束那些还没有被约束的DoF。如果这个例程遇到一个已经被约束的DoF（例如被Dirichlet边界条件约束），约束的旧设置（条目被约束的DoF，不均匀性）被保留，什么也不会发生。 <code>component_mask</code> 中的标志（见 <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ）表示有限元空间的哪些部分应受到周期性边界条件的约束。如果它与默认值相同，则所有分量都受到约束。如果它与默认值不同，则假定条目数等于有限元的分量数。这可以用来强制执行方程组中只有一个变量的周期性。 <code>face_orientation</code>, <code>face_flip</code> 和 <code>face_rotation</code> 描述了在匹配和约束DoF之前应该应用到 <code>face_1</code> 的方向。这与给定面在各自单元中的实际方向无关（对于边界面总是默认的），而是你想看到周期性被强制执行的方式。例如，通过使用这些标志，你可以执行 \(u(0,y)=u(1,1-y)\) 那种条件（即莫比乌斯带），或者在三维中执行扭曲的环。更确切地说，这些标志是以如下方式匹配局部面的DoF指数。 在2d中。<code>face_orientation</code>必须总是<code>true</code>，<code>face_rotation</code>总是<code>false</code>，face_flip具有<code>line_flip</code>的意义；这意味着，例如对于<code>Q1</code>。 </p><div class="fragment"><div class="line">face_orientation = <span class="keyword">true</span>, face_flip = <span class="keyword">false</span>, face_rotation = <span class="keyword">false</span>:</div><div class="line"></div><div class="line">  face1:           face2:</div><div class="line"></div><div class="line">  1                1</div><div class="line">  |        &lt;--&gt;    |</div><div class="line">  0                0</div><div class="line"></div><div class="line">  Resulting constraints: 0 &lt;-&gt; 0, 1 &lt;-&gt; 1</div><div class="line"></div><div class="line">  (Numbers denote local face DoF indices.)</div><div class="line"></div><div class="line"></div><div class="line">face_orientation = <span class="keyword">true</span>, face_flip = <span class="keyword">true</span>, face_rotation = <span class="keyword">false</span>:</div><div class="line"></div><div class="line">  face1:           face2:</div><div class="line"></div><div class="line">  0                1</div><div class="line">  |        &lt;--&gt;    |</div><div class="line">  1                0</div><div class="line"></div><div class="line">  Resulting constraints: 1 &lt;-&gt; 0, 0 &lt;-&gt; 1</div></div><!-- fragment --><p> 同样地，对于Q1在3D中的情况也是如此。 </p><div class="fragment"><div class="line">face_orientation = <span class="keyword">true</span>, face_flip = <span class="keyword">false</span>, face_rotation = <span class="keyword">false</span>:</div><div class="line"></div><div class="line">  face1:           face2:</div><div class="line"></div><div class="line">  2</div><div class="line"></div><div class="line">- 3            2</div><div class="line"></div><div class="line">- 3</div><div class="line">  |   |    &lt;--&gt;    |   |</div><div class="line">  0</div><div class="line"></div><div class="line">- 1            0</div><div class="line"></div><div class="line">- 1</div><div class="line"></div><div class="line">  Resulting constraints: 0 &lt;-&gt; 0, 1 &lt;-&gt; 1, 2 &lt;-&gt; 2, 3 &lt;-&gt; 3</div><div class="line"></div><div class="line">  (Numbers denote local face DoF indices.)</div><div class="line"></div><div class="line"></div><div class="line">face_orientation = <span class="keyword">false</span>, face_flip = <span class="keyword">false</span>, face_rotation = <span class="keyword">false</span>:</div><div class="line"></div><div class="line">  face1:           face2:</div><div class="line"></div><div class="line">  1</div><div class="line"></div><div class="line">- 3            2</div><div class="line"></div><div class="line">- 3</div><div class="line">  |   |    &lt;--&gt;    |   |</div><div class="line">  0</div><div class="line"></div><div class="line">- 2            0</div><div class="line"></div><div class="line">- 1</div><div class="line"></div><div class="line">  Resulting constraints: 0 &lt;-&gt; 0, 2 &lt;-&gt; 1, 1 &lt;-&gt; 2, 3 &lt;-&gt; 3</div><div class="line"></div><div class="line"></div><div class="line">face_orientation = <span class="keyword">true</span>, face_flip = <span class="keyword">true</span>, face_rotation = <span class="keyword">false</span>:</div><div class="line"></div><div class="line">  face1:           face2:</div><div class="line"></div><div class="line">  1</div><div class="line"></div><div class="line">- 0            2</div><div class="line"></div><div class="line">- 3</div><div class="line">  |   |    &lt;--&gt;    |   |</div><div class="line">  3</div><div class="line"></div><div class="line">- 2            0</div><div class="line"></div><div class="line">- 1</div><div class="line"></div><div class="line">  Resulting constraints: 3 &lt;-&gt; 0, 2 &lt;-&gt; 1, 1 &lt;-&gt; 2, 0 &lt;-&gt; 3</div><div class="line"></div><div class="line"></div><div class="line">face_orientation = <span class="keyword">true</span>, face_flip = <span class="keyword">false</span>, face_rotation = <span class="keyword">true</span></div><div class="line"></div><div class="line">  face1:           face2:</div><div class="line"></div><div class="line">  0</div><div class="line"></div><div class="line">- 2            2</div><div class="line"></div><div class="line">- 3</div><div class="line">  |   |    &lt;--&gt;    |   |</div><div class="line">  1</div><div class="line"></div><div class="line">- 3            0</div><div class="line"></div><div class="line">- 1</div><div class="line"></div><div class="line">  Resulting constraints: 1 &lt;-&gt; 0, 3 &lt;-&gt; 1, 0 &lt;-&gt; 2, 2 &lt;-&gt; 3</div><div class="line"></div><div class="line">and any combination of that...</div></div><!-- fragment --><p> 可以指定一个矩阵 <code>matrix</code> 和一个 std::vector <code>first_vector_components，描述在约束到</code> <code>face_2</code>. 的DoF之前， <code>face_1的DoF应该如何被修改，这里有两种声明。如果</code> std::vector <code>first_vector_components是非空的，该矩阵被解释为一个</code> <code>dim</code> \(\times\) <code>dim</code> 旋转矩阵，它被应用于FESystem的 <code>first_vector_components</code> 中列出的所有矢量值块。如果 <code>first_vector_components为空，该矩阵将被解释为大小为no_face_dofs</code> \(\times\) no_face_dofs的插值矩阵。 这个函数确保身份约束不会在 <code>constraints</code>. <code>periodicity_factor</code> 中产生循环，可以用来实现 \(\psi(\mathbf{r})=e^{-i\mathbf{k}\cdot\mathbf{r}}u(\mathbf{r})\) 形式的布洛赫周期条件（又称相移周期条件），其中 \(u\) 是与晶格相同的周期性， \(\mathbf{k}\) 是波矢，见[<a href="https://en.wikipedia.org/wiki/Bloch_wave">https://en.wikipedia.org/wiki/Bloch_wave</a>]（https://en.wikipedia.org/wiki/Bloch_wave）。 在 <code>face_2</code> 处的解等于 <code>face_1</code> 乘以 <code>periodicity_factor</code>. 处的解。例如，如果 <code>face_1</code> 处的解是 \(\psi(0)\) ， \(\mathbf{d}\) 是 <code>face_2</code>, 上的相应点，那么 <code>face_2</code> 处的解应该是 \(\psi(d) = \psi(0)e^{-i \mathbf{k}\cdot \mathbf{d}}\) 。这个条件可以用 \(\mathrm{periodicity\_factor}=e^{-i \mathbf{k}\cdot \mathbf{d}}\) 来实现。 详细信息可参见 <a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">关于周期性边界条件的词汇条目</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l02288">2288</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
<a id="a7025d513a21d3d3804f89fdc9c3824a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7025d513a21d3d3804f89fdc9c3824a9">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>periodic_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_vector_components</em> = <code>std::vector&lt;unsigned&#160;<a class="el" href="classint.html">int</a>&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>periodicity_factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将周期性边界条件引起的（代数）约束插入AffineConstraints对象 <code>constraints</code>. 这是上述make_periodicity_constraints()的低级变量的主要高级接口。它接受一个 std::vector <code>periodic_faces</code> 作为参数，并在每个条目上应用上面的make_periodicity_constraints()。 <code>periodic_faces</code> 可以通过 <a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">GridTools::collect_periodic_faces</a>. 创建。 </p><dl class="section note"><dt>Note</dt><dd>对于建立在 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 对象上的DoFHandler对象， <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#aa7b797070e5443a18f03a4a7f0267453">parallel::distributed::Triangulation::add_periodicity</a> 在调用此函数之前必须被调用。 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">关于周期性边界条件的词汇条目 </a> 和 <a class="el" href="step_45.html">step-45</a> 的进一步信息。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l02532">2532</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
<a id="a918a8dc3733662a03c0113296567564f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918a8dc3733662a03c0113296567564f">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; typename DoFHandlerType::cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>periodic_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_vector_components</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>periodicity_factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>使用以dim和spacedim为模板参数的函数。</dd></dl>

</div>
</div>
<a id="aaa354b2b7e406e68c04c6e6ea07931f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa354b2b7e406e68c04c6e6ea07931f2">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>periodicity_factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将周期性边界条件引起的（代数）约束插入AffineConstraints <code>constraints</code>. 这个函数作为make_periodicity_constraints()函数的一个高级接口。 定义一个 "第一 "边界为所有边界面，其边界ID为 <code>b_id1，一个</code> "第二 "边界由所有属于 <code>b_id2的面组成。</code> 这个函数试图在orthogonal_equality()的帮助下将所有属于第一条边界的面与属于第二条边界的面相匹配。更确切地说，坐标只在 <code>direction</code> 部分不同的面被识别。 如果这个匹配是成功的，它将所有与 "第一
"边界相关的DoFs约束到 "第二
"边界的相应DoFs，并尊重两个面的相对方向。 </p><dl class="section note"><dt>Note</dt><dd>这个函数是一个方便的封装器。它在内部调用 <a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">GridTools::collect_periodic_faces()</a> 的参数，并将输出结果反馈给上述make_periodicity_constraints()变量。如果你需要更多的功能，直接使用 <a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">GridTools::collect_periodic_faces()</a> 。 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">关于周期性边界条件的词汇条目</a> ，以获得更多信息。 </dd></dl>

</div>
</div>
<a id="afa423b8e89505de76ca7d2ca0f53faa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa423b8e89505de76ca7d2ca0f53faa1">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>periodicity_factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>这个版本的make_periodicity_constraints将不会在单元格不在 <a class="el" href="DEALGlossary.html#GlossFaceOrientation">标准方向 </a> 的网格上工作。 </dd>
<dd>
这个函数是一个方便的封装器。它在内部调用 <a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">GridTools::collect_periodic_faces()</a> 中提供的参数，并将输出结果反馈给上述make_periodicity_constraints()变量。如果你需要更多的功能，请直接使用 <a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">GridTools::collect_periodic_faces()</a> 。 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">关于周期性边界条件的词汇条目</a> ，以获得更多信息。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l02606">2606</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
<a id="aed6928cb7bdb5a85e8670d6bd5c90e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6928cb7bdb5a85e8670d6bd5c90e24">&#9670;&nbsp;</a></span>extract_hanging_node_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::extract_hanging_node_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个IndexSet，描述所有将被接口约束的自由度，即所有悬挂节点。 在 <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> 或 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 的情况下，只考虑本地相关的道夫。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01019">1019</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a45f4d01f1c4c6337e4be6f10a81fbdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f4d01f1c4c6337e4be6f10a81fbdab">&#9670;&nbsp;</a></span>extract_dofs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::extract_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提取属于矢量值有限元的某些矢量分量的自由度的（本地拥有的）指数。 <code>component_mask</code> 定义了要从DoFHandler <code>dof</code>. 中提取FES系统或矢量值元素的哪些组件或块，然后输出对象中的条目对应于属于这些组件的自由度。 如果所考虑的有限元不是原始的，即它的一些或全部形状函数在一个以上的矢量分量中是非零的（例如，对于FE_Nedelec或FE_RaviartThomas元素来说，这一点是成立的），那么形状函数不能与单个矢量分量相关联。 在这种情况下，如果 <em> 这个元素的一个 </em> 形状向量分量在 <code>component_mask</code> 中被标记（见 <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ），那么这相当于选择 <em> 与这个非原始基础元素对应的所有 </em> 向量分量。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>其列举的自由度将被此函数过滤的DoFHandler。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask</td><td>一个说明你要选择哪些组件的掩码。该掩码的大小必须与 <code>dof_handler</code>. 所使用的FiniteElement中的构件数量相匹配。更多信息请参见 <a class="el" href="DEALGlossary.html#GlossComponentMask">构件掩码的词汇表条目</a> 。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个IndexSet对象，它将确切地包含那些(i)对应于上述掩码所选择的自由度的条目，以及(ii)是本地拥有的条目。索引集的大小等于全局自由度的数量。请注意，产生的对象总是 <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> 返回的一个子集。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00393">393</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a63ec0cf2cf5feceaddf484a5d72126ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ec0cf2cf5feceaddf484a5d72126ab">&#9670;&nbsp;</a></span>extract_dofs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::extract_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>block_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数等同于上面的 <a class="el" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs()</a> 函数，除了不是根据组件（见 <a class="el" href="DEALGlossary.html#GlossComponent">GlossComponent</a> ）而是根据它们是否是特定块的一部分（见 GlossBlock ）来选择提取哪些自由度。 因此，第二个参数不是一个ComponentMask，而是一个BlockMask对象。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>其列举的自由度将被这个函数过滤的DoFHandler。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_mask</td><td>一个说明你想选择哪些块的掩码。该掩码的大小必须与 <code>dof_handler</code>. 所使用的FiniteElement中的块数相匹配。更多信息请参见 <a class="el" href="DEALGlossary.html#GlossBlockMask">关于块掩码的词汇表条目</a> 。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个IndexSet对象，它将确切地包含那些(i)对应于由上述掩码选择的自由度的条目，以及(ii)本地拥有的条目。索引集的大小等于全局自由度的数量。请注意，产生的对象总是 <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> 返回的一个子集。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00434">434</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a86b041e2441000ccd13f2dad06537678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b041e2441000ccd13f2dad06537678">&#9670;&nbsp;</a></span>extract_level_dofs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_level_dofs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于多网格自由度编号的一个层次，做与相应的extract_dofs()函数相同的事情。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00480">480</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="af4f492fd7f9f9511f3b5c38dc5d9fefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f492fd7f9f9511f3b5c38dc5d9fefa">&#9670;&nbsp;</a></span>extract_level_dofs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_level_dofs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对一个多网格DoF编号的一个层次，做与相应的extract_dofs()函数相同的事情。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00537">537</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a06b3c33925c1a1f15de20deda20b4d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b3c33925c1a1f15de20deda20b4d21">&#9670;&nbsp;</a></span>extract_boundary_dofs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_boundary_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提取所有在边界的自由度，并属于解决方案的指定组件。该函数在最后一个非缺省值参数中返回其结果，如果一个自由度在边界并属于所选分量之一，该参数包含 <code>true</code> ，否则包含 <code>false</code> 。 通过指定 <code>boundary_ids</code> 变量，你可以选择自由度所在的面必须有哪些边界指标才能被提取出来。如果它是一个空列表，那么所有的边界指标都被接受。 <code>component_mask</code> 的大小（见 <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ）应等于 <code>自由度所使用的有限元中的组件数。</code> <code>selected_dofs</code> 的大小应等于<code>dof_handler.n_dofs()</code>。这个数组以前的内容会被覆盖掉。 使用通常的惯例，如果一个形状函数在一个以上的分量中是非零的（即它是非正则的），那么就使用分量掩码中对应于第一个非零分量的元素。 掩码中对应于后面分量的元素被忽略。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>这个函数对建立在 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 对象上的DoFHandler对象不起作用。原因是输出参数 <code>selected_dofs</code> 的长度必须等于<em>all</em>全局自由度。因此，这不能扩展到非常大的问题，这也是该函数被废弃的原因。如果你需要这个函数的功能来进行平行三角计算，那么你需要使用另一个 <a class="el" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs()</a> 函数，它通过IndexSet对象返回信息。</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>描述哪个自由度在哪个单元上的对象。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask</td><td>表示应考虑的有限元的矢量分量的掩码（也见 <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ）。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selected_dofs</td><td>一个被返回的布尔运算的向量，对于这个向量，如果相应的索引是位于边界上的自由度（并且对应于被选择的向量分量和边界指标，取决于 <code>component_mask</code> 和 <code>boundary_ids参数的值），则该元素将是</code> <code>true</code> 。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_ids</td><td>如果为空，该函数提取边界所有部分的自由度指数。如果它是一个非空的列表，那么这个函数只考虑具有这个参数中所列边界指标的边界面。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">关于边界指标的词汇条目</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00553">553</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a05eb3b759a0491c2087cf3befcc39cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05eb3b759a0491c2087cf3befcc39cc4">&#9670;&nbsp;</a></span>extract_boundary_dofs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::extract_boundary_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提取在边界上的所有自由度，并属于解决方案的指定组件。该函数以IndexSet的形式返回其结果，IndexSet包含与这些选定的自由度相对应的条目，也就是说，这些自由度位于边界并属于选定的成分之一。 通过指定 <code>boundary_ids</code> 变量，你可以选择要提取的自由度所在的面必须有哪些边界指标。如果它是一个空列表（默认），那么所有的边界指标都被接受。 这个功能在 <a class="el" href="step_11.html">step-11</a> 和 <a class="el" href="step_15.html">step-15</a> 中使用，例如。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00594">594</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a905daad9c1cf1db522610811cd555b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905daad9c1cf1db522610811cd555b56">&#9670;&nbsp;</a></span>extract_boundary_dofs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_boundary_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与前一个函数相同，只是它通过第三个参数返回其信息。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>用前面的函数代替。</dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00580">580</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a8b97e816b29ecf963370a9d8b349828f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b97e816b29ecf963370a9d8b349828f">&#9670;&nbsp;</a></span>extract_dofs_with_support_on_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_dofs_with_support_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数与extract_boundary_dofs()函数类似，但它提取那些形状函数在所选边界的至少一部分为非零的自由度。对于连续元素，这正是自由度定义在边界面上的形状函数的集合。另一方面，如果使用的有限元是不连续元，所有的自由度都定义在单元内部，因此没有一个是边界自由度。 然而，其中有几个自由度的形状函数在边界上是不为零的。因此，这个函数提取了所有那些 <a class="el" href="classFiniteElement.html#ab275cbead21bb11b1208222b6d662357">FiniteElement::has_support_on_face</a> 函数说它在所选边界部分的任何面上都是非零的。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">关于边界指标的词汇条目</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00722">722</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a097aa54937055733af934542b5c76e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097aa54937055733af934542b5c76e35">&#9670;&nbsp;</a></span>extract_dofs_with_support_contained_within()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::extract_dofs_with_support_contained_within </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;number&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提取形状函数的所有索引，使其支持完全包含在 <code>predicate</code> 为 <code>true</code> 的单元格中。 结果以IndexSet的形式返回。 考虑以下的FE空间，其中谓词对域的左半部的所有单元格返回 <code>true</code> 。 </p><div class="image">
<img src="extract_dofs_with_support_contained_within.png" alt="extract_dofs_with_support_contained_within.png"/>
<div class="caption">
这个函数将返回这些单元格上的所有DoF指数的联合，减去DoF 11, 13, 2和0；结果将是[9,10], 12, [14,38]。在上图中，返回的DoFs被红线隔开，从本质上讲，这个函数回答的问题如下。 给定一个带有相关DoFs的子域，这些DoFs中允许非零的最大子集是什么，以便在调用 AffineConstraints::distribute() 后，得到的解向量将只在给定的域内有支持。这里， <code>constraints</code> 是包含悬挂节点约束的AffineConstraints容器。 在 parallel::distributed::Triangulation 的情况下， <code>predicate</code> 将只为本地拥有的和幽灵单元调用。产生的索引集可能包含与本地拥有的或幽灵单元相关的DoF，但不为当前MPI核所拥有。</div></div>
 
<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00804">804</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="afc96893388fe1a55c6ae5ae19ba52c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc96893388fe1a55c6ae5ae19ba52c6d">&#9670;&nbsp;</a></span>extract_constant_modes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_constant_modes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>constant_modes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提取一个向量，代表DoFHandler对<code>component_mask</code>（见 <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ）选择的组件的恒定模式。 离散化的恒定模式是所选分量上的拉普拉斯算子的无效空间，并应用诺伊曼边界条件。在使用类 <a class="el" href="classTrilinosWrappers_1_1PreconditionAMG.html">TrilinosWrappers::PreconditionAMG</a>. 时，无效空间是获得良好的AMG预处理的必要成分，因为ML AMG包只对各自矩阵的代数属性工作，它没有机会检测矩阵是来自标量还是矢量值问题。 然而，一个近乎无效的空间正好提供了所需的关于矩阵中矢量分量位置的信息。空空间（或者说，常数模式）是由给定的DoFHandler底层的有限元提供的，对于大多数元素，空空间将由与<code>component_mask</code>（见 <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ）中的真实参数一样多的向量组成，每个向量在一个向量分量中为1，在所有其他分量中为0。 然而，例如FE_DGP的常数函数的表示是不同的（每个元素上的第一个分量为一，其他所有分量为零），有些标量元素甚至可能有两个常数模式（FE_Q_DG0）。因此，我们将这个对象存储在一个向量中，其中外向量包含DoFHandler上的实际恒定模式的集合。每个内向量有多少个分量，就有多少个所选分量中的（本地拥有的）自由度。请注意，任何与这个无效空间相关的矩阵都必须使用相同的<code>component_mask</code>参数来构建，因为自由度的编号是相对于所选的道夫而言的，而不是相对于所有道夫而言的。 这个程序的主要原因是使用AMG预处理程序的空空间。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01227">1227</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a6f9a91bfa884faa7a62acc8ff789f40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9a91bfa884faa7a62acc8ff789f40e">&#9670;&nbsp;</a></span>extract_subdomain_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_subdomain_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>标记所有在给定子域id的单元上的自由度。请注意，面的自由度可以属于不同子域id的单元，所以对于不同的子域id来说，被标记的自由度集并不相互排斥。 如果你想得到自由度与子域的唯一关联，请使用 <code>get_subdomain_association</code> 函数。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01028">1028</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a5f745d25d2397a91dc65b9158b8d77a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f745d25d2397a91dc65b9158b8d77a6">&#9670;&nbsp;</a></span>extract_locally_active_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_locally_active_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提取在当前DoFHandler上有效的全局DoF指数集合。对于普通的DoFHandler来说，这些都是DoF指数，但是对于建立在 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 上的DoFHandler对象来说，这个集合是 <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> 的超集，包含了所有住在本地拥有的单元上的DoF指数（包括在与幽灵单元的接口上）。然而，它不包含专门定义在幽灵或人工单元上的自由度指数（见 词汇表 ）。 这个函数识别的自由度等于从Dof_indices_with_subdomain_association()函数中获得的自由度，当调用本地拥有的子域ID时。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01062">1062</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="af778defeb024f32c1e3500963936639f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af778defeb024f32c1e3500963936639f">&#9670;&nbsp;</a></span>extract_locally_active_level_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_locally_active_level_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述函数相同，但适用于某个（多网格）层次。 这个函数返回在给定层次上所有本地拥有的单元（包括与幽灵单元的接口）上的所有DoF指数。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01097">1097</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="acad7e0841b9046eaafddc4c617ab1d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad7e0841b9046eaafddc4c617ab1d9d">&#9670;&nbsp;</a></span>extract_locally_relevant_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_locally_relevant_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提取在当前DoFHandler上活动的全局DoF指数集合。对于普通的DoFHandler，这些都是DoF指数，但是对于建立在 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 上的DoFHandler对象，这个集合是 <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> 和所有鬼魂单元上的DoF指数的联合。实质上，它是所有非人造单元上的DoF指数（见 术语表 ）。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01133">1133</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a6378e20da50d4bda1050db19ce43d5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6378e20da50d4bda1050db19ce43d5ed">&#9670;&nbsp;</a></span>locally_owned_dofs_per_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; DoFTools::locally_owned_dofs_per_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>components</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为掩码内的每个组件提取本地拥有的DoF指数集，这些指数为当前处理器所拥有。对于被掩码禁用的组件，会返回一个空的IndexSet。对于建立在顺序三角形上的标量DoFHandler，返回的向量包含一个包含所有DoF指数的完整IndexSet。如果掩码包含所有组件（这也对应于默认值），那么返回的索引集的联合就相当于 <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> 的返回值。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00446">446</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a180d7118ecf27d72afbfecb7978c5e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180d7118ecf27d72afbfecb7978c5e09">&#9670;&nbsp;</a></span>locally_owned_dofs_per_subdomain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; DoFTools::locally_owned_dofs_per_subdomain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于每个处理器，确定本地拥有的自由度集合为一个IndexSet。然后这个函数返回一个索引集的向量，其中向量的大小等于参与自由度处理对象的MPI进程的数量。 该函数可用于 <a class="el" href="classTriangulation.html">Triangulation</a> 或 <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a>. 类型的对象，但对 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 类型的对象不起作用，因为对于这样的三角形，我们没有关于三角形的所有单元的本地可用信息，因此不能对其他处理器本地拥有的单元上的自由度有任何明确的说法。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01337">1337</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="aa2f9b39d216419f46312417550dbdd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f9b39d216419f46312417550dbdd20">&#9670;&nbsp;</a></span>locally_relevant_dofs_per_subdomain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; DoFTools::locally_relevant_dofs_per_subdomain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于每个处理器，确定本地相关自由度的集合为IndexSet。然后这个函数返回一个索引集的向量，其中向量的大小等于参与自由度处理对象的MPI进程的数量。 该函数可用于 <a class="el" href="classTriangulation.html">Triangulation</a> 或 <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a>. 类型的对象，但对 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 类型的对象不起作用，因为对于这样的三角形，我们没有关于三角形的所有单元的本地可用信息，因此不能对其他处理器本地拥有的单元上的自由度有任何明确的说法。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01432">1432</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a1fef7be07cf379b661646e39b9354e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fef7be07cf379b661646e39b9354e17">&#9670;&nbsp;</a></span>extract_locally_relevant_level_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_locally_relevant_level_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与extract_locally_relevant_dofs()相同，但对于给定的 <code>level</code>. 的多网格DoFs。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01175">1175</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a0429b3117b2ab1f5a1fd0d55de26ad81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0429b3117b2ab1f5a1fd0d55de26ad81">&#9670;&nbsp;</a></span>get_subdomain_association()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::get_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于每个自由度，在输出数组中返回它属于哪个子域（由<code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code>函数给出）。在调用这个函数时，输出数组应该已经有了合适的大小。 请注意，与面、边和顶点相关的自由度如果位于分区的边界上，可能与多个子域相关。在这种情况下，我们将它们分配给具有较小子域ID的进程。这可能会导致分区中自由度的数量不同，即使单元格的数量是完全等分的。虽然这是令人遗憾的，但在实践中这并不是一个问题，因为只要分区的数量保持不变，当我们细化网格时，分区边界上的自由度数量是渐进式消失的。 这个函数返回每个DoF与一个子域的关联。如果你正在寻找每个 <em>单元与一个子域的关联，可以查询<code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code>函数，或者使用</em> <code><a class="el" href="namespaceGridTools.html#ac41d959ae1723a898b616c3320241ffe">GridTools::get_subdomain_association</a></code> 函数。 请注意，这个函数对于建立在 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 上的DoFHandler对象的用途值得怀疑，因为在这种情况下，MPI进程对各个自由度的所有权是由DoF handler对象控制的，而不是基于某种几何算法与子域id相结合。特别是，这个命名空间中的函数所识别的与子域相关的自由度与DoFHandler类所识别的自由度不一样。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01508">1508</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="ac704c6d311cd0f289d625427e03708ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac704c6d311cd0f289d625427e03708ac">&#9670;&nbsp;</a></span>count_dofs_with_subdomain_association() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> DoFTools::count_dofs_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算有多少个自由度与给定的 <code>subdomain</code> 索引唯一相关。 请注意，可能有一些罕见的情况，即具有给定 <code>subdomain</code> 索引的单元格存在，但它的自由度实际上都没有与之相关。在这种情况下，返回值将为零。 如果没有具有给定 <code>subdomain</code> 索引的单元格，该函数将产生一个异常。 该函数返回与一个子域相关的DoFs数量。 如果你要寻找与这个子域相关的 <em>单元，请使用</em> <code><a class="el" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">GridTools::count_cells_with_subdomain_association</a></code> 函数。 注意这个函数对于建立在 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 上的DoFHandler对象的用途值得怀疑，因为在这种情况下，MPI进程对单个自由度的所有权是由DoF handler对象控制的，而不是基于一些与子域id相关的几何算法。特别是，这个命名空间中的函数所识别的与子域相关的自由度与DoFHandler类所识别的自由度不一样。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01604">1604</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="ad38e53eb1c27d67f5e341399356edb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38e53eb1c27d67f5e341399356edb55">&#9670;&nbsp;</a></span>count_dofs_with_subdomain_association() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::count_dofs_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_dofs_on_subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算有多少个自由度与给定的 <code>subdomain</code> 索引唯一相关。 这个函数的作用与前一个函数相同，只是它将结果在DoFHandler对象所使用的有限元的向量分量之间进行分割。因此，最后一个参数（其长度必须等于矢量分量的数量）将存储每个矢量分量的多少个自由度与给定的子域相关。 注意这个函数对于建立在 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 上的DoFHandler对象的用途是值得怀疑的，因为在这种情况下，MPI进程对各个自由度的所有权是由DoF handler对象控制的，而不是基于一些与子域id相关的几何算法。特别是，这个命名空间中的函数所识别的与子域相关的自由度与DoFHandler类所识别的自由度不一样。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01680">1680</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a0a84027251b470f94bcaf1f00e04e722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a84027251b470f94bcaf1f00e04e722">&#9670;&nbsp;</a></span>dof_indices_with_subdomain_association()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::dof_indices_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一组索引，表示生活在给定子域上的自由度，即当前处理器拥有的单元上的自由度。请注意，这包括这个子域 "拥有
"的自由度（即get_subdomain_association()返回的值等于这里给出的子域，并且被 <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> 函数选中的自由度），也包括所有位于给定子域和其他子域之间边界上的自由度。从本质上讲，位于子域之间边界的自由度将出现在这个函数返回的多个子域的索引集中。 注意这个函数对于建立在 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 上的DoFHandler对象的用途是值得怀疑的，因为在这种情况下，MPI进程对各个自由度的所有权是由DoF handler对象控制的，而不是基于一些与子域id相关的几何算法。特别是，这个命名空间中的函数所识别的与子域相关的自由度与DoFHandler类所识别的自由度不一样。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01621">1621</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="aba4315ae585ff3b55ba9e6d2c26825a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4315ae585ff3b55ba9e6d2c26825a3">&#9670;&nbsp;</a></span>get_dofs_on_patch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; DoFTools::get_dofs_on_patch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回由参数描述的一组单元（即补丁）上的自由度集合。 补丁通常用于定义误差估计器，这些估计器需要解决网格中每个单元周围补丁上的局部问题。你可以使用 <a class="el" href="namespaceGridTools.html#aaec69b92488f0dd0d61ff66445327f0d">GridTools::get_patch_around_cell()</a>. 得到一个构成给定单元周围补丁的单元列表。虽然 <a class="el" href="namespaceDoFTools.html#acf3d202ccd39aea458a476dd0928fb15">DoFTools::count_dofs_on_patch()</a> 可以用来确定这些局部问题的大小，这样就可以组装局部系统，然后进行求解，但仍然有必要提供一个住在补丁上的自由度的全局索引和局部枚举之间的映射。这个函数通过返回住在补丁上的自由度的集合来提供这样一个局部列举。 由于这个集合是以 std::vector, 的形式返回的，我们也可以把它看成是一个映射 </p><div class="fragment"><div class="line">i</div><div class="line"></div><div class="line">-&gt; <a class="code" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">global_dof_index</a></div></div><!-- fragment --><p> 其中 <code>i</code> 是返回向量的索引（即补丁上一个自由度的<em>local</em>索引）， <code>global_dof_index</code> 是位于补丁上的自由度的全局索引。返回的数组大小等于 <a class="el" href="namespaceDoFTools.html#acf3d202ccd39aea458a476dd0928fb15">DoFTools::count_dofs_on_patch()</a>. 。 </p><dl class="section note"><dt>Note</dt><dd>返回的数组是按全局自由度索引排序的。因此，如果我们认为这个数组的索引是本地DoF索引，那么产生的本地系统就保留了全局系统的块状结构。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">补丁</td><td>一个DoFHandler&lt;dim,  spacedim&gt;::active_cell_iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>位于补丁上的那些全局自由度的列表，如上定义。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>在并行分布式计算的背景下，只有在本地拥有的单元周围的补丁上调用这个函数才有意义。这是因为本地拥有的单元的邻居要么是本地拥有的单元，要么是幽灵单元。对于这两种情况，我们知道这些单元实际上是完整的、平行的三角形的真实单元。我们还可以查询这些单元的自由度。换句话说，这个函数只有在补丁中的所有单元都是本地拥有的或者是幽灵单元的情况下才能工作。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02775">2775</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="adf4d7fd8aba5cbf92b6f24c757cf9f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4d7fd8aba5cbf92b6f24c757cf9f23">&#9670;&nbsp;</a></span>get_dofs_on_patch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&gt; DoFTools::get_dofs_on_patch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>使用以dim和spacedim为模板参数的函数。</dd></dl>

</div>
</div>
<a id="a43ee44769769065bc594d1730477a4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ee44769769065bc594d1730477a4b9">&#9670;&nbsp;</a></span>make_cell_patches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_cell_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个稀疏模式，它列出了与给定层次上每个单元相关的自由度。这种模式可以在RelaxationBlock类中作为加法和乘法施瓦茨方法的块列表。 该模式中的行指数是通过三角法的一个层次进行标准迭代而得到的单元格指数。对于一个 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, 来说，只有本地拥有的单元被输入。 稀疏模式在这个函数中被调整为包含与给定级别上本地拥有的单元格一样多的行，与该级别上的自由度一样多的列。 <code>selected_dofs</code>是一个由单元上的局部自由度索引的向量。如果它被使用，只有这些自由度被输入到块列表中被选择。例如，这允许排除组件或边界上的道夫。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02411">2411</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a7947b3175eb0d455cd2e875df09c9385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7947b3175eb0d455cd2e875df09c9385">&#9670;&nbsp;</a></span>make_vertex_patches() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; DoFTools::make_vertex_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>interior_dofs_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>boundary_patches</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>level_boundary_patches</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>single_cell_patches</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>invert_vertex_mapping</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个入射矩阵，对于多级DoFHandler的某一层的每一个顶点，标志着哪些自由度与相邻单元相关。这个数据结构是一个矩阵，有多少行就有多少顶点，有多少列就有多少自由度，条目是真还是假。这个数据结构由一个SparsityPattern对象方便地表示。 在进入这个函数时，稀疏性模式可能是空的，将被重新初始化为正确的大小。 该函数有一些布尔参数（列在下面）控制生成补丁的细节。默认设置是Arnold-Falk-Winther类型的平滑器，用于具有基本边界条件的发散和曲率符合的有限元。其他应用也是可能的，特别是改变<code>boundary_patches</code>用于非基本边界条件。 这个函数返回<code>vertex_mapping</code>，它包含从顶点索引到<code>block_list</code>块索引的映射。对于没有导致顶点补丁的顶点，<code>vertex_mapping</code>中的条目包含值<code>invalid_unsigned_int</code>。如果<code>invert_vertex_mapping</code>被设置为<code>true</code>，那么<code>vertex_mapping</code>将被倒置，这样它就包含了从块索引到相应顶点索引的映射。 </p><ul>
<li><code>block_list</code>：将存储补丁的SparsityPattern。 </li>
<li><code>dof_handler</code>：提供拓扑结构操作的多级dof处理程序。 </li>
<li><code>interior_dofs_only</code>：对于一个顶点周围的每个单元补丁，只收集该补丁的内部自由度，而不考虑该补丁边界上的自由度。例如，这是Arnold-Falk-Winther类型的平滑器的设置。 </li>
<li><code>boundary_patches</code>：包括域的边界顶点周围的补丁。如果不包括，将只生成内部顶点周围的补丁。 </li>
<li><code>level_boundary_patches</code>：对朝向更粗的单元的细化边也是如此。 </li>
<li><code>single_cell_patches</code>：如果不为真，包含单个单元的补丁会被消除。 </li>
<li><code>invert_vertex_mapping</code>：如果为真，那么返回值包含每个块的一个顶点索引；如果为假，那么返回值包含每个顶点的一个块索引或<code>invalid_unsigned_int</code>。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02570">2570</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a4300fb13f111c1292fa146b8eb756274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4300fb13f111c1292fa146b8eb756274">&#9670;&nbsp;</a></span>make_vertex_patches() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; DoFTools::make_vertex_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>exclude_boundary_dofs</em> = <code><a class="el" href="classBlockMask.html">BlockMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>boundary_patches</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>level_boundary_patches</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>single_cell_patches</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>invert_vertex_mapping</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，但允许单独排除块上的边界道夫。 如果你想使用，例如，Taylor Hood元素，这很有帮助，因为它允许你不包括速度块在补丁上的边界DoFs，同时也允许你包括压力块的边界DoFs。 对于顶点周围的每个单元补丁，如果 <code>exclude_boundary_dofs</code> 的BlockMask中对应块的布尔值为false，则收集该补丁的所有内部自由度并忽略该补丁边界上的自由度。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02593">2593</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a97fef09370d666eccd7f811d6df8d748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fef09370d666eccd7f811d6df8d748">&#9670;&nbsp;</a></span>make_child_patches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_child_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>interior_dofs_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>boundary_dofs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个入射矩阵，对于多级DoFHandler的某一层的每一个单元，都标志着哪些自由度与这个单元的子代相关。这个数据结构可以方便地用SparsityPattern对象表示。 因此，该函数创建了一个稀疏模式，在每一行（行对应于该层的单元）列出与该单元的子单元相关的自由度。这里使用的自由度指数是多级层次结构中的一级自由度指数，也就是说，它们可能与本身并不活跃的子单元有关。进入这个函数时，稀疏模式可能是空的，将被重新初始化为正确的大小。 该函数有一些布尔参数（列在下面）控制生成补丁的细节。默认设置是Arnold-Falk-Winther类型的平滑器，用于具有基本边界条件的发散和曲率符合的有限元。其他应用也是可能的，特别是改变<code>boundary_dofs</code>用于非基本边界条件。 </p><ul>
<li><code>block_list</code>：将存储补丁的SparsityPattern。 </li>
<li><code>dof_handler</code>：提供所操作的拓扑结构的多级dof处理器。 </li>
<li><code>interior_dofs_only</code>：对于顶点周围的每个单元补丁，只收集该补丁的内部自由度，而忽略该补丁边界上的自由度。例如，这就是Arnold-Falk-Winther类型的平滑器的设置。 </li>
<li><code>boundary_dofs</code>: 包括自由度，这些自由度将被<code>interior_dofs_only</code>排除，但位于域的边界上，因此需要平滑。如果<code>interior_dofs_only</code>是假的，这个参数就没有影响。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02502">2502</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="ab270041c339a188ba4cb050f0c561737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab270041c339a188ba4cb050f0c561737">&#9670;&nbsp;</a></span>make_single_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_single_patch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>interior_dofs_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个只有一个补丁的块列表，它又包含了给定层次上的所有自由度。 这个函数主要是对make_child_patches()和make_vertex_patches()等函数在第0层的一个闭合，这些函数可能会产生一个空的补丁列表。 </p><ul>
<li><code>block_list</code>: 补丁将被存储到的SparsityPattern。 </li>
<li><code>dof_handler</code>：提供拓扑结构操作的多级dof处理程序。 </li>
<li><code>level</code> 用于建立列表的网格级别。 </li>
<li><code>interior_dofs_only</code>: 如果为真，排除域的边界上的自由度。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02457">2457</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a956ac5c6aab03ec1c04f1ad955301db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956ac5c6aab03ec1c04f1ad955301db9">&#9670;&nbsp;</a></span>count_dofs_per_fe_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; DoFTools::count_dofs_per_fe_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>vector_valued_once</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_component</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算在总数中，有多少自由度属于每个组件。如果有限元的构件数是一个（即你只有一个标量变量），那么这个构件中的数字显然等于自由度总数。 否则，所有组件中的自由度之和需要等于总数量。 然而，如果有限元不是原始的，即它的一些或全部形状函数在一个以上的矢量分量中是非零的，那么最后一句话就不成立了。例如，这适用于Nedelec或Raviart-Thomas元素。在这种情况下，一个自由度在每个分量中都被计算为非零，因此上述的总和大于自由度的总数。 这种行为可以通过可选的参数<code>vector_valued_once</code>来关闭。如果这是<code>true</code>，非原始向量值元素的成分数只收集在第一个成分中。所有其他分量的计数将为零。 额外的可选参数 <code>target_component</code> 允许对组件进行重新排序和分组。为此，它包含了每个组件的组件编号，它应该被计算为。如果多次输入相同的号码，就会把几个组件归为同一个。这个参数的应用之一是当你想形成块状矩阵和向量，但又想把几个分量打包到同一个块中时（例如，当你有 <code>dim</code> 速度和一个压力时，要把所有速度放到一个块中，而把压力放到另一个块中）。 结果在 <code>dofs_per_component</code>. 中返回。注意， <code>dofs_per_component的大小需要足以容纳</code> <code>target_component</code>. 中指定的所有索引。如果不是这样，会抛出一个断言。 没有被target_components锁定的索引将不被触及。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01851">1851</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a796721b56b3a90e4e3973c7caae4c3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796721b56b3a90e4e3973c7caae4c3d8">&#9670;&nbsp;</a></span>count_dofs_per_fe_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; DoFTools::count_dofs_per_fe_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_block</em> = <code>std::vector&lt;unsigned&#160;<a class="el" href="classint.html">int</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算每个块中的自由度。这个函数类似于count_dofs_per_component()，不同的是，计数是按块进行的。详见术语表中的 块 。在调用这个函数之前，再次假设向量具有正确的大小。如果不是这样，就会抛出一个断言。 这个函数在 <a class="el" href="step_22.html">step-22</a> , <a class="el" href="step_31.html">step-31</a> , 和 <a class="el" href="step_32.html">step-32</a> 教程中使用，还有其他一些程序。 </p><dl class="section pre"><dt>Precondition</dt><dd>dofs_per_block变量具有与dof_handler参数所使用的有限元的块数相同的组件，或者与target_blocks参数中列举的块数相同（如果给出的话）。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01943">1943</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a3e30887d7a90dc1422a9bb9e90ee1a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e30887d7a90dc1422a9bb9e90ee1a05">&#9670;&nbsp;</a></span>get_active_fe_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::get_active_fe_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_fe_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于DoFHandler的每个活动单元，提取活动的有限元索引并填充作为第二个参数的矢量。这个向量被认为具有与活动单元相同数量的条目。 对于没有hp-capabilities作为第一个参数的DoFHandler对象，返回的向量将只由0组成，表示所有单元使用相同的有限元。在hp模式下，这些值可能是不同的，但是。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l01322">1322</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="acf3d202ccd39aea458a476dd0928fb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3d202ccd39aea458a476dd0928fb15">&#9670;&nbsp;</a></span>count_dofs_on_patch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> DoFTools::count_dofs_on_patch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算参数所描述的一组单元（即一个补丁）上有多少自由度。 补丁通常用于定义误差估计器，这些估计器需要解决网格中每个单元周围补丁上的局部问题。你可以使用 <a class="el" href="namespaceGridTools.html#aaec69b92488f0dd0d61ff66445327f0d">GridTools::get_patch_around_cell()</a>. 得到一个围绕给定单元的补丁的单元列表，这个函数在设置用于解决单元周围补丁的局部问题的线性系统的大小时非常有用。然后，函数 <a class="el" href="namespaceDoFTools.html#aba4315ae585ff3b55ba9e6d2c26825a3">DoFTools::get_dofs_on_patch()</a> 将有助于建立全局自由度和局部自由度之间的联系。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>一个DoFHandler&lt;dim, spacedim&gt;类型的对象内的单元的集合 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>与这个补丁的单元相关的自由度数。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>在并行分布式计算的背景下，只有在本地拥有的单元格周围的补丁上调用这个函数才有意义。这是因为本地拥有的单元的邻居要么是本地拥有的单元，要么是幽灵单元。对于这两种情况，我们知道这些单元实际上是完整的、平行的三角形的真实单元。我们还可以查询这些单元的自由度。换句话说，这个函数只有在补丁中的所有单元都是本地拥有的或者是幽灵单元的情况下才能工作。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02744">2744</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a99d249bd0c6f5ccb1ea86d498fd7e936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d249bd0c6f5ccb1ea86d498fd7e936">&#9670;&nbsp;</a></span>count_dofs_on_patch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> DoFTools::count_dofs_on_patch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>使用以dim和spacedim为模板参数的函数。</dd></dl>

</div>
</div>
<a id="aa243d4c45775077c674ef6800e5ce215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa243d4c45775077c674ef6800e5ce215">&#9670;&nbsp;</a></span>map_dof_to_boundary_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dof_to_boundary_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个从自由度指数到该自由度在边界上的指数的映射。在此操作之后，<code>mapping[dof]</code>给出边界上自由度列表中全局编号为 <code>dof</code> 的自由度的索引。 如果要求的自由度不在边界上，则<code>mapping[dof]</code>的值为 <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a>. 该函数主要用于从试验函数中设置边界上的矩阵和向量，而矩阵和向量使用边界本地的试验函数的编号。 <code>mapping</code> 的先前内容被删除。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02032">2032</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a2e367cf4d8590470cc136bec082b216b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e367cf4d8590470cc136bec082b216b">&#9670;&nbsp;</a></span>map_dof_to_boundary_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dof_to_boundary_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与之前的函数相同，只是只考虑边界的那些部分，对于这些部分的边界指标列在第二个参数中。 更多信息请参见本类的一般文档。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">关于边界指标的词汇条目</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02074">2074</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a5514e4f59ea659f63953d62ca429eaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5514e4f59ea659f63953d62ca429eaff">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该DoF处理对象处理的所有自由度的支持点（见此 <a class="el" href="DEALGlossary.html#GlossSupport">术语条目</a> ）的列表。当然，这个函数只有在DoF处理对象使用的有限元对象实际提供支持点时才起作用，即没有边缘元素或类似的东西。否则，就会抛出一个异常。 </p><dl class="section pre"><dt>Precondition</dt><dd>给定的数组的长度必须与自由度的元素数量相同。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>这个函数的前提条件是输出参数的大小必须等于自由度的总数，这使得这个函数不适合给定的DoFHandler对象派生自 <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> 对象的情况（或任何派生自 <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>). 的类，因此，如果用这样的DoFHandler调用，这个函数将产生一个错误。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">映射</td><td>从参考单元到定义DoF的实际单元的映射。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>描述哪个DoF指数在三角结构的哪个单元上的对象。 </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">support_points</td><td>存储实空间坐标中斗室的相应位置的向量。这个对象以前的内容在这个函数中被删除。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>一个可选的分量掩码，用于限制从中提取支持点的分量。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02222">2222</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a8d68b6352f00a6e6c26eb728040284e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d68b6352f00a6e6c26eb728040284e6">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与前面的函数相同，但用于hp-case。 </p>

</div>
</div>
<a id="a297ef923ee03f234fc09ee4dcdd01140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297ef923ee03f234fc09ee4dcdd01140">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02273">2273</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="ad18da75343daf4b14fa0588445627eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18da75343daf4b14fa0588445627eab">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与前面的函数相同，但用于hp-case。 </p>

</div>
</div>
<a id="a3540ceb577e65414bde1b6b14808da2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3540ceb577e65414bde1b6b14808da2c">&#9670;&nbsp;</a></span>map_support_points_to_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_support_points_to_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, Comp &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_to_index_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这是一个与上面那个相反的函数。它生成一个地图，其中键是自由度的支持点，而值是自由度指数。关于支持点的定义，请看这个 <a class="el" href="DEALGlossary.html#GlossSupport">词汇表条目</a> 。 由于在点的空间中没有自然的顺序（除了1d的情况），你必须提供一个带有明确指定的比较器对象的地图。因此，这个函数在比较器对象上被模板化。 在这个函数中，地图对象的先前内容被删除。 就像上面的函数一样，假定这里使用的有限元实际上支持其所有组件的支持点的概念。 </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>这个函数应该生成一个多图，而不仅仅是一个地图，因为几个道夫可能位于同一个支持点。目前，只有map_dofs_to_support_points()为每个点返回的地图中的最后一个值将被返回。</dd></dl>

</div>
</div>
<a id="a952f50bcd4f8fbb09924626ecc60c605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952f50bcd4f8fbb09924626ecc60c605">&#9670;&nbsp;</a></span>distribute_cell_to_dof_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::distribute_cell_to_dof_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>取一个住在单元上的值的向量（例如，每个单元的误差），并以这样的方式将其分配到道夫上，从而产生一个有限元场，然后可以进一步处理，例如，用于输出。你应该注意到，所产生的场在悬挂的节点上将不是连续的。 然而，这可以通过在矢量完全组装后调用为该DoFHandler对象创建的AffineConstraints对象的适当 <code>分布函数来轻松安排。</code> 假设 <code>cell_data</code> 中的元素数等于活动单元的数量， <code>dof_data</code> 中的元素数等于<code>dof_handler.n_dofs()</code>。 注意，输入向量可以是任何数据类型的向量，只要它可以转换为 <code>double</code>. 输出向量，作为DoF处理程序上的数据向量，总是由 <code>double</code>. 类型的元素组成。 如果这个DoFHandler使用的有限元由一个以上的分量组成，你需要指定输出向量中的哪个分量应该用来存储有限元场；默认是0（如果有限元只由一个分量组成则不允许有其他值）。矢量的所有其他分量保持不动，即它们的内容不被改变。 如果所使用的有限元的形状函数在一个以上的向量分量中是非零的（用deal.II的话说：它们是非正则的），则不能使用这个函数。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l00306">306</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a1747081ebc1846a5b9ca3aa4bc2ee73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1747081ebc1846a5b9ca3aa4bc2ee73d">&#9670;&nbsp;</a></span>write_gnuplot_dof_support_point_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::write_gnuplot_dof_support_point_info </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>根据给定的地图，用点数据生成gnuplot可读的文本输出 <code>support_points</code>. 对于每个支持点的位置，生成一个包含地图上所有DoF列表的字符串标签。 该地图可以通过调用map_dofs_to_support_points()来生成，对于可视化未知数的位置和全局编号非常有用。 输出中每一行的格式的例子是。 </p><div class="fragment"><div class="line">x [y] [z] <span class="stringliteral">&quot;dof1, dof2&quot;</span></div></div><!-- fragment --><p> 其中x、y和z（只存在于相应的维度）是支持点的坐标，后面是一串DoF编号。 带标签的点可以在gnuplot中作如下图示。 </p><div class="fragment"><div class="line">plot <span class="stringliteral">&quot;./points.gpl&quot;</span> <span class="keyword">using</span> 1:2:3 with labels <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> offset 1,1</div></div><!-- fragment --><p> 例子（这也包括用GridOut单独编写的网格）。 </p>
<div class="image">
<img src="support_point_dofs1.png" alt="support_point_dofs1.png"/>
</div>
 <div class="image">
<img src="support_point_dofs2.png" alt="support_point_dofs2.png"/>
</div>
 <p>要在单个gnuplot文件中生成网格和支撑点信息，请使用类似的代码 </p><div class="fragment"><div class="line">std::ofstream out(<span class="stringliteral">&quot;gnuplot.gpl&quot;</span>);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;plot &#39;-&#39; using 1:2 with lines, &quot;</span></div><div class="line">  &lt;&lt; <span class="stringliteral">&quot;&#39;-&#39; with labels point pt 2 offset 1,1&quot;</span></div><div class="line">  &lt;&lt; std::endl;</div><div class="line"><a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a> (<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, out);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">std::map&lt;types::global_dof_index, Point&lt;dim&gt; &gt; support_points;</div><div class="line"><a class="code" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a> (<a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>(),</div><div class="line">                                    dof_handler,</div><div class="line">                                    support_points);</div><div class="line"><a class="code" href="namespaceDoFTools.html#a1747081ebc1846a5b9ca3aa4bc2ee73d">DoFTools::write_gnuplot_dof_support_point_info</a>(out,</div><div class="line">                                             support_points);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p> 并在gnuplot中执行以下命令。 </p><div class="fragment"><div class="line">load <span class="stringliteral">&quot;gnuplot.gpl&quot;</span></div></div><!-- fragment --><p> 或者，以下gnuplot脚本在命令行中以<code>gnuplot gnuplot.gpl</code>的形式执行时将生成一个png文件。 </p><div class="fragment"><div class="line">std::ofstream out(<span class="stringliteral">&quot;gnuplot.gpl&quot;</span>);</div><div class="line"></div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;set terminal png size 400,410 enhanced font \&quot;Helvetica,8\&quot;\n&quot;</span></div><div class="line">  &lt;&lt; <span class="stringliteral">&quot;set output \&quot;output.png\&quot;\n&quot;</span></div><div class="line">  &lt;&lt; <span class="stringliteral">&quot;set size square\n&quot;</span></div><div class="line">  &lt;&lt; <span class="stringliteral">&quot;set view equal xy\n&quot;</span></div><div class="line">  &lt;&lt; <span class="stringliteral">&quot;unset xtics\n&quot;</span></div><div class="line">  &lt;&lt; <span class="stringliteral">&quot;unset ytics\n&quot;</span></div><div class="line">  &lt;&lt; <span class="stringliteral">&quot;unset grid\n&quot;</span></div><div class="line">  &lt;&lt; <span class="stringliteral">&quot;unset border\n&quot;</span></div><div class="line">  &lt;&lt; <span class="stringliteral">&quot;plot &#39;-&#39; using 1:2 with lines notitle, &quot;</span></div><div class="line">  &lt;&lt; <span class="stringliteral">&quot;&#39;-&#39; with labels point pt 2 offset 1,1 notitle&quot;</span></div><div class="line">  &lt;&lt; std::endl;</div><div class="line"><a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a> (<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, out);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">std::map&lt;types::global_dof_index, Point&lt;dim&gt; &gt; support_points;</div><div class="line"><a class="code" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a> (<a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>(),</div><div class="line">                                    dof_handler,</div><div class="line">                                    support_points);</div><div class="line"><a class="code" href="namespaceDoFTools.html#a1747081ebc1846a5b9ca3aa4bc2ee73d">DoFTools::write_gnuplot_dof_support_point_info</a>(out,</div><div class="line">                                             support_points);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02312">2312</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a51c93a81b48b0879730f2ec459af9783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c93a81b48b0879730f2ec459af9783">&#9670;&nbsp;</a></span>DeclException0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DoFTools::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcFiniteElementsDontMatch&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>编写说明</dd></dl>

</div>
</div>
<a id="a495fa975b1d6b81f0875bf641f266ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495fa975b1d6b81f0875bf641f266ce5">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02248">2248</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="ab85610f8869cebbc3be41aed240ea4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85610f8869cebbc3be41aed240ea4b0">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dof__tools_8cc_source.html#l02294">2294</a> of file <a class="el" href="dof__tools_8cc_source.html">dof_tools.cc</a>.</p>

</div>
</div>
<a id="a730347c0582a281b1fbea079d7906e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730347c0582a281b1fbea079d7906e6a">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>periodicity_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l02573">2573</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
