<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceDoFTools.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DoFTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">DoFTools Namespace Reference<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad31df71a29dd76de9b4ab241b2527160"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> { <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">none</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">always</a>, 
<a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a155b9e72113d7008c60732d350bfbb7a">nonzero</a>
 }</td></tr>
<tr class="separator:ad31df71a29dd76de9b4ab241b2527160"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">DoF couplings</div></td></tr>
<tr class="memitem:a4d7f078a8e828165a7a1ca42570fec22"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4d7f078a8e828165a7a1ca42570fec22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a4d7f078a8e828165a7a1ca42570fec22">convert_couplings_to_blocks</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;table_by_component, std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt;&gt; &amp;tables_by_block)</td></tr>
<tr class="separator:a4d7f078a8e828165a7a1ca42570fec22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33213fe1b50e1251804521279d69b985"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a33213fe1b50e1251804521279d69b985"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a33213fe1b50e1251804521279d69b985">dof_couplings_from_component_couplings</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;component_couplings)</td></tr>
<tr class="separator:a33213fe1b50e1251804521279d69b985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af511a3eef444ad1e88802cd479e11933"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af511a3eef444ad1e88802cd479e11933"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#af511a3eef444ad1e88802cd479e11933">dof_couplings_from_component_couplings</a> (const <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;component_couplings)</td></tr>
<tr class="separator:af511a3eef444ad1e88802cd479e11933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sparsity pattern generation</div></td></tr>
<tr class="memitem:gaf78e864edbfba7e0a7477457bfb96b26"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType , typename number  = double&gt; </td></tr>
<tr class="memitem:gaf78e864edbfba7e0a7477457bfb96b26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">make_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;(), const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:gaf78e864edbfba7e0a7477457bfb96b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20db030885dbb33cb55f9a92d5e7804b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType , typename number  = double&gt; </td></tr>
<tr class="memitem:ga20db030885dbb33cb55f9a92d5e7804b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga20db030885dbb33cb55f9a92d5e7804b">make_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;coupling, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;(), const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:ga20db030885dbb33cb55f9a92d5e7804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0600dbcf28ec5bf58de34e21e1fb4b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga5a0600dbcf28ec5bf58de34e21e1fb4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga5a0600dbcf28ec5bf58de34e21e1fb4b">make_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_row, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_col, SparsityPatternType &amp;sparsity)</td></tr>
<tr class="separator:ga5a0600dbcf28ec5bf58de34e21e1fb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b2627e9bde96b98d4fcf95b629e4fd4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga7b2627e9bde96b98d4fcf95b629e4fd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">make_flux_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern)</td></tr>
<tr class="separator:ga7b2627e9bde96b98d4fcf95b629e4fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee18d72bf380f091c0fe21081e35768d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType , typename number &gt; </td></tr>
<tr class="memitem:gaee18d72bf380f091c0fe21081e35768d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaee18d72bf380f091c0fe21081e35768d">make_flux_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:gaee18d72bf380f091c0fe21081e35768d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebdabb3b4e2882a6ee130c7d8115a0df"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:gaebdabb3b4e2882a6ee130c7d8115a0df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaebdabb3b4e2882a6ee130c7d8115a0df">make_flux_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, SparsityPatternType &amp;sparsity, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;cell_integrals_mask, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;face_integrals_mask, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:gaebdabb3b4e2882a6ee130c7d8115a0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52de1b60d79f9ef5e0c642d7da16f0a8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType , typename number &gt; </td></tr>
<tr class="memitem:ga52de1b60d79f9ef5e0c642d7da16f0a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga52de1b60d79f9ef5e0c642d7da16f0a8">make_flux_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, SparsityPatternType &amp;sparsity, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;couplings, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;face_couplings, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;face_has_flux_coupling=&amp;internal::always_couple_on_faces&lt; dim, spacedim &gt;)</td></tr>
<tr class="separator:ga52de1b60d79f9ef5e0c642d7da16f0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f970db3b035e9813fc7201a2d18d032"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga9f970db3b035e9813fc7201a2d18d032"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga9f970db3b035e9813fc7201a2d18d032">make_boundary_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, SparsityPatternType &amp;sparsity_pattern)</td></tr>
<tr class="separator:ga9f970db3b035e9813fc7201a2d18d032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3dd70fabd9fe942ce3c127e6510024e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType , typename number &gt; </td></tr>
<tr class="memitem:gab3dd70fabd9fe942ce3c127e6510024e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gab3dd70fabd9fe942ce3c127e6510024e">make_boundary_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_ids, const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, SparsityPatternType &amp;sparsity)</td></tr>
<tr class="separator:gab3dd70fabd9fe942ce3c127e6510024e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hanging nodes and other constraints</div></td></tr>
<tr class="memitem:ga3b4ea7dfd313e388d868c4e4aa685799"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga3b4ea7dfd313e388d868c4e4aa685799"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">make_hanging_node_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints)</td></tr>
<tr class="separator:ga3b4ea7dfd313e388d868c4e4aa685799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae648a4b093f351b25eba50e8567b6ef"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:gaae648a4b093f351b25eba50e8567b6ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaae648a4b093f351b25eba50e8567b6ef">compute_intergrid_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;coarse_grid, const unsigned <a class="el" href="classint.html">int</a> coarse_component, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;fine_grid, const unsigned <a class="el" href="classint.html">int</a> fine_component, const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;&gt; &amp;coarse_to_fine_grid_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints)</td></tr>
<tr class="separator:gaae648a4b093f351b25eba50e8567b6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1126ff8e1542c36e6fcc2d825006d7f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:gae1126ff8e1542c36e6fcc2d825006d7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gae1126ff8e1542c36e6fcc2d825006d7f">compute_intergrid_transfer_representation</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;coarse_grid, const unsigned <a class="el" href="classint.html">int</a> coarse_component, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;fine_grid, const unsigned <a class="el" href="classint.html">int</a> fine_component, const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;&gt; &amp;coarse_to_fine_grid_map, std::vector&lt; std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, float &gt;&gt; &amp;transfer_representation)</td></tr>
<tr class="separator:gae1126ff8e1542c36e6fcc2d825006d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Periodic boundary conditions</div></td></tr>
<tr class="memitem:a929249499b1e5624728d212e90a8e037"><td class="memTemplParams" colspan="2">template&lt;typename FaceIterator , typename number &gt; </td></tr>
<tr class="memitem:a929249499b1e5624728d212e90a8e037"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">make_periodicity_constraints</a> (const FaceIterator &amp;face_1, const typename <a class="el" href="structidentity.html">identity</a>&lt; FaceIterator &gt;::type &amp;face_2, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classbool.html">bool</a> face_orientation=true, const <a class="el" href="classbool.html">bool</a> face_flip=false, const <a class="el" href="classbool.html">bool</a> face_rotation=false, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;(), const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;first_vector_components=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;(), const number periodicity_factor=1.)</td></tr>
<tr class="separator:a929249499b1e5624728d212e90a8e037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7025d513a21d3d3804f89fdc9c3824a9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a7025d513a21d3d3804f89fdc9c3824a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a7025d513a21d3d3804f89fdc9c3824a9">make_periodicity_constraints</a> (const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::cell_iterator &gt;&gt; &amp;periodic_faces, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;first_vector_components=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;(), const number periodicity_factor=1.)</td></tr>
<tr class="separator:a7025d513a21d3d3804f89fdc9c3824a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918a8dc3733662a03c0113296567564f"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType , typename number &gt; </td></tr>
<tr class="memitem:a918a8dc3733662a03c0113296567564f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a918a8dc3733662a03c0113296567564f">make_periodicity_constraints</a> (const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; typename DoFHandlerType::cell_iterator &gt;&gt; &amp;periodic_faces, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;first_vector_components=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;(), const number periodicity_factor=1.)</td></tr>
<tr class="separator:a918a8dc3733662a03c0113296567564f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa354b2b7e406e68c04c6e6ea07931f2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:aaa354b2b7e406e68c04c6e6ea07931f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#aaa354b2b7e406e68c04c6e6ea07931f2">make_periodicity_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id1, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id2, const unsigned <a class="el" href="classint.html">int</a> direction, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const number periodicity_factor=1.)</td></tr>
<tr class="separator:aaa354b2b7e406e68c04c6e6ea07931f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa423b8e89505de76ca7d2ca0f53faa1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:afa423b8e89505de76ca7d2ca0f53faa1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#afa423b8e89505de76ca7d2ca0f53faa1">make_periodicity_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id, const unsigned <a class="el" href="classint.html">int</a> direction, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const number periodicity_factor=1.)</td></tr>
<tr class="separator:afa423b8e89505de76ca7d2ca0f53faa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Identifying subsets of degrees of freedom with particular properties</div></td></tr>
<tr class="memitem:aed6928cb7bdb5a85e8670d6bd5c90e24"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aed6928cb7bdb5a85e8670d6bd5c90e24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#aed6928cb7bdb5a85e8670d6bd5c90e24">extract_hanging_node_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:aed6928cb7bdb5a85e8670d6bd5c90e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f4d01f1c4c6337e4be6f10a81fbdab"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a45f4d01f1c4c6337e4be6f10a81fbdab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">extract_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask)</td></tr>
<tr class="separator:a45f4d01f1c4c6337e4be6f10a81fbdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ec0cf2cf5feceaddf484a5d72126ab"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a63ec0cf2cf5feceaddf484a5d72126ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a63ec0cf2cf5feceaddf484a5d72126ab">extract_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;block_mask)</td></tr>
<tr class="separator:a63ec0cf2cf5feceaddf484a5d72126ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b041e2441000ccd13f2dad06537678"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a86b041e2441000ccd13f2dad06537678"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a86b041e2441000ccd13f2dad06537678">extract_level_dofs</a> (const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:a86b041e2441000ccd13f2dad06537678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f492fd7f9f9511f3b5c38dc5d9fefa"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af4f492fd7f9f9511f3b5c38dc5d9fefa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#af4f492fd7f9f9511f3b5c38dc5d9fefa">extract_level_dofs</a> (const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;component_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:af4f492fd7f9f9511f3b5c38dc5d9fefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b3c33925c1a1f15de20deda20b4d21"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a06b3c33925c1a1f15de20deda20b4d21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">extract_boundary_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids={})</td></tr>
<tr class="separator:a06b3c33925c1a1f15de20deda20b4d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05eb3b759a0491c2087cf3befcc39cc4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a05eb3b759a0491c2087cf3befcc39cc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a05eb3b759a0491c2087cf3befcc39cc4">extract_boundary_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids={})</td></tr>
<tr class="separator:a05eb3b759a0491c2087cf3befcc39cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905daad9c1cf1db522610811cd555b56"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a905daad9c1cf1db522610811cd555b56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a905daad9c1cf1db522610811cd555b56">extract_boundary_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, <a class="el" href="classIndexSet.html">IndexSet</a> &amp;selected_dofs, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids={})</td></tr>
<tr class="separator:a905daad9c1cf1db522610811cd555b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b97e816b29ecf963370a9d8b349828f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8b97e816b29ecf963370a9d8b349828f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a8b97e816b29ecf963370a9d8b349828f">extract_dofs_with_support_on_boundary</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a8b97e816b29ecf963370a9d8b349828f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097aa54937055733af934542b5c76e35"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number  = double&gt; </td></tr>
<tr class="memitem:a097aa54937055733af934542b5c76e35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a097aa54937055733af934542b5c76e35">extract_dofs_with_support_contained_within</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;)&gt; &amp;predicate, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;())</td></tr>
<tr class="separator:a097aa54937055733af934542b5c76e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc96893388fe1a55c6ae5ae19ba52c6d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:afc96893388fe1a55c6ae5ae19ba52c6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">extract_constant_modes</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask, std::vector&lt; std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&gt; &amp;constant_modes)</td></tr>
<tr class="separator:afc96893388fe1a55c6ae5ae19ba52c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Parallelization and domain decomposition</div></td></tr>
<tr class="memitem:a6f9a91bfa884faa7a62acc8ff789f40e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a6f9a91bfa884faa7a62acc8ff789f40e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a6f9a91bfa884faa7a62acc8ff789f40e">extract_subdomain_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:a6f9a91bfa884faa7a62acc8ff789f40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f745d25d2397a91dc65b9158b8d77a6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5f745d25d2397a91dc65b9158b8d77a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a5f745d25d2397a91dc65b9158b8d77a6">extract_locally_active_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, <a class="el" href="classIndexSet.html">IndexSet</a> &amp;dof_set)</td></tr>
<tr class="separator:a5f745d25d2397a91dc65b9158b8d77a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af778defeb024f32c1e3500963936639f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af778defeb024f32c1e3500963936639f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#af778defeb024f32c1e3500963936639f">extract_locally_active_level_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, <a class="el" href="classIndexSet.html">IndexSet</a> &amp;dof_set, const unsigned <a class="el" href="classint.html">int</a> level)</td></tr>
<tr class="separator:af778defeb024f32c1e3500963936639f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad7e0841b9046eaafddc4c617ab1d9d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acad7e0841b9046eaafddc4c617ab1d9d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">extract_locally_relevant_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, <a class="el" href="classIndexSet.html">IndexSet</a> &amp;dof_set)</td></tr>
<tr class="separator:acad7e0841b9046eaafddc4c617ab1d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf4d7a693cce69de01042c224e8efc8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:adbf4d7a693cce69de01042c224e8efc8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#adbf4d7a693cce69de01042c224e8efc8">locally_owned_dofs_per_component</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;components=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:adbf4d7a693cce69de01042c224e8efc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f8c5a33e13ed61dd565b1cac978b7c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af2f8c5a33e13ed61dd565b1cac978b7c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#af2f8c5a33e13ed61dd565b1cac978b7c">locally_owned_dofs_per_subdomain</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:af2f8c5a33e13ed61dd565b1cac978b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94d91fe4dcc3b3ad0fbe73a4f5ec93c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af94d91fe4dcc3b3ad0fbe73a4f5ec93c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#af94d91fe4dcc3b3ad0fbe73a4f5ec93c">locally_relevant_dofs_per_subdomain</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:af94d91fe4dcc3b3ad0fbe73a4f5ec93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fef7be07cf379b661646e39b9354e17"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1fef7be07cf379b661646e39b9354e17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">extract_locally_relevant_level_dofs</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, <a class="el" href="classIndexSet.html">IndexSet</a> &amp;dof_set)</td></tr>
<tr class="separator:a1fef7be07cf379b661646e39b9354e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0429b3117b2ab1f5a1fd0d55de26ad81"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0429b3117b2ab1f5a1fd0d55de26ad81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a0429b3117b2ab1f5a1fd0d55de26ad81">get_subdomain_association</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &amp;subdomain)</td></tr>
<tr class="separator:a0429b3117b2ab1f5a1fd0d55de26ad81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac704c6d311cd0f289d625427e03708ac"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac704c6d311cd0f289d625427e03708ac"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ac704c6d311cd0f289d625427e03708ac">count_dofs_with_subdomain_association</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain)</td></tr>
<tr class="separator:ac704c6d311cd0f289d625427e03708ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38e53eb1c27d67f5e341399356edb55"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad38e53eb1c27d67f5e341399356edb55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad38e53eb1c27d67f5e341399356edb55">count_dofs_with_subdomain_association</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;n_dofs_on_subdomain)</td></tr>
<tr class="separator:ad38e53eb1c27d67f5e341399356edb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a84027251b470f94bcaf1f00e04e722"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0a84027251b470f94bcaf1f00e04e722"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a0a84027251b470f94bcaf1f00e04e722">dof_indices_with_subdomain_association</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain)</td></tr>
<tr class="separator:a0a84027251b470f94bcaf1f00e04e722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">DoF indices on patches of cells</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Create structures containing a large set of degrees of freedom for small patches of cells. The resulting objects can be used in <a class="el" href="classRelaxationBlockSOR.html">RelaxationBlockSOR</a> and related classes to implement Schwarz preconditioners and smoothers, where the subdomains consist of small numbers of cells only. </p>
</div></td></tr>
<tr class="memitem:ad814274d3f9e209587ee1dba0f488b76"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad814274d3f9e209587ee1dba0f488b76"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad814274d3f9e209587ee1dba0f488b76">get_dofs_on_patch</a> (const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;patch)</td></tr>
<tr class="separator:ad814274d3f9e209587ee1dba0f488b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4d7fd8aba5cbf92b6f24c757cf9f23"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:adf4d7fd8aba5cbf92b6f24c757cf9f23"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#adf4d7fd8aba5cbf92b6f24c757cf9f23">get_dofs_on_patch</a> (const std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;patch)</td></tr>
<tr class="separator:adf4d7fd8aba5cbf92b6f24c757cf9f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ee44769769065bc594d1730477a4b9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a43ee44769769065bc594d1730477a4b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a43ee44769769065bc594d1730477a4b9">make_cell_patches</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs={}, const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> offset=0)</td></tr>
<tr class="separator:a43ee44769769065bc594d1730477a4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcb9366f2820c6d99017bbe22aec790"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aedcb9366f2820c6d99017bbe22aec790"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#aedcb9366f2820c6d99017bbe22aec790">make_vertex_patches</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classbool.html">bool</a> interior_dofs_only, const <a class="el" href="classbool.html">bool</a> boundary_patches=false, const <a class="el" href="classbool.html">bool</a> level_boundary_patches=false, const <a class="el" href="classbool.html">bool</a> single_cell_patches=false, const <a class="el" href="classbool.html">bool</a> invert_vertex_mapping=false)</td></tr>
<tr class="separator:aedcb9366f2820c6d99017bbe22aec790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38f199c5a12f531d73933a3ec0d52fd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af38f199c5a12f531d73933a3ec0d52fd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#af38f199c5a12f531d73933a3ec0d52fd">make_vertex_patches</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;exclude_boundary_dofs=<a class="el" href="classBlockMask.html">BlockMask</a>(), const <a class="el" href="classbool.html">bool</a> boundary_patches=false, const <a class="el" href="classbool.html">bool</a> level_boundary_patches=false, const <a class="el" href="classbool.html">bool</a> single_cell_patches=false, const <a class="el" href="classbool.html">bool</a> invert_vertex_mapping=false)</td></tr>
<tr class="separator:af38f199c5a12f531d73933a3ec0d52fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fef09370d666eccd7f811d6df8d748"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a97fef09370d666eccd7f811d6df8d748"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a97fef09370d666eccd7f811d6df8d748">make_child_patches</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classbool.html">bool</a> interior_dofs_only, const <a class="el" href="classbool.html">bool</a> boundary_dofs=false)</td></tr>
<tr class="separator:a97fef09370d666eccd7f811d6df8d748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab270041c339a188ba4cb050f0c561737"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab270041c339a188ba4cb050f0c561737"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ab270041c339a188ba4cb050f0c561737">make_single_patch</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;block_list, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classbool.html">bool</a> interior_dofs_only=false)</td></tr>
<tr class="separator:ab270041c339a188ba4cb050f0c561737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Counting degrees of freedom and related functions</div></td></tr>
<tr class="memitem:a1a0e02ae500ed576dd9487e846c9f5b6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1a0e02ae500ed576dd9487e846c9f5b6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a1a0e02ae500ed576dd9487e846c9f5b6">count_dofs_per_fe_component</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classbool.html">bool</a> vector_valued_once=false, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;target_component={})</td></tr>
<tr class="separator:a1a0e02ae500ed576dd9487e846c9f5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7782ed4f9cf0ac0c15a2e7b1d72afb27"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7782ed4f9cf0ac0c15a2e7b1d72afb27"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a7782ed4f9cf0ac0c15a2e7b1d72afb27">count_dofs_per_fe_block</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;target_block=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;())</td></tr>
<tr class="separator:a7782ed4f9cf0ac0c15a2e7b1d72afb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e30887d7a90dc1422a9bb9e90ee1a05"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3e30887d7a90dc1422a9bb9e90ee1a05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a3e30887d7a90dc1422a9bb9e90ee1a05">get_active_fe_indices</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;active_fe_indices)</td></tr>
<tr class="separator:a3e30887d7a90dc1422a9bb9e90ee1a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3d202ccd39aea458a476dd0928fb15"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acf3d202ccd39aea458a476dd0928fb15"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#acf3d202ccd39aea458a476dd0928fb15">count_dofs_on_patch</a> (const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;patch)</td></tr>
<tr class="separator:acf3d202ccd39aea458a476dd0928fb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d249bd0c6f5ccb1ea86d498fd7e936"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a99d249bd0c6f5ccb1ea86d498fd7e936"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a99d249bd0c6f5ccb1ea86d498fd7e936">count_dofs_on_patch</a> (const std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;patch)</td></tr>
<tr class="separator:a99d249bd0c6f5ccb1ea86d498fd7e936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions that return different DoF mappings</div></td></tr>
<tr class="memitem:aa243d4c45775077c674ef6800e5ce215"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa243d4c45775077c674ef6800e5ce215"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;mapping)</td></tr>
<tr class="separator:aa243d4c45775077c674ef6800e5ce215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e367cf4d8590470cc136bec082b216b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a2e367cf4d8590470cc136bec082b216b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a2e367cf4d8590470cc136bec082b216b">map_dof_to_boundary_indices</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;mapping)</td></tr>
<tr class="separator:a2e367cf4d8590470cc136bec082b216b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5514e4f59ea659f63953d62ca429eaff"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5514e4f59ea659f63953d62ca429eaff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">map_dofs_to_support_points</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;support_points, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a5514e4f59ea659f63953d62ca429eaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d68b6352f00a6e6c26eb728040284e6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8d68b6352f00a6e6c26eb728040284e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a8d68b6352f00a6e6c26eb728040284e6">map_dofs_to_support_points</a> (const ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;support_points, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a8d68b6352f00a6e6c26eb728040284e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297ef923ee03f234fc09ee4dcdd01140"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a297ef923ee03f234fc09ee4dcdd01140"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a297ef923ee03f234fc09ee4dcdd01140">map_dofs_to_support_points</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;support_points, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a297ef923ee03f234fc09ee4dcdd01140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18da75343daf4b14fa0588445627eab"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad18da75343daf4b14fa0588445627eab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#ad18da75343daf4b14fa0588445627eab">map_dofs_to_support_points</a> (const ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;support_points, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ad18da75343daf4b14fa0588445627eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3540ceb577e65414bde1b6b14808da2c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class Comp &gt; </td></tr>
<tr class="memitem:a3540ceb577e65414bde1b6b14808da2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a3540ceb577e65414bde1b6b14808da2c">map_support_points_to_dofs</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, std::map&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, Comp &gt; &amp;point_to_index_map)</td></tr>
<tr class="separator:a3540ceb577e65414bde1b6b14808da2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous</div></td></tr>
<tr class="memitem:a952f50bcd4f8fbb09924626ecc60c605"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename Number &gt; </td></tr>
<tr class="memitem:a952f50bcd4f8fbb09924626ecc60c605"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a952f50bcd4f8fbb09924626ecc60c605">distribute_cell_to_dof_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;cell_data, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;dof_data, const unsigned <a class="el" href="classint.html">int</a> component=0)</td></tr>
<tr class="separator:a952f50bcd4f8fbb09924626ecc60c605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1747081ebc1846a5b9ca3aa4bc2ee73d"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a1747081ebc1846a5b9ca3aa4bc2ee73d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFTools.html#a1747081ebc1846a5b9ca3aa4bc2ee73d">write_gnuplot_dof_support_point_info</a> (std::ostream &amp;out, const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;support_points)</td></tr>
<tr class="separator:a1747081ebc1846a5b9ca3aa4bc2ee73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06c0301bc74dd4c67a3d1db1000647f3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga06c0301bc74dd4c67a3d1db1000647f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">make_zero_boundary_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_id, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;zero_boundary_constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga06c0301bc74dd4c67a3d1db1000647f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga326f0868782800e5fa9d8e90c9cef135"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga326f0868782800e5fa9d8e90c9cef135"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga326f0868782800e5fa9d8e90c9cef135">make_zero_boundary_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;zero_boundary_constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga326f0868782800e5fa9d8e90c9cef135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exceptions</div></td></tr>
<tr class="memitem:ga51c93a81b48b0879730f2ec459af9783"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga51c93a81b48b0879730f2ec459af9783">DeclException0</a> (ExcFiniteElementsDontMatch)</td></tr>
<tr class="separator:ga51c93a81b48b0879730f2ec459af9783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga044394ead1b6613f5eb7a4c0e74b2b5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga044394ead1b6613f5eb7a4c0e74b2b5d">DeclException0</a> (ExcGridNotCoarser)</td></tr>
<tr class="separator:ga044394ead1b6613f5eb7a4c0e74b2b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56ee9b282be48fdc83565a67c64674c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga56ee9b282be48fdc83565a67c64674c7">DeclException0</a> (ExcGridsDontMatch)</td></tr>
<tr class="separator:ga56ee9b282be48fdc83565a67c64674c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga336e8e90cc9cda7a8542ed8f5fc55029"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga336e8e90cc9cda7a8542ed8f5fc55029">DeclException0</a> (ExcNoFESelected)</td></tr>
<tr class="separator:ga336e8e90cc9cda7a8542ed8f5fc55029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bef6c1580e69f6e07a10a719b4af1af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3bef6c1580e69f6e07a10a719b4af1af">DeclException0</a> (ExcInvalidBoundaryIndicator)</td></tr>
<tr class="separator:ga3bef6c1580e69f6e07a10a719b4af1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a collection of functions operating on, and manipulating the numbers of degrees of freedom. The documentation of the member functions will provide more information, but for functions that exist in multiple versions, there are sections in this global documentation stating some commonalities.</p>
<h3>Setting up sparsity patterns</h3>
<p>When assembling system matrices, the entries are usually of the form \(a_{ij} = a(\phi_i, \phi_j)\), where \(a\) is a bilinear functional, often an integral. When using sparse matrices, we therefore only need to reserve space for those \(a_{ij}\) only, which are nonzero, which is the same as to say that the basis functions \(\phi_i\) and \(\phi_j\) have a nonempty intersection of their support. Since the support of basis functions is bound only on cells on which they are located or to which they are adjacent, to determine the sparsity pattern it is sufficient to loop over all cells and connect all basis functions on each cell with all other basis functions on that cell. There may be finite elements for which not all basis functions on a cell connect with each other, but no use of this case is made since no examples where this occurs are known to the author.</p>
<h3>DoF numberings on boundaries</h3>
<p>When projecting the traces of functions to the boundary or parts thereof, one needs to build matrices and vectors that act only on those degrees of freedom that are located on the boundary, rather than on all degrees of freedom. One could do that by simply building matrices in which the entries for all interior DoFs are zero, but such matrices are always very rank deficient and not very practical to work with.</p>
<p>What is needed instead in this case is a numbering of the boundary degrees of freedom, i.e. we should enumerate all the degrees of freedom that are sitting on the boundary, and exclude all other (interior) degrees of freedom. The <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices()</a> function does exactly this: it provides a vector with as many entries as there are degrees of freedom on the whole domain, with each entry being the number in the numbering of the boundary or <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a> if the dof is not on the boundary.</p>
<p>With this vector, one can get, for any given degree of freedom, a unique number among those DoFs that sit on the boundary; or, if your DoF was interior to the domain, the result would be <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a>. We need this mapping, for example, to build the mass matrix on the boundary (for this, see <a class="el" href="group__constraints.html#ga9f970db3b035e9813fc7201a2d18d032">make_boundary_sparsity_pattern()</a> function, the corresponding section below, as well as the <a class="el" href="namespaceMatrixCreator.html">MatrixCreator</a> namespace documentation).</p>
<p>Actually, there are two <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices()</a> functions, one producing a numbering for all boundary degrees of freedom and one producing a numbering for only parts of the boundary, namely those parts for which the boundary indicator is listed in a set of indicators given to the function. The latter case is needed if, for example, we would only want to project the boundary values for the Dirichlet part of the boundary. You then give the function a list of boundary indicators referring to Dirichlet parts on which the projection is to be performed. The parts of the boundary on which you want to project need not be contiguous; however, it is not guaranteed that the indices of each of the boundary parts are continuous, i.e. the indices of degrees of freedom on different parts may be intermixed.</p>
<p>Degrees of freedom on the boundary but not on one of the specified boundary parts are given the index <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a>, as if they were in the interior. If no boundary indicator was given or if no face of a cell has a boundary indicator contained in the given list, the vector of new indices consists solely of <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a>.</p>
<p>(As a side note, for corner cases: The question what a degree of freedom on the boundary is, is not so easy. It should really be a degree of freedom of which the respective basis function has nonzero values on the boundary. At least for Lagrange elements this definition is equal to the statement that the off-point, or what deal.II calls support_point, of the shape function, i.e. the point where the function assumes its nominal value (for Lagrange elements this is the point where it has the function value 1), is located on the boundary. We do not check this directly, the criterion is rather defined through the information the finite element class gives: the <a class="el" href="classFiniteElement.html">FiniteElement</a> class defines the numbers of basis functions per vertex, per line, and so on and the basis functions are numbered after this information; a basis function is to be considered to be on the face of a cell (and thus on the boundary if the cell is at the boundary) according to it belonging to a vertex, line, etc but not to the interior of the cell. The finite element uses the same cell-wise numbering so that we can say that if a degree of freedom was numbered as one of the dofs on lines, we assume that it is located on the line. Where the off-point actually is, is a secret of the finite element (well, you can ask it, but we don't do it here) and not relevant in this context.)</p>
<h3>Setting up sparsity patterns for boundary matrices</h3>
<p>In some cases, one wants to only work with DoFs that sit on the boundary. One application is, for example, if rather than interpolating non- homogeneous boundary values, one would like to project them. For this, we need two things: a way to identify nodes that are located on (parts of) the boundary, and a way to build matrices out of only degrees of freedom that are on the boundary (i.e. much smaller matrices, in which we do not even build the large zero block that stems from the fact that most degrees of freedom have no support on the boundary of the domain). The first of these tasks is done by the <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices()</a> function (described above).</p>
<p>The second part requires us first to build a sparsity pattern for the couplings between boundary nodes, and then to actually build the components of this matrix. While actually computing the entries of these small boundary matrices is discussed in the <a class="el" href="namespaceMatrixCreator.html">MatrixCreator</a> namespace, the creation of the sparsity pattern is done by the create_boundary_sparsity_pattern() function. For its work, it needs to have a numbering of all those degrees of freedom that are on those parts of the boundary that we are interested in. You can get this from the <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices()</a> function. It then builds the sparsity pattern corresponding to integrals like \(\int_\Gamma \varphi_{b2d(i)} \varphi_{b2d(j)} dx\), where \(i\) and \(j\) are indices into the matrix, and \(b2d(i)\) is the global DoF number of a degree of freedom sitting on a boundary (i.e., \(b2d\) is the inverse of the mapping returned by <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">map_dof_to_boundary_indices()</a> function). </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad31df71a29dd76de9b4ab241b2527160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31df71a29dd76de9b4ab241b2527160">&#9670;&nbsp;</a></span>Coupling</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">DoFTools::Coupling</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The flags used in tables by certain <code>make_*_pattern</code> functions to describe whether two components of the solution couple in the bilinear forms corresponding to cell or face terms. An example of using these flags is shown in the introduction of step-46.</p>
<p>In the descriptions of the individual elements below, remember that these flags are used as elements of tables of size <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components</a> times <a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElement::n_components</a> where each element indicates whether two components do or do not couple. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba"></a>none&#160;</td><td class="fielddoc"><p>Two components do not couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec"></a>always&#160;</td><td class="fielddoc"><p>Two components do couple. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad31df71a29dd76de9b4ab241b2527160a155b9e72113d7008c60732d350bfbb7a"></a>nonzero&#160;</td><td class="fielddoc"><p>Two components couple only if their shape functions are both nonzero on a given face. This flag is only used when computing integrals over faces of cells, e.g., in <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern()</a>. Use Coupling::always in general cases where gradients etc. occur on face integrals. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="dof__tools_8h_source.html#l00226">226</a> of file <a class="el" href="dof__tools_8h_source.html">dof_tools.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4d7f078a8e828165a7a1ca42570fec22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7f078a8e828165a7a1ca42570fec22">&#9670;&nbsp;</a></span>convert_couplings_to_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::convert_couplings_to_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>table_by_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tables_by_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map a coupling table from the user friendly organization by components to the organization by blocks.</p>
<p>The return vector will be initialized to the correct length inside this function. </p>

</div>
</div>
<a id="a33213fe1b50e1251804521279d69b985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33213fe1b50e1251804521279d69b985">&#9670;&nbsp;</a></span>dof_couplings_from_component_couplings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt;2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a>&gt; DoFTools::dof_couplings_from_component_couplings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_couplings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a finite element and a table how the vector components of it couple with each other, compute and return a table that describes how the individual shape functions couple with each other. </p>

</div>
</div>
<a id="af511a3eef444ad1e88802cd479e11933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af511a3eef444ad1e88802cd479e11933">&#9670;&nbsp;</a></span>dof_couplings_from_component_couplings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classTable.html">Table</a>&lt;2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a>&gt; &gt; DoFTools::dof_couplings_from_component_couplings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_couplings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above for a collection of finite elements, returning a collection of tables.</p>
<p>The function currently treats DoFTools::Couplings::nonzero the same as DoFTools::Couplings::always . </p>

</div>
</div>
<a id="a929249499b1e5624728d212e90a8e037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929249499b1e5624728d212e90a8e037">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceIterator , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; FaceIterator &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>face_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_vector_components</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>periodicity_factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert the (algebraic) constraints due to periodic boundary conditions into an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object <code>constraints</code>.</p>
<p>Given a pair of not necessarily active boundary faces <code>face_1</code> and <code>face_2</code>, this functions constrains all DoFs associated with the boundary described by <code>face_1</code> to the respective DoFs of the boundary described by <code>face_2</code>. More precisely:</p>
<p>If <code>face_1</code> and <code>face_2</code> are both active faces it adds the DoFs of <code>face_1</code> to the list of constrained DoFs in <code>constraints</code> and adds entries to constrain them to the corresponding values of the DoFs on <code>face_2</code>. This happens on a purely algebraic level, meaning, the global DoF with (local face) index <code>i</code> on <code>face_1</code> gets constraint to the DoF with (local face) index <code>i</code> on <code>face_2</code> (possibly corrected for orientation, see below).</p>
<p>Otherwise, if <code>face_1</code> and <code>face_2</code> are not active faces, this function loops recursively over the children of <code>face_1</code> and <code>face_2</code>. If only one of the two faces is active, then we recursively iterate over the children of the non-active ones and make sure that the solution function on the refined side equals that on the non-refined face in much the same way as we enforce hanging node constraints at places where differently refined cells come together. (However, unlike hanging nodes, we do not enforce the requirement that there be only a difference of one refinement level between the two sides of the domain you would like to be periodic).</p>
<p>This routine only constrains DoFs that are not already constrained. If this routine encounters a DoF that already is constrained (for instance by Dirichlet boundary conditions), the old setting of the constraint (dofs the entry is constrained to, inhomogeneities) is kept and nothing happens.</p>
<p>The flags in the <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>) denote which components of the finite element space shall be constrained with periodic boundary conditions. If it is left as specified by the default value all components are constrained. If it is different from the default value, it is assumed that the number of entries equals the number of components of the finite element. This can be used to enforce periodicity in only one variable in a system of equations.</p>
<p><code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> describe an orientation that should be applied to <code>face_1</code> prior to matching and constraining DoFs. This has nothing to do with the actual orientation of the given faces in their respective cells (which for boundary faces is always the default) but instead how you want to see periodicity to be enforced. For example, by using these flags, you can enforce a condition of the kind \(u(0,y)=u(1,1-y)\) (i.e., a Moebius band) or in 3d a twisted torus. More precisely, these flags match local face DoF indices in the following manner:</p>
<p>In 2d: <code>face_orientation</code> must always be <code>true</code>, <code>face_rotation</code> is always <code>false</code>, and face_flip has the meaning of <code>line_flip</code>; this implies e.g. for <code>Q1</code>:</p>
<div class="fragment"><div class="line">face_orientation = <span class="keyword">true</span>, face_flip = <span class="keyword">false</span>, face_rotation = <span class="keyword">false</span>:</div><div class="line"></div><div class="line">    face1:           face2:</div><div class="line"></div><div class="line">    1                1</div><div class="line">    |        &lt;--&gt;    |</div><div class="line">    0                0</div><div class="line"></div><div class="line">    Resulting constraints: 0 &lt;-&gt; 0, 1 &lt;-&gt; 1</div><div class="line"></div><div class="line">    (Numbers denote local face DoF indices.)</div><div class="line"></div><div class="line"></div><div class="line">face_orientation = <span class="keyword">true</span>, face_flip = <span class="keyword">true</span>, face_rotation = <span class="keyword">false</span>:</div><div class="line"></div><div class="line">    face1:           face2:</div><div class="line"></div><div class="line">    0                1</div><div class="line">    |        &lt;--&gt;    |</div><div class="line">    1                0</div><div class="line"></div><div class="line">    Resulting constraints: 1 &lt;-&gt; 0, 0 &lt;-&gt; 1</div></div><!-- fragment --><p>And similarly for the case of Q1 in 3d:</p>
<div class="fragment"><div class="line">face_orientation = <span class="keyword">true</span>, face_flip = <span class="keyword">false</span>, face_rotation = <span class="keyword">false</span>:</div><div class="line"></div><div class="line">    face1:           face2:</div><div class="line"></div><div class="line">    2 - 3            2 - 3</div><div class="line">    |   |    &lt;--&gt;    |   |</div><div class="line">    0 - 1            0 - 1</div><div class="line"></div><div class="line">    Resulting constraints: 0 &lt;-&gt; 0, 1 &lt;-&gt; 1, 2 &lt;-&gt; 2, 3 &lt;-&gt; 3</div><div class="line"></div><div class="line">    (Numbers denote local face DoF indices.)</div><div class="line"></div><div class="line"></div><div class="line">face_orientation = <span class="keyword">false</span>, face_flip = <span class="keyword">false</span>, face_rotation = <span class="keyword">false</span>:</div><div class="line"></div><div class="line">    face1:           face2:</div><div class="line"></div><div class="line">    1 - 3            2 - 3</div><div class="line">    |   |    &lt;--&gt;    |   |</div><div class="line">    0 - 2            0 - 1</div><div class="line"></div><div class="line">    Resulting constraints: 0 &lt;-&gt; 0, 2 &lt;-&gt; 1, 1 &lt;-&gt; 2, 3 &lt;-&gt; 3</div><div class="line"></div><div class="line"></div><div class="line">face_orientation = <span class="keyword">true</span>, face_flip = <span class="keyword">true</span>, face_rotation = <span class="keyword">false</span>:</div><div class="line"></div><div class="line">    face1:           face2:</div><div class="line"></div><div class="line">    1 - 0            2 - 3</div><div class="line">    |   |    &lt;--&gt;    |   |</div><div class="line">    3 - 2            0 - 1</div><div class="line"></div><div class="line">    Resulting constraints: 3 &lt;-&gt; 0, 2 &lt;-&gt; 1, 1 &lt;-&gt; 2, 0 &lt;-&gt; 3</div><div class="line"></div><div class="line"></div><div class="line">face_orientation = <span class="keyword">true</span>, face_flip = <span class="keyword">false</span>, face_rotation = <span class="keyword">true</span></div><div class="line"></div><div class="line">    face1:           face2:</div><div class="line"></div><div class="line">    0 - 2            2 - 3</div><div class="line">    |   |    &lt;--&gt;    |   |</div><div class="line">    1 - 3            0 - 1</div><div class="line"></div><div class="line">    Resulting constraints: 1 &lt;-&gt; 0, 3 &lt;-&gt; 1, 0 &lt;-&gt; 2, 2 &lt;-&gt; 3</div><div class="line"></div><div class="line">and any combination of that...</div></div><!-- fragment --><p>Optionally a matrix <code>matrix</code> along with a std::vector <code>first_vector_components</code> can be specified that describes how DoFs on <code>face_1</code> should be modified prior to constraining to the DoFs of <code>face_2</code>. Here, two declarations are possible: If the std::vector <code>first_vector_components</code> is non empty the matrix is interpreted as a <code>dim</code> \(\times\) <code>dim</code> rotation matrix that is applied to all vector valued blocks listed in <code>first_vector_components</code> of the <a class="el" href="classFESystem.html">FESystem</a>. If <code>first_vector_components</code> is empty the matrix is interpreted as an interpolation matrix with size no_face_dofs \(\times\) no_face_dofs.</p>
<p>This function makes sure that identity constraints don't create cycles in <code>constraints</code>.</p>
<p><code>periodicity_factor</code> can be used to implement Bloch periodic conditions (a.k.a. phase shift periodic conditions) of the form \(\psi(\mathbf{r})=e^{-i\mathbf{k}\cdot\mathbf{r}}u(\mathbf{r})\) where \(u\) is periodic with the same periodicity as the crystal lattice and \(\mathbf{k}\) is the wavevector, see <a href="https://en.wikipedia.org/wiki/Bloch_wave">https://en.wikipedia.org/wiki/Bloch_wave</a>. The solution at <code>face_2</code> is equal to the solution at <code>face_1</code> times <code>periodicity_factor</code>. For example, if the solution at <code>face_1</code> is \(\psi(0)\) and \(\mathbf{d}\) is the corresponding point on <code>face_2</code>, then the solution at <code>face_2</code> should be \(\psi(d) = \psi(0)e^{-i \mathbf{k}\cdot \mathbf{d}}\). This condition can be implemented using \(\mathrm{periodicity\_factor}=e^{-i \mathbf{k}\cdot \mathbf{d}}\).</p>
<p>Detailed information can be found in the see <a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">Glossary entry on periodic boundary conditions</a>. </p>

</div>
</div>
<a id="a7025d513a21d3d3804f89fdc9c3824a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7025d513a21d3d3804f89fdc9c3824a9">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>periodic_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_vector_components</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>periodicity_factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert the (algebraic) constraints due to periodic boundary conditions into an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object <code>constraints</code>.</p>
<p>This is the main high level interface for above low level variant of <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">make_periodicity_constraints()</a>. It takes a std::vector <code>periodic_faces</code> as argument and applies above <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">make_periodicity_constraints()</a> on each entry. <code>periodic_faces</code> can be created by <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>.</p>
<dl class="section note"><dt>Note</dt><dd>For <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that are built on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ba7cf46ec43269f5ba430e91996d065">parallel::distributed::Triangulation::add_periodicity</a> has to be called before calling this function..</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">Glossary entry on periodic boundary conditions</a> and step-45 for further information. </dd></dl>

</div>
</div>
<a id="a918a8dc3733662a03c0113296567564f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918a8dc3733662a03c0113296567564f">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; typename DoFHandlerType::cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>periodic_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_vector_components</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>periodicity_factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as above.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Use the function that takes dim and spacedim as template argument. </dd></dl>

</div>
</div>
<a id="aaa354b2b7e406e68c04c6e6ea07931f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa354b2b7e406e68c04c6e6ea07931f2">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>periodicity_factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert the (algebraic) constraints due to periodic boundary conditions into a <a class="el" href="classAffineConstraints.html">AffineConstraints</a> <code>constraints</code>.</p>
<p>This function serves as a high level interface for the <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">make_periodicity_constraints()</a> function.</p>
<p>Define a 'first' boundary as all boundary faces having boundary_id <code>b_id1</code> and a 'second' boundary consisting of all faces belonging to <code>b_id2</code>.</p>
<p>This function tries to match all faces belonging to the first boundary with faces belonging to the second boundary with the help of <a class="el" href="namespaceGridTools.html#ac2a1903382c6cff07b33d456a641f6d9">orthogonal_equality()</a>. More precisely, faces with coordinates only differing in the <code>direction</code> component are identified.</p>
<p>If this matching is successful it constrains all DoFs associated with the 'first' boundary to the respective DoFs of the 'second' boundary respecting the relative orientation of the two faces.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a convenience wrapper. It internally calls <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces()</a> with the supplied parameters and feeds the output to above <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">make_periodicity_constraints()</a> variant. If you need more functionality use <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces()</a> directly.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">Glossary entry on periodic boundary conditions</a> for further information. </dd></dl>

</div>
</div>
<a id="afa423b8e89505de76ca7d2ca0f53faa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa423b8e89505de76ca7d2ca0f53faa1">&#9670;&nbsp;</a></span>make_periodicity_constraints() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_periodicity_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>periodicity_factor</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This compatibility version of make_periodicity_constraints only works on grids with cells in <a class="el" href="DEALGlossary.html#GlossFaceOrientation">standard orientation</a>.</p>
<p>Instead of defining a 'first' and 'second' boundary with the help of two boundary_ids this function defines a 'left' boundary as all faces with local face index <code>2*dimension</code> and boundary indicator <code>b_id</code> and, similarly, a 'right' boundary consisting of all face with local face index <code>2*dimension+1</code> and boundary indicator <code>b_id</code>. Faces with coordinates only differing in the <code>direction</code> component are identified.</p>
<dl class="section note"><dt>Note</dt><dd>This version of make_periodicity_constraints will not work on meshes with cells not in <a class="el" href="DEALGlossary.html#GlossFaceOrientation">standard orientation</a>.</dd>
<dd>
This function is a convenience wrapper. It internally calls <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces()</a> with the supplied parameters and feeds the output to above <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">make_periodicity_constraints()</a> variant. If you need more functionality use <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces()</a> directly.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">Glossary entry on periodic boundary conditions</a> for further information. </dd></dl>

</div>
</div>
<a id="aed6928cb7bdb5a85e8670d6bd5c90e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6928cb7bdb5a85e8670d6bd5c90e24">&#9670;&nbsp;</a></span>extract_hanging_node_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::extract_hanging_node_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an <a class="el" href="classIndexSet.html">IndexSet</a> describing all dofs that will be constrained by interface constraints, i.e. all hanging nodes.</p>
<p>In case of a <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> or a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> only locally relevant dofs are considered. </p>

</div>
</div>
<a id="a45f4d01f1c4c6337e4be6f10a81fbdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f4d01f1c4c6337e4be6f10a81fbdab">&#9670;&nbsp;</a></span>extract_dofs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::extract_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the (locally owned) indices of the degrees of freedom belonging to certain vector components of a vector-valued finite element. The <code>component_mask</code> defines which components or blocks of an <a class="el" href="classFESystem.html">FESystem</a> or vector-valued element are to be extracted from the <a class="el" href="classDoFHandler.html">DoFHandler</a> <code>dof</code>. The entries in the output object then correspond to degrees of freedom belonging to these components.</p>
<p>If the finite element under consideration is not primitive, i.e., some or all of its shape functions are non-zero in more than one vector component (which holds, for example, for <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> or <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> elements), then shape functions cannot be associated with a single vector component. In this case, if <em>one</em> shape vector component of this element is flagged in <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>), then this is equivalent to selecting <em>all</em> vector components corresponding to this non-primitive base element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> whose enumerated degrees of freedom are to be filtered by this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask</td><td>A mask that states which components you want to select. The size of this mask must be compatible with the number of components in the <a class="el" href="classFiniteElement.html">FiniteElement</a> used by the <code>dof_handler</code>. See <a class="el" href="DEALGlossary.html#GlossComponentMask">the glossary entry on component masks</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classIndexSet.html">IndexSet</a> object that will contain exactly those entries that (i) correspond to degrees of freedom selected by the mask above, and (ii) are locally owned. The size of the index set is equal to the global number of degrees of freedom. Note that the resulting object is always a subset of what <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> returns. </dd></dl>

</div>
</div>
<a id="a63ec0cf2cf5feceaddf484a5d72126ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ec0cf2cf5feceaddf484a5d72126ab">&#9670;&nbsp;</a></span>extract_dofs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::extract_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>block_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the equivalent to the <a class="el" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs()</a> functions above except that the selection of which degrees of freedom to extract is not done based on components (see <a class="el" href="DEALGlossary.html#GlossComponent">GlossComponent</a>) but instead based on whether they are part of a particular block (see <a class="el" href="DEALGlossary.html#GlossBlock">GlossBlock</a>). Consequently, the second argument is not a <a class="el" href="classComponentMask.html">ComponentMask</a> but a <a class="el" href="classBlockMask.html">BlockMask</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> whose enumerated degrees of freedom are to be filtered by this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_mask</td><td>A mask that states which blocks you want to select. The size of this mask must be compatible with the number of blocks in the <a class="el" href="classFiniteElement.html">FiniteElement</a> used by the <code>dof_handler</code>. See <a class="el" href="DEALGlossary.html#GlossBlockMask">the glossary entry on block masks</a> for more information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classIndexSet.html">IndexSet</a> object that will contain exactly those entries that (i) correspond to degrees of freedom selected by the mask above, and (ii) are locally owned. The size of the index set is equal to the global number of degrees of freedom. Note that the resulting object is always a subset of what <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> returns. </dd></dl>

</div>
</div>
<a id="a86b041e2441000ccd13f2dad06537678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b041e2441000ccd13f2dad06537678">&#9670;&nbsp;</a></span>extract_level_dofs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_level_dofs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do the same thing as the corresponding <a class="el" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">extract_dofs()</a> function for one level of a multi-grid DoF numbering. </p>

</div>
</div>
<a id="af4f492fd7f9f9511f3b5c38dc5d9fefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f492fd7f9f9511f3b5c38dc5d9fefa">&#9670;&nbsp;</a></span>extract_level_dofs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_level_dofs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do the same thing as the corresponding <a class="el" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">extract_dofs()</a> function for one level of a multi-grid DoF numbering. </p>

</div>
</div>
<a id="a06b3c33925c1a1f15de20deda20b4d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b3c33925c1a1f15de20deda20b4d21">&#9670;&nbsp;</a></span>extract_boundary_dofs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_boundary_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract all degrees of freedom which are at the boundary and belong to specified components of the solution. The function returns its results in the last non-default-valued parameter which contains <code>true</code> if a degree of freedom is at the boundary and belongs to one of the selected components, and <code>false</code> otherwise.</p>
<p>By specifying the <code>boundary_ids</code> variable, you can select which boundary indicators the faces have to have on which the degrees of freedom are located that shall be extracted. If it is an empty list, then all boundary indicators are accepted.</p>
<p>The size of <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>) shall equal the number of components in the finite element used by <code>dof</code>. The size of <code>selected_dofs</code> shall equal <code>dof_handler.n_dofs()</code>. Previous contents of this array are overwritten.</p>
<p>Using the usual convention, if a shape function is non-zero in more than one component (i.e. it is non-primitive), then the element in the component mask is used that corresponds to the first non-zero components. Elements in the mask corresponding to later components are ignored.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>This function will not work for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects that are built on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object. The reasons is that the output argument <code>selected_dofs</code> has to have a length equal to <em>all</em> global degrees of freedom. Consequently, this does not scale to very large problems, and this is also why the function is deprecated. If you need the functionality of this function for parallel triangulations, then you need to use the other <a class="el" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs()</a> function that returns its information via an <a class="el" href="classIndexSet.html">IndexSet</a> object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The object that describes which degrees of freedom live on which cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask</td><td>A mask denoting the vector components of the finite element that should be considered (see also <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selected_dofs</td><td>A vector of booleans that is returned and for which an element will be <code>true</code> if the corresponding index is a degree of freedom that is located on the boundary (and correspond to the selected vector components and boundary indicators, depending on the values of the <code>component_mask</code> and <code>boundary_ids</code> arguments). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_ids</td><td>If empty, this function extracts the indices of the degrees of freedom for all parts of the boundary. If it is a non- empty list, then the function only considers boundary faces with the boundary indicators listed in this argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="a05eb3b759a0491c2087cf3befcc39cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05eb3b759a0491c2087cf3befcc39cc4">&#9670;&nbsp;</a></span>extract_boundary_dofs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::extract_boundary_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract all degrees of freedom which are at the boundary and belong to specified components of the solution. The function returns its results in the form of an <a class="el" href="classIndexSet.html">IndexSet</a> that contains those entries that correspond to these selected degrees of freedom, i.e., which are at the boundary and belong to one of the selected components.</p>
<p>By specifying the <code>boundary_ids</code> variable, you can select which boundary indicators the faces have to have on which the degrees of freedom are located that shall be extracted. If it is an empty list (the default), then all boundary indicators are accepted.</p>
<p>This function is used in step-11 and step-15, for example.</p>
<dl class="section note"><dt>Note</dt><dd>If the <a class="el" href="classDoFHandler.html">DoFHandler</a> object is defined on a parallel <a class="el" href="classTriangulation.html">Triangulation</a> object, then the computed index set will contain only those degrees of freedom on the boundary that belong to the locally relevant set (see <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs</a>), i.e., the function only considers faces of locally owned and ghost cells, but not of artificial cells.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The object that describes which degrees of freedom live on which cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask</td><td>A mask denoting the vector components of the finite element that should be considered (see also <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>). If left at the default, the component mask indicates that all vector components of the finite element should be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_ids</td><td>If empty, this function extracts the indices of the degrees of freedom for all parts of the boundary. If it is a non-empty list, then the function only considers boundary faces with the boundary indicators listed in this argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classIndexSet.html">IndexSet</a> object that will contain the indices of degrees of freedom that are located on the boundary (and correspond to the selected vector components and boundary indicators, depending on the values of the <code>component_mask</code> and <code>boundary_ids</code> arguments).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="a905daad9c1cf1db522610811cd555b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905daad9c1cf1db522610811cd555b56">&#9670;&nbsp;</a></span>extract_boundary_dofs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_boundary_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as the previous function, except that it returns its information via the third argument.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Use the previous function instead. </dd></dl>

</div>
</div>
<a id="a8b97e816b29ecf963370a9d8b349828f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b97e816b29ecf963370a9d8b349828f">&#9670;&nbsp;</a></span>extract_dofs_with_support_on_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_dofs_with_support_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to the <a class="el" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">extract_boundary_dofs()</a> function but it extracts those degrees of freedom whose shape functions are nonzero on at least part of the selected boundary. For continuous elements, this is exactly the set of shape functions whose degrees of freedom are defined on boundary faces. On the other hand, if the finite element in used is a discontinuous element, all degrees of freedom are defined in the inside of cells and consequently none would be boundary degrees of freedom. Several of those would have shape functions that are nonzero on the boundary, however. This function therefore extracts all those for which the <a class="el" href="classFiniteElement.html#a68dc9f085edbcd92f8d0703d3e5fce6f">FiniteElement::has_support_on_face</a> function says that it is nonzero on any face on one of the selected boundary parts.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="a097aa54937055733af934542b5c76e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097aa54937055733af934542b5c76e35">&#9670;&nbsp;</a></span>extract_dofs_with_support_contained_within()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::extract_dofs_with_support_contained_within </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;number&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract all indices of shape functions such that their support is entirely contained within the cells for which the <code>predicate</code> is <code>true</code>. The result is returned as an <a class="el" href="classIndexSet.html">IndexSet</a>.</p>
<p>Consider the following FE space where predicate returns <code>true</code> for all cells on the left half of the domain:</p>
<div class="image">
<img src="extract_dofs_with_support_contained_within.png" alt="extract_dofs_with_support_contained_within.png"/>
</div>
<p>This functions will return the union of all DoF indices on those cells minus DoF 11, 13, 2 and 0; the result will be <code>[9,10], 12, [14,38]</code>. In the image above the returned DoFs are separated from the rest by the red line</p>
<p>Essentially, the question this functions answers is the following: Given a subdomain with associated DoFs, what is the largest subset of these DoFs that are allowed to be non-zero such that after calling <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> the resulting solution vector will have support only within the given domain. Here, <code>constraints</code> is the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> container containing hanging nodes constraints.</p>
<p>In case of <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> <code>predicate</code> will be called only for locally owned and ghost cells. The resulting index set may contain DoFs that are associated with the locally owned or ghost cells, but are not owned by the current MPI core. </p>

</div>
</div>
<a id="afc96893388fe1a55c6ae5ae19ba52c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc96893388fe1a55c6ae5ae19ba52c6d">&#9670;&nbsp;</a></span>extract_constant_modes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_constant_modes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>constant_modes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract a vector that represents the constant modes of the <a class="el" href="classDoFHandler.html">DoFHandler</a> for the components chosen by <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>). The constant modes on a discretization are the null space of a Laplace operator on the selected components with Neumann boundary conditions applied. The null space is a necessary ingredient for obtaining a good AMG preconditioner when using the class <a class="el" href="classTrilinosWrappers_1_1PreconditionAMG.html">TrilinosWrappers::PreconditionAMG</a>. Since the ML AMG package only works on algebraic properties of the respective matrix, it has no chance to detect whether the matrix comes from a scalar or a vector valued problem. However, a near null space supplies exactly the needed information about the components placement of vector components within the matrix. The null space (or rather, the constant modes) is provided by the finite element underlying the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and for most elements, the null space will consist of as many vectors as there are true arguments in <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>), each of which will be one in one vector component and zero in all others. However, the representation of the constant function for e.g. <a class="el" href="classFE__DGP.html">FE_DGP</a> is different (the first component on each element one, all other components zero), and some scalar elements may even have two constant modes (<a class="el" href="classFE__Q__DG0.html">FE_Q_DG0</a>). Therefore, we store this object in a vector of vectors, where the outer vector contains the collection of the actual constant modes on the <a class="el" href="classDoFHandler.html">DoFHandler</a>. Each inner vector has as many components as there are (locally owned) degrees of freedom in the selected components. Note that any matrix associated with this null space must have been constructed using the same <code>component_mask</code> argument, since the numbering of DoFs is done relative to the selected dofs, not to all dofs.</p>
<p>The main reason for this program is the use of the null space with the AMG preconditioner. </p>

</div>
</div>
<a id="a6f9a91bfa884faa7a62acc8ff789f40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9a91bfa884faa7a62acc8ff789f40e">&#9670;&nbsp;</a></span>extract_subdomain_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_subdomain_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag all those degrees of freedom which are on cells with the given subdomain id. Note that DoFs on faces can belong to cells with differing subdomain ids, so the sets of flagged degrees of freedom are not mutually exclusive for different subdomain ids.</p>
<p>If you want to get a unique association of degree of freedom with subdomains, use the <code>get_subdomain_association</code> function. </p>

</div>
</div>
<a id="a5f745d25d2397a91dc65b9158b8d77a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f745d25d2397a91dc65b9158b8d77a6">&#9670;&nbsp;</a></span>extract_locally_active_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_locally_active_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the set of global DoF indices that are active on the current <a class="el" href="classDoFHandler.html">DoFHandler</a>. For regular DoFHandlers, these are all DoF indices, but for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> this set is a superset of <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> and contains all DoF indices that live on all locally owned cells (including on the interface to ghost cells). However, it does not contain the DoF indices that are exclusively defined on ghost or artificial cells (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">the glossary</a>).</p>
<p>The degrees of freedom identified by this function equal those obtained from the <a class="el" href="namespaceDoFTools.html#a0a84027251b470f94bcaf1f00e04e722">dof_indices_with_subdomain_association()</a> function when called with the locally owned subdomain id. </p>

</div>
</div>
<a id="af778defeb024f32c1e3500963936639f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af778defeb024f32c1e3500963936639f">&#9670;&nbsp;</a></span>extract_locally_active_level_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_locally_active_level_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above but for a certain (multigrid-)level. This function returns all DoF indices that live on all locally owned cells (including on the interface to ghost cells) on the given level. </p>

</div>
</div>
<a id="acad7e0841b9046eaafddc4c617ab1d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad7e0841b9046eaafddc4c617ab1d9d">&#9670;&nbsp;</a></span>extract_locally_relevant_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_locally_relevant_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the set of global DoF indices that are active on the current <a class="el" href="classDoFHandler.html">DoFHandler</a>. For regular DoFHandlers, these are all DoF indices, but for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> this set is the union of <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> and the DoF indices on all ghost cells. In essence, it is the DoF indices on all cells that are not artificial (see <a class="el" href="DEALGlossary.html#GlossArtificialCell">the glossary</a>). </p>

</div>
</div>
<a id="adbf4d7a693cce69de01042c224e8efc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf4d7a693cce69de01042c224e8efc8">&#9670;&nbsp;</a></span>locally_owned_dofs_per_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classIndexSet.html">IndexSet</a>&gt; DoFTools::locally_owned_dofs_per_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>components</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the set of locally owned DoF indices for each component within the mask that are owned by the current processor. For components disabled by the mask, an empty <a class="el" href="classIndexSet.html">IndexSet</a> is returned. For a scalar <a class="el" href="classDoFHandler.html">DoFHandler</a> built on a sequential triangulation, the return vector contains a single complete <a class="el" href="classIndexSet.html">IndexSet</a> with all DoF indices. If the mask contains all components (which also corresponds to the default value), then the union of the returned index sets equlas what <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> returns. </p>

</div>
</div>
<a id="af2f8c5a33e13ed61dd565b1cac978b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f8c5a33e13ed61dd565b1cac978b7c">&#9670;&nbsp;</a></span>locally_owned_dofs_per_subdomain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classIndexSet.html">IndexSet</a>&gt; DoFTools::locally_owned_dofs_per_subdomain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each processor, determine the set of locally owned degrees of freedom as an <a class="el" href="classIndexSet.html">IndexSet</a>. This function then returns a vector of index sets, where the vector has size equal to the number of MPI processes that participate in the DoF handler object.</p>
<p>The function can be used for objects of type <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a>. It will not work for objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since for such triangulations we do not have information about all cells of the triangulation available locally, and consequently can not say anything definitive about the degrees of freedom active on other processors' locally owned cells. </p>

</div>
</div>
<a id="af94d91fe4dcc3b3ad0fbe73a4f5ec93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94d91fe4dcc3b3ad0fbe73a4f5ec93c">&#9670;&nbsp;</a></span>locally_relevant_dofs_per_subdomain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classIndexSet.html">IndexSet</a>&gt; DoFTools::locally_relevant_dofs_per_subdomain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each processor, determine the set of locally relevant degrees of freedom as an <a class="el" href="classIndexSet.html">IndexSet</a>. This function then returns a vector of index sets, where the vector has size equal to the number of MPI processes that participate in the DoF handler object.</p>
<p>The function can be used for objects of type <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a>. It will not work for objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since for such triangulations we do not have information about all cells of the triangulation available locally, and consequently can not say anything definitive about the degrees of freedom active on other processors' locally owned cells. </p>

</div>
</div>
<a id="a1fef7be07cf379b661646e39b9354e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fef7be07cf379b661646e39b9354e17">&#9670;&nbsp;</a></span>extract_locally_relevant_level_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::extract_locally_relevant_level_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dof_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">extract_locally_relevant_dofs()</a> but for multigrid DoFs for the given <code>level</code>. </p>

</div>
</div>
<a id="a0429b3117b2ab1f5a1fd0d55de26ad81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0429b3117b2ab1f5a1fd0d55de26ad81">&#9670;&nbsp;</a></span>get_subdomain_association()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::get_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each degree of freedom, return in the output array to which subdomain (as given by the <code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code> function) it belongs. The output array is supposed to have the right size already when calling this function.</p>
<p>Note that degrees of freedom associated with faces, edges, and vertices may be associated with multiple subdomains if they are sitting on partition boundaries. In these cases, we assign them to the process with the smaller subdomain id. This may lead to different numbers of degrees of freedom in partitions, even if the number of cells is perfectly equidistributed. While this is regrettable, it is not a problem in practice since the number of degrees of freedom on partition boundaries is asymptotically vanishing as we refine the mesh as long as the number of partitions is kept constant.</p>
<p>This function returns the association of each DoF with one subdomain. If you are looking for the association of each <em>cell</em> with a subdomain, either query the <code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code> function, or use the <code><a class="el" href="namespaceGridTools.html#a74728f76ec58b9956ca0a8f0dc06dfa1">GridTools::get_subdomain_association</a></code> function.</p>
<p>Note that this function is of questionable use for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since in that case ownership of individual degrees of freedom by MPI processes is controlled by the DoF handler object, not based on some geometric algorithm in conjunction with subdomain id. In particular, the degrees of freedom identified by the functions in this namespace as associated with a subdomain are not the same the <a class="el" href="classDoFHandler.html">DoFHandler</a> class identifies as those it owns. </p>

</div>
</div>
<a id="ac704c6d311cd0f289d625427e03708ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac704c6d311cd0f289d625427e03708ac">&#9670;&nbsp;</a></span>count_dofs_with_subdomain_association() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> DoFTools::count_dofs_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many degrees of freedom are uniquely associated with the given <code>subdomain</code> index.</p>
<p>Note that there may be rare cases where cells with the given <code>subdomain</code> index exist, but none of its degrees of freedom are actually associated with it. In that case, the returned value will be zero.</p>
<p>This function will generate an exception if there are no cells with the given <code>subdomain</code> index.</p>
<p>This function returns the number of DoFs associated with one subdomain. If you are looking for the association of <em>cells</em> with this subdomain, use the <code><a class="el" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">GridTools::count_cells_with_subdomain_association</a></code> function.</p>
<p>Note that this function is of questionable use for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since in that case ownership of individual degrees of freedom by MPI processes is controlled by the DoF handler object, not based on some geometric algorithm in conjunction with subdomain id. In particular, the degrees of freedom identified by the functions in this namespace as associated with a subdomain are not the same the <a class="el" href="classDoFHandler.html">DoFHandler</a> class identifies as those it owns. </p>

</div>
</div>
<a id="ad38e53eb1c27d67f5e341399356edb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38e53eb1c27d67f5e341399356edb55">&#9670;&nbsp;</a></span>count_dofs_with_subdomain_association() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::count_dofs_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_dofs_on_subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many degrees of freedom are uniquely associated with the given <code>subdomain</code> index.</p>
<p>This function does what the previous one does except that it splits the result among the vector components of the finite element in use by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object. The last argument (which must have a length equal to the number of vector components) will therefore store how many degrees of freedom of each vector component are associated with the given subdomain.</p>
<p>Note that this function is of questionable use for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since in that case ownership of individual degrees of freedom by MPI processes is controlled by the DoF handler object, not based on some geometric algorithm in conjunction with subdomain id. In particular, the degrees of freedom identified by the functions in this namespace as associated with a subdomain are not the same the <a class="el" href="classDoFHandler.html">DoFHandler</a> class identifies as those it owns. </p>

</div>
</div>
<a id="a0a84027251b470f94bcaf1f00e04e722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a84027251b470f94bcaf1f00e04e722">&#9670;&nbsp;</a></span>dof_indices_with_subdomain_association()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> DoFTools::dof_indices_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a set of indices that denotes the degrees of freedom that live on the given subdomain, i.e. that are on cells owned by the current processor. Note that this includes the ones that this subdomain "owns" (i.e. the ones for which <a class="el" href="namespaceDoFTools.html#a0429b3117b2ab1f5a1fd0d55de26ad81">get_subdomain_association()</a> returns a value equal to the subdomain given here and that are selected by the <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a> function) but also all of those that sit on the boundary between the given subdomain and other subdomain. In essence, degrees of freedom that sit on boundaries between subdomain will be in the index sets returned by this function for more than one subdomain.</p>
<p>Note that this function is of questionable use for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects built on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> since in that case ownership of individual degrees of freedom by MPI processes is controlled by the DoF handler object, not based on some geometric algorithm in conjunction with subdomain id. In particular, the degrees of freedom identified by the functions in this namespace as associated with a subdomain are not the same the <a class="el" href="classDoFHandler.html">DoFHandler</a> class identifies as those it owns. </p>

</div>
</div>
<a id="ad814274d3f9e209587ee1dba0f488b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad814274d3f9e209587ee1dba0f488b76">&#9670;&nbsp;</a></span>get_dofs_on_patch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&gt; DoFTools::get_dofs_on_patch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the set of degrees of freedom that live on a set of cells (i.e., a patch) described by the argument.</p>
<p>Patches are often used in defining error estimators that require the solution of a local problem on the patch surrounding each of the cells of the mesh. You can get a list of cells that form the patch around a given cell using <a class="el" href="namespaceGridTools.html#aea0b44d8461b32e6d3d90e2e02028e62">GridTools::get_patch_around_cell()</a>. While <a class="el" href="namespaceDoFTools.html#acf3d202ccd39aea458a476dd0928fb15">DoFTools::count_dofs_on_patch()</a> can be used to determine the size of these local problems, so that one can assemble the local system and then solve it, it is still necessary to provide a mapping between the global indices of the degrees of freedom that live on the patch and a local enumeration. This function provides such a local enumeration by returning the set of degrees of freedom that live on the patch.</p>
<p>Since this set is returned in the form of a std::vector, one can also think of it as a mapping </p><div class="fragment"><div class="line">i -&gt; <a class="code" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">global_dof_index</a></div></div><!-- fragment --><p> where <code>i</code> is an index into the returned vector (i.e., a the <em>local</em> index of a degree of freedom on the patch) and <code>global_dof_index</code> is the global index of a degree of freedom located on the patch. The array returned has size equal to <a class="el" href="namespaceDoFTools.html#acf3d202ccd39aea458a476dd0928fb15">DoFTools::count_dofs_on_patch()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The array returned is sorted by global DoF index. Consequently, if one considers the index into this array a local DoF index, then the local system that results retains the block structure of the global system.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>A collection of cells within an object of type <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler&lt;dim, spacedim&gt;::active_cell_iterator</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of those global degrees of freedom located on the patch, as defined above.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the context of a parallel distributed computation, it only makes sense to call this function on patches around locally owned cells. This is because the neighbors of locally owned cells are either locally owned themselves, or ghost cells. For both, we know that these are in fact the real cells of the complete, parallel triangulation. We can also query the degrees of freedom on these. In other words, this function can only work if all cells in the patch are either locally owned or ghost cells. </dd></dl>

</div>
</div>
<a id="adf4d7fd8aba5cbf92b6f24c757cf9f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4d7fd8aba5cbf92b6f24c757cf9f23">&#9670;&nbsp;</a></span>get_dofs_on_patch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&gt; DoFTools::get_dofs_on_patch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as above.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>Use the function that takes dim and spacedim as template argument. </dd></dl>

</div>
</div>
<a id="a43ee44769769065bc594d1730477a4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ee44769769065bc594d1730477a4b9">&#9670;&nbsp;</a></span>make_cell_patches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_cell_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a sparsity pattern, which lists the degrees of freedom associated to each cell on the given level. This pattern can be used in <a class="el" href="classRelaxationBlock.html">RelaxationBlock</a> classes as block list for additive and multiplicative Schwarz methods.</p>
<p>The row index in this pattern is the cell index resulting from standard iteration through a level of the <a class="el" href="classTriangulation.html">Triangulation</a>. For a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, only locally owned cells are entered.</p>
<p>The sparsity pattern is resized in this function to contain as many rows as there are locally owned cells on a given level, as many columns as there are degrees of freedom on this level.</p>
<p><code>selected_dofs</code> is a vector indexed by the local degrees of freedom on a cell. If it is used, only such dofs are entered into the block list which are selected. This allows for instance the exclusion of components or of dofs on the boundary. </p>

</div>
</div>
<a id="aedcb9366f2820c6d99017bbe22aec790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcb9366f2820c6d99017bbe22aec790">&#9670;&nbsp;</a></span>make_vertex_patches() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; DoFTools::make_vertex_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>interior_dofs_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>boundary_patches</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>level_boundary_patches</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>single_cell_patches</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>invert_vertex_mapping</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an incidence matrix that for every vertex on a given level of a multilevel <a class="el" href="classDoFHandler.html">DoFHandler</a> flags which degrees of freedom are associated with the adjacent cells. This data structure is a matrix with as many rows as there are vertices on a given level, as many columns as there are degrees of freedom on this level, and entries that are either true or false. This data structure is conveniently represented by a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object. The sparsity pattern may be empty when entering this function and will be reinitialized to the correct size.</p>
<p>The function has some boolean arguments (listed below) controlling details of the generated patches. The default settings are those for Arnold-Falk-Winther type smoothers for divergence and curl conforming finite elements with essential boundary conditions. Other applications are possible, in particular changing <code>boundary_patches</code> for non- essential boundary conditions.</p>
<p>This function returns the <code>vertex_mapping</code>, that contains the mapping from the vertex indices to the block indices of the <code>block_list</code>. For vertices that do not lead to a vertex patch, the entry in <code>vertex_mapping</code> contains the value <code>invalid_unsigned_int</code>. If <code>invert_vertex_mapping</code> is set to <code>true</code>, then the <code>vertex_mapping</code> is inverted such that it contains the mapping from the block indices to the corresponding vertex indices.</p>
<ul>
<li><code>block_list</code>: the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> into which the patches will be stored.</li>
</ul>
<ul>
<li><code>dof_handler</code>: the multilevel dof handler providing the topology operated on.</li>
</ul>
<ul>
<li><code>interior_dofs_only</code>: for each patch of cells around a vertex, collect only the interior degrees of freedom of the patch and disregard those on the boundary of the patch. This is for instance the setting for smoothers of Arnold-Falk-Winther type.</li>
</ul>
<ul>
<li><code>boundary_patches</code>: include patches around vertices at the boundary of the domain. If not, only patches around interior vertices will be generated.</li>
</ul>
<ul>
<li><code>level_boundary_patches</code>: same for refinement edges towards coarser cells.</li>
</ul>
<ul>
<li><code>single_cell_patches</code>: if not true, patches containing a single cell are eliminated.</li>
</ul>
<ul>
<li><code>invert_vertex_mapping</code>: if true, then the return value contains one vertex index for each block; if false, then the return value contains one block index or <code>invalid_unsigned_int</code> for each vertex. </li>
</ul>

</div>
</div>
<a id="af38f199c5a12f531d73933a3ec0d52fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38f199c5a12f531d73933a3ec0d52fd">&#9670;&nbsp;</a></span>make_vertex_patches() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; DoFTools::make_vertex_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMask.html">BlockMask</a> &amp;&#160;</td>
          <td class="paramname"><em>exclude_boundary_dofs</em> = <code><a class="el" href="classBlockMask.html">BlockMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>boundary_patches</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>level_boundary_patches</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>single_cell_patches</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>invert_vertex_mapping</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but allows boundary dofs on blocks to be excluded individually.</p>
<p>This is helpful if you want to use, for example, Taylor Hood elements as it allows you to not include the boundary DoFs for the velocity block on the patches while also letting you include the boundary DoFs for the pressure block.</p>
<p>For each patch of cells around a vertex, collect all of the interior degrees of freedom of the patch and disregard those on the boundary of the patch if the boolean value for the corresponding block in the <a class="el" href="classBlockMask.html">BlockMask</a> of <code>exclude_boundary_dofs</code> is false. </p>

</div>
</div>
<a id="a97fef09370d666eccd7f811d6df8d748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fef09370d666eccd7f811d6df8d748">&#9670;&nbsp;</a></span>make_child_patches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_child_patches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>interior_dofs_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>boundary_dofs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an incidence matrix that for every cell on a given level of a multilevel <a class="el" href="classDoFHandler.html">DoFHandler</a> flags which degrees of freedom are associated with children of this cell. This data structure is conveniently represented by a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object.</p>
<p>The function thus creates a sparsity pattern which in each row (with rows corresponding to the cells on this level) lists the degrees of freedom associated to the cells that are the children of this cell. The DoF indices used here are level dof indices of a multilevel hierarchy, i.e., they may be associated with children that are not themselves active. The sparsity pattern may be empty when entering this function and will be reinitialized to the correct size.</p>
<p>The function has some boolean arguments (listed below) controlling details of the generated patches. The default settings are those for Arnold-Falk-Winther type smoothers for divergence and curl conforming finite elements with essential boundary conditions. Other applications are possible, in particular changing <code>boundary_dofs</code> for non- essential boundary conditions.</p>
<ul>
<li><code>block_list</code>: the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> into which the patches will be stored.</li>
</ul>
<ul>
<li><code>dof_handler</code>: The multilevel dof handler providing the topology operated on.</li>
</ul>
<ul>
<li><code>interior_dofs_only</code>: for each patch of cells around a vertex, collect only the interior degrees of freedom of the patch and disregard those on the boundary of the patch. This is for instance the setting for smoothers of Arnold-Falk-Winther type.</li>
</ul>
<ul>
<li><code>boundary_dofs</code>: include degrees of freedom, which would have excluded by <code>interior_dofs_only</code>, but are lying on the boundary of the domain, and thus need smoothing. This parameter has no effect if <code>interior_dofs_only</code> is false. </li>
</ul>

</div>
</div>
<a id="ab270041c339a188ba4cb050f0c561737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab270041c339a188ba4cb050f0c561737">&#9670;&nbsp;</a></span>make_single_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_single_patch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>block_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>interior_dofs_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a block list with only a single patch, which in turn contains all degrees of freedom on the given level.</p>
<p>This function is mostly a closure on level 0 for functions like <a class="el" href="namespaceDoFTools.html#a97fef09370d666eccd7f811d6df8d748">make_child_patches()</a> and <a class="el" href="namespaceDoFTools.html#aedcb9366f2820c6d99017bbe22aec790">make_vertex_patches()</a>, which may produce an empty patch list.</p>
<ul>
<li><code>block_list</code>: the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> into which the patches will be stored.</li>
</ul>
<ul>
<li><code>dof_handler</code>: The multilevel dof handler providing the topology operated on.</li>
</ul>
<ul>
<li><code>level</code> The grid level used for building the list.</li>
</ul>
<ul>
<li><code>interior_dofs_only</code>: if true, exclude degrees of freedom on the boundary of the domain. </li>
</ul>

</div>
</div>
<a id="a1a0e02ae500ed576dd9487e846c9f5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0e02ae500ed576dd9487e846c9f5b6">&#9670;&nbsp;</a></span>count_dofs_per_fe_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&gt; DoFTools::count_dofs_per_fe_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>vector_valued_once</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_component</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many degrees of freedom out of the total number belong to each component. If the number of components the finite element has is one (i.e. you only have one scalar variable), then the number in this component obviously equals the total number of degrees of freedom. Otherwise, the sum of the DoFs in all the components needs to equal the total number.</p>
<p>However, the last statement does not hold true if the finite element is not primitive, i.e. some or all of its shape functions are non-zero in more than one vector component. This applies, for example, to the Nedelec or Raviart-Thomas elements. In this case, a degree of freedom is counted in each component in which it is non-zero, so that the sum mentioned above is greater than the total number of degrees of freedom.</p>
<p>This behavior can be switched off by the optional parameter <code>vector_valued_once</code>. If this is <code>true</code>, the number of components of a nonprimitive vector valued element is collected only in the first component. All other components will have a count of zero.</p>
<p>The additional optional argument <code>target_component</code> allows for a re- sorting and grouping of components. To this end, it contains for each component the component number it shall be counted as. Having the same number entered several times sums up several components as the same. One of the applications of this argument is when you want to form block matrices and vectors, but want to pack several components into the same block (for example, when you have <code>dim</code> velocities and one pressure, to put all velocities into one block, and the pressure into another).</p>
<p>The result is returned in <code>dofs_per_component</code>. Note that the size of <code>dofs_per_component</code> needs to be enough to hold all the indices specified in <code>target_component</code>. If this is not the case, an assertion is thrown. The indices not targeted by target_components are left untouched. </p>

</div>
</div>
<a id="a7782ed4f9cf0ac0c15a2e7b1d72afb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7782ed4f9cf0ac0c15a2e7b1d72afb27">&#9670;&nbsp;</a></span>count_dofs_per_fe_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&gt; DoFTools::count_dofs_per_fe_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_block</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the degrees of freedom in each block. This function is similar to <a class="el" href="namespaceMGTools.html#ae5631c4421ffde9e2107d9f7884a1b41">count_dofs_per_component()</a>, with the difference that the counting is done by blocks. See <a class="el" href="DEALGlossary.html#GlossBlock">blocks</a> in the glossary for details. Again the vectors are assumed to have the correct size before calling this function. If this is not the case, an assertion is thrown.</p>
<p>This function is used in the step-22, step-31, and step-32 tutorial programs, among others.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The dofs_per_block variable has as many components as the finite element used by the dof_handler argument has blocks, or alternatively as many blocks as are enumerated in the target_blocks argument if given. </dd></dl>

</div>
</div>
<a id="a3e30887d7a90dc1422a9bb9e90ee1a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e30887d7a90dc1422a9bb9e90ee1a05">&#9670;&nbsp;</a></span>get_active_fe_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::get_active_fe_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_fe_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each active cell of a <a class="el" href="classDoFHandler.html">DoFHandler</a>, extract the active finite element index and fill the vector given as second argument. This vector is assumed to have as many entries as there are active cells.</p>
<p>For <a class="el" href="classDoFHandler.html">DoFHandler</a> objects without hp-capabilities given as first argument, the returned vector will consist of only zeros, indicating that all cells use the same finite element. In hp-mode, the values may be different, though. </p>

</div>
</div>
<a id="acf3d202ccd39aea458a476dd0928fb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3d202ccd39aea458a476dd0928fb15">&#9670;&nbsp;</a></span>count_dofs_on_patch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> DoFTools::count_dofs_on_patch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many degrees of freedom live on a set of cells (i.e., a patch) described by the argument.</p>
<p>Patches are often used in defining error estimators that require the solution of a local problem on the patch surrounding each of the cells of the mesh. You can get a list of cells that form the patch around a given cell using <a class="el" href="namespaceGridTools.html#aea0b44d8461b32e6d3d90e2e02028e62">GridTools::get_patch_around_cell()</a>. This function is then useful in setting up the size of the linear system used to solve the local problem on the patch around a cell. The function <a class="el" href="namespaceDoFTools.html#ad814274d3f9e209587ee1dba0f488b76">DoFTools::get_dofs_on_patch()</a> will then help to make the connection between global degrees of freedom and the local ones.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>A collection of cells within an object of type DoFHandler&lt;dim, spacedim&gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of degrees of freedom associated with the cells of this patch.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the context of a parallel distributed computation, it only makes sense to call this function on patches around locally owned cells. This is because the neighbors of locally owned cells are either locally owned themselves, or ghost cells. For both, we know that these are in fact the real cells of the complete, parallel triangulation. We can also query the degrees of freedom on these. In other words, this function can only work if all cells in the patch are either locally owned or ghost cells. </dd></dl>

</div>
</div>
<a id="a99d249bd0c6f5ccb1ea86d498fd7e936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d249bd0c6f5ccb1ea86d498fd7e936">&#9670;&nbsp;</a></span>count_dofs_on_patch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> DoFTools::count_dofs_on_patch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename DoFHandlerType::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as above.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Use the function that takes dim and spacedim as template argument. </dd></dl>

</div>
</div>
<a id="aa243d4c45775077c674ef6800e5ce215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa243d4c45775077c674ef6800e5ce215">&#9670;&nbsp;</a></span>map_dof_to_boundary_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dof_to_boundary_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a mapping from degree of freedom indices to the index of that degree of freedom on the boundary. After this operation, <code>mapping[dof]</code> gives the index of the degree of freedom with global number <code>dof</code> in the list of degrees of freedom on the boundary. If the degree of freedom requested is not on the boundary, the value of <code>mapping[dof]</code> is <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a>. This function is mainly used when setting up matrices and vectors on the boundary from the trial functions, which have global numbers, while the matrices and vectors use numbers of the trial functions local to the boundary.</p>
<p>Prior content of <code>mapping</code> is deleted. </p>

</div>
</div>
<a id="a2e367cf4d8590470cc136bec082b216b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e367cf4d8590470cc136bec082b216b">&#9670;&nbsp;</a></span>map_dof_to_boundary_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dof_to_boundary_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous function, except that only those parts of the boundary are considered for which the boundary indicator is listed in the second argument.</p>
<p>See the general doc of this class for more information.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="a5514e4f59ea659f63953d62ca429eaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5514e4f59ea659f63953d62ca429eaff">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of support points (see this <a class="el" href="DEALGlossary.html#GlossSupport">glossary entry</a>) for all the degrees of freedom handled by this DoF handler object. This function, of course, only works if the finite element object used by the DoF handler object actually provides support points, i.e. no edge elements or the like. Otherwise, an exception is thrown.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given array must have a length of as many elements as there are degrees of freedom.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The precondition to this function that the output argument needs to have size equal to the total number of degrees of freedom makes this function unsuitable for the case that the given <a class="el" href="classDoFHandler.html">DoFHandler</a> object derives from a <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> object (or any of the classes derived from <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>). Consequently, this function will produce an error if called with such a <a class="el" href="classDoFHandler.html">DoFHandler</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>The mapping from the reference cell to the real cell on which DoFs are defined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The object that describes which DoF indices live on which cell of the triangulation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">support_points</td><td>A vector that stores the corresponding location of the dofs in real space coordinates. Previous content of this object is deleted in this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>An optional component mask that restricts the components from which the support points are extracted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d68b6352f00a6e6c26eb728040284e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d68b6352f00a6e6c26eb728040284e6">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous function but for the hp-case. </p>

</div>
</div>
<a id="a297ef923ee03f234fc09ee4dcdd01140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297ef923ee03f234fc09ee4dcdd01140">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a version of the above map_dofs_to_support_points function that doesn't simply return a vector of support points (see this <a class="el" href="DEALGlossary.html#GlossSupport">glossary entry</a>) with one entry for each global degree of freedom, but instead a map that maps from the DoFs index to its location. The point of this function is that it is also usable in cases where the <a class="el" href="classDoFHandler.html">DoFHandler</a> is based on a <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> object (or any of the classes derived from <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>). In such cases, each processor will not be able to determine the support point location of all DoFs, and worse no processor may be able to hold a vector that would contain the locations of all DoFs even if they were known. As a consequence, this function constructs a map from those DoFs for which we can know the locations (namely, those DoFs that are locally relevant (see <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs</a>) to their locations.</p>
<p>For non-distributed triangulations, the map returned as <code>support_points</code> is of course dense, i.e., every DoF is to be found in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>The mapping from the reference cell to the real cell on which DoFs are defined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The object that describes which DoF indices live on which cell of the triangulation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">support_points</td><td>A map that for every locally relevant DoF index contains the corresponding location in real space coordinates. Previous content of this object is deleted in this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>An optional component mask that restricts the components from which the support points are extracted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad18da75343daf4b14fa0588445627eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18da75343daf4b14fa0588445627eab">&#9670;&nbsp;</a></span>map_dofs_to_support_points() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_dofs_to_support_points </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous function but for the hp-case. </p>

</div>
</div>
<a id="a3540ceb577e65414bde1b6b14808da2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3540ceb577e65414bde1b6b14808da2c">&#9670;&nbsp;</a></span>map_support_points_to_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::map_support_points_to_dofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, Comp &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_to_index_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the opposite function to the one above. It generates a map where the keys are the support points of the degrees of freedom, while the values are the DoF indices. For a definition of support points, see this <a class="el" href="DEALGlossary.html#GlossSupport">glossary entry</a>.</p>
<p>Since there is no natural order in the space of points (except for the 1d case), you have to provide a map with an explicitly specified comparator object. This function is therefore templatized on the comparator object. Previous content of the map object is deleted in this function.</p>
<p>Just as with the function above, it is assumed that the finite element in use here actually supports the notion of support points of all its components.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>This function should generate a multimap, rather than just a map, since several dofs may be located at the same support point. Currently, only the last value in the map returned by <a class="el" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">map_dofs_to_support_points()</a> for each point will be returned. </dd></dl>

</div>
</div>
<a id="a952f50bcd4f8fbb09924626ecc60c605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952f50bcd4f8fbb09924626ecc60c605">&#9670;&nbsp;</a></span>distribute_cell_to_dof_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::distribute_cell_to_dof_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a vector of values which live on cells (e.g. an error per cell) and distribute it to the dofs in such a way that a finite element field results, which can then be further processed, e.g. for output. You should note that the resulting field will not be continuous at hanging nodes. This can, however, easily be arranged by calling the appropriate <code>distribute</code> function of an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object created for this <a class="el" href="classDoFHandler.html">DoFHandler</a> object, after the vector has been fully assembled.</p>
<p>It is assumed that the number of elements in <code>cell_data</code> equals the number of active cells and that the number of elements in <code>dof_data</code> equals <code>dof_handler.n_dofs()</code>.</p>
<p>Note that the input vector may be a vector of any data type as long as it is convertible to <code>double</code>. The output vector, being a data vector on a DoF handler, always consists of elements of type <code>double</code>.</p>
<p>In case the finite element used by this <a class="el" href="classDoFHandler.html">DoFHandler</a> consists of more than one component, you need to specify which component in the output vector should be used to store the finite element field in; the default is zero (no other value is allowed if the finite element consists only of one component). All other components of the vector remain untouched, i.e. their contents are not changed.</p>
<p>This function cannot be used if the finite element in use has shape functions that are non-zero in more than one vector component (in deal.II speak: they are non-primitive). </p>

</div>
</div>
<a id="a1747081ebc1846a5b9ca3aa4bc2ee73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1747081ebc1846a5b9ca3aa4bc2ee73d">&#9670;&nbsp;</a></span>write_gnuplot_dof_support_point_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::write_gnuplot_dof_support_point_info </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate text output readable by gnuplot with point data based on the given map <code>support_points</code>. For each support point location, a string label containing a list of all DoFs from the map is generated. The map can be generated with a call to <a class="el" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">map_dofs_to_support_points()</a> and is useful to visualize location and global numbering of unknowns.</p>
<p>An example for the format of each line in the output is: </p><div class="fragment"><div class="line">x [y] [z] <span class="stringliteral">&quot;dof1, dof2&quot;</span></div></div><!-- fragment --><p> where x, y, and z (present only in corresponding dimension) are the coordinates of the support point, followed by a list of DoF numbers.</p>
<p>The points with labels can be plotted as follows in gnuplot: </p><div class="fragment"><div class="line">plot <span class="stringliteral">&quot;./points.gpl&quot;</span> <span class="keyword">using</span> 1:2:3 with labels <a class="code" href="namespaceOpenCASCADE.html#a041fdfae3d9ed8c073c54277acdd0b96">point</a> offset 1,1</div></div><!-- fragment --><p>Examples (this also includes the grid written separately using <a class="el" href="classGridOut.html">GridOut</a>): </p>
<div class="image">
<img src="support_point_dofs1.png" alt="support_point_dofs1.png"/>
</div>
 <div class="image">
<img src="support_point_dofs2.png" alt="support_point_dofs2.png"/>
</div>
 <p>To generate the mesh and the support point information in a single gnuplot file, use code similar to </p><div class="fragment"><div class="line">std::ofstream out(<span class="stringliteral">&quot;gnuplot.gpl&quot;</span>);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;plot &#39;-&#39; using 1:2 with lines, &quot;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;&#39;-&#39; with labels point pt 2 offset 1,1&quot;</span></div><div class="line">    &lt;&lt; std::endl;</div><div class="line"><a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a> (triangulation, out);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">std::map&lt;types::global_dof_index, Point&lt;dim&gt; &gt; support_points;</div><div class="line"><a class="code" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a> (<a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>(),</div><div class="line">                                      dof_handler,</div><div class="line">                                      support_points);</div><div class="line"><a class="code" href="namespaceDoFTools.html#a1747081ebc1846a5b9ca3aa4bc2ee73d">DoFTools::write_gnuplot_dof_support_point_info</a>(out,</div><div class="line">                                               support_points);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p> and from within gnuplot execute the following command: </p><div class="fragment"><div class="line">load <span class="stringliteral">&quot;gnuplot.gpl&quot;</span></div></div><!-- fragment --><p>Alternatively, the following gnuplot script will generate a png file when executed as <code>gnuplot gnuplot.gpl</code> on the command line: </p><div class="fragment"><div class="line">std::ofstream out(<span class="stringliteral">&quot;gnuplot.gpl&quot;</span>);</div><div class="line"></div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;set terminal png size 400,410 enhanced font \&quot;Helvetica,8\&quot;\n&quot;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;set output \&quot;output.png\&quot;\n&quot;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;set size square\n&quot;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;set view equal xy\n&quot;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;unset xtics\n&quot;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;unset ytics\n&quot;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;unset grid\n&quot;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;unset border\n&quot;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;plot &#39;-&#39; using 1:2 with lines notitle, &quot;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;&#39;-&#39; with labels point pt 2 offset 1,1 notitle&quot;</span></div><div class="line">    &lt;&lt; std::endl;</div><div class="line"><a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a> (triangulation, out);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">std::map&lt;types::global_dof_index, Point&lt;dim&gt; &gt; support_points;</div><div class="line"><a class="code" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a> (<a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>(),</div><div class="line">                                      dof_handler,</div><div class="line">                                      support_points);</div><div class="line"><a class="code" href="namespaceDoFTools.html#a1747081ebc1846a5b9ca3aa4bc2ee73d">DoFTools::write_gnuplot_dof_support_point_info</a>(out,</div><div class="line">                                               support_points);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
