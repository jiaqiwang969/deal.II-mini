<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classMatrixFree.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MatrixFree&lt; dim, Number, VectorizedArrayType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classMatrixFree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MatrixFree&lt; dim, Number, VectorizedArrayType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__matrixfree.html">Matrix-free infrastructure</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="matrix__free_8h_source.html">deal.II/matrix_free/matrix_free.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MatrixFree&lt; dim, Number, VectorizedArrayType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classMatrixFree__inherit__graph.svg" width="186" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a751b5f06534d52773eba384d2c866a15"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> { <br />
&#160;&#160;<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15a334c4a4c42fdb79d7ebc3e73b517e6f8">DataAccessOnFaces::none</a>, 
<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15af09cc7ee3a9a93273f4b80601cafb00c">DataAccessOnFaces::values</a>, 
<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15a108449c0466dc01a217d1ab2f99e5d5c">DataAccessOnFaces::values_all_faces</a>, 
<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ac2af294b46c59f4ca21a4aac2b2d97b1">DataAccessOnFaces::gradients</a>, 
<br />
&#160;&#160;<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15adceeae01fe1b10f8d3202a66d4676915">DataAccessOnFaces::gradients_all_faces</a>, 
<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>
<br />
 }</td></tr>
<tr class="separator:a751b5f06534d52773eba384d2c866a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c999e29f872bce1d487c893c861c0b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aa3c999e29f872bce1d487c893c861c0b">value_type</a> = Number</td></tr>
<tr class="separator:aa3c999e29f872bce1d487c893c861c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae84ac145ae6c2277eca3612d46b21e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a8ae84ac145ae6c2277eca3612d46b21e">vectorized_value_type</a> = VectorizedArrayType</td></tr>
<tr class="separator:a8ae84ac145ae6c2277eca3612d46b21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">1: Construction and initialization</div></td></tr>
<tr class="memitem:ad235137af17c50208c03a418340acbc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad235137af17c50208c03a418340acbc8">MatrixFree</a> ()</td></tr>
<tr class="separator:ad235137af17c50208c03a418340acbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64503de42775fdae6c16957be9a9c050"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a64503de42775fdae6c16957be9a9c050">MatrixFree</a> (const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;other)</td></tr>
<tr class="separator:a64503de42775fdae6c16957be9a9c050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae41f0192ab55694a07606eea09fa88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a3ae41f0192ab55694a07606eea09fa88">~MatrixFree</a> () override=default</td></tr>
<tr class="separator:a3ae41f0192ab55694a07606eea09fa88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb324d469b296f2a6921b41208732ddf"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 , typename MappingType &gt; </td></tr>
<tr class="memitem:adb324d469b296f2a6921b41208732ddf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#adb324d469b296f2a6921b41208732ddf">reinit</a> (const MappingType &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:adb324d469b296f2a6921b41208732ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9a0610e482e6785491a8a2c7bd8aee"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 &gt; </td></tr>
<tr class="memitem:aeb9a0610e482e6785491a8a2c7bd8aee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aeb9a0610e482e6785491a8a2c7bd8aee">reinit</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:aeb9a0610e482e6785491a8a2c7bd8aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4a663740edef3fc4207ea2ec865a62"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 , typename MappingType &gt; </td></tr>
<tr class="memitem:ada4a663740edef3fc4207ea2ec865a62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ada4a663740edef3fc4207ea2ec865a62">reinit</a> (const MappingType &amp;mapping, const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const std::vector&lt; QuadratureType &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:ada4a663740edef3fc4207ea2ec865a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf219f9b30dff16e5c41c3086d64b166"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType , typename MappingType &gt; </td></tr>
<tr class="memitem:abf219f9b30dff16e5c41c3086d64b166"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#abf219f9b30dff16e5c41c3086d64b166">reinit</a> (const MappingType &amp;mapping, const std::vector&lt; const DoFHandlerType *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const std::vector&lt; QuadratureType &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:abf219f9b30dff16e5c41c3086d64b166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3913c1558b53ecabbc55cb83a1167cf8"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 &gt; </td></tr>
<tr class="memitem:a3913c1558b53ecabbc55cb83a1167cf8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a3913c1558b53ecabbc55cb83a1167cf8">reinit</a> (const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const std::vector&lt; QuadratureType &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a3913c1558b53ecabbc55cb83a1167cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49254941a791433cbe774cbf02649eb"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:ad49254941a791433cbe774cbf02649eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad49254941a791433cbe774cbf02649eb">reinit</a> (const std::vector&lt; const DoFHandlerType *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const std::vector&lt; QuadratureType &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:ad49254941a791433cbe774cbf02649eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1472228976422cd5c785f106f26fd54d"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 , typename MappingType &gt; </td></tr>
<tr class="memitem:a1472228976422cd5c785f106f26fd54d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1472228976422cd5c785f106f26fd54d">reinit</a> (const MappingType &amp;mapping, const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a1472228976422cd5c785f106f26fd54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5518f32796400b39a74cbf58a97e2df7"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType , typename MappingType &gt; </td></tr>
<tr class="memitem:a5518f32796400b39a74cbf58a97e2df7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a5518f32796400b39a74cbf58a97e2df7">reinit</a> (const MappingType &amp;mapping, const std::vector&lt; const DoFHandlerType *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a5518f32796400b39a74cbf58a97e2df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee59b4b26a998451b74d7f2948aed300"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 &gt; </td></tr>
<tr class="memitem:aee59b4b26a998451b74d7f2948aed300"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aee59b4b26a998451b74d7f2948aed300">reinit</a> (const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:aee59b4b26a998451b74d7f2948aed300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac683f503f6c869f7619157c446dd9713"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:ac683f503f6c869f7619157c446dd9713"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ac683f503f6c869f7619157c446dd9713">reinit</a> (const std::vector&lt; const DoFHandlerType *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:ac683f503f6c869f7619157c446dd9713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0d738934cd91482550533fd88a96fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a3d0d738934cd91482550533fd88a96fa">copy_from</a> (const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;matrix_free_base)</td></tr>
<tr class="separator:a3d0d738934cd91482550533fd88a96fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f21e8893f049def7395c8cb7c4f0ca9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1f21e8893f049def7395c8cb7c4f0ca9">update_mapping</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping)</td></tr>
<tr class="separator:a1f21e8893f049def7395c8cb7c4f0ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264d78dadbfd3bccb9c36e37226fd025"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a264d78dadbfd3bccb9c36e37226fd025">update_mapping</a> (const std::shared_ptr&lt; <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim &gt;&gt; &amp;mapping)</td></tr>
<tr class="separator:a264d78dadbfd3bccb9c36e37226fd025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0e2305a9a34137ce5db9c8c8c45507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2f0e2305a9a34137ce5db9c8c8c45507">clear</a> ()</td></tr>
<tr class="separator:a2f0e2305a9a34137ce5db9c8c8c45507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">2: Matrix-free loops</div></td></tr>
<tr class="memitem:abc204ec41ead1b5060f47ef3a5a066d7"><td class="memTemplParams" colspan="2">template&lt;typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:abc204ec41ead1b5060f47ef3a5a066d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a> (const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;cell_operation, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false) const</td></tr>
<tr class="separator:abc204ec41ead1b5060f47ef3a5a066d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa941c80d60b2cd987660d2d04587fde"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:aaa941c80d60b2cd987660d2d04587fde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aaa941c80d60b2cd987660d2d04587fde">cell_loop</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const, const CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false) const</td></tr>
<tr class="separator:aaa941c80d60b2cd987660d2d04587fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4e2ec1389ae3f7abd7c0552f782f47"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:aca4e2ec1389ae3f7abd7c0552f782f47"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aca4e2ec1389ae3f7abd7c0552f782f47">cell_loop</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;), CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false) const</td></tr>
<tr class="separator:aca4e2ec1389ae3f7abd7c0552f782f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a53b93080a15c49d5513f09fc6bbb5d"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a6a53b93080a15c49d5513f09fc6bbb5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6a53b93080a15c49d5513f09fc6bbb5d">cell_loop</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const, const CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;operation_before_loop, const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;operation_after_loop, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index_pre_post=0) const</td></tr>
<tr class="separator:a6a53b93080a15c49d5513f09fc6bbb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4299fd60761d1be3cc6461d72c265577"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a4299fd60761d1be3cc6461d72c265577"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4299fd60761d1be3cc6461d72c265577">cell_loop</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;), CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;operation_before_loop, const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;operation_after_loop, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index_pre_post=0) const</td></tr>
<tr class="separator:a4299fd60761d1be3cc6461d72c265577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3b0bd3cad76dc2e3957f205c6138ac"><td class="memTemplParams" colspan="2">template&lt;typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a2c3b0bd3cad76dc2e3957f205c6138ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2c3b0bd3cad76dc2e3957f205c6138ac">cell_loop</a> (const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;cell_operation, OutVector &amp;dst, const InVector &amp;src, const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;operation_before_loop, const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;operation_after_loop, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index_pre_post=0) const</td></tr>
<tr class="separator:a2c3b0bd3cad76dc2e3957f205c6138ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9669e4a5cfaceac78f5e26c285c2ea"><td class="memTemplParams" colspan="2">template&lt;typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a0e9669e4a5cfaceac78f5e26c285c2ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a0e9669e4a5cfaceac78f5e26c285c2ea">loop</a> (const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;cell_operation, const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;face_operation, const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;boundary_operation, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> dst_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> src_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>) const</td></tr>
<tr class="separator:a0e9669e4a5cfaceac78f5e26c285c2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c34b747893d2e6ad474aac9dbf35ec8"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a5c34b747893d2e6ad474aac9dbf35ec8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a5c34b747893d2e6ad474aac9dbf35ec8">loop</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const, void(CLASS::*face_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const, void(CLASS::*boundary_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const, const CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> dst_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> src_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>) const</td></tr>
<tr class="separator:a5c34b747893d2e6ad474aac9dbf35ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0de121d733bf745fadfc646d442524"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:add0de121d733bf745fadfc646d442524"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#add0de121d733bf745fadfc646d442524">loop</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;), void(CLASS::*face_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;), void(CLASS::*boundary_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;), CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> dst_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> src_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>) const</td></tr>
<tr class="separator:add0de121d733bf745fadfc646d442524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ebe2e71cfd7602ef9bc612d22385f8"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a60ebe2e71cfd7602ef9bc612d22385f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a60ebe2e71cfd7602ef9bc612d22385f8">loop_cell_centric</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const, const CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> src_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>) const</td></tr>
<tr class="separator:a60ebe2e71cfd7602ef9bc612d22385f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03da600450c259400259f870800aea2d"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a03da600450c259400259f870800aea2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a03da600450c259400259f870800aea2d">loop_cell_centric</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;), CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> src_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>) const</td></tr>
<tr class="separator:a03da600450c259400259f870800aea2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae39079578d1dd9d1a80b50567fc03ec"><td class="memTemplParams" colspan="2">template&lt;typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:aae39079578d1dd9d1a80b50567fc03ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aae39079578d1dd9d1a80b50567fc03ec">loop_cell_centric</a> (const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;cell_operation, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> src_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>) const</td></tr>
<tr class="separator:aae39079578d1dd9d1a80b50567fc03ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b6836f6e1df769d66d90a9d4fd8873"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a16b6836f6e1df769d66d90a9d4fd8873">create_cell_subrange_hp</a> (const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;range, const unsigned <a class="el" href="classint.html">int</a> fe_degree, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:a16b6836f6e1df769d66d90a9d4fd8873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394b47f93926a192ef5856106556d12e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a394b47f93926a192ef5856106556d12e">create_cell_subrange_hp_by_index</a> (const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;range, const unsigned <a class="el" href="classint.html">int</a> fe_index, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:a394b47f93926a192ef5856106556d12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b8b15c5c3efed4c0082db8255bf1aa"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a00b8b15c5c3efed4c0082db8255bf1aa">n_active_fe_indices</a> () const</td></tr>
<tr class="separator:a00b8b15c5c3efed4c0082db8255bf1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093da73c996f663066f827840f5c1c55"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a093da73c996f663066f827840f5c1c55">get_cell_active_fe_index</a> (const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; range) const</td></tr>
<tr class="separator:a093da73c996f663066f827840f5c1c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b265f35586470176204db6f6e70610"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad5b265f35586470176204db6f6e70610">get_face_active_fe_index</a> (const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; range, const <a class="el" href="classbool.html">bool</a> is_interior_face=true) const</td></tr>
<tr class="separator:ad5b265f35586470176204db6f6e70610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">3: Initialization of vectors</div></td></tr>
<tr class="memitem:ab92a24942737bbaf04d7e00aceba9b57"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:ab92a24942737bbaf04d7e00aceba9b57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">initialize_dof_vector</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:ab92a24942737bbaf04d7e00aceba9b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6389c1e91648d277bdd81af095b5296c"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a6389c1e91648d277bdd81af095b5296c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6389c1e91648d277bdd81af095b5296c">initialize_dof_vector</a> (<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number2 &gt; &amp;vec, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:a6389c1e91648d277bdd81af095b5296c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41cc9c8a14e3a485cefd570680268e1"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ae41cc9c8a14e3a485cefd570680268e1">get_vector_partitioner</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:ae41cc9c8a14e3a485cefd570680268e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2c36a70878d0ec24e250a9587e786e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#afb2c36a70878d0ec24e250a9587e786e">get_locally_owned_set</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:afb2c36a70878d0ec24e250a9587e786e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18245454fbd9c8a2ef6a4b30280042c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a18245454fbd9c8a2ef6a4b30280042c6">get_ghost_set</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:a18245454fbd9c8a2ef6a4b30280042c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6b0854710b1c9aeb889c4875f0a47b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4d6b0854710b1c9aeb889c4875f0a47b">get_constrained_dofs</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:a4d6b0854710b1c9aeb889c4875f0a47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40c40bd8fb8a804f2982bee8c1de070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad40c40bd8fb8a804f2982bee8c1de070">renumber_dofs</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;renumbering, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0)</td></tr>
<tr class="separator:ad40c40bd8fb8a804f2982bee8c1de070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">5: Access of internal data structure</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Note: Expert mode, interface not stable between releases. </p>
</div></td></tr>
<tr class="memitem:afad4aeebcf482bcc621c6f7947209a7c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#afad4aeebcf482bcc621c6f7947209a7c">get_task_info</a> () const</td></tr>
<tr class="separator:afad4aeebcf482bcc621c6f7947209a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94748ddaa979639d6ed02d9f4f617fdf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfo.html">internal::MatrixFreeFunctions::MappingInfo</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a94748ddaa979639d6ed02d9f4f617fdf">get_mapping_info</a> () const</td></tr>
<tr class="separator:a94748ddaa979639d6ed02d9f4f617fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e095529abf96aad2b7fbc95c545fd8d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4e095529abf96aad2b7fbc95c545fd8d">get_dof_info</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index_component=0) const</td></tr>
<tr class="separator:a4e095529abf96aad2b7fbc95c545fd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c33c7336c73d245d5624baf610d5a8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a41c33c7336c73d245d5624baf610d5a8">n_constraint_pool_entries</a> () const</td></tr>
<tr class="separator:a41c33c7336c73d245d5624baf610d5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd98b7686fe06501575420c8ad0819b"><td class="memItemLeft" align="right" valign="top">const Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2cd98b7686fe06501575420c8ad0819b">constraint_pool_begin</a> (const unsigned <a class="el" href="classint.html">int</a> pool_index) const</td></tr>
<tr class="separator:a2cd98b7686fe06501575420c8ad0819b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f37a1274ff5b9092bb4f968d499b2f8"><td class="memItemLeft" align="right" valign="top">const Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4f37a1274ff5b9092bb4f968d499b2f8">constraint_pool_end</a> (const unsigned <a class="el" href="classint.html">int</a> pool_index) const</td></tr>
<tr class="separator:a4f37a1274ff5b9092bb4f968d499b2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363a85c27301642b9d0fd219f15ff229"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt; VectorizedArrayType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a363a85c27301642b9d0fd219f15ff229">get_shape_info</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index_component=0, const unsigned <a class="el" href="classint.html">int</a> quad_index=0, const unsigned <a class="el" href="classint.html">int</a> fe_base_element=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_quad_index=0) const</td></tr>
<tr class="separator:a363a85c27301642b9d0fd219f15ff229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13157af74893593d4af73a30b01a74b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">internal::MatrixFreeFunctions::FaceToCellTopology</a>&lt; VectorizedArrayType::size()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aa13157af74893593d4af73a30b01a74b">get_face_info</a> (const unsigned <a class="el" href="classint.html">int</a> face_batch_index) const</td></tr>
<tr class="separator:aa13157af74893593d4af73a30b01a74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0656887db9b1c8123e650632eadf8996"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTable.html">Table</a>&lt; 3, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a0656887db9b1c8123e650632eadf8996">get_cell_and_face_to_plain_faces</a> () const</td></tr>
<tr class="separator:a0656887db9b1c8123e650632eadf8996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9054eb8149297fe2e062369f0dc618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#acf9054eb8149297fe2e062369f0dc618">acquire_scratch_data</a> () const</td></tr>
<tr class="separator:acf9054eb8149297fe2e062369f0dc618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59550cc34721cf03a46f6f44347bcb0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a59550cc34721cf03a46f6f44347bcb0c">release_scratch_data</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; *memory) const</td></tr>
<tr class="separator:a59550cc34721cf03a46f6f44347bcb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a77e6d9daf1c25b438f2c3a9430b908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a0a77e6d9daf1c25b438f2c3a9430b908">acquire_scratch_data_non_threadsafe</a> () const</td></tr>
<tr class="separator:a0a77e6d9daf1c25b438f2c3a9430b908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1131ad89d22abda0be5b0e766097d92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad1131ad89d22abda0be5b0e766097d92">release_scratch_data_non_threadsafe</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; Number &gt; *memory) const</td></tr>
<tr class="separator:ad1131ad89d22abda0be5b0e766097d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af7d00e4ed4f076e3a86cab23b6d8b452"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#af7d00e4ed4f076e3a86cab23b6d8b452">dimension</a> = dim</td></tr>
<tr class="separator:af7d00e4ed4f076e3a86cab23b6d8b452"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a08f23adccbd26348ab71866dc49283d7"><td class="memTemplParams" colspan="2">template&lt;typename number2 , int q_dim&gt; </td></tr>
<tr class="memitem:a08f23adccbd26348ab71866dc49283d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a08f23adccbd26348ab71866dc49283d7">internal_reinit</a> (const std::shared_ptr&lt; <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim &gt;&gt; &amp;mapping, const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; *&gt; &amp;<a class="el" href="classMatrixFree.html#aaed884d2e3733624b9028bea0952ae39">dof_handlers</a>, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;locally_owned_set, const std::vector&lt; <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; q_dim &gt;&gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data)</td></tr>
<tr class="separator:a08f23adccbd26348ab71866dc49283d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3508f2538e470b07826a62a03292e603"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a3508f2538e470b07826a62a03292e603"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a3508f2538e470b07826a62a03292e603">initialize_indices</a> (const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;locally_owned_set, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data)</td></tr>
<tr class="separator:a3508f2538e470b07826a62a03292e603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb08861aba08a05bbb6a62d30fd8ed1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#adb08861aba08a05bbb6a62d30fd8ed1c">initialize_dof_handlers</a> (const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; *&gt; &amp;<a class="el" href="classMatrixFree.html#aaed884d2e3733624b9028bea0952ae39">dof_handlers</a>, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data)</td></tr>
<tr class="separator:adb08861aba08a05bbb6a62d30fd8ed1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aaed884d2e3733624b9028bea0952ae39"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aaed884d2e3733624b9028bea0952ae39">dof_handlers</a></td></tr>
<tr class="separator:aaed884d2e3733624b9028bea0952ae39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc52f212dd2448479233a1bcad3fa40e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#acc52f212dd2448479233a1bcad3fa40e">dof_info</a></td></tr>
<tr class="separator:acc52f212dd2448479233a1bcad3fa40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1b58d294b2d341cf019efcdbab88b5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a8a1b58d294b2d341cf019efcdbab88b5">constraint_pool_data</a></td></tr>
<tr class="separator:a8a1b58d294b2d341cf019efcdbab88b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bc8be50b14ea2fd9168edcaa74db40"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ae0bc8be50b14ea2fd9168edcaa74db40">constraint_pool_row_index</a></td></tr>
<tr class="separator:ae0bc8be50b14ea2fd9168edcaa74db40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0819d60614c996f43079cc20e0d63933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfo.html">internal::MatrixFreeFunctions::MappingInfo</a>&lt; dim, Number, VectorizedArrayType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a0819d60614c996f43079cc20e0d63933">mapping_info</a></td></tr>
<tr class="separator:a0819d60614c996f43079cc20e0d63933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe9b8c6fc5ca0c15d84ca0243eea7f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a>&lt; 4, <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt; VectorizedArrayType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a0fe9b8c6fc5ca0c15d84ca0243eea7f6">shape_info</a></td></tr>
<tr class="separator:a0fe9b8c6fc5ca0c15d84ca0243eea7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccb8c2689c4029ccf44dacf47c4d224"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6ccb8c2689c4029ccf44dacf47c4d224">cell_level_index</a></td></tr>
<tr class="separator:a6ccb8c2689c4029ccf44dacf47c4d224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd8b73ecd3843be97bc6c62a91550e8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aebd8b73ecd3843be97bc6c62a91550e8">cell_level_index_end_local</a></td></tr>
<tr class="separator:aebd8b73ecd3843be97bc6c62a91550e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538b16343ba782ba2bc83624660c1a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a538b16343ba782ba2bc83624660c1a03">task_info</a></td></tr>
<tr class="separator:a538b16343ba782ba2bc83624660c1a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2d9efa44c36973e8c871c79f55cea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceInfo.html">internal::MatrixFreeFunctions::FaceInfo</a>&lt; VectorizedArrayType::size()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#adb2d9efa44c36973e8c871c79f55cea3">face_info</a></td></tr>
<tr class="separator:adb2d9efa44c36973e8c871c79f55cea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9776b9b9cb59771ed0409f0e61d9092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad9776b9b9cb59771ed0409f0e61d9092">indices_are_initialized</a></td></tr>
<tr class="separator:ad9776b9b9cb59771ed0409f0e61d9092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d4bcec742b46e930fc6d3ad1854f35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a60d4bcec742b46e930fc6d3ad1854f35">mapping_is_initialized</a></td></tr>
<tr class="separator:a60d4bcec742b46e930fc6d3ad1854f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbe6cd7b3a803387e09b5746898a1fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; std::list&lt; std::pair&lt; <a class="el" href="classbool.html">bool</a>, <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a9dbe6cd7b3a803387e09b5746898a1fc">scratch_pad</a></td></tr>
<tr class="separator:a9dbe6cd7b3a803387e09b5746898a1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab344a297bb56fc07d4490794da49fc9"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::pair&lt; <a class="el" href="classbool.html">bool</a>, <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; Number &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aab344a297bb56fc07d4490794da49fc9">scratch_pad_non_threadsafe</a></td></tr>
<tr class="separator:aab344a297bb56fc07d4490794da49fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d5b0dfea8051c30f80a7f3f72fd5bc"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a65d5b0dfea8051c30f80a7f3f72fd5bc">mg_level</a></td></tr>
<tr class="separator:a65d5b0dfea8051c30f80a7f3f72fd5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
4: General information</h2></td></tr>
<tr class="memitem:ab74907342812d74f2c89d825436d1b70"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ab74907342812d74f2c89d825436d1b70">n_components</a> () const</td></tr>
<tr class="separator:ab74907342812d74f2c89d825436d1b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2cd5fcca15d0a9cb78f15473d7bbc0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aec2cd5fcca15d0a9cb78f15473d7bbc0">n_base_elements</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index) const</td></tr>
<tr class="separator:aec2cd5fcca15d0a9cb78f15473d7bbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9298b98c63d9d7b93367fcbeda9fe1b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ab9298b98c63d9d7b93367fcbeda9fe1b">n_physical_cells</a> () const</td></tr>
<tr class="separator:ab9298b98c63d9d7b93367fcbeda9fe1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ce1aa8a6e9f3aa897a51d5dcf68c5c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ac6ce1aa8a6e9f3aa897a51d5dcf68c5c">n_macro_cells</a> () const</td></tr>
<tr class="separator:ac6ce1aa8a6e9f3aa897a51d5dcf68c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9d964339b466bdcb661552e731e222"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a> () const</td></tr>
<tr class="separator:a8c9d964339b466bdcb661552e731e222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c08e4ba63acbb93d0f3a1441b88d61c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a0c08e4ba63acbb93d0f3a1441b88d61c">n_ghost_cell_batches</a> () const</td></tr>
<tr class="separator:a0c08e4ba63acbb93d0f3a1441b88d61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d24c18bcde8d09a2a7847f0f7f96d19"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1d24c18bcde8d09a2a7847f0f7f96d19">n_inner_face_batches</a> () const</td></tr>
<tr class="separator:a1d24c18bcde8d09a2a7847f0f7f96d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa787165092c1949ce2128ca63799abc1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aa787165092c1949ce2128ca63799abc1">n_boundary_face_batches</a> () const</td></tr>
<tr class="separator:aa787165092c1949ce2128ca63799abc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3aff8b6750287728851ef8753b135a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#acf3aff8b6750287728851ef8753b135a">n_ghost_inner_face_batches</a> () const</td></tr>
<tr class="separator:acf3aff8b6750287728851ef8753b135a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c875be0229e4872a3e087a55410625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a94c875be0229e4872a3e087a55410625">get_boundary_id</a> (const unsigned <a class="el" href="classint.html">int</a> macro_face) const</td></tr>
<tr class="separator:a94c875be0229e4872a3e087a55410625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b99380acd6e278c4acf6a19fa443ba"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, VectorizedArrayType::size()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a75b99380acd6e278c4acf6a19fa443ba">get_faces_by_cells_boundary_id</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_index, const unsigned <a class="el" href="classint.html">int</a> face_number) const</td></tr>
<tr class="separator:a75b99380acd6e278c4acf6a19fa443ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bf03172546d9ba1b8b14c845da46df"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#af3bf03172546d9ba1b8b14c845da46df">get_dof_handler</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:af3bf03172546d9ba1b8b14c845da46df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2de43baa7e77d1e3e4e60fc215f843"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a6c2de43baa7e77d1e3e4e60fc215f843"><td class="memTemplItemLeft" align="right" valign="top">const DoFHandlerType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6c2de43baa7e77d1e3e4e60fc215f843">get_dof_handler</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:a6c2de43baa7e77d1e3e4e60fc215f843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2ce5ee5867360c16019d618e250ce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;::cell_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aad2ce5ee5867360c16019d618e250ce4">get_cell_iterator</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_index, const unsigned <a class="el" href="classint.html">int</a> lane_index, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:aad2ce5ee5867360c16019d618e250ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ed5ced497a19b51592f23ca8e6faf5"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a46ed5ced497a19b51592f23ca8e6faf5">get_cell_level_and_index</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_index, const unsigned <a class="el" href="classint.html">int</a> lane_index) const</td></tr>
<tr class="separator:a46ed5ced497a19b51592f23ca8e6faf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6076e2d012fad941d8d326a7dc8c3a78"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;::cell_iterator, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6076e2d012fad941d8d326a7dc8c3a78">get_face_iterator</a> (const unsigned <a class="el" href="classint.html">int</a> face_batch_index, const unsigned <a class="el" href="classint.html">int</a> lane_index, const <a class="el" href="classbool.html">bool</a> interior=true, const unsigned <a class="el" href="classint.html">int</a> fe_component=0) const</td></tr>
<tr class="separator:a6076e2d012fad941d8d326a7dc8c3a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f172cadd38fd88cfd4d1f1205b63614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;::active_cell_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1f172cadd38fd88cfd4d1f1205b63614">get_hp_cell_iterator</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_index, const unsigned <a class="el" href="classint.html">int</a> lane_index, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:a1f172cadd38fd88cfd4d1f1205b63614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c46e404d4a727175eb154f9f6e6304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a39c46e404d4a727175eb154f9f6e6304">at_irregular_cell</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_index) const</td></tr>
<tr class="separator:a39c46e404d4a727175eb154f9f6e6304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251d5c0f5cc96057223ebbffacd91a03"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a251d5c0f5cc96057223ebbffacd91a03">n_components_filled</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_number) const</td></tr>
<tr class="separator:a251d5c0f5cc96057223ebbffacd91a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d516071d20e633dc9efcadb7852ce15"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1d516071d20e633dc9efcadb7852ce15">n_active_entries_per_cell_batch</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_index) const</td></tr>
<tr class="separator:a1d516071d20e633dc9efcadb7852ce15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6297a9ec73d830ae81e5eeacf02df27"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad6297a9ec73d830ae81e5eeacf02df27">n_active_entries_per_face_batch</a> (const unsigned <a class="el" href="classint.html">int</a> face_batch_index) const</td></tr>
<tr class="separator:ad6297a9ec73d830ae81e5eeacf02df27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4183258475490709034dbff113cbc789"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4183258475490709034dbff113cbc789">get_dofs_per_cell</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const</td></tr>
<tr class="separator:a4183258475490709034dbff113cbc789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba06e049b55e59507a69e37e7a23f3b5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aba06e049b55e59507a69e37e7a23f3b5">get_n_q_points</a> (const unsigned <a class="el" href="classint.html">int</a> quad_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const</td></tr>
<tr class="separator:aba06e049b55e59507a69e37e7a23f3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0e4541d14974ef533bd9e61a8b8a7f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4e0e4541d14974ef533bd9e61a8b8a7f">get_dofs_per_face</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const</td></tr>
<tr class="separator:a4e0e4541d14974ef533bd9e61a8b8a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fea1afe46c9741117a3a5d6a6c7259"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a31fea1afe46c9741117a3a5d6a6c7259">get_n_q_points_face</a> (const unsigned <a class="el" href="classint.html">int</a> quad_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const</td></tr>
<tr class="separator:a31fea1afe46c9741117a3a5d6a6c7259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b0fd13ac2a63888c4836640e8bc68b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a16b0fd13ac2a63888c4836640e8bc68b">get_quadrature</a> (const unsigned <a class="el" href="classint.html">int</a> quad_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const</td></tr>
<tr class="separator:a16b0fd13ac2a63888c4836640e8bc68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf4cff03dbaa9fa73605966c185b60f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1cf4cff03dbaa9fa73605966c185b60f">get_face_quadrature</a> (const unsigned <a class="el" href="classint.html">int</a> quad_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const</td></tr>
<tr class="separator:a1cf4cff03dbaa9fa73605966c185b60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9822d4a731c450b74bc32843dfc57235"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a9822d4a731c450b74bc32843dfc57235">get_cell_category</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_index) const</td></tr>
<tr class="separator:a9822d4a731c450b74bc32843dfc57235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6272714d1f3a4389937894f2044a1298"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6272714d1f3a4389937894f2044a1298">get_face_category</a> (const unsigned <a class="el" href="classint.html">int</a> macro_face) const</td></tr>
<tr class="separator:a6272714d1f3a4389937894f2044a1298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f6b960d4810e6914a45d9cbb164793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a90f6b960d4810e6914a45d9cbb164793">indices_initialized</a> () const</td></tr>
<tr class="separator:a90f6b960d4810e6914a45d9cbb164793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b95d23ac163726460a536e76513ac13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2b95d23ac163726460a536e76513ac13">mapping_initialized</a> () const</td></tr>
<tr class="separator:a2b95d23ac163726460a536e76513ac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214a09bc9d553323fe8e2d4ab85bd1d1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a214a09bc9d553323fe8e2d4ab85bd1d1">get_mg_level</a> () const</td></tr>
<tr class="separator:a214a09bc9d553323fe8e2d4ab85bd1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47cc139ef80f83ed20fc55e3cd16767"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aa47cc139ef80f83ed20fc55e3cd16767">memory_consumption</a> () const</td></tr>
<tr class="separator:aa47cc139ef80f83ed20fc55e3cd16767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256aac0a2e56bb2345f7a3f0ce74bef8"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:a256aac0a2e56bb2345f7a3f0ce74bef8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a256aac0a2e56bb2345f7a3f0ce74bef8">print_memory_consumption</a> (StreamType &amp;out) const</td></tr>
<tr class="separator:a256aac0a2e56bb2345f7a3f0ce74bef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1988bac68c909d3868c61a66eb285791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1988bac68c909d3868c61a66eb285791">print</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a1988bac68c909d3868c61a66eb285791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe3ca9fc933b303cdc134fcb86bfbb6"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:afbe3ca9fc933b303cdc134fcb86bfbb6"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#afbe3ca9fc933b303cdc134fcb86bfbb6">is_supported</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe)</td></tr>
<tr class="separator:afbe3ca9fc933b303cdc134fcb86bfbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt;<br />
class MatrixFree&lt; dim, Number, VectorizedArrayType &gt;</h3>

<p>This class collects all the data that is stored for the matrix free implementation. The storage scheme is tailored towards several loops performed with the same data, i.e., typically doing many matrix-vector products or residual computations on the same mesh. The class is used in step-37 and step-48.</p>
<p>This class does not implement any operations involving finite element basis functions, i.e., regarding the operation performed on the cells. For these operations, the class <a class="el" href="classFEEvaluation.html">FEEvaluation</a> is designed to use the data collected in this class.</p>
<p>The stored data can be subdivided into three main components:</p>
<ul>
<li>DoFInfo: It stores how local degrees of freedom relate to global degrees of freedom. It includes a description of constraints that are evaluated as going through all local degrees of freedom on a cell.</li>
<li>MappingInfo: It stores the transformations from real to unit cells that are necessary in order to build derivatives of finite element functions and find location of quadrature weights in physical space.</li>
<li>ShapeInfo: It contains the shape functions of the finite element, evaluated on the unit cell.</li>
</ul>
<p>Besides the initialization routines, this class implements only a single operation, namely a loop over all cells (<a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop()</a>). This loop is scheduled in such a way that cells that share degrees of freedom are not worked on simultaneously, which implies that it is possible to write to vectors (or matrices) in parallel without having to explicitly synchronize access to these vectors and matrices. This class does not implement any shape values, all it does is to cache the respective data. To implement finite element operations, use the class <a class="el" href="classFEEvaluation.html">FEEvaluation</a> (or some of the related classes).</p>
<p>This class traverses the cells in a different order than the usual <a class="el" href="classTriangulation.html">Triangulation</a> class in deal.II, in order to be flexible with respect to parallelization in shared memory and vectorization.</p>
<p>Vectorization is implemented by merging several topological cells into one so-called macro cell. This enables the application of all cell-related operations for several cells with one CPU instruction and is one of the main features of this framework.</p>
<p>For details on usage of this class, see the description of <a class="el" href="classFEEvaluation.html">FEEvaluation</a> or the <a class="el" href="group__matrixfree.html">matrix-free module</a>. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00116">116</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa3c999e29f872bce1d487c893c861c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c999e29f872bce1d487c893c861c0b">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::<a class="el" href="classMatrixFree.html#aa3c999e29f872bce1d487c893c861c0b">value_type</a> =  Number</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias for the underlying number type specified by the template argument. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00127">127</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a8ae84ac145ae6c2277eca3612d46b21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae84ac145ae6c2277eca3612d46b21e">&#9670;&nbsp;</a></span>vectorized_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::<a class="el" href="classMatrixFree.html#a8ae84ac145ae6c2277eca3612d46b21e">vectorized_value_type</a> =  VectorizedArrayType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00128">128</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a751b5f06534d52773eba384d2c866a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751b5f06534d52773eba384d2c866a15">&#9670;&nbsp;</a></span>DataAccessOnFaces</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">MatrixFree::DataAccessOnFaces</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This class defines the type of data access for face integrals in loop () that is passed on to the <code>update_ghost_values</code> and <code>compress</code> functions of the parallel vectors, with the purpose of being able to reduce the amount of data that must be exchanged. The data exchange is a real bottleneck in particular for high-degree DG methods, therefore a more restrictive way of exchange is clearly beneficial. Note that this selection applies to <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a> objects assigned to the exterior side of cells accessing <code>FaceToCellTopology::exterior_cells</code> only; all <em>interior</em> objects are available in any case. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a751b5f06534d52773eba384d2c866a15a334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"><p>The loop does not involve any <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a> access into neighbors, as is the case with only boundary integrals (but no interior face integrals) or when doing mass matrices in a <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a> like setup. </p>
</td></tr>
<tr><td class="fieldname"><a id="a751b5f06534d52773eba384d2c866a15af09cc7ee3a9a93273f4b80601cafb00c"></a>values&#160;</td><td class="fielddoc"><p>The loop does only involve <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a> access into neighbors by function values, such as <a class="el" href="classFEFaceEvaluation.html#a4ac53fde2eab227ef45c7d29a5ed33fe">FEFaceEvaluation::gather_evaluate()</a> with argument <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>, but no access to shape function derivatives (which typically need to access more data). For <a class="el" href="classFiniteElement.html">FiniteElement</a> types where only some of the shape functions have support on a face, such as an <a class="el" href="classFE__DGQ.html">FE_DGQ</a> element with Lagrange polynomials with nodes on the element surface, the data exchange is reduced from <code>(k+1)^dim</code> to <code>(k+1)^(dim-1)</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a751b5f06534d52773eba384d2c866a15a108449c0466dc01a217d1ab2f99e5d5c"></a>values_all_faces&#160;</td><td class="fielddoc"><p>Same as above. To be used if data has to be accessed from exterior faces if <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a> was reinitialized by providing the cell batch number and a face number. This configuration is useful in the context of cell-centric loops.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="structMatrixFree_1_1AdditionalData.html#a1b94beb12bfea048e9fbbdf52c36ecb4">AdditionalData::hold_all_faces_to_owned_cells</a> has to enabled. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a751b5f06534d52773eba384d2c866a15ac2af294b46c59f4ca21a4aac2b2d97b1"></a>gradients&#160;</td><td class="fielddoc"><p>The loop does involve <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a> access into neighbors by function values and gradients, but no second derivatives, such as <a class="el" href="classFEFaceEvaluation.html#a4ac53fde2eab227ef45c7d29a5ed33fe">FEFaceEvaluation::gather_evaluate()</a> with <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> and <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a> set. For <a class="el" href="classFiniteElement.html">FiniteElement</a> types where only some of the shape functions have non-zero value and first derivative on a face, such as an <a class="el" href="classFE__DGQHermite.html">FE_DGQHermite</a> element, the data exchange is reduced, e.g. from <code>(k+1)^dim</code> to <code>2(k+1)^(dim-1)</code>. Note that for bases that do not have this special property, the full neighboring data is sent anyway. </p>
</td></tr>
<tr><td class="fieldname"><a id="a751b5f06534d52773eba384d2c866a15adceeae01fe1b10f8d3202a66d4676915"></a>gradients_all_faces&#160;</td><td class="fielddoc"><p>Same as above. To be used if data has to be accessed from exterior faces if <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a> was reinitialized by providing the cell batch number and a face number. This configuration is useful in the context of cell-centric loops.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="structMatrixFree_1_1AdditionalData.html#a1b94beb12bfea048e9fbbdf52c36ecb4">AdditionalData::hold_all_faces_to_owned_cells</a> has to enabled. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48"></a>unspecified&#160;</td><td class="fielddoc"><p>General setup where the user does not want to make a restriction. This is typically more expensive than the other options, but also the most conservative one because the full data of elements behind the faces to be computed locally will be exchanged. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00753">753</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad235137af17c50208c03a418340acbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad235137af17c50208c03a418340acbc8">&#9670;&nbsp;</a></span>MatrixFree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::<a class="el" href="classMatrixFree.html">MatrixFree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default empty constructor. Does nothing. </p>

</div>
</div>
<a id="a64503de42775fdae6c16957be9a9c050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64503de42775fdae6c16957be9a9c050">&#9670;&nbsp;</a></span>MatrixFree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::<a class="el" href="classMatrixFree.html">MatrixFree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor, calls copy_from </p>

</div>
</div>
<a id="a3ae41f0192ab55694a07606eea09fa88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae41f0192ab55694a07606eea09fa88">&#9670;&nbsp;</a></span>~MatrixFree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::~<a class="el" href="classMatrixFree.html">MatrixFree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adb324d469b296f2a6921b41208732ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb324d469b296f2a6921b41208732ddf">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 , typename MappingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const MappingType &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts the information needed to perform loops over cells. The <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classAffineConstraints.html">AffineConstraints</a> objects describe the layout of degrees of freedom, the <a class="el" href="classDoFHandler.html">DoFHandler</a> and the mapping describe the transformations from unit to real cell, and the finite element underlying the <a class="el" href="classDoFHandler.html">DoFHandler</a> together with the quadrature formula describe the local operations. Note that the finite element underlying the <a class="el" href="classDoFHandler.html">DoFHandler</a> must either be scalar or contain several copies of the same element. Mixing several different elements into one <a class="el" href="classFESystem.html">FESystem</a> is not allowed. In that case, use the initialization function with several <a class="el" href="classDoFHandler.html">DoFHandler</a> arguments. </p>

</div>
</div>
<a id="aeb9a0610e482e6785491a8a2c7bd8aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9a0610e482e6785491a8a2c7bd8aee">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as above, but using a \(Q_1\) mapping.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000071">Deprecated:</a></b></dt><dd>Use the overload taking a <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> object instead. </dd></dl>

</div>
</div>
<a id="ada4a663740edef3fc4207ea2ec865a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4a663740edef3fc4207ea2ec865a62">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 , typename MappingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const MappingType &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; QuadratureType &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts the information needed to perform loops over cells. The <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classAffineConstraints.html">AffineConstraints</a> objects describe the layout of degrees of freedom, the <a class="el" href="classDoFHandler.html">DoFHandler</a> and the mapping describe the transformations from unit to real cell, and the finite element underlying the <a class="el" href="classDoFHandler.html">DoFHandler</a> together with the quadrature formula describe the local operations. As opposed to the scalar case treated with the other initialization functions, this function allows for problems with two or more different finite elements. The DoFHandlers to each element must be passed as pointers to the initialization function. Alternatively, a system of several components may also be represented by a single <a class="el" href="classDoFHandler.html">DoFHandler</a> with an <a class="el" href="classFESystem.html">FESystem</a> element. The prerequisite for this case is that each base element of the <a class="el" href="classFESystem.html">FESystem</a> must be compatible with the present class, such as the <a class="el" href="classFE__Q.html">FE_Q</a> or <a class="el" href="classFE__DGQ.html">FE_DGQ</a> classes.</p>
<p>This function also allows for using several quadrature formulas, e.g. when the description contains independent integrations of elements of different degrees. However, the number of different quadrature formulas can be sets independently from the number of DoFHandlers, when several elements are always integrated with the same quadrature formula. </p>

</div>
</div>
<a id="abf219f9b30dff16e5c41c3086d64b166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf219f9b30dff16e5c41c3086d64b166">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType , typename MappingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const MappingType &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const DoFHandlerType *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; QuadratureType &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as above, but using DoFHandlerType.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000072">Deprecated:</a></b></dt><dd>Use the overload taking a <a class="el" href="classDoFHandler.html">DoFHandler</a> object instead. </dd></dl>

</div>
</div>
<a id="a3913c1558b53ecabbc55cb83a1167cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3913c1558b53ecabbc55cb83a1167cf8">&#9670;&nbsp;</a></span>reinit() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; QuadratureType &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as above, but using a \(Q_1\) mapping.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000073">Deprecated:</a></b></dt><dd>Use the overload taking a <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> object instead. </dd></dl>

</div>
</div>
<a id="ad49254941a791433cbe774cbf02649eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49254941a791433cbe774cbf02649eb">&#9670;&nbsp;</a></span>reinit() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const DoFHandlerType *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; QuadratureType &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as above, but using DoFHandlerType.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000074">Deprecated:</a></b></dt><dd>Use the overload taking a <a class="el" href="classDoFHandler.html">DoFHandler</a> object instead. </dd></dl>

</div>
</div>
<a id="a1472228976422cd5c785f106f26fd54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1472228976422cd5c785f106f26fd54d">&#9670;&nbsp;</a></span>reinit() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 , typename MappingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const MappingType &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as before, but now the index set description of the locally owned range of degrees of freedom is taken from the <a class="el" href="classDoFHandler.html">DoFHandler</a>. Moreover, only a single quadrature formula is used, as might be necessary when several components in a vector-valued problem are integrated together based on the same quadrature formula. </p>

</div>
</div>
<a id="a5518f32796400b39a74cbf58a97e2df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5518f32796400b39a74cbf58a97e2df7">&#9670;&nbsp;</a></span>reinit() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType , typename MappingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const MappingType &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const DoFHandlerType *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as above, but using DoFHandlerType.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000075">Deprecated:</a></b></dt><dd>Use the overload taking a <a class="el" href="classDoFHandler.html">DoFHandler</a> object instead. </dd></dl>

</div>
</div>
<a id="aee59b4b26a998451b74d7f2948aed300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee59b4b26a998451b74d7f2948aed300">&#9670;&nbsp;</a></span>reinit() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as above, but using a \(Q_1\) mapping.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000076">Deprecated:</a></b></dt><dd>Use the overload taking a <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> object instead. </dd></dl>

</div>
</div>
<a id="ac683f503f6c869f7619157c446dd9713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac683f503f6c869f7619157c446dd9713">&#9670;&nbsp;</a></span>reinit() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const DoFHandlerType *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the data structures. Same as above, but using DoFHandlerType.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000077">Deprecated:</a></b></dt><dd>Use the overload taking a <a class="el" href="classDoFHandler.html">DoFHandler</a> object instead. </dd></dl>

</div>
</div>
<a id="a3d0d738934cd91482550533fd88a96fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0d738934cd91482550533fd88a96fa">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_free_base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy function. Creates a deep copy of all data structures. It is usually enough to keep the data for different operations once, so this function should not be needed very often. </p>

</div>
</div>
<a id="a1f21e8893f049def7395c8cb7c4f0ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f21e8893f049def7395c8cb7c4f0ca9">&#9670;&nbsp;</a></span>update_mapping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::update_mapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refreshes the geometry data stored in the MappingInfo fields when the underlying geometry has changed (e.g. by a mapping that can deform through a change in the spatial configuration like <a class="el" href="classMappingFEField.html">MappingFEField</a>) whereas the topology of the mesh and unknowns have remained the same. Compared to <a class="el" href="classMatrixFree.html#adb324d469b296f2a6921b41208732ddf">reinit()</a>, this operation only has to re-generate the geometry arrays and can thus be significantly cheaper (depending on the cost to evaluate the geometry). </p>

</div>
</div>
<a id="a264d78dadbfd3bccb9c36e37226fd025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264d78dadbfd3bccb9c36e37226fd025">&#9670;&nbsp;</a></span>update_mapping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::update_mapping </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but with <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>. </p>

</div>
</div>
<a id="a2f0e2305a9a34137ce5db9c8c8c45507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0e2305a9a34137ce5db9c8c8c45507">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all data fields and brings the class into a condition similar to after having called the default constructor. </p>

</div>
</div>
<a id="abc204ec41ead1b5060f47ef3a5a066d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc204ec41ead1b5060f47ef3a5a066d7">&#9670;&nbsp;</a></span>cell_loop() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method runs the loop over all cells (in parallel) and performs the MPI data exchange on the source vector and destination vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_operation</td><td><code>std::function</code> with the signature <code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code> where the first argument passes the data of the calling class and the last argument defines the range of cells which should be worked on (typically more than one cell should be worked on in order to reduce overheads). One can pass a pointer to an object in this place if it has an <code>operator()</code> with the correct set of arguments since such a pointer can be converted to the function object.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination vector holding the result. If the vector is of type <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> (or composite objects thereof such as <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), the loop calls <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">LinearAlgebra::distributed::Vector::compress()</a> at the end of the call internally. For other vectors, including parallel Trilinos or PETSc vectors, no such call is issued. Note that Trilinos/Epetra or PETSc vectors do currently not work in parallel because the present class uses MPI-local index addressing, as opposed to the global addressing implied by those external libraries.</td></tr>
    <tr><td class="paramname">src</td><td>Input vector. If the vector is of type <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> (or composite objects thereof such as <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), the loop calls <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">LinearAlgebra::distributed::Vector::update_ghost_values()</a> at the start of the call internally to make sure all necessary data is locally available. Note, however, that the vector is reset to its original state at the end of the loop, i.e., if the vector was not ghosted upon entry of the loop, it will not be ghosted upon finishing the loop.</td></tr>
    <tr><td class="paramname">zero_dst_vector</td><td>If this flag is set to <code>true</code>, the vector <code>dst</code> will be set to zero inside the loop. Use this case in case you perform a typical <code>vmult()</code> operation on a matrix object, as it will typically be faster than calling <code>dst = 0;</code> before the loop separately. This is because the vector entries are set to zero only on subranges of the vector, making sure that the vector entries stay in caches as much as possible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa941c80d60b2cd987660d2d04587fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa941c80d60b2cd987660d2d04587fde">&#9670;&nbsp;</a></span>cell_loop() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the second variant to run the loop over all cells, now providing a function pointer to a member function of class <code>CLASS</code>. This method obviates the need to define a lambda function or to call std::bind to bind the class into the given function in case the local function needs to access data in the class (i.e., it is a non-static member function).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_operation</td><td>Pointer to member function of <code>CLASS</code> with the signature <code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code> where the first argument passes the data of the calling class and the last argument defines the range of cells which should be worked on (typically more than one cell should be worked on in order to reduce overheads).</td></tr>
    <tr><td class="paramname">owning_class</td><td>The object which provides the <code>cell_operation</code> call. To be compatible with this interface, the class must allow to call <code>owning_class-&gt;cell_operation(...)</code>.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination vector holding the result. If the vector is of type <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> (or composite objects thereof such as <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), the loop calls <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">LinearAlgebra::distributed::Vector::compress()</a> at the end of the call internally. For other vectors, including parallel Trilinos or PETSc vectors, no such call is issued. Note that Trilinos/Epetra or PETSc vectors do currently not work in parallel because the present class uses MPI-local index addressing, as opposed to the global addressing implied by those external libraries.</td></tr>
    <tr><td class="paramname">src</td><td>Input vector. If the vector is of type <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> (or composite objects thereof such as <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), the loop calls <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">LinearAlgebra::distributed::Vector::update_ghost_values()</a> at the start of the call internally to make sure all necessary data is locally available. Note, however, that the vector is reset to its original state at the end of the loop, i.e., if the vector was not ghosted upon entry of the loop, it will not be ghosted upon finishing the loop.</td></tr>
    <tr><td class="paramname">zero_dst_vector</td><td>If this flag is set to <code>true</code>, the vector <code>dst</code> will be set to zero inside the loop. Use this case in case you perform a typical <code>vmult()</code> operation on a matrix object, as it will typically be faster than calling <code>dst = 0;</code> before the loop separately. This is because the vector entries are set to zero only on subranges of the vector, making sure that the vector entries stay in caches as much as possible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca4e2ec1389ae3f7abd7c0552f782f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4e2ec1389ae3f7abd7c0552f782f47">&#9670;&nbsp;</a></span>cell_loop() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but for class member functions which are non-const. </p>

</div>
</div>
<a id="a6a53b93080a15c49d5513f09fc6bbb5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a53b93080a15c49d5513f09fc6bbb5d">&#9670;&nbsp;</a></span>cell_loop() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>operation_before_loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>operation_after_loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index_pre_post</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to the cell_loop with an std::function object to specify to operation to be performed on cells, but adds two additional functors to execute some additional work before and after the cell integrals are computed.</p>
<p>The two additional functors work on a range of degrees of freedom, expressed in terms of the degree-of-freedom numbering of the selected <a class="el" href="classDoFHandler.html">DoFHandler</a> <code>dof_handler_index_pre_post</code> in MPI-local indices. The arguments to the functors represent a range of degrees of freedom at a granularity of <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a626704a7e1e52a5399bd15cb6aa32100">internal::MatrixFreeFunctions::DoFInfo::chunk_size_zero_vector</a> entries (except for the last chunk which is set to the number of locally owned entries) in the form <code>[first, last)</code>. The idea of these functors is to bring operations on vectors closer to the point where they accessed in a matrix-free loop, with the goal to increase cache hits by temporal locality. This loop guarantees that the <code>operation_before_loop</code> hits all relevant unknowns before they are first touched in the cell_operation (including the MPI data exchange), allowing to execute some vector update that the <code>src</code> vector depends upon. The <code>operation_after_loop</code> is similar</p><ul>
<li>it starts to execute on a range of DoFs once all DoFs in that range have been touched for the last time by the <code>cell_operation</code> (including the MPI data exchange), allowing e.g. to compute some vector operations that depend on the result of the current cell loop in <code>dst</code> or want to modify <code>src</code>. The efficiency of caching depends on the numbering of the degrees of freedom because of the granularity of the ranges.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_operation</td><td>Pointer to member function of <code>CLASS</code> with the signature <code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code> where the first argument passes the data of the calling class and the last argument defines the range of cells which should be worked on (typically more than one cell should be worked on in order to reduce overheads).</td></tr>
    <tr><td class="paramname">owning_class</td><td>The object which provides the <code>cell_operation</code> call. To be compatible with this interface, the class must allow to call <code>owning_class-&gt;cell_operation(...)</code>.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination vector holding the result. If the vector is of type <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> (or composite objects thereof such as <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), the loop calls <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">LinearAlgebra::distributed::Vector::compress()</a> at the end of the call internally. For other vectors, including parallel Trilinos or PETSc vectors, no such call is issued. Note that Trilinos/Epetra or PETSc vectors do currently not work in parallel because the present class uses MPI-local index addressing, as opposed to the global addressing implied by those external libraries.</td></tr>
    <tr><td class="paramname">src</td><td>Input vector. If the vector is of type <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> (or composite objects thereof such as <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), the loop calls <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">LinearAlgebra::distributed::Vector::update_ghost_values()</a> at the start of the call internally to make sure all necessary data is locally available. Note, however, that the vector is reset to its original state at the end of the loop, i.e., if the vector was not ghosted upon entry of the loop, it will not be ghosted upon finishing the loop.</td></tr>
    <tr><td class="paramname">operation_before_loop</td><td>This functor can be used to perform an operation on entries of the <code>src</code> and <code>dst</code> vectors (or other vectors) before the operation on cells first touches a particular DoF according to the general description in the text above. This function is passed a range of the locally owned degrees of freedom on the selected <code>dof_handler_index_pre_post</code> (in MPI-local numbering).</td></tr>
    <tr><td class="paramname">operation_after_loop</td><td>This functor can be used to perform an operation on entries of the <code>src</code> and <code>dst</code> vectors (or other vectors) after the operation on cells last touches a particular DoF according to the general description in the text above. This function is passed a range of the locally owned degrees of freedom on the selected <code>dof_handler_index_pre_post</code> (in MPI-local numbering).</td></tr>
    <tr><td class="paramname">dof_handler_index_pre_post</td><td>Since <a class="el" href="classMatrixFree.html">MatrixFree</a> can be initialized with a vector of <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, each of them will in general have vector sizes and thus different ranges returned to <code>operation_before_loop</code> and <code>operation_after_loop</code>. Use this variable to specify which one of the <a class="el" href="classDoFHandler.html">DoFHandler</a> objects the index range should be associated to. Defaults to the <code>dof_handler_index</code> 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The close locality of the <code>operation_before_loop</code> and <code>operation_after_loop</code> is currently only implemented for the MPI-only case. In case threading is enabled, the complete <code>operation_before_loop</code> is scheduled before the parallel loop, and <code>operation_after_loop</code> is scheduled strictly afterwards, due to the complicated dependencies. </dd></dl>

</div>
</div>
<a id="a4299fd60761d1be3cc6461d72c265577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4299fd60761d1be3cc6461d72c265577">&#9670;&nbsp;</a></span>cell_loop() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>operation_before_loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>operation_after_loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index_pre_post</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but for class member functions which are non-const. </p>

</div>
</div>
<a id="a2c3b0bd3cad76dc2e3957f205c6138ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3b0bd3cad76dc2e3957f205c6138ac">&#9670;&nbsp;</a></span>cell_loop() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>operation_before_loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>operation_after_loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index_pre_post</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but taking an <code>std::function</code> as the <code>cell_operation</code> rather than a class member function. </p>

</div>
</div>
<a id="a0e9669e4a5cfaceac78f5e26c285c2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9669e4a5cfaceac78f5e26c285c2ea">&#9670;&nbsp;</a></span>loop() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::loop </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>face_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>dst_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>src_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method runs a loop over all cells (in parallel) and performs the MPI data exchange on the source vector and destination vector. As opposed to the other variants that only runs a function on cells, this method also takes as arguments a function for the interior faces and for the boundary faces, respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_operation</td><td><code>std::function</code> with the signature <code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code> where the first argument passes the data of the calling class and the last argument defines the range of cells which should be worked on (typically more than one cell should be worked on in order to reduce overheads). One can pass a pointer to an object in this place if it has an <code>operator()</code> with the correct set of arguments since such a pointer can be converted to the function object.</td></tr>
    <tr><td class="paramname">face_operation</td><td><code>std::function</code> with the signature <code>face_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code> in analogy to <code>cell_operation</code>, but now the part associated to the work on interior faces. Note that the <a class="el" href="classMatrixFree.html">MatrixFree</a> framework treats periodic faces as interior ones, so they will be assigned their correct neighbor after applying periodicity constraints within the face_operation calls.</td></tr>
    <tr><td class="paramname">boundary_operation</td><td><code>std::function</code> with the signature <code>boundary_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code> in analogy to <code>cell_operation</code> and <code>face_operation</code>, but now the part associated to the work on boundary faces. Boundary faces are separated by their <code>boundary_id</code> and it is possible to query that id using <a class="el" href="classMatrixFree.html#a94c875be0229e4872a3e087a55410625">MatrixFree::get_boundary_id()</a>. Note that both interior and faces use the same numbering, and faces in the interior are assigned lower numbers than the boundary faces.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination vector holding the result. If the vector is of type <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> (or composite objects thereof such as <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), the loop calls <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">LinearAlgebra::distributed::Vector::compress()</a> at the end of the call internally.</td></tr>
    <tr><td class="paramname">src</td><td>Input vector. If the vector is of type <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> (or composite objects thereof such as <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), the loop calls <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">LinearAlgebra::distributed::Vector::update_ghost_values()</a> at the start of the call internally to make sure all necessary data is locally available. Note, however, that the vector is reset to its original state at the end of the loop, i.e., if the vector was not ghosted upon entry of the loop, it will not be ghosted upon finishing the loop.</td></tr>
    <tr><td class="paramname">zero_dst_vector</td><td>If this flag is set to <code>true</code>, the vector <code>dst</code> will be set to zero inside the loop. Use this case in case you perform a typical <code>vmult()</code> operation on a matrix object, as it will typically be faster than calling <code>dst = 0;</code> before the loop separately. This is because the vector entries are set to zero only on subranges of the vector, making sure that the vector entries stay in caches as much as possible.</td></tr>
    <tr><td class="paramname">dst_vector_face_access</td><td>Set the type of access into the vector <code>dst</code> that will happen inside the body of the <code>face_operation</code> function. As explained in the description of the DataAccessOnFaces struct, the purpose of this selection is to reduce the amount of data that must be exchanged over the MPI network (or via <code>memcpy</code> if within the shared memory region of a node) to gain performance. Note that there is no way to communicate this setting with the <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a> class, therefore this selection must be made at this site in addition to what is implemented inside the <code>face_operation</code> function. As a consequence, there is also no way to check that the setting passed to this call is consistent with what is later done by <code><a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a></code>, and it is the user's responsibility to ensure correctness of data.</td></tr>
    <tr><td class="paramname">src_vector_face_access</td><td>Set the type of access into the vector <code>src</code> that will happen inside the body of the <code>face_operation</code> function, in analogy to <code>dst_vector_face_access</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c34b747893d2e6ad474aac9dbf35ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c34b747893d2e6ad474aac9dbf35ec8">&#9670;&nbsp;</a></span>loop() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>face_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>boundary_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>dst_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>src_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the second variant to run the loop over all cells, interior faces, and boundary faces, now providing three function pointers to member functions of class <code>CLASS</code> with the signature <code>operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt;&amp;)const</code>. This method obviates the need to define a lambda function or to call std::bind to bind the class into the given function in case the local function needs to access data in the class (i.e., it is a non-static member function).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_operation</td><td>Pointer to member function of <code>CLASS</code> with the signature <code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code> where the first argument passes the data of the calling class and the last argument defines the range of cells which should be worked on (typically more than one cell should be worked on in order to reduce overheads). Note that the loop will typically split the <code>cell_range</code> into smaller pieces and work on <code>cell_operation</code>, <code>face_operation</code>, and <code>boundary_operation</code> alternately, in order to increase the potential reuse of vector entries in caches.</td></tr>
    <tr><td class="paramname">face_operation</td><td>Pointer to member function of <code>CLASS</code> with the signature <code>face_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code> in analogy to <code>cell_operation</code>, but now the part associated to the work on interior faces. Note that the <a class="el" href="classMatrixFree.html">MatrixFree</a> framework treats periodic faces as interior ones, so they will be assigned their correct neighbor after applying periodicity constraints within the face_operation calls.</td></tr>
    <tr><td class="paramname">boundary_operation</td><td>Pointer to member function of <code>CLASS</code> with the signature <code>boundary_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code> in analogy to <code>cell_operation</code> and <code>face_operation</code>, but now the part associated to the work on boundary faces. Boundary faces are separated by their <code>boundary_id</code> and it is possible to query that id using <a class="el" href="classMatrixFree.html#a94c875be0229e4872a3e087a55410625">MatrixFree::get_boundary_id()</a>. Note that both interior and faces use the same numbering, and faces in the interior are assigned lower numbers than the boundary faces.</td></tr>
    <tr><td class="paramname">owning_class</td><td>The object which provides the <code>cell_operation</code> call. To be compatible with this interface, the class must allow to call <code>owning_class-&gt;cell_operation(...)</code>, <code>owning_class-&gt;face_operation(...)</code>, and <code>owning_class-&gt;boundary_operation(...)</code>.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination vector holding the result. If the vector is of type <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> (or composite objects thereof such as <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), the loop calls <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">LinearAlgebra::distributed::Vector::compress()</a> at the end of the call internally.</td></tr>
    <tr><td class="paramname">src</td><td>Input vector. If the vector is of type <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> (or composite objects thereof such as <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), the loop calls <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">LinearAlgebra::distributed::Vector::update_ghost_values()</a> at the start of the call internally to make sure all necessary data is locally available. Note, however, that the vector is reset to its original state at the end of the loop, i.e., if the vector was not ghosted upon entry of the loop, it will not be ghosted upon finishing the loop.</td></tr>
    <tr><td class="paramname">zero_dst_vector</td><td>If this flag is set to <code>true</code>, the vector <code>dst</code> will be set to zero inside the loop. Use this case in case you perform a typical <code>vmult()</code> operation on a matrix object, as it will typically be faster than calling <code>dst = 0;</code> before the loop separately. This is because the vector entries are set to zero only on subranges of the vector, making sure that the vector entries stay in caches as much as possible.</td></tr>
    <tr><td class="paramname">dst_vector_face_access</td><td>Set the type of access into the vector <code>dst</code> that will happen inside the body of the <code>face_operation</code> function. As explained in the description of the DataAccessOnFaces struct, the purpose of this selection is to reduce the amount of data that must be exchanged over the MPI network (or via <code>memcpy</code> if within the shared memory region of a node) to gain performance. Note that there is no way to communicate this setting with the <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a> class, therefore this selection must be made at this site in addition to what is implemented inside the <code>face_operation</code> function. As a consequence, there is also no way to check that the setting passed to this call is consistent with what is later done by <code><a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a></code>, and it is the user's responsibility to ensure correctness of data.</td></tr>
    <tr><td class="paramname">src_vector_face_access</td><td>Set the type of access into the vector <code>src</code> that will happen inside the body of the <code>face_operation</code> function, in analogy to <code>dst_vector_face_access</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add0de121d733bf745fadfc646d442524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0de121d733bf745fadfc646d442524">&#9670;&nbsp;</a></span>loop() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&#160;</td>
          <td class="paramname"><em>face_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&#160;</td>
          <td class="paramname"><em>boundary_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>dst_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>src_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but for class member functions which are non-const. </p>

</div>
</div>
<a id="a60ebe2e71cfd7602ef9bc612d22385f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ebe2e71cfd7602ef9bc612d22385f8">&#9670;&nbsp;</a></span>loop_cell_centric() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::loop_cell_centric </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>src_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method runs the loop over all cells (in parallel) similarly as <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop()</a> does. However, this function is intended to be used for the case if face and boundary integrals should be also evaluated. In contrast to <a class="el" href="classMatrixFree.html#a0e9669e4a5cfaceac78f5e26c285c2ea">loop()</a>, the user provides only a single function that should contain the cell integral over a cell (or batch of cells when vectorizing) and the face and boundary integrals over all its faces. This is referred to in the literature as <code>element-centric loop</code> or <code>cell-centric loop</code>.</p>
<p>To be able to evaluate all face integrals (with values or gradients from the neighboring cells), all ghost values from neighboring cells are updated. Use FEFaceEvalution::reinit(cell, face_no) to access quantities on arbitrary faces of a cell and the respective neighbors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_operation</td><td>Pointer to member function of <code>CLASS</code> with the signature <code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code> where the first argument passes the data of the calling class and the last argument defines the range of cells which should be worked on (typically more than one cell is passed in from the loop in order to reduce overheads).</td></tr>
    <tr><td class="paramname">owning_class</td><td>The object which provides the <code>cell_operation</code> call. To be compatible with this interface, the class must allow to call <code>owning_class-&gt;cell_operation(...)</code>.</td></tr>
    <tr><td class="paramname">dst</td><td>Destination vector holding the result. If the vector is of type <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> (or composite objects thereof such as <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), the loop calls <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">LinearAlgebra::distributed::Vector::compress()</a> at the end of the call internally.</td></tr>
    <tr><td class="paramname">src</td><td>Input vector. If the vector is of type <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> (or composite objects thereof such as <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), the loop calls <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">LinearAlgebra::distributed::Vector::update_ghost_values()</a> at the start of the call internally to make sure all necessary data is locally available. Note, however, that the vector is reset to its original state at the end of the loop, i.e., if the vector was not ghosted upon entry of the loop, it will not be ghosted upon finishing the loop.</td></tr>
    <tr><td class="paramname">zero_dst_vector</td><td>If this flag is set to <code>true</code>, the vector <code>dst</code> will be set to zero inside the loop. Use this case in case you perform a typical <code>vmult()</code> operation on a matrix object, as it will typically be faster than calling <code>dst = 0;</code> before the loop separately. This is because the vector entries are set to zero only on subranges of the vector, making sure that the vector entries stay in caches as much as possible.</td></tr>
    <tr><td class="paramname">src_vector_face_access</td><td>Set the type of access into the vector <code>src</code> that will happen inside the body of the <code>cell_operation</code> function during face integrals. As explained in the description of the DataAccessOnFaces struct, the purpose of this selection is to reduce the amount of data that must be exchanged over the MPI network (or via <code>memcpy</code> if within the shared memory region of a node) to gain performance. Note that there is no way to communicate this setting with the <a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a> class, therefore this selection must be made at this site in addition to what is implemented inside the <code>face_operation</code> function. As a consequence, there is also no way to check that the setting passed to this call is consistent with what is later done by <code><a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a></code>, and it is the user's responsibility to ensure correctness of data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03da600450c259400259f870800aea2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03da600450c259400259f870800aea2d">&#9670;&nbsp;</a></span>loop_cell_centric() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::loop_cell_centric </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>src_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but for the class member function which is non-const. </p>

</div>
</div>
<a id="aae39079578d1dd9d1a80b50567fc03ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae39079578d1dd9d1a80b50567fc03ec">&#9670;&nbsp;</a></span>loop_cell_centric() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::loop_cell_centric </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>src_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but with std::function. </p>

</div>
</div>
<a id="a16b6836f6e1df769d66d90a9d4fd8873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b6836f6e1df769d66d90a9d4fd8873">&#9670;&nbsp;</a></span>create_cell_subrange_hp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::create_cell_subrange_hp </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the hp-adaptive case, a subrange of cells as computed during the cell loop might contain elements of different degrees. Use this function to compute what the subrange for an individual finite element degree is. The finite element degree is associated to the vector component given in the function call. </p>

</div>
</div>
<a id="a394b47f93926a192ef5856106556d12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394b47f93926a192ef5856106556d12e">&#9670;&nbsp;</a></span>create_cell_subrange_hp_by_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::create_cell_subrange_hp_by_index </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the hp-adaptive case, a subrange of cells as computed during the cell loop might contain elements of different degrees. Use this function to compute what the subrange for a given index the hp-finite element, as opposed to the finite element degree in the other function. </p>

</div>
</div>
<a id="a00b8b15c5c3efed4c0082db8255bf1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b8b15c5c3efed4c0082db8255bf1aa">&#9670;&nbsp;</a></span>n_active_fe_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_active_fe_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the hp adaptive case, return number of active_fe_indices. </p>

</div>
</div>
<a id="a093da73c996f663066f827840f5c1c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093da73c996f663066f827840f5c1c55">&#9670;&nbsp;</a></span>get_cell_active_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_cell_active_fe_index </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the hp-adaptive case, return the active_fe_index of a cell range. </p>

</div>
</div>
<a id="ad5b265f35586470176204db6f6e70610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b265f35586470176204db6f6e70610">&#9670;&nbsp;</a></span>get_face_active_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_face_active_fe_index </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_interior_face</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the hp-adaptive case, return the active_fe_index of a face range. </p>

</div>
</div>
<a id="ab92a24942737bbaf04d7e00aceba9b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92a24942737bbaf04d7e00aceba9b57">&#9670;&nbsp;</a></span>initialize_dof_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::initialize_dof_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize function for a general vector. The length of the vector is equal to the total number of degrees in the <a class="el" href="classDoFHandler.html">DoFHandler</a>. If the vector is of class <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt;Number&gt;, the ghost entries are set accordingly. For vector-valued problems with several DoFHandlers underlying this class, the parameter <code>vector_component</code> defines which component is to be used.</p>
<p>For the vectors used with <a class="el" href="classMatrixFree.html">MatrixFree</a> and in <a class="el" href="classFEEvaluation.html">FEEvaluation</a>, a vector needs to hold all <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">locally active DoFs</a> and also some of the <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs</a>. The selection of DoFs is such that one can read all degrees of freedom on all locally relevant elements (locally active) plus the degrees of freedom that constraints expand into from the locally owned cells. However, not all locally relevant DoFs are stored because most of them would never be accessed in matrix-vector products and result in too much data sent around which impacts the performance. </p>

</div>
</div>
<a id="a6389c1e91648d277bdd81af095b5296c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6389c1e91648d277bdd81af095b5296c">&#9670;&nbsp;</a></span>initialize_dof_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::initialize_dof_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize function for a distributed vector. The length of the vector is equal to the total number of degrees in the <a class="el" href="classDoFHandler.html">DoFHandler</a>. If the vector is of class <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt;Number&gt;, the ghost entries are set accordingly. For vector-valued problems with several DoFHandlers underlying this class, the parameter <code>vector_component</code> defines which component is to be used.</p>
<p>For the vectors used with <a class="el" href="classMatrixFree.html">MatrixFree</a> and in <a class="el" href="classFEEvaluation.html">FEEvaluation</a>, a vector needs to hold all <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">locally active DoFs</a> and also some of the <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs</a>. The selection of DoFs is such that one can read all degrees of freedom on all locally relevant elements (locally active) plus the degrees of freedom that constraints expand into from the locally owned cells. However, not all locally relevant DoFs are stored because most of them would never be accessed in matrix-vector products and result in too much data sent around which impacts the performance. </p>

</div>
</div>
<a id="ae41cc9c8a14e3a485cefd570680268e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41cc9c8a14e3a485cefd570680268e1">&#9670;&nbsp;</a></span>get_vector_partitioner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_vector_partitioner </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the partitioner that represents the locally owned data and the ghost indices where access is needed to for the cell loop. The partitioner is constructed from the locally owned dofs and ghost dofs given by the respective fields. If you want to have specific information about these objects, you can query them with the respective access functions. If you just want to initialize a (parallel) vector, you should usually prefer this data structure as the data exchange information can be reused from one vector to another. </p>

</div>
</div>
<a id="afb2c36a70878d0ec24e250a9587e786e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2c36a70878d0ec24e250a9587e786e">&#9670;&nbsp;</a></span>get_locally_owned_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndexSet.html">IndexSet</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_locally_owned_set </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the set of cells that are owned by the processor. </p>

</div>
</div>
<a id="a18245454fbd9c8a2ef6a4b30280042c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18245454fbd9c8a2ef6a4b30280042c6">&#9670;&nbsp;</a></span>get_ghost_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndexSet.html">IndexSet</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_ghost_set </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the set of ghost cells needed but not owned by the processor. </p>

</div>
</div>
<a id="a4d6b0854710b1c9aeb889c4875f0a47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6b0854710b1c9aeb889c4875f0a47b">&#9670;&nbsp;</a></span>get_constrained_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_constrained_dofs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of all degrees of freedom that are constrained. The list is returned in MPI-local index space for the locally owned range of the vector, not in global MPI index space that spans all MPI processors. To get numbers in global index space, call <code><a class="el" href="classMatrixFree.html#ae41cc9c8a14e3a485cefd570680268e1">get_vector_partitioner()</a>-&gt;local_to_global</code> on an entry of the vector. In addition, it only returns the indices for degrees of freedom that are owned locally, not for ghosts. </p>

</div>
</div>
<a id="ad40c40bd8fb8a804f2982bee8c1de070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40c40bd8fb8a804f2982bee8c1de070">&#9670;&nbsp;</a></span>renumber_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::renumber_dofs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes a renumbering of degrees of freedom that better fits with the data layout in <a class="el" href="classMatrixFree.html">MatrixFree</a> according to the given layout of data. Note that this function does not re-arrange the information stored in this class, but rather creates a renumbering for consumption of <a class="el" href="classDoFHandler.html#a44e80b846cf60a8671969ce90ae3625b">DoFHandler::renumber_dofs</a>. To have any effect a <a class="el" href="classMatrixFree.html">MatrixFree</a> object must be set up again using the renumbered <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classAffineConstraints.html">AffineConstraints</a>. Note that if a <a class="el" href="classDoFHandler.html">DoFHandler</a> calls <a class="el" href="classDoFHandler.html#a44e80b846cf60a8671969ce90ae3625b">DoFHandler::renumber_dofs</a>, all information in <a class="el" href="classMatrixFree.html">MatrixFree</a> becomes invalid. </p>

</div>
</div>
<a id="afbe3ca9fc933b303cdc134fcb86bfbb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe3ca9fc933b303cdc134fcb86bfbb6">&#9670;&nbsp;</a></span>is_supported()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::is_supported </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether a given <a class="el" href="classFiniteElement.html">FiniteElement</a> <code>fe</code> is supported by this class. </p>

</div>
</div>
<a id="ab74907342812d74f2c89d825436d1b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74907342812d74f2c89d825436d1b70">&#9670;&nbsp;</a></span>n_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of different DoFHandlers specified at initialization. </p>

</div>
</div>
<a id="aec2cd5fcca15d0a9cb78f15473d7bbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2cd5fcca15d0a9cb78f15473d7bbc0">&#9670;&nbsp;</a></span>n_base_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_base_elements </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For the finite element underlying the <a class="el" href="classDoFHandler.html">DoFHandler</a> specified by <code>dof_handler_index</code>, return the number of base elements. </p>

</div>
</div>
<a id="ab9298b98c63d9d7b93367fcbeda9fe1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9298b98c63d9d7b93367fcbeda9fe1b">&#9670;&nbsp;</a></span>n_physical_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_physical_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of cells this structure is based on. If you are using a usual <a class="el" href="classDoFHandler.html">DoFHandler</a>, it corresponds to the number of (locally owned) active cells. Note that most data structures in this class do not directly act on this number but rather on <a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches()</a> which gives the number of cells as seen when lumping several cells together with vectorization. </p>

</div>
</div>
<a id="ac6ce1aa8a6e9f3aa897a51d5dcf68c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ce1aa8a6e9f3aa897a51d5dcf68c5c">&#9670;&nbsp;</a></span>n_macro_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_macro_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000078">Deprecated:</a></b></dt><dd>Use <a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches()</a> instead. </dd></dl>

</div>
</div>
<a id="a8c9d964339b466bdcb661552e731e222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9d964339b466bdcb661552e731e222">&#9670;&nbsp;</a></span>n_cell_batches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_cell_batches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of cell batches that this structure works on. The batches are formed by application of vectorization over several cells in general. The cell range in <code>cell_loop</code> runs from zero to <a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches()</a> (exclusive), so this is the appropriate size if you want to store arrays of data for all cells to be worked on. This number is approximately <code><a class="el" href="classMatrixFree.html#ab9298b98c63d9d7b93367fcbeda9fe1b">n_physical_cells()</a>/VectorizedArray::size()</code> (depending on how many cell batches that do not get filled up completely). </p>

</div>
</div>
<a id="a0c08e4ba63acbb93d0f3a1441b88d61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c08e4ba63acbb93d0f3a1441b88d61c">&#9670;&nbsp;</a></span>n_ghost_cell_batches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_ghost_cell_batches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of additional cell batches that this structure keeps for face integration. Note that not all cells that are ghosted in the triangulation are kept in this data structure, but only the ones which are necessary for evaluating face integrals from both sides. </p>

</div>
</div>
<a id="a1d24c18bcde8d09a2a7847f0f7f96d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d24c18bcde8d09a2a7847f0f7f96d19">&#9670;&nbsp;</a></span>n_inner_face_batches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_inner_face_batches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of interior face batches that this structure works on. The batches are formed by application of vectorization over several faces in general. The face range in <code>loop</code> runs from zero to <a class="el" href="classMatrixFree.html#a1d24c18bcde8d09a2a7847f0f7f96d19">n_inner_face_batches()</a> (exclusive), so this is the appropriate size if you want to store arrays of data for all interior faces to be worked on. </p>

</div>
</div>
<a id="aa787165092c1949ce2128ca63799abc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa787165092c1949ce2128ca63799abc1">&#9670;&nbsp;</a></span>n_boundary_face_batches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_boundary_face_batches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of boundary face batches that this structure works on. The batches are formed by application of vectorization over several faces in general. The face range in <code>loop</code> runs from <a class="el" href="classMatrixFree.html#a1d24c18bcde8d09a2a7847f0f7f96d19">n_inner_face_batches()</a> to <a class="el" href="classMatrixFree.html#a1d24c18bcde8d09a2a7847f0f7f96d19">n_inner_face_batches()</a>+n_boundary_face_batches() (exclusive), so if you need to store arrays that hold data for all boundary faces but not the interior ones, this number gives the appropriate size. </p>

</div>
</div>
<a id="acf3aff8b6750287728851ef8753b135a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3aff8b6750287728851ef8753b135a">&#9670;&nbsp;</a></span>n_ghost_inner_face_batches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_ghost_inner_face_batches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of faces that are not processed locally but belong to locally owned faces. </p>

</div>
</div>
<a id="a94c875be0229e4872a3e087a55410625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c875be0229e4872a3e087a55410625">&#9670;&nbsp;</a></span>get_boundary_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_boundary_id </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>macro_face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In order to apply different operators to different parts of the boundary, this method can be used to query the boundary id of a given face in the faces' own sorting by lanes in a <a class="el" href="classVectorizedArray.html">VectorizedArray</a>. Only valid for an index indicating a boundary face. </p>

</div>
</div>
<a id="a75b99380acd6e278c4acf6a19fa443ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b99380acd6e278c4acf6a19fa443ba">&#9670;&nbsp;</a></span>get_faces_by_cells_boundary_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, VectorizedArrayType::size()&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_faces_by_cells_boundary_id </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the boundary ids for the faces within a cell, using the cells' sorting by lanes in the <a class="el" href="classVectorizedArray.html">VectorizedArray</a>. </p>

</div>
</div>
<a id="af3bf03172546d9ba1b8b14c845da46df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3bf03172546d9ba1b8b14c845da46df">&#9670;&nbsp;</a></span>get_dof_handler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_dof_handler </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classDoFHandler.html">DoFHandler</a> with the index as given to the respective <code>std::vector</code> argument in the <a class="el" href="classMatrixFree.html#adb324d469b296f2a6921b41208732ddf">reinit()</a> function. </p>

</div>
</div>
<a id="a6c2de43baa7e77d1e3e4e60fc215f843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2de43baa7e77d1e3e4e60fc215f843">&#9670;&nbsp;</a></span>get_dof_handler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const DoFHandlerType&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_dof_handler </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classDoFHandler.html">DoFHandler</a> with the index as given to the respective <code>std::vector</code> argument in the <a class="el" href="classMatrixFree.html#adb324d469b296f2a6921b41208732ddf">reinit()</a> function. Note that if you want to call this function with a template parameter different than the default one, you will need to use the <code>template</code> before the function call, i.e., you will have something like <code>matrix_free.template get_dof_handler&lt;<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a>&lt;dim&gt;&gt;()</code>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000079">Deprecated:</a></b></dt><dd>Use the non-templated equivalent of this function. </dd></dl>

</div>
</div>
<a id="aad2ce5ee5867360c16019d618e250ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2ce5ee5867360c16019d618e250ce4">&#9670;&nbsp;</a></span>get_cell_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;::cell_iterator <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_cell_iterator </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>lane_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the cell iterator in deal.II speak to a given cell batch (populating several lanes in a <a class="el" href="classVectorizedArray.html">VectorizedArray</a>) and the lane index within the vectorization across cells in the renumbering of this structure.</p>
<p>Note that the cell iterators in deal.II go through cells differently to what the cell loop of this class does. This is because several cells are processed together (vectorization across cells), and since cells with neighbors on different MPI processors need to be accessed at a certain time when accessing remote data and overlapping communication with computation. </p>

</div>
</div>
<a id="a46ed5ced497a19b51592f23ca8e6faf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ed5ced497a19b51592f23ca8e6faf5">&#9670;&nbsp;</a></span>get_cell_level_and_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_cell_level_and_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>lane_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns the level and index for the cell that would be returned by <a class="el" href="classMatrixFree.html#aad2ce5ee5867360c16019d618e250ce4">get_cell_iterator()</a> for the same arguments <code>cell_batch_index</code> and <code>lane_index</code>. </p>

</div>
</div>
<a id="a6076e2d012fad941d8d326a7dc8c3a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6076e2d012fad941d8d326a7dc8c3a78">&#9670;&nbsp;</a></span>get_face_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;::cell_iterator, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_face_iterator </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_batch_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>lane_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>interior</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the cell iterator in deal.II speak to an interior/exterior cell of a face in a pair of a face batch and lane index. The second element of the pair is the face number so that the face iterator can be accessed: <code>pair.first()-&gt;face(pair.second());</code></p>
<p>Note that the face iterators in deal.II go through cells differently to what the face/boundary loop of this class does. This is because several faces are worked on together (vectorization), and since faces with neighbor cells on different MPI processors need to be accessed at a certain time when accessing remote data and overlapping communication with computation. </p>

</div>
</div>
<a id="a1f172cadd38fd88cfd4d1f1205b63614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f172cadd38fd88cfd4d1f1205b63614">&#9670;&nbsp;</a></span>get_hp_cell_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;::active_cell_iterator <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_hp_cell_iterator </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>lane_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Return the cell iterator in deal.II speak to a given cell batch (populating several lanes in a <a class="el" href="classVectorizedArray.html">VectorizedArray</a>) and the lane index within the vectorization across cells in the renumbering of this structure.</p>
<p>Note that the cell iterators in deal.II go through cells differently to what the cell loop of this class does. This is because several cells are processed together (vectorization across cells), and since cells with neighbors on different MPI processors need to be accessed at a certain time when accessing remote data and overlapping communication with computation.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000080">Deprecated:</a></b></dt><dd>Use <a class="el" href="classMatrixFree.html#aad2ce5ee5867360c16019d618e250ce4">get_cell_iterator()</a> instead. </dd></dl>

</div>
</div>
<a id="a39c46e404d4a727175eb154f9f6e6304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c46e404d4a727175eb154f9f6e6304">&#9670;&nbsp;</a></span>at_irregular_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::at_irregular_cell </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Since this class uses vectorized data types with usually more than one value in the data field, a situation might occur when some components of the vector type do not correspond to an actual cell in the mesh. When using only this class, one usually does not need to bother about that fact since the values are padded with zeros. However, when this class is mixed with deal.II access to cells, care needs to be taken. This function returns <code>true</code> if not all <code>n_lanes</code> cells for the given <code>cell_batch_index</code> correspond to actual cells of the mesh and some are merely present for padding reasons. To find out how many cells are actually used, use the function <a class="el" href="classMatrixFree.html#a1d516071d20e633dc9efcadb7852ce15">n_active_entries_per_cell_batch()</a>. </p>

</div>
</div>
<a id="a251d5c0f5cc96057223ebbffacd91a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251d5c0f5cc96057223ebbffacd91a03">&#9670;&nbsp;</a></span>n_components_filled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_components_filled </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000081">Deprecated:</a></b></dt><dd>Use <a class="el" href="classMatrixFree.html#a1d516071d20e633dc9efcadb7852ce15">n_active_entries_per_cell_batch()</a> instead. </dd></dl>

</div>
</div>
<a id="a1d516071d20e633dc9efcadb7852ce15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d516071d20e633dc9efcadb7852ce15">&#9670;&nbsp;</a></span>n_active_entries_per_cell_batch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_active_entries_per_cell_batch </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This query returns how many cells among the <code>VectorizedArrayType::size()</code> many cells within a cell batch to actual cells in the mesh, rather than being present for padding reasons. For most given cell batches in <a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches()</a>, this number is equal to <code>VectorizedArrayType::size()</code>, but there might be one or a few cell batches in the mesh (where the numbers do not add up) where only some of the cells within a batch are used, indicated by the function <a class="el" href="classMatrixFree.html#a39c46e404d4a727175eb154f9f6e6304">at_irregular_cell()</a>. </p>

</div>
</div>
<a id="ad6297a9ec73d830ae81e5eeacf02df27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6297a9ec73d830ae81e5eeacf02df27">&#9670;&nbsp;</a></span>n_active_entries_per_face_batch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_active_entries_per_face_batch </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_batch_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this function to find out how many faces over the length of vectorization data types correspond to real faces (both interior and boundary faces, as those use the same indexing but with different ranges) in the mesh. For most given indices in n_inner_faces_batches() and <a class="el" href="classMatrixFree.html#aa787165092c1949ce2128ca63799abc1">n_boundary_face_batches()</a>, this is just <code>vectorization_length</code> many, but there might be one or a few meshes (where the numbers do not add up) where there are less such lanes filled. </p>

</div>
</div>
<a id="a4183258475490709034dbff113cbc789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4183258475490709034dbff113cbc789">&#9670;&nbsp;</a></span>get_dofs_per_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_dofs_per_cell </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of degrees of freedom per cell for a given hp-index. </p>

</div>
</div>
<a id="aba06e049b55e59507a69e37e7a23f3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba06e049b55e59507a69e37e7a23f3b5">&#9670;&nbsp;</a></span>get_n_q_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_n_q_points </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of quadrature points per cell for a given hp-index. </p>

</div>
</div>
<a id="a4e0e4541d14974ef533bd9e61a8b8a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0e4541d14974ef533bd9e61a8b8a7f">&#9670;&nbsp;</a></span>get_dofs_per_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_dofs_per_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of degrees of freedom on each face of the cell for given hp-index. </p>

</div>
</div>
<a id="a31fea1afe46c9741117a3a5d6a6c7259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fea1afe46c9741117a3a5d6a6c7259">&#9670;&nbsp;</a></span>get_n_q_points_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_n_q_points_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of quadrature points on each face of the cell for given hp-index. </p>

</div>
</div>
<a id="a16b0fd13ac2a63888c4836640e8bc68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b0fd13ac2a63888c4836640e8bc68b">&#9670;&nbsp;</a></span>get_quadrature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_quadrature </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the quadrature rule for given hp-index. </p>

</div>
</div>
<a id="a1cf4cff03dbaa9fa73605966c185b60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf4cff03dbaa9fa73605966c185b60f">&#9670;&nbsp;</a></span>get_face_quadrature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim - 1&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_face_quadrature </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the quadrature rule for given hp-index. </p>

</div>
</div>
<a id="a9822d4a731c450b74bc32843dfc57235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9822d4a731c450b74bc32843dfc57235">&#9670;&nbsp;</a></span>get_cell_category()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_cell_category </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the category the current batch of cells was assigned to. Categories run between the given values in the field <a class="el" href="structMatrixFree_1_1AdditionalData.html#a969eb6b91d17748718c4affd03841e91">AdditionalData::cell_vectorization_category</a> for non-hp-DoFHandler types and return the active FE index in the hp-adaptive case. </p>

</div>
</div>
<a id="a6272714d1f3a4389937894f2044a1298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6272714d1f3a4389937894f2044a1298">&#9670;&nbsp;</a></span>get_face_category()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_face_category </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>macro_face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the category on the cells on the two sides of the current batch of faces. </p>

</div>
</div>
<a id="a90f6b960d4810e6914a45d9cbb164793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f6b960d4810e6914a45d9cbb164793">&#9670;&nbsp;</a></span>indices_initialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::indices_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries whether or not the indexation has been set. </p>

</div>
</div>
<a id="a2b95d23ac163726460a536e76513ac13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b95d23ac163726460a536e76513ac13">&#9670;&nbsp;</a></span>mapping_initialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::mapping_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries whether or not the geometry-related information for the cells has been set. </p>

</div>
</div>
<a id="a214a09bc9d553323fe8e2d4ab85bd1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214a09bc9d553323fe8e2d4ab85bd1d1">&#9670;&nbsp;</a></span>get_mg_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_mg_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the level of the mesh to be worked on. Returns <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> if working on active cells. </p>

</div>
</div>
<a id="aa47cc139ef80f83ed20fc55e3cd16767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47cc139ef80f83ed20fc55e3cd16767">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an approximation of the memory consumption of this class in bytes. </p>

</div>
</div>
<a id="a256aac0a2e56bb2345f7a3f0ce74bef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256aac0a2e56bb2345f7a3f0ce74bef8">&#9670;&nbsp;</a></span>print_memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::print_memory_consumption </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a detailed summary of memory consumption in the different structures of this class to the given output stream. </p>

</div>
</div>
<a id="a1988bac68c909d3868c61a66eb285791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1988bac68c909d3868c61a66eb285791">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a summary of this class to the given output stream. It is focused on the indices, and does not print all the data stored. </p>

</div>
</div>
<a id="afad4aeebcf482bcc621c6f7947209a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad4aeebcf482bcc621c6f7947209a7c">&#9670;&nbsp;</a></span>get_task_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_task_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return information on task graph. </p>

</div>
</div>
<a id="a94748ddaa979639d6ed02d9f4f617fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94748ddaa979639d6ed02d9f4f617fdf">&#9670;&nbsp;</a></span>get_mapping_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const internal::MatrixFreeFunctions:: MappingInfo&lt;dim, Number, VectorizedArrayType&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_mapping_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e095529abf96aad2b7fbc95c545fd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e095529abf96aad2b7fbc95c545fd8d">&#9670;&nbsp;</a></span>get_dof_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_dof_info </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index_component</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return information on indexation degrees of freedom. </p>

</div>
</div>
<a id="a41c33c7336c73d245d5624baf610d5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c33c7336c73d245d5624baf610d5a8">&#9670;&nbsp;</a></span>n_constraint_pool_entries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_constraint_pool_entries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of weights in the constraint pool. </p>

</div>
</div>
<a id="a2cd98b7686fe06501575420c8ad0819b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd98b7686fe06501575420c8ad0819b">&#9670;&nbsp;</a></span>constraint_pool_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Number* <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::constraint_pool_begin </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>pool_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the first number in the constraint pool data with index <code>pool_index</code> (to be used together with <code><a class="el" href="classMatrixFree.html#a4f37a1274ff5b9092bb4f968d499b2f8">constraint_pool_end()</a></code>). </p>

</div>
</div>
<a id="a4f37a1274ff5b9092bb4f968d499b2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f37a1274ff5b9092bb4f968d499b2f8">&#9670;&nbsp;</a></span>constraint_pool_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Number* <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::constraint_pool_end </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>pool_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to one past the last number in the constraint pool data with index <code>pool_index</code> (to be used together with <code><a class="el" href="classMatrixFree.html#a2cd98b7686fe06501575420c8ad0819b">constraint_pool_begin()</a></code>). </p>

</div>
</div>
<a id="a363a85c27301642b9d0fd219f15ff229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363a85c27301642b9d0fd219f15ff229">&#9670;&nbsp;</a></span>get_shape_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt;VectorizedArrayType&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_shape_info </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index_component</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_base_element</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_quad_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the unit cell information for given hp-index. </p>

</div>
</div>
<a id="aa13157af74893593d4af73a30b01a74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13157af74893593d4af73a30b01a74b">&#9670;&nbsp;</a></span>get_face_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">internal::MatrixFreeFunctions::FaceToCellTopology</a>&lt; VectorizedArrayType::size()&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_face_info </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_batch_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the connectivity information of a face. </p>

</div>
</div>
<a id="a0656887db9b1c8123e650632eadf8996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0656887db9b1c8123e650632eadf8996">&#9670;&nbsp;</a></span>get_cell_and_face_to_plain_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTable.html">Table</a>&lt;3, unsigned <a class="el" href="classint.html">int</a>&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_cell_and_face_to_plain_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the table that translates a triple of the macro cell number, the index of a face within a cell and the index within the cell batch of vectorization into the index within the faces array. </p>

</div>
</div>
<a id="acf9054eb8149297fe2e062369f0dc618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9054eb8149297fe2e062369f0dc618">&#9670;&nbsp;</a></span>acquire_scratch_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;VectorizedArrayType&gt;* <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::acquire_scratch_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains a scratch data object for internal use. Make sure to release it afterwards by passing the pointer you obtain from this object to the <a class="el" href="classMatrixFree.html#a59550cc34721cf03a46f6f44347bcb0c">release_scratch_data()</a> function. This interface is used by <a class="el" href="classFEEvaluation.html">FEEvaluation</a> objects for storing their data structures.</p>
<p>The organization of the internal data structure is a thread-local storage of a list of vectors. Multiple threads will each get a separate storage field and separate vectors, ensuring thread safety. The mechanism to acquire and release objects is similar to the mechanisms used for the local contributions of <a class="el" href="namespaceWorkStream.html">WorkStream</a>, see <a class="el" href="DEALGlossary.html#workstream_paper">the WorkStream paper</a>. </p>

</div>
</div>
<a id="a59550cc34721cf03a46f6f44347bcb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59550cc34721cf03a46f6f44347bcb0c">&#9670;&nbsp;</a></span>release_scratch_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::release_scratch_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; *&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes the object of the scratchpad available again. </p>

</div>
</div>
<a id="a0a77e6d9daf1c25b438f2c3a9430b908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a77e6d9daf1c25b438f2c3a9430b908">&#9670;&nbsp;</a></span>acquire_scratch_data_non_threadsafe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;Number&gt;* <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::acquire_scratch_data_non_threadsafe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains a scratch data object for internal use. Make sure to release it afterwards by passing the pointer you obtain from this object to the <a class="el" href="classMatrixFree.html#ad1131ad89d22abda0be5b0e766097d92">release_scratch_data_non_threadsafe()</a> function. Note that, as opposed to <a class="el" href="classMatrixFree.html#acf9054eb8149297fe2e062369f0dc618">acquire_scratch_data()</a>, this method can only be called by a single thread at a time, but opposed to the <a class="el" href="classMatrixFree.html#acf9054eb8149297fe2e062369f0dc618">acquire_scratch_data()</a> it is also possible that the thread releasing the scratch data can be different than the one that acquired it. </p>

</div>
</div>
<a id="ad1131ad89d22abda0be5b0e766097d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1131ad89d22abda0be5b0e766097d92">&#9670;&nbsp;</a></span>release_scratch_data_non_threadsafe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::release_scratch_data_non_threadsafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; Number &gt; *&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes the object of the scratch data available again. </p>

</div>
</div>
<a id="a08f23adccbd26348ab71866dc49283d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f23adccbd26348ab71866dc49283d7">&#9670;&nbsp;</a></span>internal_reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename number2 , int q_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::internal_reinit </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handlers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; q_dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the actual reinit function that sets up the indices for the <a class="el" href="classDoFHandler.html">DoFHandler</a> case. </p>

</div>
</div>
<a id="a3508f2538e470b07826a62a03292e603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3508f2538e470b07826a62a03292e603">&#9670;&nbsp;</a></span>initialize_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::initialize_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the fields in DoFInfo together with the constraint pool that holds all different weights in the constraints (not part of DoFInfo because several DoFInfo classes can have the same weights which consequently only need to be stored once). </p>

</div>
</div>
<a id="adb08861aba08a05bbb6a62d30fd8ed1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb08861aba08a05bbb6a62d30fd8ed1c">&#9670;&nbsp;</a></span>initialize_dof_handlers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::initialize_dof_handlers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handlers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the DoFHandlers based on a <a class="el" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> argument. </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af7d00e4ed4f076e3a86cab23b6d8b452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d00e4ed4f076e3a86cab23b6d8b452">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dimension set by the template argument <code>dim</code>. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00133">133</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="aaed884d2e3733624b9028bea0952ae39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed884d2e3733624b9028bea0952ae39">&#9670;&nbsp;</a></span>dof_handlers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt; &gt; &gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::dof_handlers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointers to the DoFHandlers underlying the current problem. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l02072">2072</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="acc52f212dd2448479233a1bcad3fa40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc52f212dd2448479233a1bcad3fa40e">&#9670;&nbsp;</a></span>dof_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::dof_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains the information about degrees of freedom on the individual cells and constraints. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l02078">2078</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a8a1b58d294b2d341cf019efcdbab88b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1b58d294b2d341cf019efcdbab88b5">&#9670;&nbsp;</a></span>constraint_pool_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Number&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::constraint_pool_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains the weights for constraints stored in DoFInfo. Filled into a separate field since several vector components might share similar weights, which reduces memory consumption. Moreover, it obviates template arguments on DoFInfo and keeps it a plain field of indices only. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l02086">2086</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="ae0bc8be50b14ea2fd9168edcaa74db40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0bc8be50b14ea2fd9168edcaa74db40">&#9670;&nbsp;</a></span>constraint_pool_row_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::constraint_pool_row_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains an indicator to the start of the ith index in the constraint pool data. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l02092">2092</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a0819d60614c996f43079cc20e0d63933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0819d60614c996f43079cc20e0d63933">&#9670;&nbsp;</a></span>mapping_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfo.html">internal::MatrixFreeFunctions::MappingInfo</a>&lt;dim, Number, VectorizedArrayType&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::mapping_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Holds information on transformation of cells from reference cell to real cell that is needed for evaluating integrals. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l02099">2099</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a0fe9b8c6fc5ca0c15d84ca0243eea7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe9b8c6fc5ca0c15d84ca0243eea7f6">&#9670;&nbsp;</a></span>shape_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt;4, <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt;VectorizedArrayType&gt; &gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::shape_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains shape value information on the unit cell. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l02105">2105</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a6ccb8c2689c4029ccf44dacf47c4d224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccb8c2689c4029ccf44dacf47c4d224">&#9670;&nbsp;</a></span>cell_level_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_level_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Describes how the cells are gone through. With the cell level (first index in this field) and the index within the level, one can reconstruct a deal.II cell iterator and use all the traditional things deal.II offers to do with cell iterators. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l02113">2113</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="aebd8b73ecd3843be97bc6c62a91550e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd8b73ecd3843be97bc6c62a91550e8">&#9670;&nbsp;</a></span>cell_level_index_end_local</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_level_index_end_local</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For discontinuous Galerkin, the cell_level_index includes cells that are not on the local processor but that are needed to evaluate the cell integrals. In cell_level_index_end_local, we store the number of local cells. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l02122">2122</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a538b16343ba782ba2bc83624660c1a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538b16343ba782ba2bc83624660c1a03">&#9670;&nbsp;</a></span>task_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::task_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the basic layout of the cells and faces to be treated, including the task layout for the shared memory parallelization and possible overlaps between communications and computations with MPI. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l02129">2129</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="adb2d9efa44c36973e8c871c79f55cea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2d9efa44c36973e8c871c79f55cea3">&#9670;&nbsp;</a></span>face_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceInfo.html">internal::MatrixFreeFunctions::FaceInfo</a>&lt;VectorizedArrayType::size()&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::face_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classVector.html">Vector</a> holding face information. Only initialized if build_face_info=true. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l02136">2136</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="ad9776b9b9cb59771ed0409f0e61d9092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9776b9b9cb59771ed0409f0e61d9092">&#9670;&nbsp;</a></span>indices_are_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::indices_are_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores whether indices have been initialized. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l02141">2141</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a60d4bcec742b46e930fc6d3ad1854f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d4bcec742b46e930fc6d3ad1854f35">&#9670;&nbsp;</a></span>mapping_is_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::mapping_is_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores whether indices have been initialized. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l02146">2146</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a9dbe6cd7b3a803387e09b5746898a1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbe6cd7b3a803387e09b5746898a1fc">&#9670;&nbsp;</a></span>scratch_pad</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; std::list&lt;std::pair&lt;<a class="el" href="classbool.html">bool</a>, <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;VectorizedArrayType&gt; &gt; &gt; &gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::scratch_pad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scratchpad memory for use in evaluation. We allow more than one evaluation object to attach to this field (this, the outer std::vector), so we need to keep tracked of whether a certain data field is already used (first part of pair) and keep a list of objects. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l02157">2157</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="aab344a297bb56fc07d4490794da49fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab344a297bb56fc07d4490794da49fc9">&#9670;&nbsp;</a></span>scratch_pad_non_threadsafe</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;std::pair&lt;<a class="el" href="classbool.html">bool</a>, <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;Number&gt; &gt; &gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::scratch_pad_non_threadsafe</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scratchpad memory for use in evaluation and other contexts, non-thread safe variant. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l02164">2164</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a65d5b0dfea8051c30f80a7f3f72fd5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d5b0dfea8051c30f80a7f3f72fd5bc">&#9670;&nbsp;</a></span>mg_level</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::mg_level</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stored the level of the mesh to be worked on. </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l02169">2169</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/matrix_free/<a class="el" href="matrix__free_8h_source.html">matrix_free.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
