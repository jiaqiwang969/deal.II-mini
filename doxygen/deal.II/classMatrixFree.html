<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classMatrixFree.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MatrixFree&lt; dim, Number, VectorizedArrayType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classMatrixFree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MatrixFree&lt; dim, Number, VectorizedArrayType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__matrixfree.html">Matrix-free infrastructure</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="matrix__free_8h_source.html">deal.II/matrix_free/matrix_free.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MatrixFree&lt; dim, Number, VectorizedArrayType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classMatrixFree__inherit__graph.svg" width="206" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a751b5f06534d52773eba384d2c866a15"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> { <br />
&#160;&#160;<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15a334c4a4c42fdb79d7ebc3e73b517e6f8">DataAccessOnFaces::none</a>, 
<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15af09cc7ee3a9a93273f4b80601cafb00c">DataAccessOnFaces::values</a>, 
<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15a108449c0466dc01a217d1ab2f99e5d5c">DataAccessOnFaces::values_all_faces</a>, 
<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ac2af294b46c59f4ca21a4aac2b2d97b1">DataAccessOnFaces::gradients</a>, 
<br />
&#160;&#160;<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15adceeae01fe1b10f8d3202a66d4676915">DataAccessOnFaces::gradients_all_faces</a>, 
<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>
<br />
 }</td></tr>
<tr class="separator:a751b5f06534d52773eba384d2c866a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c999e29f872bce1d487c893c861c0b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aa3c999e29f872bce1d487c893c861c0b">value_type</a> = Number</td></tr>
<tr class="separator:aa3c999e29f872bce1d487c893c861c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae84ac145ae6c2277eca3612d46b21e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a8ae84ac145ae6c2277eca3612d46b21e">vectorized_value_type</a> = VectorizedArrayType</td></tr>
<tr class="separator:a8ae84ac145ae6c2277eca3612d46b21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">1：构造和初始化</div></td></tr>
<tr class="memitem:ad235137af17c50208c03a418340acbc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad235137af17c50208c03a418340acbc8">MatrixFree</a> ()</td></tr>
<tr class="separator:ad235137af17c50208c03a418340acbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64503de42775fdae6c16957be9a9c050"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a64503de42775fdae6c16957be9a9c050">MatrixFree</a> (const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;other)</td></tr>
<tr class="separator:a64503de42775fdae6c16957be9a9c050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae41f0192ab55694a07606eea09fa88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a3ae41f0192ab55694a07606eea09fa88">~MatrixFree</a> () override=default</td></tr>
<tr class="separator:a3ae41f0192ab55694a07606eea09fa88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb324d469b296f2a6921b41208732ddf"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 , typename MappingType &gt; </td></tr>
<tr class="memitem:adb324d469b296f2a6921b41208732ddf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#adb324d469b296f2a6921b41208732ddf">reinit</a> (const MappingType &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:adb324d469b296f2a6921b41208732ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9a0610e482e6785491a8a2c7bd8aee"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 &gt; </td></tr>
<tr class="memitem:aeb9a0610e482e6785491a8a2c7bd8aee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aeb9a0610e482e6785491a8a2c7bd8aee">reinit</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;dof_handler, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:aeb9a0610e482e6785491a8a2c7bd8aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4a663740edef3fc4207ea2ec865a62"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 , typename MappingType &gt; </td></tr>
<tr class="memitem:ada4a663740edef3fc4207ea2ec865a62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ada4a663740edef3fc4207ea2ec865a62">reinit</a> (const MappingType &amp;mapping, const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const std::vector&lt; QuadratureType &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:ada4a663740edef3fc4207ea2ec865a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf219f9b30dff16e5c41c3086d64b166"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType , typename MappingType &gt; </td></tr>
<tr class="memitem:abf219f9b30dff16e5c41c3086d64b166"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#abf219f9b30dff16e5c41c3086d64b166">reinit</a> (const MappingType &amp;mapping, const std::vector&lt; const DoFHandlerType *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const std::vector&lt; QuadratureType &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:abf219f9b30dff16e5c41c3086d64b166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3913c1558b53ecabbc55cb83a1167cf8"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 &gt; </td></tr>
<tr class="memitem:a3913c1558b53ecabbc55cb83a1167cf8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a3913c1558b53ecabbc55cb83a1167cf8">reinit</a> (const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const std::vector&lt; QuadratureType &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a3913c1558b53ecabbc55cb83a1167cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49254941a791433cbe774cbf02649eb"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:ad49254941a791433cbe774cbf02649eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad49254941a791433cbe774cbf02649eb">reinit</a> (const std::vector&lt; const DoFHandlerType *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const std::vector&lt; QuadratureType &gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:ad49254941a791433cbe774cbf02649eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1472228976422cd5c785f106f26fd54d"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 , typename MappingType &gt; </td></tr>
<tr class="memitem:a1472228976422cd5c785f106f26fd54d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1472228976422cd5c785f106f26fd54d">reinit</a> (const MappingType &amp;mapping, const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a1472228976422cd5c785f106f26fd54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5518f32796400b39a74cbf58a97e2df7"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType , typename MappingType &gt; </td></tr>
<tr class="memitem:a5518f32796400b39a74cbf58a97e2df7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a5518f32796400b39a74cbf58a97e2df7">reinit</a> (const MappingType &amp;mapping, const std::vector&lt; const DoFHandlerType *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:a5518f32796400b39a74cbf58a97e2df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee59b4b26a998451b74d7f2948aed300"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 &gt; </td></tr>
<tr class="memitem:aee59b4b26a998451b74d7f2948aed300"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aee59b4b26a998451b74d7f2948aed300">reinit</a> (const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:aee59b4b26a998451b74d7f2948aed300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac683f503f6c869f7619157c446dd9713"><td class="memTemplParams" colspan="2">template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:ac683f503f6c869f7619157c446dd9713"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ac683f503f6c869f7619157c446dd9713">reinit</a> (const std::vector&lt; const DoFHandlerType *&gt; &amp;dof_handler, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const QuadratureType &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:ac683f503f6c869f7619157c446dd9713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0d738934cd91482550533fd88a96fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a3d0d738934cd91482550533fd88a96fa">copy_from</a> (const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;matrix_free_base)</td></tr>
<tr class="separator:a3d0d738934cd91482550533fd88a96fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f21e8893f049def7395c8cb7c4f0ca9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1f21e8893f049def7395c8cb7c4f0ca9">update_mapping</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping)</td></tr>
<tr class="separator:a1f21e8893f049def7395c8cb7c4f0ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264d78dadbfd3bccb9c36e37226fd025"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a264d78dadbfd3bccb9c36e37226fd025">update_mapping</a> (const std::shared_ptr&lt; <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim &gt;&gt; &amp;mapping)</td></tr>
<tr class="separator:a264d78dadbfd3bccb9c36e37226fd025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0e2305a9a34137ce5db9c8c8c45507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2f0e2305a9a34137ce5db9c8c8c45507">clear</a> ()</td></tr>
<tr class="separator:a2f0e2305a9a34137ce5db9c8c8c45507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">2：无矩阵循环</div></td></tr>
<tr class="memitem:abc204ec41ead1b5060f47ef3a5a066d7"><td class="memTemplParams" colspan="2">template&lt;typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:abc204ec41ead1b5060f47ef3a5a066d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a> (const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;cell_operation, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false) const</td></tr>
<tr class="separator:abc204ec41ead1b5060f47ef3a5a066d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa941c80d60b2cd987660d2d04587fde"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:aaa941c80d60b2cd987660d2d04587fde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aaa941c80d60b2cd987660d2d04587fde">cell_loop</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const, const CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false) const</td></tr>
<tr class="separator:aaa941c80d60b2cd987660d2d04587fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4e2ec1389ae3f7abd7c0552f782f47"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:aca4e2ec1389ae3f7abd7c0552f782f47"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aca4e2ec1389ae3f7abd7c0552f782f47">cell_loop</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;), CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false) const</td></tr>
<tr class="separator:aca4e2ec1389ae3f7abd7c0552f782f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a53b93080a15c49d5513f09fc6bbb5d"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a6a53b93080a15c49d5513f09fc6bbb5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6a53b93080a15c49d5513f09fc6bbb5d">cell_loop</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const, const CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;operation_before_loop, const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;operation_after_loop, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index_pre_post=0) const</td></tr>
<tr class="separator:a6a53b93080a15c49d5513f09fc6bbb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4299fd60761d1be3cc6461d72c265577"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a4299fd60761d1be3cc6461d72c265577"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4299fd60761d1be3cc6461d72c265577">cell_loop</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;), CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;operation_before_loop, const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;operation_after_loop, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index_pre_post=0) const</td></tr>
<tr class="separator:a4299fd60761d1be3cc6461d72c265577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3b0bd3cad76dc2e3957f205c6138ac"><td class="memTemplParams" colspan="2">template&lt;typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a2c3b0bd3cad76dc2e3957f205c6138ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2c3b0bd3cad76dc2e3957f205c6138ac">cell_loop</a> (const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;cell_operation, OutVector &amp;dst, const InVector &amp;src, const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;operation_before_loop, const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;operation_after_loop, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index_pre_post=0) const</td></tr>
<tr class="separator:a2c3b0bd3cad76dc2e3957f205c6138ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9669e4a5cfaceac78f5e26c285c2ea"><td class="memTemplParams" colspan="2">template&lt;typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a0e9669e4a5cfaceac78f5e26c285c2ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a0e9669e4a5cfaceac78f5e26c285c2ea">loop</a> (const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;cell_operation, const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;face_operation, const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;boundary_operation, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> dst_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> src_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>) const</td></tr>
<tr class="separator:a0e9669e4a5cfaceac78f5e26c285c2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c34b747893d2e6ad474aac9dbf35ec8"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a5c34b747893d2e6ad474aac9dbf35ec8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a5c34b747893d2e6ad474aac9dbf35ec8">loop</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const, void(CLASS::*face_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const, void(CLASS::*boundary_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const, const CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> dst_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> src_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>) const</td></tr>
<tr class="separator:a5c34b747893d2e6ad474aac9dbf35ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0de121d733bf745fadfc646d442524"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:add0de121d733bf745fadfc646d442524"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#add0de121d733bf745fadfc646d442524">loop</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;), void(CLASS::*face_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;), void(CLASS::*boundary_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;), CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> dst_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> src_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>) const</td></tr>
<tr class="separator:add0de121d733bf745fadfc646d442524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ebe2e71cfd7602ef9bc612d22385f8"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a60ebe2e71cfd7602ef9bc612d22385f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a60ebe2e71cfd7602ef9bc612d22385f8">loop_cell_centric</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const, const CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> src_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>) const</td></tr>
<tr class="separator:a60ebe2e71cfd7602ef9bc612d22385f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03da600450c259400259f870800aea2d"><td class="memTemplParams" colspan="2">template&lt;typename CLASS , typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:a03da600450c259400259f870800aea2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a03da600450c259400259f870800aea2d">loop_cell_centric</a> (void(CLASS::*cell_operation)(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;), CLASS *owning_class, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> src_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>) const</td></tr>
<tr class="separator:a03da600450c259400259f870800aea2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae39079578d1dd9d1a80b50567fc03ec"><td class="memTemplParams" colspan="2">template&lt;typename OutVector , typename InVector &gt; </td></tr>
<tr class="memitem:aae39079578d1dd9d1a80b50567fc03ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aae39079578d1dd9d1a80b50567fc03ec">loop_cell_centric</a> (const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a> &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;cell_operation, OutVector &amp;dst, const InVector &amp;src, const <a class="el" href="classbool.html">bool</a> zero_dst_vector=false, const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a> src_vector_face_access=<a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a>) const</td></tr>
<tr class="separator:aae39079578d1dd9d1a80b50567fc03ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b6836f6e1df769d66d90a9d4fd8873"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a16b6836f6e1df769d66d90a9d4fd8873">create_cell_subrange_hp</a> (const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;range, const unsigned <a class="el" href="classint.html">int</a> fe_degree, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:a16b6836f6e1df769d66d90a9d4fd8873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394b47f93926a192ef5856106556d12e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a394b47f93926a192ef5856106556d12e">create_cell_subrange_hp_by_index</a> (const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;range, const unsigned <a class="el" href="classint.html">int</a> fe_index, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:a394b47f93926a192ef5856106556d12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b8b15c5c3efed4c0082db8255bf1aa"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a00b8b15c5c3efed4c0082db8255bf1aa">n_active_fe_indices</a> () const</td></tr>
<tr class="separator:a00b8b15c5c3efed4c0082db8255bf1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093da73c996f663066f827840f5c1c55"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a093da73c996f663066f827840f5c1c55">get_cell_active_fe_index</a> (const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; range) const</td></tr>
<tr class="separator:a093da73c996f663066f827840f5c1c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b265f35586470176204db6f6e70610"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad5b265f35586470176204db6f6e70610">get_face_active_fe_index</a> (const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; range, const <a class="el" href="classbool.html">bool</a> is_interior_face=true) const</td></tr>
<tr class="separator:ad5b265f35586470176204db6f6e70610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">3: 向量的初始化</div></td></tr>
<tr class="memitem:ab92a24942737bbaf04d7e00aceba9b57"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:ab92a24942737bbaf04d7e00aceba9b57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">initialize_dof_vector</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:ab92a24942737bbaf04d7e00aceba9b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6389c1e91648d277bdd81af095b5296c"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a6389c1e91648d277bdd81af095b5296c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6389c1e91648d277bdd81af095b5296c">initialize_dof_vector</a> (<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number2 &gt; &amp;vec, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:a6389c1e91648d277bdd81af095b5296c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41cc9c8a14e3a485cefd570680268e1"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ae41cc9c8a14e3a485cefd570680268e1">get_vector_partitioner</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:ae41cc9c8a14e3a485cefd570680268e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2c36a70878d0ec24e250a9587e786e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#afb2c36a70878d0ec24e250a9587e786e">get_locally_owned_set</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:afb2c36a70878d0ec24e250a9587e786e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18245454fbd9c8a2ef6a4b30280042c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a18245454fbd9c8a2ef6a4b30280042c6">get_ghost_set</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:a18245454fbd9c8a2ef6a4b30280042c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6b0854710b1c9aeb889c4875f0a47b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4d6b0854710b1c9aeb889c4875f0a47b">get_constrained_dofs</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:a4d6b0854710b1c9aeb889c4875f0a47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40c40bd8fb8a804f2982bee8c1de070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad40c40bd8fb8a804f2982bee8c1de070">renumber_dofs</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;renumbering, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0)</td></tr>
<tr class="separator:ad40c40bd8fb8a804f2982bee8c1de070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">5: 访问内部数据结构 注意：专家模式，接口在不同版本之间不稳定。</div></td></tr>
<tr class="memitem:afad4aeebcf482bcc621c6f7947209a7c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#afad4aeebcf482bcc621c6f7947209a7c">get_task_info</a> () const</td></tr>
<tr class="separator:afad4aeebcf482bcc621c6f7947209a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94748ddaa979639d6ed02d9f4f617fdf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfo.html">internal::MatrixFreeFunctions::MappingInfo</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a94748ddaa979639d6ed02d9f4f617fdf">get_mapping_info</a> () const</td></tr>
<tr class="separator:a94748ddaa979639d6ed02d9f4f617fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e095529abf96aad2b7fbc95c545fd8d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4e095529abf96aad2b7fbc95c545fd8d">get_dof_info</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index_component=0) const</td></tr>
<tr class="separator:a4e095529abf96aad2b7fbc95c545fd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c33c7336c73d245d5624baf610d5a8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a41c33c7336c73d245d5624baf610d5a8">n_constraint_pool_entries</a> () const</td></tr>
<tr class="separator:a41c33c7336c73d245d5624baf610d5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd98b7686fe06501575420c8ad0819b"><td class="memItemLeft" align="right" valign="top">const Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2cd98b7686fe06501575420c8ad0819b">constraint_pool_begin</a> (const unsigned <a class="el" href="classint.html">int</a> pool_index) const</td></tr>
<tr class="separator:a2cd98b7686fe06501575420c8ad0819b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f37a1274ff5b9092bb4f968d499b2f8"><td class="memItemLeft" align="right" valign="top">const Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4f37a1274ff5b9092bb4f968d499b2f8">constraint_pool_end</a> (const unsigned <a class="el" href="classint.html">int</a> pool_index) const</td></tr>
<tr class="separator:a4f37a1274ff5b9092bb4f968d499b2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363a85c27301642b9d0fd219f15ff229"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt; VectorizedArrayType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a363a85c27301642b9d0fd219f15ff229">get_shape_info</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index_component=0, const unsigned <a class="el" href="classint.html">int</a> quad_index=0, const unsigned <a class="el" href="classint.html">int</a> fe_base_element=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_quad_index=0) const</td></tr>
<tr class="separator:a363a85c27301642b9d0fd219f15ff229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13157af74893593d4af73a30b01a74b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">internal::MatrixFreeFunctions::FaceToCellTopology</a>&lt; VectorizedArrayType::size()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aa13157af74893593d4af73a30b01a74b">get_face_info</a> (const unsigned <a class="el" href="classint.html">int</a> face_batch_index) const</td></tr>
<tr class="separator:aa13157af74893593d4af73a30b01a74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0656887db9b1c8123e650632eadf8996"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTable.html">Table</a>&lt; 3, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a0656887db9b1c8123e650632eadf8996">get_cell_and_face_to_plain_faces</a> () const</td></tr>
<tr class="separator:a0656887db9b1c8123e650632eadf8996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9054eb8149297fe2e062369f0dc618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#acf9054eb8149297fe2e062369f0dc618">acquire_scratch_data</a> () const</td></tr>
<tr class="separator:acf9054eb8149297fe2e062369f0dc618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59550cc34721cf03a46f6f44347bcb0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a59550cc34721cf03a46f6f44347bcb0c">release_scratch_data</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; *memory) const</td></tr>
<tr class="separator:a59550cc34721cf03a46f6f44347bcb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a77e6d9daf1c25b438f2c3a9430b908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; Number &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a0a77e6d9daf1c25b438f2c3a9430b908">acquire_scratch_data_non_threadsafe</a> () const</td></tr>
<tr class="separator:a0a77e6d9daf1c25b438f2c3a9430b908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1131ad89d22abda0be5b0e766097d92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad1131ad89d22abda0be5b0e766097d92">release_scratch_data_non_threadsafe</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; Number &gt; *memory) const</td></tr>
<tr class="separator:ad1131ad89d22abda0be5b0e766097d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af7d00e4ed4f076e3a86cab23b6d8b452"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#af7d00e4ed4f076e3a86cab23b6d8b452">dimension</a> = dim</td></tr>
<tr class="separator:af7d00e4ed4f076e3a86cab23b6d8b452"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a08f23adccbd26348ab71866dc49283d7"><td class="memTemplParams" colspan="2">template&lt;typename number2 , int q_dim&gt; </td></tr>
<tr class="memitem:a08f23adccbd26348ab71866dc49283d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a08f23adccbd26348ab71866dc49283d7">internal_reinit</a> (const std::shared_ptr&lt; <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim &gt;&gt; &amp;mapping, const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; *&gt; &amp;<a class="el" href="classMatrixFree.html#aaed884d2e3733624b9028bea0952ae39">dof_handlers</a>, const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;locally_owned_set, const std::vector&lt; <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; q_dim &gt;&gt; &amp;quad, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data)</td></tr>
<tr class="separator:a08f23adccbd26348ab71866dc49283d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3508f2538e470b07826a62a03292e603"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a3508f2538e470b07826a62a03292e603"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a3508f2538e470b07826a62a03292e603">initialize_indices</a> (const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;constraint, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;locally_owned_set, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data)</td></tr>
<tr class="separator:a3508f2538e470b07826a62a03292e603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb08861aba08a05bbb6a62d30fd8ed1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#adb08861aba08a05bbb6a62d30fd8ed1c">initialize_dof_handlers</a> (const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; *&gt; &amp;<a class="el" href="classMatrixFree.html#aaed884d2e3733624b9028bea0952ae39">dof_handlers</a>, const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data)</td></tr>
<tr class="separator:adb08861aba08a05bbb6a62d30fd8ed1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aaed884d2e3733624b9028bea0952ae39"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aaed884d2e3733624b9028bea0952ae39">dof_handlers</a></td></tr>
<tr class="separator:aaed884d2e3733624b9028bea0952ae39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc52f212dd2448479233a1bcad3fa40e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#acc52f212dd2448479233a1bcad3fa40e">dof_info</a></td></tr>
<tr class="separator:acc52f212dd2448479233a1bcad3fa40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1b58d294b2d341cf019efcdbab88b5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a8a1b58d294b2d341cf019efcdbab88b5">constraint_pool_data</a></td></tr>
<tr class="separator:a8a1b58d294b2d341cf019efcdbab88b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bc8be50b14ea2fd9168edcaa74db40"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ae0bc8be50b14ea2fd9168edcaa74db40">constraint_pool_row_index</a></td></tr>
<tr class="separator:ae0bc8be50b14ea2fd9168edcaa74db40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0819d60614c996f43079cc20e0d63933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfo.html">internal::MatrixFreeFunctions::MappingInfo</a>&lt; dim, Number, VectorizedArrayType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a0819d60614c996f43079cc20e0d63933">mapping_info</a></td></tr>
<tr class="separator:a0819d60614c996f43079cc20e0d63933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe9b8c6fc5ca0c15d84ca0243eea7f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a>&lt; 4, <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt; VectorizedArrayType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a0fe9b8c6fc5ca0c15d84ca0243eea7f6">shape_info</a></td></tr>
<tr class="separator:a0fe9b8c6fc5ca0c15d84ca0243eea7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccb8c2689c4029ccf44dacf47c4d224"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6ccb8c2689c4029ccf44dacf47c4d224">cell_level_index</a></td></tr>
<tr class="separator:a6ccb8c2689c4029ccf44dacf47c4d224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd8b73ecd3843be97bc6c62a91550e8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aebd8b73ecd3843be97bc6c62a91550e8">cell_level_index_end_local</a></td></tr>
<tr class="separator:aebd8b73ecd3843be97bc6c62a91550e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538b16343ba782ba2bc83624660c1a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a538b16343ba782ba2bc83624660c1a03">task_info</a></td></tr>
<tr class="separator:a538b16343ba782ba2bc83624660c1a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2d9efa44c36973e8c871c79f55cea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceInfo.html">internal::MatrixFreeFunctions::FaceInfo</a>&lt; VectorizedArrayType::size()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#adb2d9efa44c36973e8c871c79f55cea3">face_info</a></td></tr>
<tr class="separator:adb2d9efa44c36973e8c871c79f55cea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9776b9b9cb59771ed0409f0e61d9092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad9776b9b9cb59771ed0409f0e61d9092">indices_are_initialized</a></td></tr>
<tr class="separator:ad9776b9b9cb59771ed0409f0e61d9092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d4bcec742b46e930fc6d3ad1854f35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a60d4bcec742b46e930fc6d3ad1854f35">mapping_is_initialized</a></td></tr>
<tr class="separator:a60d4bcec742b46e930fc6d3ad1854f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbe6cd7b3a803387e09b5746898a1fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; std::list&lt; std::pair&lt; <a class="el" href="classbool.html">bool</a>, <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a9dbe6cd7b3a803387e09b5746898a1fc">scratch_pad</a></td></tr>
<tr class="separator:a9dbe6cd7b3a803387e09b5746898a1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab344a297bb56fc07d4490794da49fc9"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::pair&lt; <a class="el" href="classbool.html">bool</a>, <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; Number &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aab344a297bb56fc07d4490794da49fc9">scratch_pad_non_threadsafe</a></td></tr>
<tr class="separator:aab344a297bb56fc07d4490794da49fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d5b0dfea8051c30f80a7f3f72fd5bc"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a65d5b0dfea8051c30f80a7f3f72fd5bc">mg_level</a></td></tr>
<tr class="separator:a65d5b0dfea8051c30f80a7f3f72fd5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
4：一般信息</h2></td></tr>
<tr class="memitem:ab74907342812d74f2c89d825436d1b70"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ab74907342812d74f2c89d825436d1b70">n_components</a> () const</td></tr>
<tr class="separator:ab74907342812d74f2c89d825436d1b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2cd5fcca15d0a9cb78f15473d7bbc0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aec2cd5fcca15d0a9cb78f15473d7bbc0">n_base_elements</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index) const</td></tr>
<tr class="separator:aec2cd5fcca15d0a9cb78f15473d7bbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9298b98c63d9d7b93367fcbeda9fe1b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ab9298b98c63d9d7b93367fcbeda9fe1b">n_physical_cells</a> () const</td></tr>
<tr class="separator:ab9298b98c63d9d7b93367fcbeda9fe1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ce1aa8a6e9f3aa897a51d5dcf68c5c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ac6ce1aa8a6e9f3aa897a51d5dcf68c5c">n_macro_cells</a> () const</td></tr>
<tr class="separator:ac6ce1aa8a6e9f3aa897a51d5dcf68c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9d964339b466bdcb661552e731e222"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a> () const</td></tr>
<tr class="separator:a8c9d964339b466bdcb661552e731e222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c08e4ba63acbb93d0f3a1441b88d61c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a0c08e4ba63acbb93d0f3a1441b88d61c">n_ghost_cell_batches</a> () const</td></tr>
<tr class="separator:a0c08e4ba63acbb93d0f3a1441b88d61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d24c18bcde8d09a2a7847f0f7f96d19"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1d24c18bcde8d09a2a7847f0f7f96d19">n_inner_face_batches</a> () const</td></tr>
<tr class="separator:a1d24c18bcde8d09a2a7847f0f7f96d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa787165092c1949ce2128ca63799abc1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aa787165092c1949ce2128ca63799abc1">n_boundary_face_batches</a> () const</td></tr>
<tr class="separator:aa787165092c1949ce2128ca63799abc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3aff8b6750287728851ef8753b135a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#acf3aff8b6750287728851ef8753b135a">n_ghost_inner_face_batches</a> () const</td></tr>
<tr class="separator:acf3aff8b6750287728851ef8753b135a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c875be0229e4872a3e087a55410625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a94c875be0229e4872a3e087a55410625">get_boundary_id</a> (const unsigned <a class="el" href="classint.html">int</a> macro_face) const</td></tr>
<tr class="separator:a94c875be0229e4872a3e087a55410625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b99380acd6e278c4acf6a19fa443ba"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, VectorizedArrayType::size()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a75b99380acd6e278c4acf6a19fa443ba">get_faces_by_cells_boundary_id</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_index, const unsigned <a class="el" href="classint.html">int</a> face_number) const</td></tr>
<tr class="separator:a75b99380acd6e278c4acf6a19fa443ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bf03172546d9ba1b8b14c845da46df"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#af3bf03172546d9ba1b8b14c845da46df">get_dof_handler</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:af3bf03172546d9ba1b8b14c845da46df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2de43baa7e77d1e3e4e60fc215f843"><td class="memTemplParams" colspan="2">template&lt;typename DoFHandlerType &gt; </td></tr>
<tr class="memitem:a6c2de43baa7e77d1e3e4e60fc215f843"><td class="memTemplItemLeft" align="right" valign="top">const DoFHandlerType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6c2de43baa7e77d1e3e4e60fc215f843">get_dof_handler</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:a6c2de43baa7e77d1e3e4e60fc215f843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2ce5ee5867360c16019d618e250ce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;::cell_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aad2ce5ee5867360c16019d618e250ce4">get_cell_iterator</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_index, const unsigned <a class="el" href="classint.html">int</a> lane_index, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:aad2ce5ee5867360c16019d618e250ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ed5ced497a19b51592f23ca8e6faf5"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a46ed5ced497a19b51592f23ca8e6faf5">get_cell_level_and_index</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_index, const unsigned <a class="el" href="classint.html">int</a> lane_index) const</td></tr>
<tr class="separator:a46ed5ced497a19b51592f23ca8e6faf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6076e2d012fad941d8d326a7dc8c3a78"><td class="memItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;::cell_iterator, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6076e2d012fad941d8d326a7dc8c3a78">get_face_iterator</a> (const unsigned <a class="el" href="classint.html">int</a> face_batch_index, const unsigned <a class="el" href="classint.html">int</a> lane_index, const <a class="el" href="classbool.html">bool</a> interior=true, const unsigned <a class="el" href="classint.html">int</a> fe_component=0) const</td></tr>
<tr class="separator:a6076e2d012fad941d8d326a7dc8c3a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f172cadd38fd88cfd4d1f1205b63614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt;::active_cell_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1f172cadd38fd88cfd4d1f1205b63614">get_hp_cell_iterator</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_index, const unsigned <a class="el" href="classint.html">int</a> lane_index, const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0) const</td></tr>
<tr class="separator:a1f172cadd38fd88cfd4d1f1205b63614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c46e404d4a727175eb154f9f6e6304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a39c46e404d4a727175eb154f9f6e6304">at_irregular_cell</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_index) const</td></tr>
<tr class="separator:a39c46e404d4a727175eb154f9f6e6304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251d5c0f5cc96057223ebbffacd91a03"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a251d5c0f5cc96057223ebbffacd91a03">n_components_filled</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_number) const</td></tr>
<tr class="separator:a251d5c0f5cc96057223ebbffacd91a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d516071d20e633dc9efcadb7852ce15"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1d516071d20e633dc9efcadb7852ce15">n_active_entries_per_cell_batch</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_index) const</td></tr>
<tr class="separator:a1d516071d20e633dc9efcadb7852ce15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6297a9ec73d830ae81e5eeacf02df27"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#ad6297a9ec73d830ae81e5eeacf02df27">n_active_entries_per_face_batch</a> (const unsigned <a class="el" href="classint.html">int</a> face_batch_index) const</td></tr>
<tr class="separator:ad6297a9ec73d830ae81e5eeacf02df27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4183258475490709034dbff113cbc789"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4183258475490709034dbff113cbc789">get_dofs_per_cell</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const</td></tr>
<tr class="separator:a4183258475490709034dbff113cbc789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba06e049b55e59507a69e37e7a23f3b5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aba06e049b55e59507a69e37e7a23f3b5">get_n_q_points</a> (const unsigned <a class="el" href="classint.html">int</a> quad_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const</td></tr>
<tr class="separator:aba06e049b55e59507a69e37e7a23f3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0e4541d14974ef533bd9e61a8b8a7f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a4e0e4541d14974ef533bd9e61a8b8a7f">get_dofs_per_face</a> (const unsigned <a class="el" href="classint.html">int</a> dof_handler_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const</td></tr>
<tr class="separator:a4e0e4541d14974ef533bd9e61a8b8a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fea1afe46c9741117a3a5d6a6c7259"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a31fea1afe46c9741117a3a5d6a6c7259">get_n_q_points_face</a> (const unsigned <a class="el" href="classint.html">int</a> quad_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const</td></tr>
<tr class="separator:a31fea1afe46c9741117a3a5d6a6c7259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b0fd13ac2a63888c4836640e8bc68b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a16b0fd13ac2a63888c4836640e8bc68b">get_quadrature</a> (const unsigned <a class="el" href="classint.html">int</a> quad_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const</td></tr>
<tr class="separator:a16b0fd13ac2a63888c4836640e8bc68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf4cff03dbaa9fa73605966c185b60f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1cf4cff03dbaa9fa73605966c185b60f">get_face_quadrature</a> (const unsigned <a class="el" href="classint.html">int</a> quad_index=0, const unsigned <a class="el" href="classint.html">int</a> hp_active_fe_index=0) const</td></tr>
<tr class="separator:a1cf4cff03dbaa9fa73605966c185b60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9822d4a731c450b74bc32843dfc57235"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a9822d4a731c450b74bc32843dfc57235">get_cell_category</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_index) const</td></tr>
<tr class="separator:a9822d4a731c450b74bc32843dfc57235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6272714d1f3a4389937894f2044a1298"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a6272714d1f3a4389937894f2044a1298">get_face_category</a> (const unsigned <a class="el" href="classint.html">int</a> macro_face) const</td></tr>
<tr class="separator:a6272714d1f3a4389937894f2044a1298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f6b960d4810e6914a45d9cbb164793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a90f6b960d4810e6914a45d9cbb164793">indices_initialized</a> () const</td></tr>
<tr class="separator:a90f6b960d4810e6914a45d9cbb164793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b95d23ac163726460a536e76513ac13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a2b95d23ac163726460a536e76513ac13">mapping_initialized</a> () const</td></tr>
<tr class="separator:a2b95d23ac163726460a536e76513ac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214a09bc9d553323fe8e2d4ab85bd1d1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a214a09bc9d553323fe8e2d4ab85bd1d1">get_mg_level</a> () const</td></tr>
<tr class="separator:a214a09bc9d553323fe8e2d4ab85bd1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47cc139ef80f83ed20fc55e3cd16767"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#aa47cc139ef80f83ed20fc55e3cd16767">memory_consumption</a> () const</td></tr>
<tr class="separator:aa47cc139ef80f83ed20fc55e3cd16767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256aac0a2e56bb2345f7a3f0ce74bef8"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:a256aac0a2e56bb2345f7a3f0ce74bef8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a256aac0a2e56bb2345f7a3f0ce74bef8">print_memory_consumption</a> (StreamType &amp;out) const</td></tr>
<tr class="separator:a256aac0a2e56bb2345f7a3f0ce74bef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1988bac68c909d3868c61a66eb285791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#a1988bac68c909d3868c61a66eb285791">print</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a1988bac68c909d3868c61a66eb285791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe3ca9fc933b303cdc134fcb86bfbb6"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:afbe3ca9fc933b303cdc134fcb86bfbb6"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixFree.html#afbe3ca9fc933b303cdc134fcb86bfbb6">is_supported</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe)</td></tr>
<tr class="separator:afbe3ca9fc933b303cdc134fcb86bfbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt;<br />
class MatrixFree&lt; dim, Number, VectorizedArrayType &gt;</h3>

<p>这个类收集了所有为矩阵自由实现而存储的数据。这个存储方案是针对用相同数据进行的几个循环而定制的，也就是说，通常在同一个网格上做许多矩阵-向量乘积或残差计算。该类在 <a class="el" href="step_37.html">step-37</a> 和 <a class="el" href="step_48.html">step-48</a> 中使用。 该类不实现任何涉及有限元基函数的操作，即关于对单元的操作。对于这些操作，FEEvaluation类被设计为使用该类中收集的数据。 存储的数据可以细分为三个主要部分。</p>
<ul>
<li>DoFInfo：它存储了局部自由度与全局自由度的关系。它包括对约束条件的描述，这些约束条件被评估为穿过一个单元上的所有局部自由度。</li>
<li>MappingInfo：它存储了从实数到单位单元的转换，这些转换对于建立有限元函数的导数和找到物理空间中正交权重的位置是必要的。</li>
<li>ShapeInfo：它包含有限元的形状函数，在单元格上进行评估。 除了初始化程序，这个类只实现了一个单一的操作，即所有单元的循环（cell_loop()）。这个循环的安排方式是，共享自由度的单元不会同时工作，这意味着可以并行地写入向量（或矩阵），而不必明确地同步访问这些向量和矩阵。这个类没有实现任何形状值，它所做的只是缓存相应的数据。要实现有限元操作，请使用FEEvaluation类（或一些相关的类）。 这个类以不同的顺序遍历单元，与deal.II中通常的Triangulation类不同，以便在共享内存和矢量化的并行化方面具有灵活性。 矢量化是通过将几个拓扑单元合并成一个所谓的宏观单元来实现的。这使得几个单元的所有相关操作都可以用一条CPU指令来实现，这也是这个框架的主要特点之一。 关于这个类的使用细节，见FEEvaluation的描述或 <a class="el" href="group__matrixfree.html">无矩阵模块</a> 。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00093">93</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa3c999e29f872bce1d487c893c861c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c999e29f872bce1d487c893c861c0b">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::<a class="el" href="classMatrixFree.html#aa3c999e29f872bce1d487c893c861c0b">value_type</a> =  Number</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>由模板参数指定的底层数字类型的别名。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00104">104</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a8ae84ac145ae6c2277eca3612d46b21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae84ac145ae6c2277eca3612d46b21e">&#9670;&nbsp;</a></span>vectorized_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::<a class="el" href="classMatrixFree.html#a8ae84ac145ae6c2277eca3612d46b21e">vectorized_value_type</a> =  VectorizedArrayType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00105">105</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a751b5f06534d52773eba384d2c866a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751b5f06534d52773eba384d2c866a15">&#9670;&nbsp;</a></span>DataAccessOnFaces</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">MatrixFree::DataAccessOnFaces</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个类定义了循环（）中的面积分的数据访问类型，它被传递给并行向量的<code>update_ghost_values</code>和<code>compress</code>函数，目的是能够减少必须交换的数据量。数据交换是一个真正的瓶颈，特别是对于高等级的DG方法，因此更严格的交换方式显然是有益的。请注意，这种选择只适用于分配给访问 <code>FaceToCellTopology::exterior_cells</code> 的单元格外部的FEFaceEvaluation对象；所有<em>interior</em>对象在任何情况下都是可用的。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a751b5f06534d52773eba384d2c866a15a334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"><p>循环不涉及任何FEFaceEvaluation对邻居的访问，就像只有边界积分（但没有内部面积分）或在类似 <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a> 的设置中做质量矩阵时的情况。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a751b5f06534d52773eba384d2c866a15af09cc7ee3a9a93273f4b80601cafb00c"></a>values&#160;</td><td class="fielddoc"><p>循环只涉及到FEFaceEvaluation通过函数值访问邻居，如 <a class="el" href="classFEFaceEvaluation.html#a4ac53fde2eab227ef45c7d29a5ed33fe">FEFaceEvaluation::gather_evaluate()</a> 的参数 <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>, ，但没有访问形状函数导数（通常需要访问更多数据）。对于只有部分形状函数在面上有支持的FiniteElement类型，如FE_DGQ元素，其节点在元素表面的拉格朗日多项式，数据交换从<code>(k+1)^dim</code>减少到<code>(k+1)^(dim-1)</code>。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a751b5f06534d52773eba384d2c866a15a108449c0466dc01a217d1ab2f99e5d5c"></a>values_all_faces&#160;</td><td class="fielddoc"><p>与上述相同。如果FEFaceEvaluation通过提供单元批号和一个面的编号而被重新初始化，则必须从外部面访问数据时使用。这种配置在以单元为中心的循环中很有用。 </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="structMatrixFree_1_1AdditionalData.html#a1b94beb12bfea048e9fbbdf52c36ecb4">AdditionalData::hold_all_faces_to_owned_cells</a> 必须启用。 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a751b5f06534d52773eba384d2c866a15ac2af294b46c59f4ca21a4aac2b2d97b1"></a>gradients&#160;</td><td class="fielddoc"><p>循环确实涉及到FEFaceEvaluation通过函数值和梯度访问到邻居，但没有二阶导数，比如 <a class="el" href="classFEFaceEvaluation.html#a4ac53fde2eab227ef45c7d29a5ed33fe">FEFaceEvaluation::gather_evaluate()</a> 设置了 <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> 和 <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a> 。对于只有部分形状函数在一个面上有非零值和一阶导数的FiniteElement类型，例如FE_DGQHermite元素，数据交换会减少，例如从<code>(k+1)^dim</code>到<code>2(k+1)^(dim-1)</code>。请注意，对于不具备这种特殊属性的基数，无论如何都要发送完整的邻接数据。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a751b5f06534d52773eba384d2c866a15adceeae01fe1b10f8d3202a66d4676915"></a>gradients_all_faces&#160;</td><td class="fielddoc"><p>与上述相同。如果FEFaceEvaluation通过提供单元格批号和一个面的编号而被重新初始化的话，要用于必须从外部面访问数据。这种配置在以单元为中心的循环中很有用。 </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="structMatrixFree_1_1AdditionalData.html#a1b94beb12bfea048e9fbbdf52c36ecb4">AdditionalData::hold_all_faces_to_owned_cells</a> 必须启用。 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48"></a>unspecified&#160;</td><td class="fielddoc"><p>用户不想做限制的一般设置。这通常比其他选项更昂贵，但也是最保守的一种，因为要在本地计算的面后面的元素的全部数据将被交换。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00574">574</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad235137af17c50208c03a418340acbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad235137af17c50208c03a418340acbc8">&#9670;&nbsp;</a></span>MatrixFree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::<a class="el" href="classMatrixFree.html">MatrixFree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>默认的空构造函数。什么都不做。 </p>

</div>
</div>
<a id="a64503de42775fdae6c16957be9a9c050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64503de42775fdae6c16957be9a9c050">&#9670;&nbsp;</a></span>MatrixFree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::<a class="el" href="classMatrixFree.html">MatrixFree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制构造函数，调用copy_from </p>

</div>
</div>
<a id="a3ae41f0192ab55694a07606eea09fa88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae41f0192ab55694a07606eea09fa88">&#9670;&nbsp;</a></span>~MatrixFree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::~<a class="el" href="classMatrixFree.html">MatrixFree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解构器。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adb324d469b296f2a6921b41208732ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb324d469b296f2a6921b41208732ddf">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 , typename MappingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const MappingType &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提取在单元格上进行循环所需的信息。DoFHandler和AffineConstraints对象描述了自由度的布局，DoFHandler和映射描述了从单元到实数单元的转换，而DoFHandler底层的有限元与正交公式一起描述了局部操作。请注意，DoFHandler底层的有限元必须是标量的，或者包含同一元素的几个副本。不允许将几个不同的元素混入一个FES系统。在这种情况下，使用带有几个DoFHandler参数的初始化函数。 </p>

</div>
</div>
<a id="aeb9a0610e482e6785491a8a2c7bd8aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9a0610e482e6785491a8a2c7bd8aee">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>初始化数据结构。和上面一样，但使用 \(Q_1\) 的映射。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000073">Deprecated:</a></b></dt><dd>使用重载来代替Mapping对象。</dd></dl>

</div>
</div>
<a id="ada4a663740edef3fc4207ea2ec865a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4a663740edef3fc4207ea2ec865a62">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 , typename MappingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const MappingType &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; QuadratureType &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提取在单元格上进行循环所需的信息。DoFHandler和AffineConstraints对象描述了自由度的布局，DoFHandler和映射描述了从单元到实数单元的转换，DoFHandler的基础有限元与正交公式一起描述了局部操作。与其他初始化函数处理的标量情况不同，这个函数允许有两个或多个不同的有限元的问题。每个元素的DoFHandlers必须作为指针传递给初始化函数。另外，一个由多个构件组成的系统也可以由一个带有FESystem元素的单一DoFHandler来表示。这种情况的前提条件是FESystem的每个基本元素必须与本类兼容，如FE_Q或FE_DGQ类。 这个函数也允许使用多个正交公式，例如当描述中包含不同程度的元素的独立积分时。然而，不同正交公式的数量可以独立于DoFHandlers的数量进行设置，当几个元素总是用同一个正交公式进行积分时。 </p>

</div>
</div>
<a id="abf219f9b30dff16e5c41c3086d64b166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf219f9b30dff16e5c41c3086d64b166">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType , typename MappingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const MappingType &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const DoFHandlerType *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; QuadratureType &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>初始化数据结构。与上述相同，但使用DoFHandlerType。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000074">Deprecated:</a></b></dt><dd>使用获取DoFHandler对象的重载来代替。</dd></dl>

</div>
</div>
<a id="a3913c1558b53ecabbc55cb83a1167cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3913c1558b53ecabbc55cb83a1167cf8">&#9670;&nbsp;</a></span>reinit() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; QuadratureType &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>初始化数据结构。和上面一样，但使用 \(Q_1\) 的映射。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000075">Deprecated:</a></b></dt><dd>使用获取Mapping对象的重载来代替。</dd></dl>

</div>
</div>
<a id="ad49254941a791433cbe774cbf02649eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49254941a791433cbe774cbf02649eb">&#9670;&nbsp;</a></span>reinit() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const DoFHandlerType *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; QuadratureType &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>初始化数据结构。和上面一样，但使用DoFHandlerType。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000076">Deprecated:</a></b></dt><dd>使用获取DoFHandler对象的重载来代替。</dd></dl>

</div>
</div>
<a id="a1472228976422cd5c785f106f26fd54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1472228976422cd5c785f106f26fd54d">&#9670;&nbsp;</a></span>reinit() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 , typename MappingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const MappingType &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>初始化数据结构。和以前一样，但现在本地拥有的自由度范围的索引集描述取自DoFHandler。此外，只使用一个正交公式，当一个矢量值问题中的几个分量基于同一个正交公式被整合在一起时，这可能是必要的。 </p>

</div>
</div>
<a id="a5518f32796400b39a74cbf58a97e2df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5518f32796400b39a74cbf58a97e2df7">&#9670;&nbsp;</a></span>reinit() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType , typename MappingType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const MappingType &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const DoFHandlerType *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>初始化数据结构。与上述相同，但使用DoFHandlerType。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000077">Deprecated:</a></b></dt><dd>使用获取DoFHandler对象的重载来代替。</dd></dl>

</div>
</div>
<a id="aee59b4b26a998451b74d7f2948aed300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee59b4b26a998451b74d7f2948aed300">&#9670;&nbsp;</a></span>reinit() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>初始化数据结构。和上面一样，但使用 \(Q_1\) 的映射。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000078">Deprecated:</a></b></dt><dd>使用获取映射对象的重载来代替。</dd></dl>

</div>
</div>
<a id="ac683f503f6c869f7619157c446dd9713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac683f503f6c869f7619157c446dd9713">&#9670;&nbsp;</a></span>reinit() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename QuadratureType , typename number2 , typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const DoFHandlerType *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureType &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>初始化数据结构。和上面一样，但使用DoFHandlerType。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000079">Deprecated:</a></b></dt><dd>使用获取DoFHandler对象的重载来代替。</dd></dl>

</div>
</div>
<a id="a3d0d738934cd91482550533fd88a96fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0d738934cd91482550533fd88a96fa">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_free_base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制函数。创建一个所有数据结构的深度拷贝。通常情况下，为不同的操作保留一次数据就足够了，所以不应该经常需要这个函数。 </p>

</div>
</div>
<a id="a1f21e8893f049def7395c8cb7c4f0ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f21e8893f049def7395c8cb7c4f0ca9">&#9670;&nbsp;</a></span>update_mapping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::update_mapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>当底层几何体发生变化（例如，通过像MappingFEField这样可以通过空间配置的变化而变形的映射）而网格和未知数的拓扑结构保持不变时，重新刷新存储在MappingInfo字段中的几何体数据。与reinit()相比，这个操作只需要重新生成几何体阵列，因此可以大大降低成本（取决于评估几何体的成本）。 </p>

</div>
</div>
<a id="a264d78dadbfd3bccb9c36e37226fd025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264d78dadbfd3bccb9c36e37226fd025">&#9670;&nbsp;</a></span>update_mapping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::update_mapping </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，但有 <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>. 。 </p>

</div>
</div>
<a id="a2f0e2305a9a34137ce5db9c8c8c45507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0e2305a9a34137ce5db9c8c8c45507">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>清除所有的数据字段，使类进入类似于调用了默认构造函数后的状态。 </p>

</div>
</div>
<a id="abc204ec41ead1b5060f47ef3a5a066d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc204ec41ead1b5060f47ef3a5a066d7">&#9670;&nbsp;</a></span>cell_loop() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这种方法在所有单元格上运行循环（并行），并在源向量和目的向量上执行MPI数据交换。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_operation</td><td><code>std::function</code> ，签名为<code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned  int,unsigned int&gt; &amp;)</code>，第一个参数传递调用类的数据，最后一个参数定义应该被处理的单元的范围（通常应该处理多个单元以减少开销）。 如果一个对象有一个具有正确参数集的<code>operator()</code>，人们可以在这个地方传递一个指针，因为这样的指针可以被转换为函数对象。 </td></tr>
    <tr><td class="paramname">dst</td><td>保存结果的目标向量。如果向量是 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> 类型（或其复合对象，如 <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), ，循环在内部调用结束时调用 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">LinearAlgebra::distributed::Vector::compress()</a> 。对于其他向量，包括平行的Trilinos或PETSc向量，不发出这样的调用。请注意，Trilinos/Epetra或PETSc向量目前不能并行工作，因为本类使用MPI本地索引寻址，而不是这些外部库所暗示的全局寻址。 </td></tr>
    <tr><td class="paramname">src</td><td>输入向量。如果向量是 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> 类型（或其复合对象，如 <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), ，则循环在内部调用开始时调用 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">LinearAlgebra::distributed::Vector::update_ghost_values()</a> ，以确保所有必要的数据在本地可用。然而，请注意，在循环结束时，向量会被重置为原始状态，即如果向量在进入循环时没有被重影，那么在完成循环时也不会被重影。 </td></tr>
    <tr><td class="paramname">zero_dst_vector</td><td>如果这个标志被设置为<code>true</code>，向量<code>dst</code>将在循环内被设置为零。在你对矩阵对象进行典型的<code>vmult()</code>操作时使用这种情况，因为它通常会比在循环之前单独调用`dst = 0;`更快。这是因为向量项只在向量的子范围内被设置为零，确保向量项尽可能地留在缓存中。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa941c80d60b2cd987660d2d04587fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa941c80d60b2cd987660d2d04587fde">&#9670;&nbsp;</a></span>cell_loop() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这是第二个变种，在所有单元格上运行循环，现在提供一个指向<code>CLASS</code>类成员函数的函数指针。这种方法避免了定义lambda函数或调用 std::bind 将类绑定到给定的函数中，以防本地函数需要访问类中的数据（即，它是一个非静态成员函数）。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_operation</td><td>指向<code>CLASS</code>的成员函数，其签名为<code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code>，其中第一个参数传递调用类的数据，最后一个参数定义应该被处理的单元范围（通常应该处理一个以上的单元以减少开销）。 </td></tr>
    <tr><td class="paramname">owning_class</td><td>提供<code>cell_operation</code>调用的对象。为了与该接口兼容，该类必须允许调用<code>owning_class-&gt;cell_operation(..)</code>。 </td></tr>
    <tr><td class="paramname">dst</td><td>保存结果的目标向量。如果向量是 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> 类型（或其复合对象，如 <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), ，循环在内部调用结束时调用 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">LinearAlgebra::distributed::Vector::compress()</a> 。对于其他向量，包括平行的Trilinos或PETSc向量，不发出这样的调用。请注意，Trilinos/Epetra或PETSc向量目前不能并行工作，因为本类使用MPI本地索引寻址，而不是那些外部库所暗示的全局寻址。 </td></tr>
    <tr><td class="paramname">src</td><td>输入向量。如果向量是 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> 类型（或其复合对象，如 <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), ），循环在内部调用开始时调用 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">LinearAlgebra::distributed::Vector::update_ghost_values()</a> ，以确保所有必要的数据在本地可用。然而，请注意，在循环结束时，向量会被重置为原始状态，即如果向量在进入循环时没有被重影，那么在完成循环时也不会被重影。 </td></tr>
    <tr><td class="paramname">zero_dst_vector</td><td>如果这个标志被设置为<code>true</code>，向量<code>dst</code>将在循环中被设置为零。在你对矩阵对象进行典型的<code>vmult()</code>操作时使用这种情况，因为它通常会比在循环之前单独调用`dst = 0;`更快。这是因为向量项只在向量的子范围内被设置为零，确保向量项尽可能地留在缓存中。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca4e2ec1389ae3f7abd7c0552f782f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4e2ec1389ae3f7abd7c0552f782f47">&#9670;&nbsp;</a></span>cell_loop() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，但对于非const的类成员函数。 </p>

</div>
</div>
<a id="a6a53b93080a15c49d5513f09fc6bbb5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a53b93080a15c49d5513f09fc6bbb5d">&#9670;&nbsp;</a></span>cell_loop() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>operation_before_loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>operation_after_loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index_pre_post</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数类似于cell_loop，用一个 std::function 对象来指定要对单元格进行的操作，但增加了两个额外的向量，在计算单元格积分前后执行一些额外的工作。 这两个额外的向量在自由度范围内工作，以MPI本地索引中选定的DoFHandler<code>dof_handler_index_pre_post</code>的自由度编号表示。向量的参数代表自由度范围，粒度为 <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a626704a7e1e52a5399bd15cb6aa32100">internal::MatrixFreeFunctions::DoFInfo::chunk_size_zero_vector</a> 个条目（除了最后一个块被设置为本地拥有的条目数），形式为<code>[first, last)</code>。这些向量的想法是使向量上的操作更接近于它们在无矩阵循环中的访问点，目的是通过时间上的定位来增加缓存的点击。这个循环保证了<code>operation_before_loop</code>在cell_operation（包括MPI数据交换）中第一次接触到所有相关的未知数之前，就已经击中了这些未知数，允许执行一些<code>src</code>向量依赖的向量更新。循环后的操作 "是类似的</p>
<ul>
<li>一旦该范围内的所有自由度被<code>cell_operation</code>最后一次触及（包括MPI数据交换），它就开始在该范围的自由度上执行，允许例如计算一些取决于当前<code>dst</code>中的单元循环结果的向量操作，或者想修改<code>src</code>。缓存的效率取决于自由度的编号，因为范围的粒度不同。 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_operation</td><td>指向<code>CLASS</code>的成员函数，签名为<code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned  int,unsigned int&gt; &amp;)</code>，第一个参数传递调用类的数据，最后一个参数定义应该被处理的单元范围（通常应该处理多个单元，以减少开销）。 </td></tr>
    <tr><td class="paramname">owning_class</td><td>提供<code>cell_operation</code>调用的对象。为了与该接口兼容，该类必须允许调用<code>owning_class-&gt;cell_operation(..)</code>。 </td></tr>
    <tr><td class="paramname">dst</td><td>保存结果的目标向量。如果向量是 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> 类型（或其复合对象，如 <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), ，循环在内部调用结束时调用 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">LinearAlgebra::distributed::Vector::compress()</a> 。对于其他向量，包括平行的Trilinos或PETSc向量，不发出这样的调用。请注意，Trilinos/Epetra或PETSc向量目前不能并行工作，因为本类使用MPI本地索引寻址，而不是这些外部库所暗示的全局寻址。 </td></tr>
    <tr><td class="paramname">src</td><td>输入向量。如果向量是 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> 类型（或其复合对象，如 <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), ），循环在内部调用开始时调用 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">LinearAlgebra::distributed::Vector::update_ghost_values()</a> ，以确保所有必要的数据在本地可用。然而，请注意，在循环结束时，向量被重置为其原始状态，即如果向量在进入循环时没有被重影，那么在完成循环时也不会被重影。 </td></tr>
    <tr><td class="paramname">operation_before_loop</td><td>这个函数可以用来对<code>src'和</code>dst'向量（或其他向量）的条目进行操作，在对单元的操作第一次接触到特定的DoF之前，根据上面文本中的一般描述。这个函数被传递给选定的<code>dof_handler_index_pre_post</code>（用MPI本地编号）上的本地拥有的自由度范围。 </td></tr>
    <tr><td class="paramname">operation_after_loop</td><td>这个函数可以用来对<code>src'和</code>dst'向量（或其他向量）的条目进行操作，在对单元的操作最后触及一个特定的DoF之后，根据上面文字的一般描述。这个函数被传递给选定的<code>dof_handler_index_pre_post</code>（以MPI本地编号）上的本地拥有的自由度范围。 </td></tr>
    <tr><td class="paramname">dof_handler_index_pre_post</td><td>由于MatrixFree可以用DoFHandler对象的矢量初始化，一般来说，每个对象都会有矢量大小，因此返回给<code>operation_before_loop</code>和<code>operation_after_loop</code>的范围也不同。使用这个变量来指定索引范围应该与哪一个DoFHandler对象相关。默认为<code>dof_handler_index</code> 0。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>operation_before_loop</code>和<code>operation_after_loop</code>的近距离定位目前只在仅MPI的情况下实现。在启用线程的情况下，由于复杂的依赖关系，完整的<code>operation_before_loop</code>被安排在并行循环之前，而<code>operation_after_loop</code>被严格安排在之后。 </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a4299fd60761d1be3cc6461d72c265577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4299fd60761d1be3cc6461d72c265577">&#9670;&nbsp;</a></span>cell_loop() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>operation_before_loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>operation_after_loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index_pre_post</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，但对于非const的类成员函数。 </p>

</div>
</div>
<a id="a2c3b0bd3cad76dc2e3957f205c6138ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3b0bd3cad76dc2e3957f205c6138ac">&#9670;&nbsp;</a></span>cell_loop() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_loop </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>operation_before_loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>operation_after_loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index_pre_post</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>同上，但取一个 <code>std::function</code> 作为<code>cell_operation</code>，而不是类成员函数。 </p>

</div>
</div>
<a id="a0e9669e4a5cfaceac78f5e26c285c2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9669e4a5cfaceac78f5e26c285c2ea">&#9670;&nbsp;</a></span>loop() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::loop </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>face_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>dst_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>src_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个方法在所有单元格上运行一个循环（并行），并在源向量和目的向量上执行MPI数据交换。与其他只在单元格上运行一个函数的变体不同，这个方法还分别以内部面和边界面的函数为参数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_operation</td><td><code>std::function</code> 的签名为<code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned  int,unsigned int&gt; &amp;)</code>，第一个参数传递调用类的数据，最后一个参数定义应该被处理的单元的范围（通常应该处理一个以上的单元以减少开销）。如果有一个 <code>operator()</code> 具有正确的参数集，人们可以在这个地方传递一个对象的指针，因为这样的指针可以被转换为函数对象。 </td></tr>
    <tr><td class="paramname">face_operation</td><td><code>std::function</code> 的签名是<code>face_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned  int,unsigned int&gt; &amp;)</code>，类似于<code>cell_operation</code>，但现在是与内部面的工作有关的部分。请注意，MatrixFree框架将周期性面视为内部面，因此，在调用face_operation时应用周期性约束后，它们将被分配到正确的邻居。 </td></tr>
    <tr><td class="paramname">boundary_operation</td><td><code>std::function</code> 签名为<code>boundary_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned  int,unsigned int&gt; &amp;)</code>，与<code>cell_operation</code>和<code>face_operation</code>类似，但现在是与边界面的工作相关的部分。边界面是由它们的`boundary_id'分开的，可以用 <a class="el" href="classMatrixFree.html#a94c875be0229e4872a3e087a55410625">MatrixFree::get_boundary_id()</a>. 来查询这个id。注意，内部和面都使用相同的编号，内部的面被分配的编号比边界面低。 </td></tr>
    <tr><td class="paramname">dst</td><td>保存结果的目的向量。如果向量是 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> 类型（或其复合对象，如 <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), ，循环在内部调用结束时调用 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">LinearAlgebra::distributed::Vector::compress()</a> 。 </td></tr>
    <tr><td class="paramname">src</td><td>输入向量。如果向量是 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> 类型（或其复合对象，如 <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), ，则循环在内部调用开始时调用 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">LinearAlgebra::distributed::Vector::update_ghost_values()</a> 以确保所有必要的数据在本地可用。然而，请注意，在循环结束时，向量会被重置为其原始状态，即如果向量在进入循环时没有被重影，那么在完成循环时也不会被重影。 </td></tr>
    <tr><td class="paramname">zero_dst_vector</td><td>如果这个标志被设置为<code>true</code>，向量<code>dst</code>将在循环中被设置为零。在你对矩阵对象进行典型的<code>vmult()</code>操作时使用这种情况，因为它通常会比在循环之前单独调用`dst = 0;`更快。这是因为向量项只在向量的子范围内被设置为0，确保向量项尽可能地留在缓存中。 </td></tr>
    <tr><td class="paramname">dst_vector_face_access</td><td>设置对向量<code>dst</code>的访问类型，该访问将发生在 <code>face_operation</code> 函数内部。正如在DataAccessOnFaces结构的描述中所解释的，这个选择的目的是减少必须通过MPI网络（如果在节点的共享内存区域内，则通过<code>memcpy</code>）交换的数据量以获得性能。请注意，没有办法与FEFaceEvaluation类沟通这一设置，因此除了在<code>face_operation</code>函数中实现的内容外，这一选择必须在这个地方进行。因此，也没有办法检查传递给这个调用的设置是否与后来<code><a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a></code>所做的一致，确保数据的正确性是用户的责任。 </td></tr>
    <tr><td class="paramname">src_vector_face_access</td><td>设置对向量<code>src</code>的访问类型，将在 <code>face_operation</code> 函数体内发生，与<code>dst_vector_face_access</code>相类似。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c34b747893d2e6ad474aac9dbf35ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c34b747893d2e6ad474aac9dbf35ec8">&#9670;&nbsp;</a></span>loop() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>face_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>boundary_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>dst_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>src_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这是第二个变体，在所有的单元格、内部面和边界面上运行循环，现在提供了三个指向 <code>CLASS</code> 类成员函数的函数指针，其签名为<code>operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned  int,unsigned int&gt;&amp;) const</code>。如果本地函数需要访问类中的数据（即，它是一个非静态成员函数），该方法就不需要定义lambda函数或调用 std::bind 将类绑定到给定函数中。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_operation</td><td>指向<code>CLASS</code>的成员函数，其签名为<code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code>，其中第一个参数传递调用类的数据，最后一个参数定义应该被处理的单元范围（通常应该处理一个以上的单元以减少开销）。注意，这个循环通常会将<code>cell_range'分割成更小的部分，并交替工作于</code>cell_operation'、<code>face_operation'和</code>boundary_operation'，以增加缓存中向量项的潜在重用。 </td></tr>
    <tr><td class="paramname">face_operation</td><td>指向<code>CLASS</code>的成员函数，其签名为<code>face_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code>，与<code>cell_operation</code>相类似，但现在是与内部面的工作相关的部分。请注意，MatrixFree框架将周期性面视为内部面，因此，在调用face_operation时应用周期性约束后，它们将被分配给正确的邻居。 </td></tr>
    <tr><td class="paramname">boundary_operation</td><td>指向<code>CLASS</code>的成员函数，其签名为<code>boundary_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code>，与<code>cell_operation</code>和<code>face_operation</code>类似，但现在是与边界面的工作相关的部分。边界面由它们的`boundary_id'分开，可以使用 <a class="el" href="classMatrixFree.html#a94c875be0229e4872a3e087a55410625">MatrixFree::get_boundary_id()</a>. 查询该id。注意，内部和面都使用相同的编号，内部的面被分配的编号比边界面低。 </td></tr>
    <tr><td class="paramname">owning_class</td><td>提供<code>cell_operation</code>调用的对象。为了与该接口兼容，该类必须允许调用<code>owning_class-&gt;cell_operation(...)</code>, <code>owning_class-&gt;face_operation(...)</code>, 和<code>owning_class-&gt;boundary_operation(...)</code>。 </td></tr>
    <tr><td class="paramname">dst</td><td>保存结果的目标向量。如果向量是 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> 类型（或其复合对象，如 <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), ，循环在内部调用结束时调用 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">LinearAlgebra::distributed::Vector::compress()</a> 。 </td></tr>
    <tr><td class="paramname">src</td><td>输入向量。如果向量是 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> 类型（或其复合对象，如 <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), ，则循环在内部调用开始时调用 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">LinearAlgebra::distributed::Vector::update_ghost_values()</a> 以确保所有必要的数据在本地可用。然而，请注意，在循环结束时，向量会被重置为其原始状态，即如果向量在进入循环时没有被重影，那么在完成循环时也不会被重影。 </td></tr>
    <tr><td class="paramname">zero_dst_vector</td><td>如果这个标志被设置为<code>true</code>，向量<code>dst</code>将在循环中被设置为零。在你对矩阵对象进行典型的<code>vmult()</code>操作时使用这种情况，因为它通常会比在循环之前单独调用`dst = 0;`更快。这是因为向量项只在向量的子范围内被设置为0，确保向量项尽可能地留在缓存中。 </td></tr>
    <tr><td class="paramname">dst_vector_face_access</td><td>设置对向量<code>dst</code>的访问类型，将在 <code>face_operation</code> 函数内部发生。正如在DataAccessOnFaces结构的描述中所解释的，这个选择的目的是减少必须通过MPI网络（如果在节点的共享内存区域内，则通过<code>memcpy</code>）交换的数据量以获得性能。请注意，没有办法与FEFaceEvaluation类沟通这一设置，因此除了在<code>face_operation</code>函数中实现的内容外，这一选择必须在这个地方进行。因此，也没有办法检查传递给这个调用的设置是否与后来<code><a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a></code>所做的一致，确保数据的正确性是用户的责任。 </td></tr>
    <tr><td class="paramname">src_vector_face_access</td><td>设置对向量<code>src</code>的访问类型，将在 <code>face_operation</code> 函数体内发生，与<code>dst_vector_face_access</code>相类似。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add0de121d733bf745fadfc646d442524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0de121d733bf745fadfc646d442524">&#9670;&nbsp;</a></span>loop() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::loop </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&#160;</td>
          <td class="paramname"><em>face_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&#160;</td>
          <td class="paramname"><em>boundary_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>dst_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>src_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和上面一样，但对于非const的类成员函数。 </p>

</div>
</div>
<a id="a60ebe2e71cfd7602ef9bc612d22385f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ebe2e71cfd7602ef9bc612d22385f8">&#9670;&nbsp;</a></span>loop_cell_centric() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::loop_cell_centric </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;) const&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>src_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个方法与cell_loop()的做法类似，在所有单元格上运行循环（并行）。然而，这个函数的目的是用于面和边界积分也应该被评估的情况。与loop()相反，用户只需提供一个单一的函数，该函数应包含一个单元（或向量化时的一批单元）的单元积分和所有面的面和边界积分。这在文献中被称为 "以元素为中心的循环 "或 "以单元为中心的循环"。 为了能够评估所有的面积分（用来自相邻单元的值或梯度），相邻单元的所有幽灵值都要更新。使用 FEFaceEvalution::reinit(cell, face_no)来访问一个单元的任意面和各自的邻居的数量。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_operation</td><td>指向<code>CLASS</code>的成员函数，其签名为<code>cell_operation (const MatrixFree&lt;dim,Number&gt; &amp;, OutVector &amp;, InVector &amp;, std::pair&lt;unsigned int,unsigned int&gt; &amp;)</code>，第一个参数传递调用类的数据，最后一个参数定义应该被处理的单元范围（通常从循环中传递多个单元以减少开销）。 </td></tr>
    <tr><td class="paramname">owning_class</td><td>提供<code>cell_operation</code>调用的对象。为了与该接口兼容，该类必须允许调用<code>owning_class-&gt;cell_operation(..)</code>。 </td></tr>
    <tr><td class="paramname">dst</td><td>保存结果的目标向量。如果向量是 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> 类型（或其复合对象，如 <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), ，循环在内部调用结束时调用 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">LinearAlgebra::distributed::Vector::compress()</a> 。 </td></tr>
    <tr><td class="paramname">src</td><td>输入向量。如果向量是 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> 类型（或其复合对象，如 <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>), ，循环在内部调用开始时调用 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">LinearAlgebra::distributed::Vector::update_ghost_values()</a> ，以确保所有必要的数据在本地可用。然而，请注意，在循环结束时，向量会被重置为原始状态，即如果向量在进入循环时没有被重影，那么在完成循环时也不会被重影。 </td></tr>
    <tr><td class="paramname">zero_dst_vector</td><td>如果这个标志被设置为<code>true</code>，向量<code>dst</code>将在循环中被设置为零。在你对矩阵对象进行典型的<code>vmult()</code>操作时使用这种情况，因为它通常会比在循环之前单独调用`dst = 0;`更快。这是因为向量项只在向量的子范围内被设置为0，确保向量项尽可能地留在缓存中。 </td></tr>
    <tr><td class="paramname">src_vector_face_access</td><td>设置对向量<code>src</code>的访问类型，这将在面积分过程中发生在 <code>cell_operation</code> 函数的内部。 正如在DataAccessOnFaces结构的描述中所解释的，这个选择的目的是减少必须通过MPI网络（如果在节点的共享内存区域内，则通过<code>memcpy</code>）交换的数据量以获得性能。请注意，没有办法与FEFaceEvaluation类沟通这一设置，因此除了在<code>face_operation</code>函数中实现的内容外，这一选择必须在这个地方进行。因此，也没有办法检查传递给这个调用的设置是否与后来<code><a class="el" href="classFEFaceEvaluation.html">FEFaceEvaluation</a></code>所做的一致，确保数据的正确性是用户的责任。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03da600450c259400259f870800aea2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03da600450c259400259f870800aea2d">&#9670;&nbsp;</a></span>loop_cell_centric() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CLASS , typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::loop_cell_centric </td>
          <td>(</td>
          <td class="paramtype">void(CLASS::*)(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CLASS *&#160;</td>
          <td class="paramname"><em>owning_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>src_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>同上，但对于类的成员函数，它是非const的。 </p>

</div>
</div>
<a id="aae39079578d1dd9d1a80b50567fc03ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae39079578d1dd9d1a80b50567fc03ec">&#9670;&nbsp;</a></span>loop_cell_centric() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OutVector , typename InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::loop_cell_centric </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;, OutVector &amp;, const InVector &amp;, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>zero_dst_vector</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15">DataAccessOnFaces</a>&#160;</td>
          <td class="paramname"><em>src_vector_face_access</em> = <code><a class="el" href="classMatrixFree.html#a751b5f06534d52773eba384d2c866a15ad415f0e30c471dfdd9bc4f827329ef48">DataAccessOnFaces::unspecified</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，但有 std::function. 。 </p>

</div>
</div>
<a id="a16b6836f6e1df769d66d90a9d4fd8873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b6836f6e1df769d66d90a9d4fd8873">&#9670;&nbsp;</a></span>create_cell_subrange_hp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::create_cell_subrange_hp </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在hp-adaptive情况下，在单元格循环中计算的单元格子范围可能包含不同程度的元素。使用这个函数来计算一个单独的有限元度的子范围是什么。有限元度与函数调用中给出的矢量分量相关。 </p>

</div>
</div>
<a id="a394b47f93926a192ef5856106556d12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394b47f93926a192ef5856106556d12e">&#9670;&nbsp;</a></span>create_cell_subrange_hp_by_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::create_cell_subrange_hp_by_index </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在hp-adaptive情况下，在单元循环中计算的单元子范围可能包含不同程度的元素。使用这个函数来计算给定索引的子范围的hp-finite元素，而不是其他函数中的有限元素程度。 </p>

</div>
</div>
<a id="a00b8b15c5c3efed4c0082db8255bf1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b8b15c5c3efed4c0082db8255bf1aa">&#9670;&nbsp;</a></span>n_active_fe_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_active_fe_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在hp自适应情况下，返回active_fe_indices的数量。 </p>

</div>
</div>
<a id="a093da73c996f663066f827840f5c1c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093da73c996f663066f827840f5c1c55">&#9670;&nbsp;</a></span>get_cell_active_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_cell_active_fe_index </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在hp-adaptive情况下，返回单元格范围的active_fe_index。 </p>

</div>
</div>
<a id="ad5b265f35586470176204db6f6e70610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b265f35586470176204db6f6e70610">&#9670;&nbsp;</a></span>get_face_active_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_face_active_fe_index </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_interior_face</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在hp-adaptive的情况下，返回一个面域的active_fe_index。 </p>

</div>
</div>
<a id="ab92a24942737bbaf04d7e00aceba9b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92a24942737bbaf04d7e00aceba9b57">&#9670;&nbsp;</a></span>initialize_dof_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::initialize_dof_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6389c1e91648d277bdd81af095b5296c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6389c1e91648d277bdd81af095b5296c">&#9670;&nbsp;</a></span>initialize_dof_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::initialize_dof_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae41cc9c8a14e3a485cefd570680268e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41cc9c8a14e3a485cefd570680268e1">&#9670;&nbsp;</a></span>get_vector_partitioner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_vector_partitioner </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回代表本地拥有的数据的分区器，以及单元格循环需要访问的幽灵索引。分区器是由各自字段给出的本地拥有的道夫和幽灵道夫构建的。如果你想知道这些对象的具体信息，你可以用各自的访问函数来查询它们。如果你只是想初始化一个（平行）向量，你通常应该更喜欢这种数据结构，因为数据交换信息可以从一个向量重复使用到另一个向量。 </p>

</div>
</div>
<a id="afb2c36a70878d0ec24e250a9587e786e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2c36a70878d0ec24e250a9587e786e">&#9670;&nbsp;</a></span>get_locally_owned_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndexSet.html">IndexSet</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_locally_owned_set </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回由处理器拥有的单元格集合。 </p>

</div>
</div>
<a id="a18245454fbd9c8a2ef6a4b30280042c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18245454fbd9c8a2ef6a4b30280042c6">&#9670;&nbsp;</a></span>get_ghost_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndexSet.html">IndexSet</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_ghost_set </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回需要但不为处理器所拥有的幽灵单元的集合。 </p>

</div>
</div>
<a id="a4d6b0854710b1c9aeb889c4875f0a47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6b0854710b1c9aeb889c4875f0a47b">&#9670;&nbsp;</a></span>get_constrained_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_constrained_dofs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个所有被约束的自由度的列表。该列表是在本地拥有的向量范围的MPI本地索引空间中返回的，而不是跨越所有MPI处理器的全局MPI索引空间。要获得全局索引空间的数字，请在向量的一个条目上调用<code><a class="el" href="classMatrixFree.html#ae41cc9c8a14e3a485cefd570680268e1">get_vector_partitioner()</a>-&gt;local_to_global</code>。此外，它只返回本地拥有的自由度的指数，而不是鬼魂的指数。 </p>

</div>
</div>
<a id="ad40c40bd8fb8a804f2982bee8c1de070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40c40bd8fb8a804f2982bee8c1de070">&#9670;&nbsp;</a></span>renumber_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::renumber_dofs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>根据给定的数据布局，计算自由度的重新编号，使其更符合MatrixFree中的数据布局。注意，这个函数并不重新排列存储在这个类中的信息，而是创建一个重新编号以消耗 <a class="el" href="classDoFHandler.html#a44e80b846cf60a8671969ce90ae3625b">DoFHandler::renumber_dofs</a>. 为了产生任何效果，必须使用重新编号的DoFHandler和AffineConstraints再次设置MatrixFree对象。注意，如果DoFHandler调用 <a class="el" href="classDoFHandler.html#a44e80b846cf60a8671969ce90ae3625b">DoFHandler::renumber_dofs</a>, ，MatrixFree中的所有信息都会失效。 </p>

</div>
</div>
<a id="afbe3ca9fc933b303cdc134fcb86bfbb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe3ca9fc933b303cdc134fcb86bfbb6">&#9670;&nbsp;</a></span>is_supported()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::is_supported </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个给定的FiniteElement <code>fe</code> 是否被这个类所支持。 </p>

</div>
</div>
<a id="ab74907342812d74f2c89d825436d1b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74907342812d74f2c89d825436d1b70">&#9670;&nbsp;</a></span>n_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回初始化时指定的不同DoFHandlers的数量。 </p>

</div>
</div>
<a id="aec2cd5fcca15d0a9cb78f15473d7bbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2cd5fcca15d0a9cb78f15473d7bbc0">&#9670;&nbsp;</a></span>n_base_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_base_elements </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于由 <code>dof_handler_index指定的DoFHandler的基础有限元，返回基础元的数量。</code> </p>

</div>
</div>
<a id="ab9298b98c63d9d7b93367fcbeda9fe1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9298b98c63d9d7b93367fcbeda9fe1b">&#9670;&nbsp;</a></span>n_physical_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_physical_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个结构所基于的单元数。如果你使用的是一个通常的DoFHandler，它对应于（本地拥有的）活动单元的数量。请注意，这个类中的大多数数据结构并不直接作用于这个数字，而是作用于n_cell_batches()，它给出了用矢量化将几个单元拼凑在一起时看到的单元的数量。 </p>

</div>
</div>
<a id="ac6ce1aa8a6e9f3aa897a51d5dcf68c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ce1aa8a6e9f3aa897a51d5dcf68c5c">&#9670;&nbsp;</a></span>n_macro_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_macro_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000080">Deprecated:</a></b></dt><dd>用n_cell_batches()代替。</dd></dl>

</div>
</div>
<a id="a8c9d964339b466bdcb661552e731e222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9d964339b466bdcb661552e731e222">&#9670;&nbsp;</a></span>n_cell_batches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_cell_batches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该结构所处理的单元格批次的数量。批次是通过在一般的几个单元上应用矢量化而形成的。 <code>cell_loop</code> 中的细胞范围从零到n_cell_batches()（独占），所以如果你想为所有要处理的细胞存储数据数组，这是一个合适的大小。这个数字大约是 <code><a class="el" href="classMatrixFree.html#ab9298b98c63d9d7b93367fcbeda9fe1b">n_physical_cells()</a>/VectorizedArray::size()</code> （取决于有多少细胞批没有被完全填满）。 </p>

</div>
</div>
<a id="a0c08e4ba63acbb93d0f3a1441b88d61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c08e4ba63acbb93d0f3a1441b88d61c">&#9670;&nbsp;</a></span>n_ghost_cell_batches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_ghost_cell_batches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该结构为面层集成而保留的额外单元格批次的数量。请注意，并不是所有在三角形中被重影的单元格都被保留在这个数据结构中，而是只有那些对评估两边的面积分有必要的单元格。 </p>

</div>
</div>
<a id="a1d24c18bcde8d09a2a7847f0f7f96d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d24c18bcde8d09a2a7847f0f7f96d19">&#9670;&nbsp;</a></span>n_inner_face_batches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_inner_face_batches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个结构所处理的内部面批的数量。 这些批次是通过在一般的几个面上应用矢量化而形成的。 <code>loop</code> 中的面的范围从零到n_inner_face_batches()（独占），所以如果你想为所有要处理的内部面存储数据的数组，这就是合适的大小。 </p>

</div>
</div>
<a id="aa787165092c1949ce2128ca63799abc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa787165092c1949ce2128ca63799abc1">&#9670;&nbsp;</a></span>n_boundary_face_batches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_boundary_face_batches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个结构所处理的边界面批的数量。 这些批次是通过在一般的几个面上应用矢量化而形成的。 <code>loop</code> 中的面的范围从n_inner_face_batches()到n_inner_face_batches()+n_boundary_face_batches()（独占），所以如果你需要存储所有边界面而不是内部面的数据的数组，这个数字给出适当的大小。 </p>

</div>
</div>
<a id="acf3aff8b6750287728851ef8753b135a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3aff8b6750287728851ef8753b135a">&#9670;&nbsp;</a></span>n_ghost_inner_face_batches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_ghost_inner_face_batches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回未在本地处理但属于本地拥有的面的数量。 </p>

</div>
</div>
<a id="a94c875be0229e4872a3e087a55410625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c875be0229e4872a3e087a55410625">&#9670;&nbsp;</a></span>get_boundary_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_boundary_id </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>macro_face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为了对边界的不同部分应用不同的运算符，这个方法可以用来查询面孔自己在VectorizedArray中按车道排序的边界ID。只对表示边界面的索引有效。 </p>

</div>
</div>
<a id="a75b99380acd6e278c4acf6a19fa443ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b99380acd6e278c4acf6a19fa443ba">&#9670;&nbsp;</a></span>get_faces_by_cells_boundary_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, VectorizedArrayType::size()&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_faces_by_cells_boundary_id </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个单元格内的面的边界ID，使用单元格在VectorizedArray中按车道的排序。 </p>

</div>
</div>
<a id="af3bf03172546d9ba1b8b14c845da46df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3bf03172546d9ba1b8b14c845da46df">&#9670;&nbsp;</a></span>get_dof_handler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_dof_handler </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回DoFHandler，其索引与reinit()函数中各自的 <code>std::vector</code> 参数一样。 </p>

</div>
</div>
<a id="a6c2de43baa7e77d1e3e4e60fc215f843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2de43baa7e77d1e3e4e60fc215f843">&#9670;&nbsp;</a></span>get_dof_handler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename DoFHandlerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const DoFHandlerType&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_dof_handler </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回DoFHandler，其索引与reinit()函数中相应的 <code>std::vector</code> 参数一样。注意，如果你想用不同于默认的模板参数来调用这个函数，你需要在函数调用前使用<code>template</code>，也就是说，你会有类似<code>matrix_free.template get_dof_handler&lt;<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a>&lt;dim&gt;&gt;()</code>.</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000081">Deprecated:</a></b></dt><dd>使用这个函数的非模板化等价物。</dd></dl>

</div>
</div>
<a id="aad2ce5ee5867360c16019d618e250ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2ce5ee5867360c16019d618e250ce4">&#9670;&nbsp;</a></span>get_cell_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;::cell_iterator <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_cell_iterator </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>lane_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回deal.II中的单元格迭代器讲到一个给定的单元格批次（在一个VectorizedArray中填充几个车道）和在这个结构的重新编号中跨单元格的矢量化中的车道索引。 请注意，deal.II中的单元格迭代器与本类的单元格循环的处理方式不同。这是因为几个单元被一起处理（跨单元的矢量化），而且在访问远程数据和与计算重叠的通信时，在不同的MPI处理器上有邻居的单元需要在某个时间被访问。 </p>

</div>
</div>
<a id="a46ed5ced497a19b51592f23ca8e6faf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ed5ced497a19b51592f23ca8e6faf5">&#9670;&nbsp;</a></span>get_cell_level_and_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_cell_level_and_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>lane_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这将返回由get_cell_iterator()对相同参数<code>cell_batch_index</code>和<code>lane_index</code>所返回的单元的级别和索引。 </p>

</div>
</div>
<a id="a6076e2d012fad941d8d326a7dc8c3a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6076e2d012fad941d8d326a7dc8c3a78">&#9670;&nbsp;</a></span>get_face_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;::cell_iterator, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_face_iterator </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_batch_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>lane_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>interior</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在deal.II中返回单元格的迭代器，该迭代器与一个面的内部/外部单元格在一对面批和巷道索引中。这一对中的第二个元素是面的编号，这样就可以访问面的迭代器。 <code>pair.first()-&gt;face(pair.second());</code>注意deal.II中的面迭代器通过单元格的方式与本类的面/边界循环的方式不同。这是因为几个面是一起工作的（矢量化），而且在访问远程数据和与计算重叠的通信时，在不同的MPI处理器上有相邻单元的面需要在某个时间被访问。 </p>

</div>
</div>
<a id="a1f172cadd38fd88cfd4d1f1205b63614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f172cadd38fd88cfd4d1f1205b63614">&#9670;&nbsp;</a></span>get_hp_cell_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt;::active_cell_iterator <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_hp_cell_iterator </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>lane_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>返回deal.II中的单元格迭代器讲到一个给定的单元格批次（在一个VectorizedArray中填充几个车道）和在这个结构的重新编号中跨单元格的矢量化中的车道索引。 请注意，deal.II中的单元格迭代器与本类的单元格循环的处理方式不同。这是因为几个单元被一起处理（跨单元的矢量化），而且在访问远程数据和与计算重叠的通信时，在不同的MPI处理器上有邻居的单元需要在某个时间被访问。  使用get_cell_iterator()代替。 </p>

</div>
</div>
<a id="a39c46e404d4a727175eb154f9f6e6304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c46e404d4a727175eb154f9f6e6304">&#9670;&nbsp;</a></span>at_irregular_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::at_irregular_cell </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>由于该类使用的是矢量数据类型，数据域中通常有多个值，因此可能会出现矢量类型的某些分量与网格中的实际单元不对应的情况。当只使用这个类时，通常不需要理会这个事实，因为这些值是用零填充的。然而，当这个类与访问单元格的deal.II混合时，需要注意。如果不是所有给定的&lt;tt&gt;cell_batch_index的<code>n_lanes</code>单元都对应于网格中的实际单元，有些只是为了填充的原因而出现，则该函数返回 <code>true</code> 。要知道有多少单元被实际使用，可以使用函数n_active_entries_per_cell_batch()。 </p>

</div>
</div>
<a id="a251d5c0f5cc96057223ebbffacd91a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251d5c0f5cc96057223ebbffacd91a03">&#9670;&nbsp;</a></span>n_components_filled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_components_filled </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000082">Deprecated:</a></b></dt><dd>使用n_active_entries_per_cell_batch()代替。</dd></dl>

</div>
</div>
<a id="a1d516071d20e633dc9efcadb7852ce15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d516071d20e633dc9efcadb7852ce15">&#9670;&nbsp;</a></span>n_active_entries_per_cell_batch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_active_entries_per_cell_batch </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个查询返回在一个单元格批中的 <code>VectorizedArrayType::size()</code> 个单元格中，有多少单元格是网格中的实际单元格，而不是因为填充的原因而出现的。对于大多数给定的n_cell_batches()中的单元格批次，这个数字等于 <code>VectorizedArrayType::size()</code>, ，但在网格中可能有一个或几个单元格批次（数字不相加），其中只有一个批次中的一些单元格被使用，由函数at_irregular_cell()表示。 </p>

</div>
</div>
<a id="ad6297a9ec73d830ae81e5eeacf02df27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6297a9ec73d830ae81e5eeacf02df27">&#9670;&nbsp;</a></span>n_active_entries_per_face_batch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_active_entries_per_face_batch </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_batch_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用这个函数找出在矢量化数据类型的长度上有多少个面对应于网格中的真实面（包括内部和边界面，因为这些面使用相同的索引，但范围不同）。对于大多数在n_inner_faces_batches()和n_boundary_face_batches()中给定的索引，这只是 <code>vectorization_length</code> 个，但可能有一个或几个网格（数字不相加），其中有更少的这种道的填充。 </p>

</div>
</div>
<a id="a4183258475490709034dbff113cbc789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4183258475490709034dbff113cbc789">&#9670;&nbsp;</a></span>get_dofs_per_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_dofs_per_cell </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回给定hp-index的每个单元的自由度数量。 </p>

</div>
</div>
<a id="aba06e049b55e59507a69e37e7a23f3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba06e049b55e59507a69e37e7a23f3b5">&#9670;&nbsp;</a></span>get_n_q_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_n_q_points </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回给定hp-index的每个单元的正交点的数量。 </p>

</div>
</div>
<a id="a4e0e4541d14974ef533bd9e61a8b8a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0e4541d14974ef533bd9e61a8b8a7f">&#9670;&nbsp;</a></span>get_dofs_per_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_dofs_per_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回给定hp-index的单元格每个面上的自由度数量。 </p>

</div>
</div>
<a id="a31fea1afe46c9741117a3a5d6a6c7259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fea1afe46c9741117a3a5d6a6c7259">&#9670;&nbsp;</a></span>get_n_q_points_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_n_q_points_face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回给定hp-index的单元格每个面上的正交点的数量。 </p>

</div>
</div>
<a id="a16b0fd13ac2a63888c4836640e8bc68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b0fd13ac2a63888c4836640e8bc68b">&#9670;&nbsp;</a></span>get_quadrature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_quadrature </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回给定hp-index的正交规则。 </p>

</div>
</div>
<a id="a1cf4cff03dbaa9fa73605966c185b60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf4cff03dbaa9fa73605966c185b60f">&#9670;&nbsp;</a></span>get_face_quadrature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim - 1&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_face_quadrature </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回给定hp-index的正交规则。 </p>

</div>
</div>
<a id="a9822d4a731c450b74bc32843dfc57235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9822d4a731c450b74bc32843dfc57235">&#9670;&nbsp;</a></span>get_cell_category()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_cell_category </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回当前批次的电池被分配到的类别。对于非hp-DoFHandler类型，类别在字段 <a class="el" href="structMatrixFree_1_1AdditionalData.html#a969eb6b91d17748718c4affd03841e91">AdditionalData::cell_vectorization_category</a> 中的给定值之间运行，在hp-adaptive情况下返回活动的FE指数。 </p>

</div>
</div>
<a id="a6272714d1f3a4389937894f2044a1298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6272714d1f3a4389937894f2044a1298">&#9670;&nbsp;</a></span>get_face_category()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_face_category </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>macro_face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回当前一批面的两边的单元格上的类别。 </p>

</div>
</div>
<a id="a90f6b960d4810e6914a45d9cbb164793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f6b960d4810e6914a45d9cbb164793">&#9670;&nbsp;</a></span>indices_initialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::indices_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>查询是否已经设置了索引。 </p>

</div>
</div>
<a id="a2b95d23ac163726460a536e76513ac13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b95d23ac163726460a536e76513ac13">&#9670;&nbsp;</a></span>mapping_initialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::mapping_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>查询单元格的几何相关信息是否已被设置。 </p>

</div>
</div>
<a id="a214a09bc9d553323fe8e2d4ab85bd1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214a09bc9d553323fe8e2d4ab85bd1d1">&#9670;&nbsp;</a></span>get_mg_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_mg_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回要处理的网格的级别。如果在活动单元上工作，返回 <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> 。 </p>

</div>
</div>
<a id="aa47cc139ef80f83ed20fc55e3cd16767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47cc139ef80f83ed20fc55e3cd16767">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该类的内存消耗量的近似值，单位为字节。 </p>

</div>
</div>
<a id="a256aac0a2e56bb2345f7a3f0ce74bef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256aac0a2e56bb2345f7a3f0ce74bef8">&#9670;&nbsp;</a></span>print_memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::print_memory_consumption </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在给定的输出流中打印出该类不同结构的内存消耗的详细摘要。 </p>

</div>
</div>
<a id="a1988bac68c909d3868c61a66eb285791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1988bac68c909d3868c61a66eb285791">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在给定的输出流中打印这个类的摘要。它集中在索引上，并不打印所有存储的数据。 </p>

</div>
</div>
<a id="afad4aeebcf482bcc621c6f7947209a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad4aeebcf482bcc621c6f7947209a7c">&#9670;&nbsp;</a></span>get_task_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_task_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回任务图的信息。 </p>

</div>
</div>
<a id="a94748ddaa979639d6ed02d9f4f617fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94748ddaa979639d6ed02d9f4f617fdf">&#9670;&nbsp;</a></span>get_mapping_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const internal::MatrixFreeFunctions:: MappingInfo&lt;dim, Number, VectorizedArrayType&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_mapping_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e095529abf96aad2b7fbc95c545fd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e095529abf96aad2b7fbc95c545fd8d">&#9670;&nbsp;</a></span>get_dof_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a>&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_dof_info </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index_component</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回关于索引自由度的信息。 </p>

</div>
</div>
<a id="a41c33c7336c73d245d5624baf610d5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c33c7336c73d245d5624baf610d5a8">&#9670;&nbsp;</a></span>n_constraint_pool_entries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::n_constraint_pool_entries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回约束池中的权重数量。 </p>

</div>
</div>
<a id="a2cd98b7686fe06501575420c8ad0819b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd98b7686fe06501575420c8ad0819b">&#9670;&nbsp;</a></span>constraint_pool_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Number* <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::constraint_pool_begin </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>pool_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个指向约束池数据中第一个数字的指针，索引为 <code>pool_index</code> （与 <code><a class="el" href="classMatrixFree.html#a4f37a1274ff5b9092bb4f968d499b2f8">constraint_pool_end()</a></code>). 一起使用 </p>

</div>
</div>
<a id="a4f37a1274ff5b9092bb4f968d499b2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f37a1274ff5b9092bb4f968d499b2f8">&#9670;&nbsp;</a></span>constraint_pool_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Number* <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::constraint_pool_end </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>pool_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个指向约束池数据中最后一个数字的指针，索引为 <code>pool_index</code> （与 <code><a class="el" href="classMatrixFree.html#a2cd98b7686fe06501575420c8ad0819b">constraint_pool_begin()</a>一起使用）。</code> </p>

</div>
</div>
<a id="a363a85c27301642b9d0fd219f15ff229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363a85c27301642b9d0fd219f15ff229">&#9670;&nbsp;</a></span>get_shape_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt;VectorizedArrayType&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_shape_info </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_handler_index_component</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_base_element</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_fe_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>hp_active_quad_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回给定hp-index的单元格信息。 </p>

</div>
</div>
<a id="aa13157af74893593d4af73a30b01a74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13157af74893593d4af73a30b01a74b">&#9670;&nbsp;</a></span>get_face_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceToCellTopology.html">internal::MatrixFreeFunctions::FaceToCellTopology</a>&lt; VectorizedArrayType::size()&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_face_info </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_batch_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个面的连接信息。 </p>

</div>
</div>
<a id="a0656887db9b1c8123e650632eadf8996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0656887db9b1c8123e650632eadf8996">&#9670;&nbsp;</a></span>get_cell_and_face_to_plain_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTable.html">Table</a>&lt;3, unsigned <a class="el" href="classint.html">int</a>&gt;&amp; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::get_cell_and_face_to_plain_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回将宏观单元格号、单元格内的面的索引和向量的单元格批内的索引这三者转化为面数组内的索引的表格。 </p>

</div>
</div>
<a id="acf9054eb8149297fe2e062369f0dc618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9054eb8149297fe2e062369f0dc618">&#9670;&nbsp;</a></span>acquire_scratch_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;VectorizedArrayType&gt;* <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::acquire_scratch_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取一个内部使用的抓取数据对象。请确保事后将你从这个对象获得的指针传递给release_scratch_data()函数，以释放它。这个接口被FEEvaluation对象用来存储其数据结构。 内部数据结构的组织是一个线程本地存储的向量列表。多个线程将各自获得一个单独的存储域和单独的向量，确保线程安全。获取和释放对象的机制类似于WorkStream的本地贡献机制，见 <a class="el" href="DEALGlossary.html#workstream_paper">WorkStream论文</a> 。 </p>

</div>
</div>
<a id="a59550cc34721cf03a46f6f44347bcb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59550cc34721cf03a46f6f44347bcb0c">&#9670;&nbsp;</a></span>release_scratch_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::release_scratch_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; *&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使得抓取板的对象再次可用。 </p>

</div>
</div>
<a id="a0a77e6d9daf1c25b438f2c3a9430b908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a77e6d9daf1c25b438f2c3a9430b908">&#9670;&nbsp;</a></span>acquire_scratch_data_non_threadsafe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;Number&gt;* <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::acquire_scratch_data_non_threadsafe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取一个用于内部使用的划痕数据对象。确保事后将你从这个对象获得的指针传递给release_scratch_data_non_threadsafe()函数，以释放它。注意，与acquisition_scratch_data()相反，这个方法一次只能由一个线程调用，但与acquisition_scratch_data()相反，释放scratch数据的线程也有可能与获取它的线程不同。 </p>

</div>
</div>
<a id="ad1131ad89d22abda0be5b0e766097d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1131ad89d22abda0be5b0e766097d92">&#9670;&nbsp;</a></span>release_scratch_data_non_threadsafe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::release_scratch_data_non_threadsafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; Number &gt; *&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使得从头数据的对象再次可用。 </p>

</div>
</div>
<a id="a08f23adccbd26348ab71866dc49283d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f23adccbd26348ab71866dc49283d7">&#9670;&nbsp;</a></span>internal_reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename number2 , int q_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::internal_reinit </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handlers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; q_dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这是实际的reinit函数，为DoFHandler的情况设置索引。 </p>

</div>
</div>
<a id="a3508f2538e470b07826a62a03292e603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3508f2538e470b07826a62a03292e603">&#9670;&nbsp;</a></span>initialize_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::initialize_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number2 &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>初始化DoFInfo中的字段和约束池，约束池中保存了所有不同的权重（不是DoFInfo的一部分，因为几个DoFInfo类可以有相同的权重，因此只需要存储一次）。 </p>

</div>
</div>
<a id="adb08861aba08a05bbb6a62d30fd8ed1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb08861aba08a05bbb6a62d30fd8ed1c">&#9670;&nbsp;</a></span>initialize_dof_handlers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::initialize_dof_handlers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handlers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMatrixFree_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>基于DoFHandler&lt;dim&gt;参数初始化DoFHandlers。 </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af7d00e4ed4f076e3a86cab23b6d8b452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d00e4ed4f076e3a86cab23b6d8b452">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>由模板参数<code>dim</code>设定的尺寸。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l00111">111</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="aaed884d2e3733624b9028bea0952ae39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed884d2e3733624b9028bea0952ae39">&#9670;&nbsp;</a></span>dof_handlers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim&gt; &gt; &gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::dof_handlers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向当前问题基础的DoFHandlers的指针。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01609">1609</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="acc52f212dd2448479233a1bcad3fa40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc52f212dd2448479233a1bcad3fa40e">&#9670;&nbsp;</a></span>dof_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::dof_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>包含各个单元格上的自由度和约束信息。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01615">1615</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a8a1b58d294b2d341cf019efcdbab88b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1b58d294b2d341cf019efcdbab88b5">&#9670;&nbsp;</a></span>constraint_pool_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Number&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::constraint_pool_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>包含存储在DoFInfo中的约束条件的权重。填充到一个单独的字段中，因为几个向量组件可能共享类似的权重，这样可以减少内存消耗。此外，它省去了DoFInfo上的模板参数，使之成为一个只有索引的普通字段。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01621">1621</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="ae0bc8be50b14ea2fd9168edcaa74db40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0bc8be50b14ea2fd9168edcaa74db40">&#9670;&nbsp;</a></span>constraint_pool_row_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::constraint_pool_row_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>包含一个指向约束池数据中第i个索引开始的指标。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01627">1627</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a0819d60614c996f43079cc20e0d63933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0819d60614c996f43079cc20e0d63933">&#9670;&nbsp;</a></span>mapping_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfo.html">internal::MatrixFreeFunctions::MappingInfo</a>&lt;dim, Number, VectorizedArrayType&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::mapping_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>保存单元格从参考单元格到实数单元格的转换信息，这是评估积分所需要的。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01634">1634</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a0fe9b8c6fc5ca0c15d84ca0243eea7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe9b8c6fc5ca0c15d84ca0243eea7f6">&#9670;&nbsp;</a></span>shape_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt;4, <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt;VectorizedArrayType&gt; &gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::shape_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>包含单元格的形状值信息。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01641">1641</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a6ccb8c2689c4029ccf44dacf47c4d224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccb8c2689c4029ccf44dacf47c4d224">&#9670;&nbsp;</a></span>cell_level_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_level_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>描述了单元格是如何被穿过的。有了单元格级别（该字段的第一个索引）和级别内的索引，就可以重建一个deal.II单元格迭代器，并使用deal.II提供的所有传统的单元格迭代器的功能。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01647">1647</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="aebd8b73ecd3843be97bc6c62a91550e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd8b73ecd3843be97bc6c62a91550e8">&#9670;&nbsp;</a></span>cell_level_index_end_local</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::cell_level_index_end_local</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于非连续Galerkin，cell_level_index包括不在本地处理器上的单元，但需要用来计算单元积分。在cell_level_index_end_local中，我们存储本地单元的数量。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01654">1654</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a538b16343ba782ba2bc83624660c1a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538b16343ba782ba2bc83624660c1a03">&#9670;&nbsp;</a></span>task_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1TaskInfo.html">internal::MatrixFreeFunctions::TaskInfo</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::task_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储要处理的单元和面的基本布局，包括共享内存并行化的任务布局以及与MPI的通信和计算之间可能的重叠。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01660">1660</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="adb2d9efa44c36973e8c871c79f55cea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2d9efa44c36973e8c871c79f55cea3">&#9670;&nbsp;</a></span>face_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1FaceInfo.html">internal::MatrixFreeFunctions::FaceInfo</a>&lt;VectorizedArrayType::size()&gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::face_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>持有面孔信息的向量。只在build_face_info=true时初始化。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01667">1667</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="ad9776b9b9cb59771ed0409f0e61d9092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9776b9b9cb59771ed0409f0e61d9092">&#9670;&nbsp;</a></span>indices_are_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::indices_are_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储索引是否已被初始化。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01673">1673</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a60d4bcec742b46e930fc6d3ad1854f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d4bcec742b46e930fc6d3ad1854f35">&#9670;&nbsp;</a></span>mapping_is_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::mapping_is_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储索引是否已被初始化。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01679">1679</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a9dbe6cd7b3a803387e09b5746898a1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbe6cd7b3a803387e09b5746898a1fc">&#9670;&nbsp;</a></span>scratch_pad</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; std::list&lt;std::pair&lt;<a class="el" href="classbool.html">bool</a>, <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;VectorizedArrayType&gt; &gt; &gt; &gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::scratch_pad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用于评估的刮板内存。我们允许超过一个评估对象附加到这个字段（这个，外 std::vector), 所以我们需要跟踪某个数据字段是否已经被使用（第一部分对）并保持一个对象的列表。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01689">1689</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="aab344a297bb56fc07d4490794da49fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab344a297bb56fc07d4490794da49fc9">&#9670;&nbsp;</a></span>scratch_pad_non_threadsafe</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;std::pair&lt;<a class="el" href="classbool.html">bool</a>, <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;Number&gt; &gt; &gt; <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::scratch_pad_non_threadsafe</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用于评估和其他情况下的Scratchpad内存，非线程安全的变体。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01696">1696</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<a id="a65d5b0dfea8051c30f80a7f3f72fd5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d5b0dfea8051c30f80a7f3f72fd5bc">&#9670;&nbsp;</a></span>mg_level</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number = double, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt;::mg_level</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储了要处理的网格的级别。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__free_8h_source.html#l01702">1702</a> of file <a class="el" href="matrix__free_8h_source.html">matrix_free.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/matrix_free/<a class="el" href="matrix__free_8h_source.html">matrix_free.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
