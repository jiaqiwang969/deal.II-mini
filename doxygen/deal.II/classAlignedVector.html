<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classAlignedVector.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: AlignedVector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classAlignedVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AlignedVector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="aligned__vector_8h_source.html">deal.II/base/aligned_vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AlignedVector&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classAlignedVector__inherit__graph.svg" width="655" height="1612"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2733daf0af1fdb8e5142829561abdb1d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a2733daf0af1fdb8e5142829561abdb1d">value_type</a> = T</td></tr>
<tr class="separator:a2733daf0af1fdb8e5142829561abdb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe658fc9ffde91aa425029dcf809bb4f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#afe658fc9ffde91aa425029dcf809bb4f">pointer</a> = <a class="el" href="classAlignedVector.html#a2733daf0af1fdb8e5142829561abdb1d">value_type</a> *</td></tr>
<tr class="separator:afe658fc9ffde91aa425029dcf809bb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd95095ee2bf7058874cfa968bf8d47"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a9cd95095ee2bf7058874cfa968bf8d47">const_pointer</a> = const <a class="el" href="classAlignedVector.html#a2733daf0af1fdb8e5142829561abdb1d">value_type</a> *</td></tr>
<tr class="separator:a9cd95095ee2bf7058874cfa968bf8d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5254e23b73ee1494467758418e8caf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#aff5254e23b73ee1494467758418e8caf">iterator</a> = <a class="el" href="classAlignedVector.html#a2733daf0af1fdb8e5142829561abdb1d">value_type</a> *</td></tr>
<tr class="separator:aff5254e23b73ee1494467758418e8caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3afb726ea74e387e885b049dc035a23"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ad3afb726ea74e387e885b049dc035a23">const_iterator</a> = const <a class="el" href="classAlignedVector.html#a2733daf0af1fdb8e5142829561abdb1d">value_type</a> *</td></tr>
<tr class="separator:ad3afb726ea74e387e885b049dc035a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4a1ef6d1b3464ab5f66deac35e968a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a8c4a1ef6d1b3464ab5f66deac35e968a">reference</a> = <a class="el" href="classAlignedVector.html#a2733daf0af1fdb8e5142829561abdb1d">value_type</a> &amp;</td></tr>
<tr class="separator:a8c4a1ef6d1b3464ab5f66deac35e968a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2db6542d6b9737826e218bbe1cab5b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#af2db6542d6b9737826e218bbe1cab5b4">const_reference</a> = const <a class="el" href="classAlignedVector.html#a2733daf0af1fdb8e5142829561abdb1d">value_type</a> &amp;</td></tr>
<tr class="separator:af2db6542d6b9737826e218bbe1cab5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f43ccbd5f7be4b004995ee723a4010"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a> = std::size_t</td></tr>
<tr class="separator:ac7f43ccbd5f7be4b004995ee723a4010"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae0c7b2f2bf51aa54825ad6565e8413e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ae0c7b2f2bf51aa54825ad6565e8413e8">AlignedVector</a> ()</td></tr>
<tr class="separator:ae0c7b2f2bf51aa54825ad6565e8413e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7471090217ad0df74031a7fbb4e3457"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#aa7471090217ad0df74031a7fbb4e3457">AlignedVector</a> (const <a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a> <a class="el" href="classAlignedVector.html#ac1900b4748c7de0d12858b0a93ee0060">size</a>, const T &amp;init=T())</td></tr>
<tr class="separator:aa7471090217ad0df74031a7fbb4e3457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3193278efeaa81d926366d4761040a8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a3193278efeaa81d926366d4761040a8c">~AlignedVector</a> ()=default</td></tr>
<tr class="separator:a3193278efeaa81d926366d4761040a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1c70aaf5700b42530b57e0f0b7e402"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#abd1c70aaf5700b42530b57e0f0b7e402">AlignedVector</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:abd1c70aaf5700b42530b57e0f0b7e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bfc34442b79654d3e3fcf5dc45d55e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a35bfc34442b79654d3e3fcf5dc45d55e">AlignedVector</a> (<a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&amp;vec) noexcept</td></tr>
<tr class="separator:a35bfc34442b79654d3e3fcf5dc45d55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d07700c53e247ea13a18c82c2e0ed6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#aa0d07700c53e247ea13a18c82c2e0ed6">operator=</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:aa0d07700c53e247ea13a18c82c2e0ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6c2525499f06c06f7f90c2a8f8a24d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a2a6c2525499f06c06f7f90c2a8f8a24d">operator=</a> (<a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&amp;vec) noexcept</td></tr>
<tr class="separator:a2a6c2525499f06c06f7f90c2a8f8a24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e0b92fca68fabf1f273d4e186861f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a12e0b92fca68fabf1f273d4e186861f1">resize_fast</a> (const <a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a> new_size)</td></tr>
<tr class="separator:a12e0b92fca68fabf1f273d4e186861f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c3bb98b1243d1822179dd63e8d119a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ad5c3bb98b1243d1822179dd63e8d119a">resize</a> (const <a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a> new_size)</td></tr>
<tr class="separator:ad5c3bb98b1243d1822179dd63e8d119a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf0ce91d3fdcd68f7f290d1fc7ef0e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a6cf0ce91d3fdcd68f7f290d1fc7ef0e5">resize</a> (const <a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a> new_size, const T &amp;init)</td></tr>
<tr class="separator:a6cf0ce91d3fdcd68f7f290d1fc7ef0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e56ff3ba26e09e033d5054affc32d08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a3e56ff3ba26e09e033d5054affc32d08">reserve</a> (const <a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a> new_allocated_size)</td></tr>
<tr class="separator:a3e56ff3ba26e09e033d5054affc32d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2beb26ca2ae3921a0dc634bc8c9cdd44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a2beb26ca2ae3921a0dc634bc8c9cdd44">clear</a> ()</td></tr>
<tr class="separator:a2beb26ca2ae3921a0dc634bc8c9cdd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de70f70d696a43451f4e48c1c119d69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a9de70f70d696a43451f4e48c1c119d69">push_back</a> (const T in_data)</td></tr>
<tr class="separator:a9de70f70d696a43451f4e48c1c119d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa09530be204c4fd3f25155da71215a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html#a8c4a1ef6d1b3464ab5f66deac35e968a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#afa09530be204c4fd3f25155da71215a7">back</a> ()</td></tr>
<tr class="separator:afa09530be204c4fd3f25155da71215a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71d86c84614ed6356f845b9d951b8af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html#af2db6542d6b9737826e218bbe1cab5b4">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ac71d86c84614ed6356f845b9d951b8af">back</a> () const</td></tr>
<tr class="separator:ac71d86c84614ed6356f845b9d951b8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bc666796f52070206a2798b1dba090"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:af2bc666796f52070206a2798b1dba090"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#af2bc666796f52070206a2798b1dba090">insert_back</a> (ForwardIterator <a class="el" href="classAlignedVector.html#a2a928b90e816fe71668a693dd1e50edf">begin</a>, ForwardIterator <a class="el" href="classAlignedVector.html#a007a479f46a0321254b029315193000a">end</a>)</td></tr>
<tr class="separator:af2bc666796f52070206a2798b1dba090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1805fd5c0824de60b496daa958b8a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a6d1805fd5c0824de60b496daa958b8a5">fill</a> ()</td></tr>
<tr class="separator:a6d1805fd5c0824de60b496daa958b8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3f8d9637308d670fca25e85e39c80f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a1d3f8d9637308d670fca25e85e39c80f">fill</a> (const T &amp;element)</td></tr>
<tr class="separator:a1d3f8d9637308d670fca25e85e39c80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dcb894546bc3211462aa0da2dbe570"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ad4dcb894546bc3211462aa0da2dbe570">replicate_across_communicator</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator, const unsigned <a class="el" href="classint.html">int</a> root_process)</td></tr>
<tr class="separator:ad4dcb894546bc3211462aa0da2dbe570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679c42669ff9aede60f9fc89a57b732b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a679c42669ff9aede60f9fc89a57b732b">swap</a> (<a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:a679c42669ff9aede60f9fc89a57b732b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76d46499c3e4eae5c0ff0ebdbddb853"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ab76d46499c3e4eae5c0ff0ebdbddb853">empty</a> () const</td></tr>
<tr class="separator:ab76d46499c3e4eae5c0ff0ebdbddb853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1900b4748c7de0d12858b0a93ee0060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ac1900b4748c7de0d12858b0a93ee0060">size</a> () const</td></tr>
<tr class="separator:ac1900b4748c7de0d12858b0a93ee0060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862418053c6e253515381451d77818c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a862418053c6e253515381451d77818c0">capacity</a> () const</td></tr>
<tr class="separator:a862418053c6e253515381451d77818c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172650dad815f1e7b0053567f5782260"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html#a8c4a1ef6d1b3464ab5f66deac35e968a">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a172650dad815f1e7b0053567f5782260">operator[]</a> (const <a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a> index)</td></tr>
<tr class="separator:a172650dad815f1e7b0053567f5782260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec7ff2f0ee47fb5df016fad1870fdb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html#af2db6542d6b9737826e218bbe1cab5b4">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a5ec7ff2f0ee47fb5df016fad1870fdb3">operator[]</a> (const <a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a> index) const</td></tr>
<tr class="separator:a5ec7ff2f0ee47fb5df016fad1870fdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d3ec3ed58e7c10cb66288834220cd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html#afe658fc9ffde91aa425029dcf809bb4f">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a60d3ec3ed58e7c10cb66288834220cd3">data</a> ()</td></tr>
<tr class="separator:a60d3ec3ed58e7c10cb66288834220cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacd3e98e6c0ed2e1afa44cfbb14e2ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html#a9cd95095ee2bf7058874cfa968bf8d47">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#afacd3e98e6c0ed2e1afa44cfbb14e2ee">data</a> () const</td></tr>
<tr class="separator:afacd3e98e6c0ed2e1afa44cfbb14e2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a928b90e816fe71668a693dd1e50edf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html#aff5254e23b73ee1494467758418e8caf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a2a928b90e816fe71668a693dd1e50edf">begin</a> ()</td></tr>
<tr class="separator:a2a928b90e816fe71668a693dd1e50edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007a479f46a0321254b029315193000a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html#aff5254e23b73ee1494467758418e8caf">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a007a479f46a0321254b029315193000a">end</a> ()</td></tr>
<tr class="separator:a007a479f46a0321254b029315193000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72f9cd8f0d7ca2098b81d070ecf953f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html#ad3afb726ea74e387e885b049dc035a23">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#aa72f9cd8f0d7ca2098b81d070ecf953f">begin</a> () const</td></tr>
<tr class="separator:aa72f9cd8f0d7ca2098b81d070ecf953f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b355e808731cc71dd0a90f07e566275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html#ad3afb726ea74e387e885b049dc035a23">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a2b355e808731cc71dd0a90f07e566275">end</a> () const</td></tr>
<tr class="separator:a2b355e808731cc71dd0a90f07e566275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe56d5aff0ce372d2bddc2a0847ff35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a0fe56d5aff0ce372d2bddc2a0847ff35">memory_consumption</a> () const</td></tr>
<tr class="separator:a0fe56d5aff0ce372d2bddc2a0847ff35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae546c280e6238488934b4958bab7cc1b"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ae546c280e6238488934b4958bab7cc1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ae546c280e6238488934b4958bab7cc1b">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:ae546c280e6238488934b4958bab7cc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc55665c8e84f060b973cdbc322c4f00"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:adc55665c8e84f060b973cdbc322c4f00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#adc55665c8e84f060b973cdbc322c4f00">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:adc55665c8e84f060b973cdbc322c4f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415dee9f9e4d36c245754727ea2a8d3d"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a415dee9f9e4d36c245754727ea2a8d3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a415dee9f9e4d36c245754727ea2a8d3d">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a415dee9f9e4d36c245754727ea2a8d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac85363b5dd2b212cd7d91151e76ac1a0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; T[], std::function&lt; void(T *)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ac85363b5dd2b212cd7d91151e76ac1a0">elements</a></td></tr>
<tr class="separator:ac85363b5dd2b212cd7d91151e76ac1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bffd0cf33678ed838f989de5e5de9e5"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a8bffd0cf33678ed838f989de5e5de9e5">used_elements_end</a></td></tr>
<tr class="separator:a8bffd0cf33678ed838f989de5e5de9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd1539b449c73e545bf79273e594fcf"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#aacd1539b449c73e545bf79273e594fcf">allocated_elements_end</a></td></tr>
<tr class="separator:aacd1539b449c73e545bf79273e594fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ad12008400b484088aa5e775e6d2262ab"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad12008400b484088aa5e775e6d2262ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#ad12008400b484088aa5e775e6d2262ab">operator==</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:ad12008400b484088aa5e775e6d2262ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5194e9bde680a0b5d359cd17fc1de808"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5194e9bde680a0b5d359cd17fc1de808"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAlignedVector.html#a5194e9bde680a0b5d359cd17fc1de808">operator!=</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a5194e9bde680a0b5d359cd17fc1de808"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class AlignedVector&lt; T &gt;</h3>

<p>This is a replacement class for std::vector to be used in combination with <a class="el" href="classVectorizedArray.html">VectorizedArray</a> and derived data types. It allocates memory aligned to addresses of a vectorized data type (in order to avoid segmentation faults when a variable of type <a class="el" href="classVectorizedArray.html">VectorizedArray</a> which the compiler assumes to be aligned to certain memory addresses does not actually follow these rules). This could also be achieved by proving std::vector with a user-defined allocator. On the other hand, writing an own small vector class lets us implement parallel copy and move operations with TBB, insert deal.II-style assertions, and cut some unnecessary functionality. Note that this vector is a bit more memory-consuming than std::vector because of alignment, so it is recommended to only use this vector on long vectors. </p>

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00061">61</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2733daf0af1fdb8e5142829561abdb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2733daf0af1fdb8e5142829561abdb1d">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html#a2733daf0af1fdb8e5142829561abdb1d">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare standard types used in all containers. These types parallel those in the <code>C++</code> standard libraries <code>vector&lt;...&gt;</code> class. </p>

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00068">68</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<a id="afe658fc9ffde91aa425029dcf809bb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe658fc9ffde91aa425029dcf809bb4f">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html#afe658fc9ffde91aa425029dcf809bb4f">pointer</a> =  <a class="el" href="classAlignedVector.html#a2733daf0af1fdb8e5142829561abdb1d">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00069">69</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<a id="a9cd95095ee2bf7058874cfa968bf8d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd95095ee2bf7058874cfa968bf8d47">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html#a9cd95095ee2bf7058874cfa968bf8d47">const_pointer</a> =  const <a class="el" href="classAlignedVector.html#a2733daf0af1fdb8e5142829561abdb1d">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00070">70</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<a id="aff5254e23b73ee1494467758418e8caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5254e23b73ee1494467758418e8caf">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html#aff5254e23b73ee1494467758418e8caf">iterator</a> =  <a class="el" href="classAlignedVector.html#a2733daf0af1fdb8e5142829561abdb1d">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00071">71</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<a id="ad3afb726ea74e387e885b049dc035a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3afb726ea74e387e885b049dc035a23">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html#ad3afb726ea74e387e885b049dc035a23">const_iterator</a> =  const <a class="el" href="classAlignedVector.html#a2733daf0af1fdb8e5142829561abdb1d">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00072">72</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<a id="a8c4a1ef6d1b3464ab5f66deac35e968a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4a1ef6d1b3464ab5f66deac35e968a">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html#a8c4a1ef6d1b3464ab5f66deac35e968a">reference</a> =  <a class="el" href="classAlignedVector.html#a2733daf0af1fdb8e5142829561abdb1d">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00073">73</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<a id="af2db6542d6b9737826e218bbe1cab5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2db6542d6b9737826e218bbe1cab5b4">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html#af2db6542d6b9737826e218bbe1cab5b4">const_reference</a> =  const <a class="el" href="classAlignedVector.html#a2733daf0af1fdb8e5142829561abdb1d">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00074">74</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<a id="ac7f43ccbd5f7be4b004995ee723a4010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f43ccbd5f7be4b004995ee723a4010">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a> =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00075">75</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae0c7b2f2bf51aa54825ad6565e8413e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c7b2f2bf51aa54825ad6565e8413e8">&#9670;&nbsp;</a></span>AlignedVector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html">AlignedVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty constructor. Sets the vector size to zero. </p>

</div>
</div>
<a id="aa7471090217ad0df74031a7fbb4e3457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7471090217ad0df74031a7fbb4e3457">&#9670;&nbsp;</a></span>AlignedVector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html">AlignedVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>init</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the vector size to the given size and initializes all elements with <a class="el" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a3193278efeaa81d926366d4761040a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3193278efeaa81d926366d4761040a8c">&#9670;&nbsp;</a></span>~AlignedVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::~<a class="el" href="classAlignedVector.html">AlignedVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a id="abd1c70aaf5700b42530b57e0f0b7e402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1c70aaf5700b42530b57e0f0b7e402">&#9670;&nbsp;</a></span>AlignedVector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html">AlignedVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a35bfc34442b79654d3e3fcf5dc45d55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bfc34442b79654d3e3fcf5dc45d55e">&#9670;&nbsp;</a></span>AlignedVector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classAlignedVector.html">AlignedVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Create a new aligned vector by stealing the contents of <code>vec</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa0d07700c53e247ea13a18c82c2e0ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d07700c53e247ea13a18c82c2e0ed6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&amp; <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment to the input vector <code>vec</code>.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a2a6c2525499f06c06f7f90c2a8f8a24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6c2525499f06c06f7f90c2a8f8a24d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&amp; <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator. </p>

</div>
</div>
<a id="a12e0b92fca68fabf1f273d4e186861f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e0b92fca68fabf1f273d4e186861f1">&#9670;&nbsp;</a></span>resize_fast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::resize_fast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the size of the vector. If the new size is larger than the previous size, then new elements will be added to the end of the vector; these elements will remain uninitialized (i.e., left in an undefined state) if <code>std::is_trivial&lt;T&gt;</code> is <code>true</code>, and will be default initialized if <code>std::is_trivial&lt;T&gt;</code> is <code>false</code>. See <a href="https://en.cppreference.com/w/cpp/types/is_trivial">here</a> for a definition of what <code>std::is_trivial</code> does.</p>
<p>If the new size is less than the previous size, then the last few elements will be destroyed if <code>std::is_trivial&lt;T&gt;</code> will be <code>false</code> or will simply be ignored in the future if <code>std::is_trivial&lt;T&gt;</code> is <code>true</code>.</p>
<p>As a consequence of the outline above, the "_fast" suffix of this function refers to the fact that for "trivial" classes <code>T</code>, this function omits constructor/destructor calls and in particular the initialization of new elements.</p>
<dl class="section note"><dt>Note</dt><dd>This method can only be invoked for classes <code>T</code> that define a default constructor, <code><a class="el" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T()</a></code>. Otherwise, compilation will fail. </dd></dl>

</div>
</div>
<a id="ad5c3bb98b1243d1822179dd63e8d119a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c3bb98b1243d1822179dd63e8d119a">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the size of the vector. It keeps old elements previously available, and initializes each newly added element to a default-constructed object of type <code>T</code>.</p>
<p>If the new vector size is shorter than the old one, the memory is not immediately released unless the new size is zero; however, the size of the current object is of course set to the requested value. The destructors of released elements are also called.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a6cf0ce91d3fdcd68f7f290d1fc7ef0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf0ce91d3fdcd68f7f290d1fc7ef0e5">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the size of the vector. It keeps old elements previously available, and initializes each newly added element with the provided initializer.</p>
<p>If the new vector size is shorter than the old one, the memory is not immediately released unless the new size is zero; however, the size of the current object is of course set to the requested value.</p>
<dl class="section note"><dt>Note</dt><dd>This method can only be invoked for classes that define the copy assignment operator. Otherwise, compilation will fail.</dd>
<dd>
If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a3e56ff3ba26e09e033d5054affc32d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e56ff3ba26e09e033d5054affc32d08">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a>&#160;</td>
          <td class="paramname"><em>new_allocated_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserve memory space for <code>new_allocated_size</code> elements.</p>
<p>If the argument <code>new_allocated_size</code> is less than the current number of stored elements (as indicated by calling <a class="el" href="classAlignedVector.html#ac1900b4748c7de0d12858b0a93ee0060">size()</a>), then this function does not do anything at all. Except if the argument <code>new_allocated_size</code> is set to zero, then all previously allocated memory is released (this operation then being equivalent to directly calling the <a class="el" href="classAlignedVector.html#a2beb26ca2ae3921a0dc634bc8c9cdd44">clear()</a> function).</p>
<p>In order to avoid too frequent reallocation (which involves copy of the data), this function doubles the amount of memory occupied when the given size is larger than the previously allocated size.</p>
<p>Note that this function only changes the amount of elements the object <em>can</em> store, but not the number of elements it <em>actually</em> stores. As a consequence, no constructors or destructors of newly created objects are run, though the existing elements may be moved to a new location (which involves running the move constructor at the new location and the destructor at the old location). </p>

</div>
</div>
<a id="a2beb26ca2ae3921a0dc634bc8c9cdd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2beb26ca2ae3921a0dc634bc8c9cdd44">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases all previously allocated memory and leaves the vector in a state equivalent to the state after the default constructor has been called. </p>

</div>
</div>
<a id="a9de70f70d696a43451f4e48c1c119d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de70f70d696a43451f4e48c1c119d69">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>in_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts an element at the end of the vector, increasing the vector size by one. Note that the allocated size will double whenever the previous space is not enough to hold the new element. </p>

</div>
</div>
<a id="afa09530be204c4fd3f25155da71215a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa09530be204c4fd3f25155da71215a7">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html#a8c4a1ef6d1b3464ab5f66deac35e968a">reference</a> <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the last element of the vector (read and write access). </p>

</div>
</div>
<a id="ac71d86c84614ed6356f845b9d951b8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71d86c84614ed6356f845b9d951b8af">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html#af2db6542d6b9737826e218bbe1cab5b4">const_reference</a> <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the last element of the vector (read-only access). </p>

</div>
</div>
<a id="af2bc666796f52070206a2798b1dba090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bc666796f52070206a2798b1dba090">&#9670;&nbsp;</a></span>insert_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::insert_back </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts several elements at the end of the vector given by a range of elements. </p>

</div>
</div>
<a id="a6d1805fd5c0824de60b496daa958b8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1805fd5c0824de60b496daa958b8a5">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::fill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the vector with <a class="el" href="classAlignedVector.html#ac1900b4748c7de0d12858b0a93ee0060">size()</a> copies of a default constructed object.</p>
<dl class="section note"><dt>Note</dt><dd>Unlike the other <a class="el" href="classAlignedVector.html#a6d1805fd5c0824de60b496daa958b8a5">fill()</a> function, this method can also be invoked for classes that do not define a copy assignment operator.</dd>
<dd>
If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a1d3f8d9637308d670fca25e85e39c80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3f8d9637308d670fca25e85e39c80f">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the vector with <a class="el" href="classAlignedVector.html#ac1900b4748c7de0d12858b0a93ee0060">size()</a> copies of the given input.</p>
<dl class="section note"><dt>Note</dt><dd>This method can only be invoked for classes that define the copy assignment operator. Otherwise, compilation will fail.</dd>
<dd>
If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ad4dcb894546bc3211462aa0da2dbe570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dcb894546bc3211462aa0da2dbe570">&#9670;&nbsp;</a></span>replicate_across_communicator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::replicate_across_communicator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>root_process</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function replicates the state found on the process indicated by <code>root_process</code> across all processes of the MPI communicator. The current state found on any of the processes other than <code>root_process</code> is lost in this process. One can imagine this operation to act like a call to <a class="el" href="namespaceUtilities_1_1MPI.html#a128aed5c46be49d692bbbc3a23424c36">Utilities::MPI::broadcast()</a> from the root process to all other processes, though in practice the function may try to move the data into shared memory regions on each of the machines that host MPI processes and let all MPI processes on this machine then access this shared memory region instead of keeping their own copy.</p>
<p>The intent of this function is to quickly exchange large arrays from one process to others, rather than having to compute or create it on all processes. This is specifically the case for data loaded from disk &ndash; say, large data tables &ndash; that are more easily dealt with by reading once and then distributing across all processes in an MPI universe, than letting each process read the data from disk itself. Specifically, the use of shared memory regions allows for replicating the data only once per multicore machine in the MPI universe, rather than replicating data once for each MPI process. This results in large memory savings if the data is large on today's machines that can easily house several dozen MPI processes per shared memory space. This use case is outlined in the <a class="el" href="classTableBase.html">TableBase</a> class documentation as the current function is called from <a class="el" href="classTableBase.html#a1959c3a73b399248ccda523c66831a01">TableBase::replicate_across_communicator()</a>. Indeed, the primary rationale for this function is to enable sharing data tables based on <a class="el" href="classTableBase.html">TableBase</a> across MPI processes.</p>
<p>This function does not imply a model of keeping data on different processes in sync, as parallel::distributed::Vector and other vector classes do where there exists a notion of certain elements of the vector owned by each process and possibly ghost elements that are mirrored from its owning process to other processes. Rather, the elements of the current object are simply copied to the other processes, and it is useful to think of this operation as creating a set of <code>const</code> <a class="el" href="classAlignedVector.html">AlignedVector</a> objects on all processes that should not be changed any more after the replication operation, as this is the only way to ensure that the vectors remain the same on all processes. This is particularly true because of the use of shared memory regions where any modification of a vector element on one MPI process may also result in a modification of elements visible on other processes, assuming they are located within one shared memory node.</p>
<dl class="section note"><dt>Note</dt><dd>The use of shared memory between MPI processes requires that the detected MPI installation supports the necessary operations. This is the case for MPI 3.0 and higher.</dd>
<dd>
This function is not cheap. It needs to create sub-communicators of the provided <code>communicator</code> object, which is generally an expensive operation. Likewise, the generation of shared memory spaces is not a cheap operation. As a consequence, this function primarily makes sense when the goal is to share large read-only data tables among processes; examples are data tables that are loaded at start-up time and then used over the course of the run time of the program. In such cases, the start-up cost of running this function can be amortized over time, and the potential memory savings from not having to store the table on each process may be substantial on machines with large core counts on which many MPI processes run on the same machine.</dd>
<dd>
This function only makes sense if the data type <code>T</code> is "self-contained", i.e., all if its information is stored in its member variables, and if none of the member variables are pointers to other parts of the memory. This is because if a type <code>T</code> does have pointers to other parts of memory, then moving <code>T</code> into a shared memory space does not result in the other processes having access to data that the object points to with its member variable pointers: These continue to live only on one process, and are typically in memory areas not accessible to the other processes. As a consequence, the usual use case for this function is to share arrays of simple objects such as <code>double</code>s or <code>int</code>s.</dd>
<dd>
After calling this function, objects on different MPI processes share a common state. That means that certain operations become "collective", i.e., they must be called on all participating processors at the same time. In particular, you can no longer call <a class="el" href="classAlignedVector.html#ad5c3bb98b1243d1822179dd63e8d119a">resize()</a>, <a class="el" href="classAlignedVector.html#a3e56ff3ba26e09e033d5054affc32d08">reserve()</a>, or <a class="el" href="classAlignedVector.html#a2beb26ca2ae3921a0dc634bc8c9cdd44">clear()</a> on one MPI process &ndash; you have to do so on all processes at the same time, because they have to communicate for these operations. If you do not do so, you will likely get a deadlock that may be difficult to debug. By extension, this rule of only collectively resizing extends to this function itself: You can not call it twice in a row because that implies that first all but the <code>root_process</code> throw away their data, which is not a collective operation. Generally, these restrictions on what can and can not be done hint at the correctness of the comments above: You should treat an <a class="el" href="classAlignedVector.html">AlignedVector</a> on which the current function has been called as <code>const</code>, on which no further operations can be performed until the destructor is called. </dd></dl>

</div>
</div>
<a id="a679c42669ff9aede60f9fc89a57b732b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679c42669ff9aede60f9fc89a57b732b">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps the given vector with the calling vector. </p>

</div>
</div>
<a id="ab76d46499c3e4eae5c0ff0ebdbddb853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76d46499c3e4eae5c0ff0ebdbddb853">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the vector is empty, i.e., its size is zero. </p>

</div>
</div>
<a id="ac1900b4748c7de0d12858b0a93ee0060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1900b4748c7de0d12858b0a93ee0060">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a> <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the size of the vector. </p>

</div>
</div>
<a id="a862418053c6e253515381451d77818c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862418053c6e253515381451d77818c0">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a> <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the capacity of the vector, i.e., the size this vector can hold without reallocation. Note that <a class="el" href="classAlignedVector.html#a862418053c6e253515381451d77818c0">capacity()</a> &gt;= <a class="el" href="classAlignedVector.html#ac1900b4748c7de0d12858b0a93ee0060">size()</a>. </p>

</div>
</div>
<a id="a172650dad815f1e7b0053567f5782260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172650dad815f1e7b0053567f5782260">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html#a8c4a1ef6d1b3464ab5f66deac35e968a">reference</a> <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read-write access to entry <code>index</code> in the vector. </p>

</div>
</div>
<a id="a5ec7ff2f0ee47fb5df016fad1870fdb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec7ff2f0ee47fb5df016fad1870fdb3">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html#af2db6542d6b9737826e218bbe1cab5b4">const_reference</a> <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read-only access to entry <code>index</code> in the vector. </p>

</div>
</div>
<a id="a60d3ec3ed58e7c10cb66288834220cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d3ec3ed58e7c10cb66288834220cd3">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html#afe658fc9ffde91aa425029dcf809bb4f">pointer</a> <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the underlying data buffer. </p>

</div>
</div>
<a id="afacd3e98e6c0ed2e1afa44cfbb14e2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacd3e98e6c0ed2e1afa44cfbb14e2ee">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html#a9cd95095ee2bf7058874cfa968bf8d47">const_pointer</a> <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const pointer to the underlying data buffer. </p>

</div>
</div>
<a id="a2a928b90e816fe71668a693dd1e50edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a928b90e816fe71668a693dd1e50edf">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html#aff5254e23b73ee1494467758418e8caf">iterator</a> <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a read and write pointer to the beginning of the data array. </p>

</div>
</div>
<a id="a007a479f46a0321254b029315193000a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007a479f46a0321254b029315193000a">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html#aff5254e23b73ee1494467758418e8caf">iterator</a> <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a read and write pointer to the end of the data array. </p>

</div>
</div>
<a id="aa72f9cd8f0d7ca2098b81d070ecf953f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72f9cd8f0d7ca2098b81d070ecf953f">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html#ad3afb726ea74e387e885b049dc035a23">const_iterator</a> <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a read-only pointer to the beginning of the data array. </p>

</div>
</div>
<a id="a2b355e808731cc71dd0a90f07e566275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b355e808731cc71dd0a90f07e566275">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html#ad3afb726ea74e387e885b049dc035a23">const_iterator</a> <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a read-only pointer to the end of the data array. </p>

</div>
</div>
<a id="a0fe56d5aff0ce372d2bddc2a0847ff35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe56d5aff0ce372d2bddc2a0847ff35">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html#ac7f43ccbd5f7be4b004995ee723a4010">size_type</a> <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the memory consumption of the allocated memory in this class. If the underlying type <code>T</code> allocates memory by itself, this memory is not counted. </p>

</div>
</div>
<a id="ae546c280e6238488934b4958bab7cc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae546c280e6238488934b4958bab7cc1b">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="adc55665c8e84f060b973cdbc322c4f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc55665c8e84f060b973cdbc322c4f00">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="a415dee9f9e4d36c245754727ea2a8d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415dee9f9e4d36c245754727ea2a8d3d">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad12008400b484088aa5e775e6d2262ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12008400b484088aa5e775e6d2262ab">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Relational operator == for <a class="el" href="classAlignedVector.html">AlignedVector</a> </p>

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l01812">1812</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<a id="a5194e9bde680a0b5d359cd17fc1de808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5194e9bde680a0b5d359cd17fc1de808">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Relational operator != for <a class="el" href="classAlignedVector.html">AlignedVector</a> </p>

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l01834">1834</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac85363b5dd2b212cd7d91151e76ac1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85363b5dd2b212cd7d91151e76ac1a0">&#9670;&nbsp;</a></span>elements</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T[], std::function&lt;void(T *)&gt; &gt; <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to actual data array. </p>

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00468">468</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<a id="a8bffd0cf33678ed838f989de5e5de9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bffd0cf33678ed838f989de5e5de9e5">&#9670;&nbsp;</a></span>used_elements_end</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::used_elements_end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to one past the last valid value. </p>

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00473">473</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<a id="aacd1539b449c73e545bf79273e594fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd1539b449c73e545bf79273e594fcf">&#9670;&nbsp;</a></span>allocated_elements_end</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::allocated_elements_end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the end of the allocated memory. </p>

<p class="definition">Definition at line <a class="el" href="aligned__vector_8h_source.html#l00478">478</a> of file <a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/base/<a class="el" href="aligned__vector_8h_source.html">aligned_vector.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
