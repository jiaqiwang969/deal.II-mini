<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__simplex.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Simplex support (experimental)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Simplex support (experimental)</div>  </div>
</div><!--header-->
<div class="contents">

<p>This module describes the experimental simplex support in deal.II. deal.II中的Simplex和混合网格仍然是实验性的，也就是正在进行的工作。该库的大部分内容已经被移植到能够操作这种网格上。然而，仍有许多函数需要被概括。通过查看 "test/simplex
"文件夹中的测试，你可以对移植的功能有一个很好的概述。在下文中，我们提供了两个非常基本的例子来入门，并提供一些实现细节。  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Simplex support (experimental):</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__simplex.svg" width="679" height="111"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classScalarLagrangePolynomialPyramid.html">ScalarLagrangePolynomialPyramid&lt; dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQGaussSimplex.html">QGaussSimplex&lt; dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQWitherdenVincentSimplex.html">QWitherdenVincentSimplex&lt; dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PyramidPoly.html">FE_PyramidPoly&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PyramidP.html">FE_PyramidP&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__PyramidDGP.html">FE_PyramidDGP&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__SimplexPoly.html">FE_SimplexPoly&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__SimplexP.html">FE_SimplexP&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__SimplexDGP.html">FE_SimplexDGP&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__WedgePoly.html">FE_WedgePoly&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__WedgeP.html">FE_WedgeP&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFE__WedgeDGP.html">FE_WedgeDGP&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFE.html">MappingFE&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga058cd187cea704428ac1118410cd0fb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__simplex.html#ga058cd187cea704428ac1118410cd0fb8">GridIn&lt; dim, spacedim &gt;::read_vtk</a> (std::istream &amp;in)</td></tr>
<tr class="separator:ga058cd187cea704428ac1118410cd0fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83872db02e04f52ac52d578912f6da5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__simplex.html#ga83872db02e04f52ac52d578912f6da5e">GridIn&lt; dim, spacedim &gt;::read_msh</a> (std::istream &amp;in)</td></tr>
<tr class="separator:ga83872db02e04f52ac52d578912f6da5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a87000a17a31132729c23656ada559b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__simplex.html#ga6a87000a17a31132729c23656ada559b">GridIn&lt; dim, spacedim &gt;::read_msh</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:ga6a87000a17a31132729c23656ada559b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
从其他网格中创建网格</h2></td></tr>
<tr class="memitem:ga88f07aec3ce0611f459d2f692ade0c17"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga88f07aec3ce0611f459d2f692ade0c17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__simplex.html#ga88f07aec3ce0611f459d2f692ade0c17">GridGenerator::subdivided_hyper_rectangle_with_simplices</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;repetitions, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p2, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:ga88f07aec3ce0611f459d2f692ade0c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00002873580ef3b74d81c5ed4250bfbc"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga00002873580ef3b74d81c5ed4250bfbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__simplex.html#ga00002873580ef3b74d81c5ed4250bfbc">GridGenerator::subdivided_hyper_cube_with_simplices</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a> repetitions, const <a class="el" href="classdouble.html">double</a> p1=0.0, const <a class="el" href="classdouble.html">double</a> p2=1.0, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:ga00002873580ef3b74d81c5ed4250bfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module describes the experimental simplex support in deal.II. deal.II中的Simplex和混合网格仍然是实验性的，也就是正在进行的工作。该库的大部分内容已经被移植到能够操作这种网格上。然而，仍有许多函数需要被概括。通过查看 "test/simplex
"文件夹中的测试，你可以对移植的功能有一个很好的概述。在下文中，我们提供了两个非常基本的例子来入门，并提供一些实现细节。 </p>
<h1><a class="anchor" id="simplex_reference_example_simplex"></a>
示例：simplex网格</h1>
<p>下面的代码显示了如何处理单纯x网格。 </p><div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;br&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;i&gt;</span></div><div class="line"><span class="comment"> * This program was contributed by Peter Munch. This work and the required</span></div><div class="line"><span class="comment"> * generalizations of the internal data structures of deal.II form part of the</span></div><div class="line"><span class="comment"> * project &quot;Virtual Materials Design&quot; funded by the Helmholtz Association of</span></div><div class="line"><span class="comment"> * German Research Centres.</span></div><div class="line"><span class="comment"> * &lt;/i&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;a name=&quot;Intro&quot;&gt;&lt;/a&gt;</span></div><div class="line"><span class="comment"> * &lt;h1&gt;Introduction&lt;/h1&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;h3&gt;Motivation&lt;/h3&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Many freely available mesh-generation tools produce meshes that consist of</span></div><div class="line"><span class="comment"> * simplices (triangles in 2D; tetrahedra in 3D). The reason for this is that</span></div><div class="line"><span class="comment"> * generating such kind of meshes for complex geometries is simpler than the</span></div><div class="line"><span class="comment"> * generation of hex-only meshes. This tutorial shows how to work on such kind</span></div><div class="line"><span class="comment"> * of meshes with the experimental simplex features in deal.II. For this</span></div><div class="line"><span class="comment"> * purpose, we solve the Poisson problem from @ref step_3 &quot;step-3&quot; in 2D with a mesh only</span></div><div class="line"><span class="comment"> * consisting of triangles.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;h3&gt;Working on simplex meshes&lt;/h3&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * To be able to work on simplex meshes, one has to select appropriate finite</span></div><div class="line"><span class="comment"> * elements, quadrature rules, and mapping objects. In @ref step_3 &quot;step-3&quot;, we used FE_Q,</span></div><div class="line"><span class="comment"> * QGauss, and (implicitly by not specifying a mapping) MappingQ1. The</span></div><div class="line"><span class="comment"> * equivalent classes for the first two classes in the context of simplices are</span></div><div class="line"><span class="comment"> * FE_SimplexP and QGaussSimplex, which we will utilize here. For mapping</span></div><div class="line"><span class="comment"> * purposes, we use the class MappingFE, which implements an isoparametric</span></div><div class="line"><span class="comment"> * mapping. We initialize it with an FE_SimplexP object so that it can be</span></div><div class="line"><span class="comment"> * applied on simplex meshes.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;h3&gt;Mesh generation&lt;/h3&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * In contrast to @ref step_3 &quot;step-3&quot;, we do not use a function from the GridGenerator</span></div><div class="line"><span class="comment"> * namespace, but rather read an externally generated mesh. For this tutorial,</span></div><div class="line"><span class="comment"> * we have created the mesh (square with width and height of one) with Gmsh with</span></div><div class="line"><span class="comment"> * the following journal file &quot;box_2D_tri.geo&quot;:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @code</span></div><div class="line"><span class="comment"> * Rectangle(1) = {0, 0, 0, 1, 1, 0};</span></div><div class="line"><span class="comment"> * Mesh 2;</span></div><div class="line"><span class="comment"> * Save &quot;box_2D_tri.msh&quot;;</span></div><div class="line"><span class="comment"> * @endcode</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The journal file can be processed by Gmsh generating the actual mesh with the</span></div><div class="line"><span class="comment"> * ending &quot;.geo&quot;:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @code</span></div><div class="line"><span class="comment"> * gmsh box_2D_tri.geo</span></div><div class="line"><span class="comment"> * @endcode</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * We have included in the tutorial folder both the journal file and the mesh</span></div><div class="line"><span class="comment"> * file in the event that one does not have access to Gmsh.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The mesh can be simply read by deal.II with methods provided by the GridIn</span></div><div class="line"><span class="comment"> * class, as shown below.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect3{Include files}</span></div><div class="line"></div><div class="line"><span class="comment">// Include files, as used in @ref step_3 &quot;step-3&quot;:</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Include files that contain appropriate quadrature rules, finite elements,</span></div><div class="line"><span class="comment">// and mapping objects for simplex meshes.</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__simplex__p_8h.html">deal.II/fe/fe_simplex_p.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe_8h.html">deal.II/fe/mapping_fe.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// The following file contains the class GridIn, which allows us to read</span></div><div class="line"><span class="comment">// external meshes.</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="comment">// @sect3{The &lt;code&gt;Step3&lt;/code&gt; class}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// This is the main class of the tutorial. Since it is very similar to the</span></div><div class="line"><span class="comment">// version from @ref step_3 &quot;step-3&quot;, we will only point out and explain the relevant</span></div><div class="line"><span class="comment">// differences that allow to perform simulations on simplex meshes.</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Step3</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step3();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <span class="comment">// Here, we select a mapping object, a finite element, and a quadrature rule</span></div><div class="line">  <span class="comment">// that are compatible with simplex meshes.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMappingFE.html">MappingFE&lt;2&gt;</a>     mapping;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFE__SimplexP.html">FE_SimplexP&lt;2&gt;</a>   fe;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGaussSimplex.html">QGaussSimplex&lt;2&gt;</a> quadrature_formula;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; solution;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect4{Step3::Step3}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// In the constructor, we set the polynomial degree of the finite element and</span></div><div class="line"><span class="comment">// the number of quadrature points. Furthermore, we initialize the MappingFE</span></div><div class="line"><span class="comment">// object with a (linear) FE_SimplexP object so that it can work on simplex</span></div><div class="line"><span class="comment">// meshes.</span></div><div class="line">Step3::Step3()</div><div class="line">  : mapping(<a class="code" href="classFE__SimplexP.html">FE_SimplexP</a>&lt;2&gt;(1))</div><div class="line">  , fe(2)</div><div class="line">  , quadrature_formula(3)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect4{Step3::make_grid}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Read the external mesh file &quot;box_2D_tri.msh&quot; as in @ref step_3 &quot;step-3&quot;.</span></div><div class="line"><span class="keywordtype">void</span> Step3::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;2&gt;</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>).read(<span class="stringliteral">&quot;box_2D_tri.msh&quot;</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect4{Step3::setup_system}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// From here on, nothing has changed. Not even, the</span></div><div class="line"><span class="comment">// cell integrals have been changed depending on whether one operates on</span></div><div class="line"><span class="comment">// hypercube or simplex meshes. This is astonishing and is possible due to the</span></div><div class="line"><span class="comment">// design of the following two classes:</span></div><div class="line"><span class="comment">//  - DoFHandler: this class stores degrees of freedom in a flexible way and</span></div><div class="line"><span class="comment">//    allows simple access to them depending on the element type independent of</span></div><div class="line"><span class="comment">//    the cell type.</span></div><div class="line"><span class="comment">//  - FEValues: this class hides the details of finite element, quadrature rule,</span></div><div class="line"><span class="comment">//    and mapping (even if the implementations are inherently different)</span></div><div class="line"><span class="comment">//    behind a unified interface.</span></div><div class="line"><span class="keywordtype">void</span> Step3::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.copy_from(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.n_dofs());</div><div class="line">  system_rhs.reinit(dof_handler.n_dofs());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect4{Step3::assemble_system}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Nothing has changed here.</span></div><div class="line"><span class="keywordtype">void</span> Step3::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(mapping,</div><div class="line">                        fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.reinit(cell);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> = 0;</div><div class="line">      cell_rhs    = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index : fe_values.quadrature_point_indices())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.dof_indices())</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.dof_indices())</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                (fe_values.shape_grad(i, q_index) * <span class="comment">// grad phi_i(x_q)</span></div><div class="line">                 fe_values.shape_grad(j, q_index) * <span class="comment">// grad phi_j(x_q)</span></div><div class="line">                 fe_values.JxW(q_index));           <span class="comment">// dx</span></div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.dof_indices())</div><div class="line">            cell_rhs(i) += (fe_values.shape_value(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                            1. *                                <span class="comment">// f(x_q)</span></div><div class="line">                            fe_values.JxW(q_index));            <span class="comment">// dx</span></div><div class="line">        }</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.dof_indices())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.dof_indices())</div><div class="line">          system_matrix.add(local_dof_indices[i],</div><div class="line">                            local_dof_indices[j],</div><div class="line">                            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.dof_indices())</div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    mapping, dof_handler, 0, <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;2&gt;</a>(), boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect4{Step3::solve}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Nothing has changed here.</span></div><div class="line"><span class="keywordtype">void</span> Step3::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect4{Step3::output_results}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Nothing has changed here.</span></div><div class="line"><span class="keywordtype">void</span> Step3::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div><div class="line"></div><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">  flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#aa9dd1830c0ff35a2431704c4d45453eb">write_higher_order_cells</a> = <span class="keyword">true</span>;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping, 2);</div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect4{Step3::run}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Nothing has changed here.</span></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step3::run</a>()</div><div class="line">{</div><div class="line">  make_grid();</div><div class="line">  setup_system();</div><div class="line">  assemble_system();</div><div class="line">  solve();</div><div class="line">  output_results();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect3{The &lt;code&gt;main&lt;/code&gt; function}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Nothing has changed here.</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line"></div><div class="line">  Step3 laplace_problem;</div><div class="line">  laplace_problem.run();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * &lt;h1&gt;Results&lt;/h1&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The following figures show the mesh and the result obtained by executing this</span></div><div class="line"><span class="comment"> * program:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;table align=&quot;center&quot; class=&quot;doxtable&quot; style=&quot;width:65%&quot;&gt;</span></div><div class="line"><span class="comment"> *   &lt;tr&gt;</span></div><div class="line"><span class="comment"> *     &lt;td&gt;</span></div><div class="line"><span class="comment"> *         @image html step_3_simplex_0.png</span></div><div class="line"><span class="comment"> *     &lt;/td&gt;</span></div><div class="line"><span class="comment"> *     &lt;td&gt;</span></div><div class="line"><span class="comment"> *         @image html step_3_simplex_1.png</span></div><div class="line"><span class="comment"> *     &lt;/td&gt;</span></div><div class="line"><span class="comment"> *   &lt;/tr&gt;</span></div><div class="line"><span class="comment"> * &lt;/table&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Not surprisingly, the result looks as expected.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;h3&gt;Possibilities for extensions&lt;/h3&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * In this tutorial, we presented how to use the deal.II simplex infrastructure</span></div><div class="line"><span class="comment"> * to solve a simple Poisson problem on a simplex mesh in 2D. In this scope, we</span></div><div class="line"><span class="comment"> * could only present a small section of the capabilities. In the following, we</span></div><div class="line"><span class="comment"> * point out further capabilities briefly.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;h4&gt;3D meshes and codim-1 meshes in 3D&lt;/h4&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * An extension to 3D is quite straightforward. Both FE_SimplexP and</span></div><div class="line"><span class="comment"> * QGaussSimplex are implemented in a dimensional-independent way so that simply</span></div><div class="line"><span class="comment"> * replacing everywhere dim=2 with dim=3 should work out of the box.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Furthermore, embedding of a 2D mesh consisting of triangles in 3D space is</span></div><div class="line"><span class="comment"> * possible.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;h4&gt;Mixed meshes&lt;/h4&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * In @ref step_3 &quot;step-3&quot;, we considered meshes only consisting of quadrilaterals. In this</span></div><div class="line"><span class="comment"> * tutorial, we took a look at the case that the mesh only consists of</span></div><div class="line"><span class="comment"> * triangles. In the general case (also known as mixed mesh), the mesh consists</span></div><div class="line"><span class="comment"> * of both cell types. In 3D, meshes might even consist of more cell types, like</span></div><div class="line"><span class="comment"> * wedges/prisms and pyramids. We consider such meshes in the tutorial</span></div><div class="line"><span class="comment"> * @ref step_3mixed &quot;step-3mixed&quot;.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;h4&gt;Alternative finite elements, quadrature rules, and mapping objects&lt;/h4&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * In this tutorial, we used the most basic finite-element, quadrature-rule, and</span></div><div class="line"><span class="comment"> * mapping classes. However, more classes are compatible with simplices. The</span></div><div class="line"><span class="comment"> * following list gives an overview of these classes:</span></div><div class="line"><span class="comment"> * - finite elements: FE_SimplexP, FE_SimplexDGP, FE_SimplexP_Bubbles</span></div><div class="line"><span class="comment"> * - quadrature rules: QGaussSimplex, QWitherdenVincentSimplex, QDuffy</span></div><div class="line"><span class="comment"> * - mapping objects: MappingFE, MappingFEField</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * It should be also pointed out that FESystems can also handle simplex finite</span></div><div class="line"><span class="comment"> * elements which is crucial to solve vector-valued problems, as needed, e.g.,</span></div><div class="line"><span class="comment"> * to solve elasticity and fluid problems (see also @ref step_17 &quot;step-17&quot;).</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;h4&gt;Alternative mesh generation approaches&lt;/h4&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * In this tutorial, we have created the mesh externally and read it with the</span></div><div class="line"><span class="comment"> * help of GridIn. Since we believe that the main motivation to work on simplex</span></div><div class="line"><span class="comment"> * meshes is that one has a complex geometry that can only be meshed with</span></div><div class="line"><span class="comment"> * an external tool with simplices, deal.II does not have too many functions in</span></div><div class="line"><span class="comment"> * the GridGenerator namespace, targeting simplex meshes. However, we would like</span></div><div class="line"><span class="comment"> * to point out the following functions:</span></div><div class="line"><span class="comment"> *  - GridGenerator::subdivided_hyper_cube_with_simplices() and</span></div><div class="line"><span class="comment"> *    GridGenerator::subdivided_hyper_rectangle_with_simplices(), which fill a</span></div><div class="line"><span class="comment"> *    hypercube and a hyperrectangle domain with simplices</span></div><div class="line"><span class="comment"> *  - GridGenerator::convert_hypercube_to_simplex_mesh(), which converts meshes</span></div><div class="line"><span class="comment"> *    consisting of hypercube cells to simplex meshes by replacing one</span></div><div class="line"><span class="comment"> *    quadrilateral with 4 triangles and one hexahedron with 24 tetrahedrons</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;h4&gt;hp-adaptivity&lt;/h4&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Here, we considered a mesh without refinements and with all cells assigned</span></div><div class="line"><span class="comment"> * the same type of element with the same polynomial degree. However, one is not</span></div><div class="line"><span class="comment"> * restricted to this. For further details on hp-methods, see @ref step_27 &quot;step-27&quot;.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;h4&gt;Parallelization&lt;/h4&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * To parallelize the code, one needs to replace the Triangulation object either</span></div><div class="line"><span class="comment"> * with parallel::shared::Triangulation or</span></div><div class="line"><span class="comment"> * parallel::fullydistributed::Triangulation and make some minor adjustments, as</span></div><div class="line"><span class="comment"> * discussed in @ref step_6 &quot;step-6&quot;.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;h4&gt;Face integrals and discontinuous Galerkin methods&lt;/h4&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The classes FEFaceValues and FEInterfaceValues are also compatible with</span></div><div class="line"><span class="comment"> * simplex meshes.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;h4&gt;Matrix-free operator evaluation&lt;/h4&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * In this tutorial, we showed a matrix-based approach. However, one could also</span></div><div class="line"><span class="comment"> * rewrite the code using MatrixFree, FEEvaluation, and FEFaceEvaluation, which</span></div><div class="line"><span class="comment"> * are also compatible with simplex meshes.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div></div><!-- fragment --><h1><a class="anchor" id="simplex_reference_example_mixed"></a>
示例：混合网格</h1>
<p>下面的代码显示了如何处理混合网格的工作。 </p><div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;br&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;i&gt;</span></div><div class="line"><span class="comment"> * This program was contributed by Peter Munch. This work and the required</span></div><div class="line"><span class="comment"> * generalizations of the internal data structures of deal.II form part of the</span></div><div class="line"><span class="comment"> * project &quot;Virtual Materials Design&quot; funded by the Helmholtz Association of</span></div><div class="line"><span class="comment"> * German Research Centres.</span></div><div class="line"><span class="comment"> * &lt;/i&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;a name=&quot;Intro&quot;&gt;&lt;/a&gt;</span></div><div class="line"><span class="comment"> * &lt;h1&gt;Introduction&lt;/h1&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;h3&gt;Motivation&lt;/h3&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The motivation for using simplex meshes (as done in @ref step_3simplex &quot;step-3simplex&quot;) is</span></div><div class="line"><span class="comment"> * straightforward: many freely available mesh-generation tools are very good in</span></div><div class="line"><span class="comment"> * creating good-quality meshes in such a format, while they struggle with</span></div><div class="line"><span class="comment"> * hex-only meshes. Hex-only meshes, on the other hand, are characterized with</span></div><div class="line"><span class="comment"> * better numerical properties (e.g., less degrees of freedom for the same</span></div><div class="line"><span class="comment"> * degree of accuracy and possibly better performance since the tensor-product</span></div><div class="line"><span class="comment"> * structure can be exploited) and are, as a consequence, the natural choice for</span></div><div class="line"><span class="comment"> * rather simple geometries and for meshes described by a coarse mesh with a few</span></div><div class="line"><span class="comment"> * cells (like a hyperball) and obtained in their final form through iterative</span></div><div class="line"><span class="comment"> * local refinement.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Mixed meshes try to combine the best of both worlds by partitioning the</span></div><div class="line"><span class="comment"> * geometry in parts that can be easily meshed by hypercube cells</span></div><div class="line"><span class="comment"> * (quadrilaterals in 2D, hexahedrons in 3D) and in parts that can not be meshed</span></div><div class="line"><span class="comment"> * easily, requiring simplices (triangles in 2D, tetrahedrons in 3D). Since one</span></div><div class="line"><span class="comment"> * assumes that the region requiring simplices is rather small compared to the</span></div><div class="line"><span class="comment"> * rest of the domain where more efficient and accurate methods can be applied,</span></div><div class="line"><span class="comment"> * one can expect that the overall efficiency is hardly impacted by such an</span></div><div class="line"><span class="comment"> * approach.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * One should note that in 3D, one also needs a transition region between</span></div><div class="line"><span class="comment"> * hypercube and simplex regions. Here, one can use wedges/prisms and/or</span></div><div class="line"><span class="comment"> * pyramids.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;h3&gt;Working with mixed meshes&lt;/h3&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;i&gt;</span></div><div class="line"><span class="comment"> * In the following, we concentrate, for the sake of simplicity, on 2D meshes:</span></div><div class="line"><span class="comment"> * they can only contain triangles and quadrilaterals. However, as detailed in</span></div><div class="line"><span class="comment"> * the outlook, an extension of the presented approach to the 3D case is</span></div><div class="line"><span class="comment"> * straightforward.</span></div><div class="line"><span class="comment"> * &lt;/i&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The complexity of working with mixed meshes in 2D results from the fact</span></div><div class="line"><span class="comment"> * that it contains of two</span></div><div class="line"><span class="comment"> * types of geometrical objects: quadrilaterals and triangles. How to deal with</span></div><div class="line"><span class="comment"> * quadrilaterals, we have discussed in @ref step_3 &quot;step-3&quot;: we selected an appropriate</span></div><div class="line"><span class="comment"> * finite element, quadrature rule and mapping object, e.g., FE_Q, QGauss, and</span></div><div class="line"><span class="comment"> * MappingFE (initialized with FE_Q). For simplex meshes, we selected in</span></div><div class="line"><span class="comment"> * @ref step_3simplex &quot;step-3simplex&quot; FE_SimplexP, QGaussSimplex, and MappingFE (intialized with</span></div><div class="line"><span class="comment"> * FE_SimplexP).</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * For mixed meshes, we need multiple finite elements, quadrature rules, and</span></div><div class="line"><span class="comment"> * mapping objects (one set for triangles and one set for quadrilaterals) in the</span></div><div class="line"><span class="comment"> * same program. To ease the work with the multitude of objects (in particular</span></div><div class="line"><span class="comment"> * in 3D, we need at least four of each), you can collect the objects and group</span></div><div class="line"><span class="comment"> * them together in hp::FECollection, hp::QCollection, and</span></div><div class="line"><span class="comment"> * hp::MappingCollection.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Just like in the context of finite elements, quadrature rules, and mapping</span></div><div class="line"><span class="comment"> * objects, we need multiple FEValues objects: the collection of FEValues is</span></div><div class="line"><span class="comment"> * called hp::FEValues. It returns the FEValues object needed for the current</span></div><div class="line"><span class="comment"> * cell via the method hp::FEValues::get_present_fe_values().</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * For hp::FEValues, to be able to select the right finite element/quadrature</span></div><div class="line"><span class="comment"> * rule/ mapping object set, it queries the active_fe_index of the given cell</span></div><div class="line"><span class="comment"> * during hp::FEValues::reinit(). The indices have to be set - as shown below -</span></div><div class="line"><span class="comment"> * before calling DoFHandler::distribute_dofs() by the user.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;i&gt;</span></div><div class="line"><span class="comment"> * The namespace name of hp::FECollection, hp::QCollection,</span></div><div class="line"><span class="comment"> * hp::MappingCollection, and hp::FEValues indicates that these classes have not</span></div><div class="line"><span class="comment"> * been written for mixed meshes in the first place, but for problems where each</span></div><div class="line"><span class="comment"> * (hypercube) cell could have a different type of finite element assigned - in</span></div><div class="line"><span class="comment"> * the simplest case, all cells have the same element type but different</span></div><div class="line"><span class="comment"> * polynomial degrees p (the reason for the letter &quot;p&quot; in &quot;hp&quot;). An extension of</span></div><div class="line"><span class="comment"> * this infrastructure to work not only on different element types but also on</span></div><div class="line"><span class="comment"> * different geometrical objects was a natural choice. For further details on</span></div><div class="line"><span class="comment"> * hp-methods, see @ref step_27 &quot;step-27&quot;.</span></div><div class="line"><span class="comment"> * &lt;/i&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;h3&gt;Mesh generation&lt;/h3&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Just like in @ref step_3simplex &quot;step-3simplex&quot;, we read an externally generated mesh. For this</span></div><div class="line"><span class="comment"> * tutorial, we have created the mesh (square with width and height of one;</span></div><div class="line"><span class="comment"> * quadrilaterals on the left half and triangles on the right half) with Gmsh</span></div><div class="line"><span class="comment"> * with the following journal file &quot;box_2D_mixed.geo&quot;:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @code</span></div><div class="line"><span class="comment"> * Rectangle(1) = {0.0, 0, 0, 0.5, 1, 0};</span></div><div class="line"><span class="comment"> * Rectangle(2) = {0.5, 0, 0, 0.5, 1, 0};</span></div><div class="line"><span class="comment"> * Recombine Surface{1};</span></div><div class="line"><span class="comment"> * Physical Surface(&quot;All&quot;) = {1, 2};</span></div><div class="line"><span class="comment"> * Mesh 2;</span></div><div class="line"><span class="comment"> * Coherence Mesh;</span></div><div class="line"><span class="comment"> * Save &quot;box_2D_mixed.msh&quot;;</span></div><div class="line"><span class="comment"> * @endcode</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The journal file can be processed by Gmsh generating the actual mesh with the</span></div><div class="line"><span class="comment"> * ending &quot;.msh&quot;:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @code</span></div><div class="line"><span class="comment"> * gmsh box_2D_mixed.geo</span></div><div class="line"><span class="comment"> * @endcode</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * We have included in the tutorial folder both the journal file and the mesh</span></div><div class="line"><span class="comment"> * file in the event that one does not have access to Gmsh.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect3{Include files}</span></div><div class="line"></div><div class="line"><span class="comment">// Include files, as used in @ref step_3 &quot;step-3&quot;:</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Include files, as added in @ref step_3simplex &quot;step-3simplex&quot;:</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__simplex__p_8h.html">deal.II/fe/fe_simplex_p.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe_8h.html">deal.II/fe/mapping_fe.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Include files that we need in this tutorial to be able to deal with</span></div><div class="line"><span class="comment">// collections of finite elements, quadrature rules, mapping objects, and</span></div><div class="line"><span class="comment">// FEValues.</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__collection_8h.html">deal.II/hp/fe_collection.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2fe__values_8h.html">deal.II/hp/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__collection_8h.html">deal.II/hp/mapping_collection.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="q__collection_8h.html">deal.II/hp/q_collection.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="comment">// @sect3{The &lt;code&gt;Step3&lt;/code&gt; class}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// This is the main class of the tutorial. Since it is very similar to the</span></div><div class="line"><span class="comment">// version from @ref step_3 &quot;step-3&quot; and @ref step_3simplex &quot;step-3simplex&quot;, we will only point out and explain</span></div><div class="line"><span class="comment">// the relevant differences that allow to perform simulations on mixed meshes.</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Step3</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Step3();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <span class="comment">// As already explained, we are not working with mapping objects, finite</span></div><div class="line">  <span class="comment">// elements, and quadrature rules directly but with collections of them.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classhp_1_1MappingCollection.html">hp::MappingCollection&lt;2&gt;</a> mapping;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;2&gt;</a>      fe;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;2&gt;</a>       quadrature_formula;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; solution;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect4{Step3::Step3}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// In the constructor of the Step3 class, we fill the collections. Here, we</span></div><div class="line"><span class="comment">// position the objects related to triangles in the first place (index 0) and</span></div><div class="line"><span class="comment">// the ones related to quadrilaterals in the second place (index 1).</span></div><div class="line">Step3::Step3()</div><div class="line">  : mapping(<a class="code" href="classMappingFE.html">MappingFE</a>&lt;2&gt;(<a class="code" href="classFE__SimplexP.html">FE_SimplexP</a>&lt;2&gt;(1)), <a class="code" href="classMappingFE.html">MappingFE</a>&lt;2&gt;(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;2&gt;(1)))</div><div class="line">  , fe(<a class="code" href="classFE__SimplexP.html">FE_SimplexP</a>&lt;2&gt;(2), <a class="code" href="classFE__Q.html">FE_Q</a>&lt;2&gt;(2))</div><div class="line">  , quadrature_formula(<a class="code" href="classQGaussSimplex.html">QGaussSimplex</a>&lt;2&gt;(3), <a class="code" href="classQGauss.html">QGauss</a>&lt;2&gt;(3))</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect4{Step3::make_grid}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Read the external mesh file &quot;box_2D_mixed.msh&quot; as in @ref step_3simplex &quot;step-3simplex&quot;.</span></div><div class="line"><span class="keywordtype">void</span> Step3::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;2&gt;</a>(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>).read(<span class="stringliteral">&quot;box_2D_mixed.msh&quot;</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect4{Step3::setup_system}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// In contrast to @ref step_3 &quot;step-3&quot; and @ref step_3simplex &quot;step-3simplex&quot;, we need here a preprocessing step</span></div><div class="line"><span class="comment">// that assigns an active_fe_index to each cell consistently according to the</span></div><div class="line"><span class="comment">// indices in the collections and the cell type.</span></div><div class="line"><span class="keywordtype">void</span> Step3::setup_system()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;reference_cell() == <a class="code" href="namespaceReferenceCells.html#a3ab331cfe2d03f3c89c0738624a11344">ReferenceCells::Triangle</a>)</div><div class="line">        cell-&gt;set_active_fe_index(0);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;reference_cell() == <a class="code" href="namespaceReferenceCells.html#a14badca7aa0e6d807934973e046a2e2f">ReferenceCells::Quadrilateral</a>)</div><div class="line">        cell-&gt;set_active_fe_index(1);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.copy_from(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.n_dofs());</div><div class="line">  system_rhs.reinit(dof_handler.n_dofs());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect4{Step3::assemble_system}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The following function looks similar to the version in @ref step_3 &quot;step-3&quot; and</span></div><div class="line"><span class="comment">// @ref step_3simplex &quot;step-3simplex&quot; with the following two differences:</span></div><div class="line"><span class="comment">//  - We do not work with FEValues directly but with the collection class</span></div><div class="line"><span class="comment">//    hp::FEValues. It gives us - after it has been initialized with the current</span></div><div class="line"><span class="comment">//    cell - a reference to the right FEValues object (constructed</span></div><div class="line"><span class="comment">//    with the correct mapping object, finite element, and quadrature rule),</span></div><div class="line"><span class="comment">//    which can be used as usual to compute the cell integrals.</span></div><div class="line"><span class="comment">//  - The cell-local stiffness matrix and the right-hand-side vector have</span></div><div class="line"><span class="comment">//    different sizes depending on the cell type (6 DoFs vs. 9 DoFs) so that</span></div><div class="line"><span class="comment">//    they might need to be resized for each cell.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Apart from these two changes, the code has not changed. Not even, the</span></div><div class="line"><span class="comment">// cell integrals have been changed depending on whether one operates on</span></div><div class="line"><span class="comment">// hypercube, simplex, or mixed meshes.</span></div><div class="line"><span class="keywordtype">void</span> Step3::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;2&gt;</a> hp_fe_values(mapping,</div><div class="line">                               fe,</div><div class="line">                               quadrature_formula,</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  Vector&lt;double&gt;                       cell_rhs;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      hp_fe_values.reinit(cell);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = hp_fe_values.get_present_fe_values();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">      cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line">      cell_rhs.reinit(dofs_per_cell);</div><div class="line">      local_dof_indices.resize(dofs_per_cell);</div><div class="line"></div><div class="line">      cell_matrix = 0;</div><div class="line">      cell_rhs    = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index : fe_values.quadrature_point_indices())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.dof_indices())</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.dof_indices())</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                (fe_values.shape_grad(i, q_index) * <span class="comment">// grad phi_i(x_q)</span></div><div class="line">                 fe_values.shape_grad(j, q_index) * <span class="comment">// grad phi_j(x_q)</span></div><div class="line">                 fe_values.JxW(q_index));           <span class="comment">// dx</span></div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.dof_indices())</div><div class="line">            cell_rhs(i) += (fe_values.shape_value(i, q_index) * <span class="comment">// phi_i(x_q)</span></div><div class="line">                            1. *                                <span class="comment">// f(x_q)</span></div><div class="line">                            fe_values.JxW(q_index));            <span class="comment">// dx</span></div><div class="line">        }</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.dof_indices())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.dof_indices())</div><div class="line">          system_matrix.add(local_dof_indices[i],</div><div class="line">                            local_dof_indices[j],</div><div class="line">                            cell_matrix(i, j));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.dof_indices())</div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    mapping, dof_handler, 0, <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;2&gt;</a>(), boundary_values);</div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                     system_matrix,</div><div class="line">                                     solution,</div><div class="line">                                     system_rhs);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect4{Step3::solve}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Nothing has changed here.</span></div><div class="line"><span class="keywordtype">void</span> Step3::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect4{Step3::output_results}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Nothing has changed here.</span></div><div class="line"><span class="keywordtype">void</span> Step3::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div><div class="line"></div><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">  flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#aa9dd1830c0ff35a2431704c4d45453eb">write_higher_order_cells</a> = <span class="keyword">true</span>;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping, 2);</div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect4{Step3::run}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Nothing has changed here.</span></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step3::run</a>()</div><div class="line">{</div><div class="line">  make_grid();</div><div class="line">  setup_system();</div><div class="line">  assemble_system();</div><div class="line">  solve();</div><div class="line">  output_results();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// @sect3{The &lt;code&gt;main&lt;/code&gt; function}</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Nothing has changed here.</span></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line"></div><div class="line">  Step3 laplace_problem;</div><div class="line">  laplace_problem.run();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="simplex_reference_cells"></a>
参考单元</h1>
<p>在二维中，我们提供三角形和四边形，在三维中的可能方向如下。 </p><div class="twocolumn" style="width: 100%"> <div class="parent"> <div class="img" align="center"> <div class="image">
<img src="reference_cells_0.png" alt="reference_cells_0.png"/>
</div>
 </div> <div class="text" align="center"> 2D: triangle and quadrilateral </div> </div> <div class="parent"> <div class="img" align="center"> <div class="image">
<img src="reference_cells_1.png" alt="reference_cells_1.png"/>
</div>
 </div> <div class="text" align="center"> Possible orientations of triangles and quadrilaterals in 3D </div> </div> </div><p> 在三维中，四面体、金字塔、楔形和六面体都可以使用。 </p><div class="parent"> <div class="img" align="center"> <div class="image">
<img src="reference_cells_2.png" alt="reference_cells_2.png"/>
</div>
 </div> <div class="text" align="center"> 3D: Tetrahedron </div> </div>  <div class="parent"> <div class="img" align="center"> <div class="image">
<img src="reference_cells_3.png" alt="reference_cells_3.png"/>
</div>
 </div> <div class="text" align="center"> 3D: Pyramid </div><p> &lt;/div </p><div class="parent"> <div class="img" align="center"> <div class="image">
<img src="reference_cells_4.png" alt="reference_cells_4.png"/>
</div>
 </div> <div class="text" align="center"> 3D: Wedge </div><p> &lt;/div </p><div class="parent"> <div class="img" align="center"> <div class="image">
<img src="reference_cells_5.png" alt="reference_cells_5.png"/>
</div>
 </div> <div class="text" align="center"> 3D: Hexahedron </div> </div> </div><p> 一个三维参考单元的每个表面由二维参考单元组成。枚举其顶点和线的编号的文件在右列给出。 </div><h2 class="groupheader">Function Documentation</h2>
<a id="ga88f07aec3ce0611f459d2f692ade0c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88f07aec3ce0611f459d2f692ade0c17">&#9670;&nbsp;</a></span>subdivided_hyper_rectangle_with_simplices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_rectangle_with_simplices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>repetitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从两个斜对角的角点 <code>p1</code> 和 <code>p2</code>. 创建一个坐标平行的砖块，坐标方向 <code>i</code> 的顶点数量由<code>repetitions[i]+1</code>决定。 </p><dl class="section note"><dt>Note</dt><dd>这个函数在内部将4/8个顶点连接到四边形/六面体单元，并将这些单元细分为2/5个三角形/四面体单元。 </dd>
<dd>
目前，这个函数只对<code>dim==spacedim</code>起作用。 </dd></dl>

</div>
</div>
<a id="ga00002873580ef3b74d81c5ed4250bfbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00002873580ef3b74d81c5ed4250bfbc">&#9670;&nbsp;</a></span>subdivided_hyper_cube_with_simplices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_cube_with_simplices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>repetitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>p1</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>p2</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用一个超立方体（二维的正方形和三维的立方体）初始化给定的三角形，该超立方体在每个方向上由 <code>repetitions</code> 个单元组成。 超立方体的体积是目前维数中的张量乘积区间 \([left,right]^{\text{dim}}\) ，其中极限作为参数给出。它们默认为零和一，然后产生单位超立方体。 </p><dl class="section note"><dt>Note</dt><dd>这个函数在内部将4/8个顶点连接到四边形/六面体单元，并将其细分为2/5个三角形/四面体单元。 </dd></dl>

</div>
</div>
<a id="ga058cd187cea704428ac1118410cd0fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga058cd187cea704428ac1118410cd0fb8">&#9670;&nbsp;</a></span>read_vtk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGridIn.html">GridIn</a>&lt; dim, spacedim &gt;::read_vtk </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从一个非结构化的vtk文件中读取网格数据。vtk文件可能包含以下VTK单元类型。VTK_HEXAHEDRON（12），VTK_TETRA（10），VTK_QUAD（9），VTK_TRIANGLE（5），以及VTK_LINE（3）。 根据模板维度的不同，只接受上述的部分内容。 特别是，在三个维度中，该函数希望文件包含</p>
<ul>
<li>VTK_HEXAHEDRON/VTK_TETRA细胞类型</li>
<li>VTK_QUAD/VTK_TRIANGLE单元类型，以指定可选的边界或内部四边形面</li>
<li>VTK_LINE单元格类型，用于指定可选的边界或内部边缘 在二维方面。</li>
<li>VTK_QUAD/VTK_TRIANGLE单元类型</li>
<li>VTK_LINE单元格类型，用于指定可选的边界或内部边缘 在一个维度上</li>
<li>VTK_LINE单元格类型 输入文件可以使用<a href="http://www.vtk.org/VTK/img/file-formats.pdf">VTK文件格式</a>的CELL_DATA部分指定边界ID、材料ID和流形ID。 该函数解释了输入文件中包含的两种CELL_DATA类型。<code>SCALARS MaterialID</code>，用于指定单元的材料ID，或面和边的边界ID，以及<code>SCALARS ManifoldID</code>，可用于指定任何三角测量对象（单元、面或边）的流形ID。 配套的 <a class="el" href="classGridOut.html#a6b72484c35abc1f84abb8bf1bc1048dc">GridOut::write_vtk</a> 函数可用于编写与此方法兼容的VTK文件。 </li>
</ul>
<p>Processing the CELL_TYPES section//////////////////////// </p>

<p class="definition">Definition at line <a class="el" href="grid__in_8cc_source.html#l00128">128</a> of file <a class="el" href="grid__in_8cc_source.html">grid_in.cc</a>.</p>

</div>
</div>
<a id="ga83872db02e04f52ac52d578912f6da5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83872db02e04f52ac52d578912f6da5e">&#9670;&nbsp;</a></span>read_msh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGridIn.html">GridIn</a>&lt; dim, spacedim &gt;::read_msh </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从msh文件中读取网格数据，可以是该文件格式的第一版或第二版。Gmsh格式的文件在http://www.gmsh.info/。 </p><dl class="section note"><dt>Note</dt><dd>deal.II的输入函数不区分换行和其他空白。因此，deal.II将能够读取比Gmsh略微通用的格式的文件。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__in_8cc_source.html#l01427">1427</a> of file <a class="el" href="grid__in_8cc_source.html">grid_in.cc</a>.</p>

</div>
</div>
<a id="ga6a87000a17a31132729c23656ada559b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a87000a17a31132729c23656ada559b">&#9670;&nbsp;</a></span>read_msh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGridIn.html">GridIn</a>&lt; dim, spacedim &gt;::read_msh </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用Gmsh API读取网格数据。任何由Gmsh支持的文件都可以作为参数传递。格式是由文件名的扩展名推断出来的。 该函数将非命名的物理id（gmsh格式&lt;4.0）解释为材料或边界id（类似于其他read_msh()函数的情况）。如果你想指定非默认的流形或边界ID，你必须将所有需要非默认边界或流形ID的实体分组到命名的物理组中，其中名称是使用应用于 <code>std::map&lt;std::string, int&gt;</code>的函数 <a class="el" href="namespacePatterns_1_1Tools.html#a59da8cbc1fc7db44bebb4fbc9dc4bbe9">Patterns::Tools::to_value()</a> 来解释的。键值可以是<code>MaterialID</code>（如果物理组指的是尺寸为<code>dim</code>的对象），<code>BoundaryID</code>（如果组指的是尺寸&lt;<code>dim</code>的对象），或者<code>ManifoldID</code>。 从Gmsh文档中，物理标签的格式遵循以下惯例。 </p><div class="fragment"><div class="line">$PhysicalNames <span class="comment">// same as MSH version 2</span></div><div class="line">numPhysicalNames(ASCII <span class="keywordtype">int</span>)</div><div class="line">dimension(ASCII <span class="keywordtype">int</span>) physicalTag(ASCII <span class="keywordtype">int</span>) <span class="stringliteral">&quot;name&quot;</span>(127 characters <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">max</a>)</div><div class="line">...</div><div class="line">$EndPhysicalNames</div></div><!-- fragment --><p> 例如，下面是网格文件的片段 </p><div class="fragment"><div class="line">MeshFormat</div><div class="line">4.1 0 8</div><div class="line">$EndMeshFormat</div><div class="line">$PhysicalNames</div><div class="line">4</div><div class="line">1 1 <span class="stringliteral">&quot;ManifoldID:0&quot;</span></div><div class="line">1 2 <span class="stringliteral">&quot;BoundaryID:</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">-1, ManifoldID: 1&quot;</span></div><div class="line">2 3 <span class="stringliteral">&quot;ManifoldID: 1&quot;</span></div><div class="line">2 4 <span class="stringliteral">&quot;MaterialID: 2, ManifoldID: 1&quot;</span></div><div class="line">$EndPhysicalNames</div><div class="line">$Entities</div><div class="line">...</div></div><!-- fragment --><p> 指的是一个二维网格，其中。</p>
<ul>
<li>维度1的部分边界具有物理标签1，流形ID 0</li>
<li>一些内部面（维度为1的线）有流形ID 1</li>
<li>一些元素的流形ID为1（而材料ID等于默认值，即0）。</li>
<li>一些元素的流形id为1，材料id等于2 如果物理组没有命名，那么行为与其他read_msh()函数相同，即物理标签本身被解释为边界或材料id。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="grid__in_8cc_source.html#l02124">2124</a> of file <a class="el" href="grid__in_8cc_source.html">grid_in.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
