<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTriangulation.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Triangulation&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="classTriangulation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Triangulation&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="grid_2tria_8h_source.html">deal.II/grid/tria.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Triangulation&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTriangulation__inherit__graph.svg" width="1612" height="524"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTriangulation_1_1CellWeightSum.html">CellWeightSum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTriangulation_1_1Signals.html">Signals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0633dd17e535a59162b79f338c6ff5ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> { <br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9828da1d84133b33b112afd4a0ac15ec">none</a> = 0x0, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">limit_level_difference_at_vertices</a> = 0x1, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a> = 0x2, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea37c283b96070dc09dde81f51d3ce1812">patch_level_1</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae94a75f4383724ef8f58639aef2eb6c0">coarsest_level_1</a> = 0x8, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa44d17458e16327fb4b674745b883910">allow_anisotropic_smoothing</a> = 0x10, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a> = 0x100, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58">eliminate_refined_boundary_islands</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea75171630dec90d241c811d2732410303">do_not_produce_unrefined_islands</a> = 0x400, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea3fb6b9153821aefc45661f67f22e232a">smoothing_on_refinement</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea8d8dbaaa62136a7e51c7bf5c02d6e1e7">smoothing_on_coarsening</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf64b535fd0fad99b6032412d2cccac36">maximum_smoothing</a> = 0xffff ^ allow_anisotropic_smoothing
<br />
 }</td></tr>
<tr class="separator:a0633dd17e535a59162b79f338c6ff5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga997d61ac77777cdc2be3ae934b1f7cdb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga997d61ac77777cdc2be3ae934b1f7cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12cedb5139eeea73fb2a3eec16636f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad12cedb5139eeea73fb2a3eec16636f8">level_cell_iterator</a> = <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a></td></tr>
<tr class="separator:ad12cedb5139eeea73fb2a3eec16636f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c836c1e503743e8073eb615603aab9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga08c836c1e503743e8073eb615603aab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4015f9d1dc9115fbdf74d74960bec074"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga4015f9d1dc9115fbdf74d74960bec074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad77aace3a5c6c96b985cbf22a28c83f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:gad77aace3a5c6c96b985cbf22a28c83f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23052ad0b446137324ccf9ea0fd386e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:gac23052ad0b446137324ccf9ea0fd386e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8738294ebb9d165e6b431589b0bbc7f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga8738294ebb9d165e6b431589b0bbc7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga863d37379dceb11324e72a44039ac495"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> = typename IteratorSelector::line_iterator</td></tr>
<tr class="separator:ga863d37379dceb11324e72a44039ac495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfba44e3df01252843f37ee1f8e6df58"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a> = typename IteratorSelector::active_line_iterator</td></tr>
<tr class="separator:gabfba44e3df01252843f37ee1f8e6df58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga672c99b1c8da16227cae6f0cf66cc109"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> = typename IteratorSelector::quad_iterator</td></tr>
<tr class="separator:ga672c99b1c8da16227cae6f0cf66cc109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b331baff3d6bfb841950b10845fc5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a> = typename IteratorSelector::active_quad_iterator</td></tr>
<tr class="separator:ga31b331baff3d6bfb841950b10845fc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0500bbdefc5ea6a1306892b933896875"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> = typename IteratorSelector::hex_iterator</td></tr>
<tr class="separator:ga0500bbdefc5ea6a1306892b933896875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fed0f1753adab5eb220b1bec03ae571"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a> = typename IteratorSelector::active_hex_iterator</td></tr>
<tr class="separator:ga4fed0f1753adab5eb220b1bec03ae571"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a67f431ce66c6df985caf5587bf329ebc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a67f431ce66c6df985caf5587bf329ebc">Triangulation</a> (const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> <a class="el" href="group__Exceptions.html#gac9474a14d0e8429412c82450013bde67">smooth_grid</a>=<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9828da1d84133b33b112afd4a0ac15ec">none</a>, const <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html#a5c55287cc4c709190b521fd98a4f5e02">check_for_distorted_cells</a>=false)</td></tr>
<tr class="separator:a67f431ce66c6df985caf5587bf329ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc766f8def6774029a22aa635270ebce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afc766f8def6774029a22aa635270ebce">Triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;)=delete</td></tr>
<tr class="separator:afc766f8def6774029a22aa635270ebce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ac8a261c841e50cddfff066c28498b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af7ac8a261c841e50cddfff066c28498b">Triangulation</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&amp;tria) noexcept</td></tr>
<tr class="separator:af7ac8a261c841e50cddfff066c28498b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518a862e7c4547dfb860f3cba47f534b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html">Triangulation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a518a862e7c4547dfb860f3cba47f534b">operator=</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&amp;tria) noexcept</td></tr>
<tr class="separator:a518a862e7c4547dfb860f3cba47f534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9931013dff6e9094c5b525359b6e1c5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad9931013dff6e9094c5b525359b6e1c5">~Triangulation</a> () override</td></tr>
<tr class="separator:ad9931013dff6e9094c5b525359b6e1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d54b7dae635d867bf8d2c4b3605817"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12d54b7dae635d867bf8d2c4b3605817">clear</a> ()</td></tr>
<tr class="separator:a12d54b7dae635d867bf8d2c4b3605817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1005ad6002b51c5bc4592da7246b6a49"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1005ad6002b51c5bc4592da7246b6a49">get_communicator</a> () const</td></tr>
<tr class="separator:a1005ad6002b51c5bc4592da7246b6a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a302f66ccc9bd281cf850fdc4f76e50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4a302f66ccc9bd281cf850fdc4f76e50">set_mesh_smoothing</a> (const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> mesh_smoothing)</td></tr>
<tr class="separator:a4a302f66ccc9bd281cf850fdc4f76e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df95bfd43216e389a132786f87474f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a06df95bfd43216e389a132786f87474f">get_mesh_smoothing</a> () const</td></tr>
<tr class="separator:a06df95bfd43216e389a132786f87474f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number, const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;manifold_object)</td></tr>
<tr class="separator:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644a2152b8f5a6902afdc503d163d950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga644a2152b8f5a6902afdc503d163d950">reset_manifold</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> manifold_number)</td></tr>
<tr class="separator:ga644a2152b8f5a6902afdc503d163d950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a> ()</td></tr>
<tr class="separator:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2acfbef517fd03855c4b371f3e182f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number)</td></tr>
<tr class="separator:gae2acfbef517fd03855c4b371f3e182f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number)</td></tr>
<tr class="separator:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa4e0af28512cb5f9cc8cb3b95a38c669">set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id, const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number)</td></tr>
<tr class="separator:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d4bed3d2ac6148e969a331bde49f63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa5d4bed3d2ac6148e969a331bde49f63">get_manifold</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number) const</td></tr>
<tr class="separator:gaa5d4bed3d2ac6148e969a331bde49f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05662a55166596efb520479b495275f8"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a05662a55166596efb520479b495275f8">get_boundary_ids</a> () const</td></tr>
<tr class="separator:a05662a55166596efb520479b495275f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee729ae049af6f1495d0059d6086e52"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga0ee729ae049af6f1495d0059d6086e52">get_manifold_ids</a> () const</td></tr>
<tr class="separator:ga0ee729ae049af6f1495d0059d6086e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bca327fa47f88b58086dacc20028064"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1bca327fa47f88b58086dacc20028064">copy_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;other_tria)</td></tr>
<tr class="separator:a1bca327fa47f88b58086dacc20028064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b191fa3249c9c3641492b6eedebf456"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">create_triangulation</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="classTriangulation.html#a51469854babb27752dc9f26ed9d5ee30">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:a1b191fa3249c9c3641492b6eedebf456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80c37d5d647831736e40e4ffb0e0ee2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa80c37d5d647831736e40e4ffb0e0ee2">create_triangulation</a> (const <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>&lt; dim, spacedim &gt; &amp;construction_data)</td></tr>
<tr class="separator:aa80c37d5d647831736e40e4ffb0e0ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbee6e665998c3e4a745cd7836df364"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abbbee6e665998c3e4a745cd7836df364">create_triangulation_compatibility</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="classTriangulation.html#a51469854babb27752dc9f26ed9d5ee30">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:abbbee6e665998c3e4a745cd7836df364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc34248a9ba0c38fd0020256a8def5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afdc34248a9ba0c38fd0020256a8def5c">flip_all_direction_flags</a> ()</td></tr>
<tr class="separator:afdc34248a9ba0c38fd0020256a8def5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mesh refinement</div></td></tr>
<tr class="memitem:aed8e461d4b2b23a0e1730afdef36e694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aed8e461d4b2b23a0e1730afdef36e694">set_all_refine_flags</a> ()</td></tr>
<tr class="separator:aed8e461d4b2b23a0e1730afdef36e694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad0b3fb24aae17f4668427a433dea19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (const unsigned <a class="el" href="classint.html">int</a> times=1)</td></tr>
<tr class="separator:a6ad0b3fb24aae17f4668427a433dea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6552fa04ee753657bd9f92571d76cf09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6552fa04ee753657bd9f92571d76cf09">coarsen_global</a> (const unsigned <a class="el" href="classint.html">int</a> times=1)</td></tr>
<tr class="separator:a6552fa04ee753657bd9f92571d76cf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedd900205c1879d8d9ef6ffe7d1a554"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:aaedd900205c1879d8d9ef6ffe7d1a554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf55199c30b0330cf9bf98e2582078e1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">prepare_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:abf55199c30b0330cf9bf98e2582078e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">History of a triangulation</div></td></tr>
<tr class="memitem:aca5cfa9068a5d3ad32dfca87e2901a87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aca5cfa9068a5d3ad32dfca87e2901a87">save_refine_flags</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:aca5cfa9068a5d3ad32dfca87e2901a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affce5fca29acccbb2dc1294ebe404a03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#affce5fca29acccbb2dc1294ebe404a03">save_refine_flags</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:affce5fca29acccbb2dc1294ebe404a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fc07c3f9e1f02658ca556f41087c85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a43fc07c3f9e1f02658ca556f41087c85">load_refine_flags</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a43fc07c3f9e1f02658ca556f41087c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac924a05e66d5e76458ad088a2b7b5583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac924a05e66d5e76458ad088a2b7b5583">load_refine_flags</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:ac924a05e66d5e76458ad088a2b7b5583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64b6155fd89f8f29d4c02795c1a10d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af64b6155fd89f8f29d4c02795c1a10d9">save_coarsen_flags</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:af64b6155fd89f8f29d4c02795c1a10d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaecbe89311fdaa8a9b999209ff9155"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abaaecbe89311fdaa8a9b999209ff9155">save_coarsen_flags</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:abaaecbe89311fdaa8a9b999209ff9155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4029122ffe741f843f2f3a7deeceea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa4029122ffe741f843f2f3a7deeceea9">load_coarsen_flags</a> (std::istream &amp;out)</td></tr>
<tr class="separator:aa4029122ffe741f843f2f3a7deeceea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a9463dcf9aeb3a69831e5e1a321053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a48a9463dcf9aeb3a69831e5e1a321053">load_coarsen_flags</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a48a9463dcf9aeb3a69831e5e1a321053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178e9ce017916f190ddf7a734ef15902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a178e9ce017916f190ddf7a734ef15902">get_anisotropic_refinement_flag</a> () const</td></tr>
<tr class="separator:a178e9ce017916f190ddf7a734ef15902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">User data</div></td></tr>
<tr class="memitem:aaa726b33b52f694cfca48fae8e761661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaa726b33b52f694cfca48fae8e761661">clear_user_flags</a> ()</td></tr>
<tr class="separator:aaa726b33b52f694cfca48fae8e761661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9971ee882f15fe521afc4e079383b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6a9971ee882f15fe521afc4e079383b5">save_user_flags</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a6a9971ee882f15fe521afc4e079383b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad25280beb6c2607418a0d3e903819a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aad25280beb6c2607418a0d3e903819a3">save_user_flags</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:aad25280beb6c2607418a0d3e903819a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3612ed3c7f7f9cccd3003d85b6f7350"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af3612ed3c7f7f9cccd3003d85b6f7350">load_user_flags</a> (std::istream &amp;in)</td></tr>
<tr class="separator:af3612ed3c7f7f9cccd3003d85b6f7350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17946286639b12a03804ebc400eab51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac17946286639b12a03804ebc400eab51">load_user_flags</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:ac17946286639b12a03804ebc400eab51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8896f8e838dd34ed5b7c1aa351f76f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af8896f8e838dd34ed5b7c1aa351f76f5">clear_user_flags_line</a> ()</td></tr>
<tr class="separator:af8896f8e838dd34ed5b7c1aa351f76f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7d8e059d6f8f903879eea858215fb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2b7d8e059d6f8f903879eea858215fb8">save_user_flags_line</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a2b7d8e059d6f8f903879eea858215fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02adea7b298cd5047ee5a5755f87ae36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a02adea7b298cd5047ee5a5755f87ae36">save_user_flags_line</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a02adea7b298cd5047ee5a5755f87ae36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25190c31d16cde2a01fa0f2318aa0b74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a25190c31d16cde2a01fa0f2318aa0b74">load_user_flags_line</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a25190c31d16cde2a01fa0f2318aa0b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87294511c2f203a57531aaaf2bd2ce39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a87294511c2f203a57531aaaf2bd2ce39">load_user_flags_line</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a87294511c2f203a57531aaaf2bd2ce39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd263157214206ceb637c402552f0eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1dd263157214206ceb637c402552f0eb">clear_user_flags_quad</a> ()</td></tr>
<tr class="separator:a1dd263157214206ceb637c402552f0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4a2db0492d38971366bfcd159cbbc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#acf4a2db0492d38971366bfcd159cbbc1">save_user_flags_quad</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:acf4a2db0492d38971366bfcd159cbbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431026974872f49e59f6a799ee0a19d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a431026974872f49e59f6a799ee0a19d6">save_user_flags_quad</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a431026974872f49e59f6a799ee0a19d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e868cde85c04bcc8cec82ba09f24e7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5e868cde85c04bcc8cec82ba09f24e7b">load_user_flags_quad</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a5e868cde85c04bcc8cec82ba09f24e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8651e0def48d61e3f8f0aa8051ae5985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8651e0def48d61e3f8f0aa8051ae5985">load_user_flags_quad</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a8651e0def48d61e3f8f0aa8051ae5985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbe198bb49c3135378bb680582afd46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7cbe198bb49c3135378bb680582afd46">clear_user_flags_hex</a> ()</td></tr>
<tr class="separator:a7cbe198bb49c3135378bb680582afd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5512376f914359303ce7d4666d550b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1d5512376f914359303ce7d4666d550b">save_user_flags_hex</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a1d5512376f914359303ce7d4666d550b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57c92493d66995cf29bef79f0e8e09b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae57c92493d66995cf29bef79f0e8e09b">save_user_flags_hex</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:ae57c92493d66995cf29bef79f0e8e09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e15f4d848adbe6c8bf1af374e467a31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6e15f4d848adbe6c8bf1af374e467a31">load_user_flags_hex</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a6e15f4d848adbe6c8bf1af374e467a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e827086d26927d08129c8489fdcd45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a77e827086d26927d08129c8489fdcd45">load_user_flags_hex</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a77e827086d26927d08129c8489fdcd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26562806fd764afdffb973dce92554e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">clear_user_data</a> ()</td></tr>
<tr class="separator:a26562806fd764afdffb973dce92554e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3794cd2d7f80bd81f69fcb828535412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae3794cd2d7f80bd81f69fcb828535412">save_user_indices</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const</td></tr>
<tr class="separator:ae3794cd2d7f80bd81f69fcb828535412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a2359968a027a8b14ae381c8886d30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12a2359968a027a8b14ae381c8886d30">load_user_indices</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:a12a2359968a027a8b14ae381c8886d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a41f6c10b5db7d540a9df15742ebf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a03a41f6c10b5db7d540a9df15742ebf0">save_user_pointers</a> (std::vector&lt; void *&gt; &amp;v) const</td></tr>
<tr class="separator:a03a41f6c10b5db7d540a9df15742ebf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8891e8277a047b9dd4fe86943d1321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2f8891e8277a047b9dd4fe86943d1321">load_user_pointers</a> (const std::vector&lt; void *&gt; &amp;v)</td></tr>
<tr class="separator:a2f8891e8277a047b9dd4fe86943d1321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451b2af8e62783f4780552088fd9ad88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a451b2af8e62783f4780552088fd9ad88">save_user_indices_line</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a451b2af8e62783f4780552088fd9ad88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2160dd04545294d138ca00deb4af42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7b2160dd04545294d138ca00deb4af42">load_user_indices_line</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:a7b2160dd04545294d138ca00deb4af42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d65cc99c33ea13361700a58ff9d6686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8d65cc99c33ea13361700a58ff9d6686">save_user_indices_quad</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a8d65cc99c33ea13361700a58ff9d6686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1020c09b32fbb78156b00b833271e21d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1020c09b32fbb78156b00b833271e21d">load_user_indices_quad</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:a1020c09b32fbb78156b00b833271e21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a18d1c25ca9c0b7cef07c6e92fdd28f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8a18d1c25ca9c0b7cef07c6e92fdd28f">save_user_indices_hex</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a8a18d1c25ca9c0b7cef07c6e92fdd28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad8869b9c8234d6c81c24c69dd97d39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abad8869b9c8234d6c81c24c69dd97d39">load_user_indices_hex</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:abad8869b9c8234d6c81c24c69dd97d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699d7c1b73eccc41bc53009003ab3d28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a699d7c1b73eccc41bc53009003ab3d28">save_user_pointers_line</a> (std::vector&lt; void *&gt; &amp;v) const</td></tr>
<tr class="separator:a699d7c1b73eccc41bc53009003ab3d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879d77427982a2d69d2dd9512d4ba6c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a879d77427982a2d69d2dd9512d4ba6c9">load_user_pointers_line</a> (const std::vector&lt; void *&gt; &amp;v)</td></tr>
<tr class="separator:a879d77427982a2d69d2dd9512d4ba6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d27b23e1d873b38817d08b7bb6884f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7d27b23e1d873b38817d08b7bb6884f8">save_user_pointers_quad</a> (std::vector&lt; void *&gt; &amp;v) const</td></tr>
<tr class="separator:a7d27b23e1d873b38817d08b7bb6884f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f771811ec221a4ca0c49f3a09164fec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4f771811ec221a4ca0c49f3a09164fec">load_user_pointers_quad</a> (const std::vector&lt; void *&gt; &amp;v)</td></tr>
<tr class="separator:a4f771811ec221a4ca0c49f3a09164fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42ad416119dff0589b8b67dd3de02e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac42ad416119dff0589b8b67dd3de02e8">save_user_pointers_hex</a> (std::vector&lt; void *&gt; &amp;v) const</td></tr>
<tr class="separator:ac42ad416119dff0589b8b67dd3de02e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dad0c49d2423e8c4410efcc773ad82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a03dad0c49d2423e8c4410efcc773ad82">load_user_pointers_hex</a> (const std::vector&lt; void *&gt; &amp;v)</td></tr>
<tr class="separator:a03dad0c49d2423e8c4410efcc773ad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell iterator functions</div></td></tr>
<tr class="memitem:a36fb6b15f119483143c433dd10df9b26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a36fb6b15f119483143c433dd10df9b26">begin</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:a36fb6b15f119483143c433dd10df9b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6c58805fe436a94b141c1585606c7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afe6c58805fe436a94b141c1585606c7f">begin_active</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:afe6c58805fe436a94b141c1585606c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c41c89a9cf1e020050985822196dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end</a> () const</td></tr>
<tr class="separator:a92c41c89a9cf1e020050985822196dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9597b118c84fce0addf7f4db3b067659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9597b118c84fce0addf7f4db3b067659">end</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a9597b118c84fce0addf7f4db3b067659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0967cc6653ea9a08e94fe9da4d11793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab0967cc6653ea9a08e94fe9da4d11793">end_active</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:ab0967cc6653ea9a08e94fe9da4d11793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51f6fbd9bcd9e41757039a7b4954d2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab51f6fbd9bcd9e41757039a7b4954d2a">last</a> () const</td></tr>
<tr class="separator:ab51f6fbd9bcd9e41757039a7b4954d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb00096abe5ef91413440e1e1b66c00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2eb00096abe5ef91413440e1e1b66c00">last_active</a> () const</td></tr>
<tr class="separator:a2eb00096abe5ef91413440e1e1b66c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367c0bd718b0ae9316f3b6f52d0ff4c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a367c0bd718b0ae9316f3b6f52d0ff4c6">create_cell_iterator</a> (const <a class="el" href="classCellId.html">CellId</a> &amp;cell_id) const</td></tr>
<tr class="separator:a367c0bd718b0ae9316f3b6f52d0ff4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell iterator functions returning ranges of iterators</div></td></tr>
<tr class="memitem:gae2dc0cda6c74461c0bbc22a41b5525c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gae2dc0cda6c74461c0bbc22a41b5525c4">cell_iterators</a> () const</td></tr>
<tr class="separator:gae2dc0cda6c74461c0bbc22a41b5525c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23e860c5192f6501650dda8bb3e2b497"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga23e860c5192f6501650dda8bb3e2b497">active_cell_iterators</a> () const</td></tr>
<tr class="separator:ga23e860c5192f6501650dda8bb3e2b497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae69f18aa4845bfe513fd51a39755b9d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gae69f18aa4845bfe513fd51a39755b9d6">cell_iterators_on_level</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:gae69f18aa4845bfe513fd51a39755b9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad45356a49aeb1130d244abb313afdc24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gad45356a49aeb1130d244abb313afdc24">active_cell_iterators_on_level</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:gad45356a49aeb1130d244abb313afdc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Face iterator functions</div></td></tr>
<tr class="memitem:abd8e77917e8512bd1e70bf180929f407"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abd8e77917e8512bd1e70bf180929f407">begin_face</a> () const</td></tr>
<tr class="separator:abd8e77917e8512bd1e70bf180929f407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e8d4115aad4a2a5c97a7f7c06d34d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af7e8d4115aad4a2a5c97a7f7c06d34d5">begin_active_face</a> () const</td></tr>
<tr class="separator:af7e8d4115aad4a2a5c97a7f7c06d34d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359dfdc82f2269b68b1d30c8a2286c6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a359dfdc82f2269b68b1d30c8a2286c6f">end_face</a> () const</td></tr>
<tr class="separator:a359dfdc82f2269b68b1d30c8a2286c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c4ae1d1e8d3e7d179fdd6bcbbae7d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga95c4ae1d1e8d3e7d179fdd6bcbbae7d6">active_face_iterators</a> () const</td></tr>
<tr class="separator:ga95c4ae1d1e8d3e7d179fdd6bcbbae7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vertex iterator functions</div></td></tr>
<tr class="memitem:aa76498325599ace7304627cb64e5fcd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa76498325599ace7304627cb64e5fcd2">begin_vertex</a> () const</td></tr>
<tr class="separator:aa76498325599ace7304627cb64e5fcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8705fe160c08af9a2372c605525ef0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0e8705fe160c08af9a2372c605525ef0">begin_active_vertex</a> () const</td></tr>
<tr class="separator:a0e8705fe160c08af9a2372c605525ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad93f466afba9b3f003d09a685a615f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaad93f466afba9b3f003d09a685a615f">end_vertex</a> () const</td></tr>
<tr class="separator:aaad93f466afba9b3f003d09a685a615f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information about the triangulation</div></td></tr>
<tr class="memitem:a46edbe1027405ca9545e3c2289eb3938"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines</a> () const</td></tr>
<tr class="separator:a46edbe1027405ca9545e3c2289eb3938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5ba9d51dfdd307da590e31c9262c28"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aee5ba9d51dfdd307da590e31c9262c28">n_lines</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:aee5ba9d51dfdd307da590e31c9262c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c9d6f7b2068f5afa429020086b6b8c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines</a> () const</td></tr>
<tr class="separator:a76c9d6f7b2068f5afa429020086b6b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d30203bdeaa3b9e2b416f24b7e9d6d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a21d30203bdeaa3b9e2b416f24b7e9d6d">n_active_lines</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a21d30203bdeaa3b9e2b416f24b7e9d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105d0305d8c801076bea2404087f29a7"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a105d0305d8c801076bea2404087f29a7">n_quads</a> () const</td></tr>
<tr class="separator:a105d0305d8c801076bea2404087f29a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0817fceed7429359f89928eec87d381"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af0817fceed7429359f89928eec87d381">n_quads</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:af0817fceed7429359f89928eec87d381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a0837c6dabdda21930bf3d49e9852d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab7a0837c6dabdda21930bf3d49e9852d">n_active_quads</a> () const</td></tr>
<tr class="separator:ab7a0837c6dabdda21930bf3d49e9852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf97ad6187b553b2980043dd1c8d75db"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abf97ad6187b553b2980043dd1c8d75db">n_active_quads</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:abf97ad6187b553b2980043dd1c8d75db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa75fe811e9d1707ce798f874aa2e117"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaa75fe811e9d1707ce798f874aa2e117">n_hexs</a> () const</td></tr>
<tr class="separator:aaa75fe811e9d1707ce798f874aa2e117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015bc7a2fecb2cba52050a8f2bfbafe1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a015bc7a2fecb2cba52050a8f2bfbafe1">n_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a015bc7a2fecb2cba52050a8f2bfbafe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee621a8e59e259c252ccc64f19e37301"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aee621a8e59e259c252ccc64f19e37301">n_active_hexs</a> () const</td></tr>
<tr class="separator:aee621a8e59e259c252ccc64f19e37301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8bbb4c8ffd9f8adb683b39a82a9b1e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ade8bbb4c8ffd9f8adb683b39a82a9b1e">n_active_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:ade8bbb4c8ffd9f8adb683b39a82a9b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea687f123f3f5a8b09d7485cf03be72"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a> () const</td></tr>
<tr class="separator:abea687f123f3f5a8b09d7485cf03be72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c5623c62d2e43aa63f1eb4904eeec8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a40c5623c62d2e43aa63f1eb4904eeec8">n_cells</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a40c5623c62d2e43aa63f1eb4904eeec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea5c9957dbb566a562bbe2c0f3971e9"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a> () const</td></tr>
<tr class="separator:a5ea5c9957dbb566a562bbe2c0f3971e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05502400e5b4bdd3bb7e0fd410fdf0fb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a05502400e5b4bdd3bb7e0fd410fdf0fb">n_global_active_cells</a> () const</td></tr>
<tr class="separator:a05502400e5b4bdd3bb7e0fd410fdf0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d106ed8c9a29d6bb7d2bfb636f8df62"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3d106ed8c9a29d6bb7d2bfb636f8df62">n_active_cells</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a3d106ed8c9a29d6bb7d2bfb636f8df62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bff048d1ed54471bbd2dcfc76a46523"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1bff048d1ed54471bbd2dcfc76a46523">n_global_coarse_cells</a> () const</td></tr>
<tr class="separator:a1bff048d1ed54471bbd2dcfc76a46523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e297d311818e3a79bcede5804f51065"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1e297d311818e3a79bcede5804f51065">n_faces</a> () const</td></tr>
<tr class="separator:a1e297d311818e3a79bcede5804f51065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae907d55b3b12c5c75e58174c1781ff"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5ae907d55b3b12c5c75e58174c1781ff">n_active_faces</a> () const</td></tr>
<tr class="separator:a5ae907d55b3b12c5c75e58174c1781ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777f035a17e91a4d822971516ca11db5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a> () const</td></tr>
<tr class="separator:a777f035a17e91a4d822971516ca11db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd960d483675c4eb2c538529350e56b"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a> () const</td></tr>
<tr class="separator:aafd960d483675c4eb2c538529350e56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935cc3b953d71fe4081fa8f88820f034"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a935cc3b953d71fe4081fa8f88820f034">has_hanging_nodes</a> () const</td></tr>
<tr class="separator:a935cc3b953d71fe4081fa8f88820f034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aadc2300ef9a6f2368fe7bc5926fe8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a> () const</td></tr>
<tr class="separator:ae1aadc2300ef9a6f2368fe7bc5926fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3059d54432e0d739534e5330bb7b3a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">get_vertices</a> () const</td></tr>
<tr class="separator:afb3059d54432e0d739534e5330bb7b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76937acd9dfc3ade1fb885c7ab1ae776"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">n_used_vertices</a> () const</td></tr>
<tr class="separator:a76937acd9dfc3ade1fb885c7ab1ae776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2295fdb4bfc8ab41f51cdbc34de449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aab2295fdb4bfc8ab41f51cdbc34de449">vertex_used</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:aab2295fdb4bfc8ab41f51cdbc34de449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07690a619d2817f4c8ef3bb74c43b80a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a07690a619d2817f4c8ef3bb74c43b80a">get_used_vertices</a> () const</td></tr>
<tr class="separator:a07690a619d2817f4c8ef3bb74c43b80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6313a19a8cc20e07249978218b5ca6a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa6313a19a8cc20e07249978218b5ca6a">max_adjacent_cells</a> () const</td></tr>
<tr class="separator:aa6313a19a8cc20e07249978218b5ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5827cdfafd5fef99803cde97b70e86bc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5827cdfafd5fef99803cde97b70e86bc">locally_owned_subdomain</a> () const</td></tr>
<tr class="separator:a5827cdfafd5fef99803cde97b70e86bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcac8668993d582f192d3c85b642dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#acbcac8668993d582f192d3c85b642dd3">get_triangulation</a> ()</td></tr>
<tr class="separator:acbcac8668993d582f192d3c85b642dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae427477f592d34c1bf3367e408f90c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aae427477f592d34c1bf3367e408f90c3">get_triangulation</a> () const</td></tr>
<tr class="separator:aae427477f592d34c1bf3367e408f90c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Internal information about the number of objects</div></td></tr>
<tr class="memitem:a4a466c6b1755b353d43ce8827b1518e3"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4a466c6b1755b353d43ce8827b1518e3">n_raw_lines</a> () const</td></tr>
<tr class="separator:a4a466c6b1755b353d43ce8827b1518e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615e8e8877a420fede76cea831f6ca52"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a615e8e8877a420fede76cea831f6ca52">n_raw_lines</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a615e8e8877a420fede76cea831f6ca52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcdcdaea38195ba043370ddc6202224"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abbcdcdaea38195ba043370ddc6202224">n_raw_quads</a> () const</td></tr>
<tr class="separator:abbcdcdaea38195ba043370ddc6202224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f590c6799cf3bb79c3c810f972a117e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9f590c6799cf3bb79c3c810f972a117e">n_raw_quads</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a9f590c6799cf3bb79c3c810f972a117e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5a359c972a4679b5ff1be96b68efc1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aed5a359c972a4679b5ff1be96b68efc1">n_raw_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:aed5a359c972a4679b5ff1be96b68efc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c26f9d04c1b4a4fb190334ebd1542"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a947c26f9d04c1b4a4fb190334ebd1542">n_raw_cells</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a947c26f9d04c1b4a4fb190334ebd1542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7926c72a24cc478de8217c1f6988e0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5a7926c72a24cc478de8217c1f6988e0">n_raw_faces</a> () const</td></tr>
<tr class="separator:a5a7926c72a24cc478de8217c1f6988e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a63bdde5124e79a1370f29499128518"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4a63bdde5124e79a1370f29499128518">memory_consumption</a> () const</td></tr>
<tr class="separator:a4a63bdde5124e79a1370f29499128518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0c10f7a8cd32d961e9367173685047"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a2f0c10f7a8cd32d961e9367173685047"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2f0c10f7a8cd32d961e9367173685047">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:a2f0c10f7a8cd32d961e9367173685047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae2f72d5fbb277ec65dbe0382ae72a929">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7117ea716b516ef11a205a5d0020fe40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7117ea716b516ef11a205a5d0020fe40">add_periodicity</a> (const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> &gt;&gt; &amp;)</td></tr>
<tr class="separator:a7117ea716b516ef11a205a5d0020fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34318b9fb11fa49f10ba7c5155960c6"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::pair&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::pair&lt; std::pair&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::bitset&lt; 3 &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac34318b9fb11fa49f10ba7c5155960c6">get_periodic_face_map</a> () const</td></tr>
<tr class="separator:ac34318b9fb11fa49f10ba7c5155960c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f08d0df83f6455dbdac86c1a0736b8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classReferenceCell.html">ReferenceCell</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af4f08d0df83f6455dbdac86c1a0736b8">get_reference_cells</a> () const</td></tr>
<tr class="separator:af4f08d0df83f6455dbdac86c1a0736b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c84e9fa932ccd35820fe68abfe1348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a24c84e9fa932ccd35820fe68abfe1348">all_reference_cells_are_hyper_cube</a> () const</td></tr>
<tr class="separator:a24c84e9fa932ccd35820fe68abfe1348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70afc9a4f52455c18183ab31dd6789f"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ac70afc9a4f52455c18183ab31dd6789f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac70afc9a4f52455c18183ab31dd6789f">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ac70afc9a4f52455c18183ab31dd6789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aefd8ddbf96799abebb6c05dced569329"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aefd8ddbf96799abebb6c05dced569329">dimension</a> = dim</td></tr>
<tr class="separator:aefd8ddbf96799abebb6c05dced569329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3414a986e63a95d54e961b9b35d756fb"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3414a986e63a95d54e961b9b35d756fb">space_dimension</a> = spacedim</td></tr>
<tr class="separator:a3414a986e63a95d54e961b9b35d756fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ac6506c3f82279eed1dd2ee7f1ea66dc7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac6506c3f82279eed1dd2ee7f1ea66dc7">IteratorSelector</a> = ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt; dim, spacedim &gt;</td></tr>
<tr class="separator:ac6506c3f82279eed1dd2ee7f1ea66dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Line iterator functions for internal use</div></td></tr>
<tr class="memitem:af97878288a5eca64303abe53572ea159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af97878288a5eca64303abe53572ea159">begin_raw_line</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:af97878288a5eca64303abe53572ea159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50f2b3deed6e5f99e91768266df1d6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa50f2b3deed6e5f99e91768266df1d6e">begin_line</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:aa50f2b3deed6e5f99e91768266df1d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3efa7416e6b56419ffab72ac227a4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8d3efa7416e6b56419ffab72ac227a4a">begin_active_line</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:a8d3efa7416e6b56419ffab72ac227a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf640d5b174cae0f46e415c3fe39db2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5cf640d5b174cae0f46e415c3fe39db2">end_line</a> () const</td></tr>
<tr class="separator:a5cf640d5b174cae0f46e415c3fe39db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Quad iterator functions for internal use</div></td></tr>
<tr class="memitem:a52db7f90cd64a56e55383bef561aa7d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a52db7f90cd64a56e55383bef561aa7d1">begin_raw_quad</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:a52db7f90cd64a56e55383bef561aa7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ee8cea6762ae96b484436de70b3983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a09ee8cea6762ae96b484436de70b3983">begin_quad</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:a09ee8cea6762ae96b484436de70b3983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169e053e788e4d1b6abf7fb7cee6ba3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a169e053e788e4d1b6abf7fb7cee6ba3c">begin_active_quad</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:a169e053e788e4d1b6abf7fb7cee6ba3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f723b45ffdd6bfefec560fd333dadf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa4f723b45ffdd6bfefec560fd333dadf">end_quad</a> () const</td></tr>
<tr class="separator:aa4f723b45ffdd6bfefec560fd333dadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Keeping up with what happens to a triangulation</h2></td></tr>
<tr class="memitem:a1f047c753e5299ed179b042b1d014ee2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a> { <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2a94cffc65673af17059d03284f1f4528a">CELL_PERSIST</a>, 
<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2a499cef1e66d839e3344b256fd5feb117">CELL_REFINE</a>, 
<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2a37a57cd1b9fd76f736f5e9e810011824">CELL_COARSEN</a>, 
<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2a77e3cf6150ed62cd551424de92cc880b">CELL_INVALID</a>
 }</td></tr>
<tr class="separator:a1f047c753e5299ed179b042b1d014ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad136f601f63a6d1bd8e205edd93cbae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTriangulation_1_1Signals.html">Signals</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad136f601f63a6d1bd8e205edd93cbae3">signals</a></td></tr>
<tr class="separator:ad136f601f63a6d1bd8e205edd93cbae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Exceptions</h2></td></tr>
<tr class="memitem:gac9474a14d0e8429412c82450013bde67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac9474a14d0e8429412c82450013bde67">smooth_grid</a></td></tr>
<tr class="separator:gac9474a14d0e8429412c82450013bde67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f47aa64420502db8ebeffd531572779"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classReferenceCell.html">ReferenceCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f47aa64420502db8ebeffd531572779">reference_cells</a></td></tr>
<tr class="separator:ga5f47aa64420502db8ebeffd531572779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacae2fa4c23a286d83b8d947a714bba40"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; ::internal::TriangulationImplementation::Policy&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacae2fa4c23a286d83b8d947a714bba40">policy</a></td></tr>
<tr class="separator:gacae2fa4c23a286d83b8d947a714bba40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93d8df10255e3616c7380a31de4c90a3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga93d8df10255e3616c7380a31de4c90a3">periodic_face_pairs_level_0</a></td></tr>
<tr class="separator:ga93d8df10255e3616c7380a31de4c90a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga371da19ac0c451181b22f371e83a91a6"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::pair&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::pair&lt; std::pair&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::bitset&lt; 3 &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga371da19ac0c451181b22f371e83a91a6">periodic_face_map</a></td></tr>
<tr class="separator:ga371da19ac0c451181b22f371e83a91a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc78a1322a1040b8601290e52f2cc532"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gafc78a1322a1040b8601290e52f2cc532">DeclException2</a> (ExcInvalidLevel, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are requesting information from refinement level &quot;&lt;&lt; arg1&lt;&lt; &quot; of a triangulation, but this triangulation only has &quot;&lt;&lt; arg2&lt;&lt; &quot; refinement levels. The given level &quot;&lt;&lt; arg1&lt;&lt; &quot; must be *less* than &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:gafc78a1322a1040b8601290e52f2cc532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c118c9eb467d05ebe068651b74002ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8c118c9eb467d05ebe068651b74002ab">DeclException2</a> (ExcTriangulationNotEmpty, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are trying to perform an operation on a triangulation &quot;&lt;&lt; &quot;that is only allowed if the triangulation is currently empty. &quot;&lt;&lt; &quot;However, it currently stores &quot;&lt;&lt; arg1&lt;&lt; &quot; vertices and has &quot;&lt;&lt; &quot;cells on &quot;&lt;&lt; arg2&lt;&lt; &quot; levels.&quot;)</td></tr>
<tr class="separator:ga8c118c9eb467d05ebe068651b74002ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966384346b2c7308b814ab09065d0470"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga966384346b2c7308b814ab09065d0470">DeclException0</a> (ExcGridReadError)</td></tr>
<tr class="separator:ga966384346b2c7308b814ab09065d0470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa031bdac9392e3cdaa7ecf87171335"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaafa031bdac9392e3cdaa7ecf87171335">DeclException0</a> (ExcFacesHaveNoLevel)</td></tr>
<tr class="separator:gaafa031bdac9392e3cdaa7ecf87171335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391a9a406c14d6830d2ccbf0c59b429b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga391a9a406c14d6830d2ccbf0c59b429b">DeclException1</a> (ExcEmptyLevel, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You tried to do something on level &quot;&lt;&lt; arg1&lt;&lt; &quot;, but this level is empty.&quot;)</td></tr>
<tr class="separator:ga391a9a406c14d6830d2ccbf0c59b429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7cec3f85f90fe0e3d9e9ec626a0dbfc3">DeclException0</a> (ExcNonOrientableTriangulation)</td></tr>
<tr class="separator:ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9880263a1f12cd1dfecf45ac55c75c8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9880263a1f12cd1dfecf45ac55c75c8b">DeclException1</a> (ExcBoundaryIdNotFound, <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>,&lt;&lt; &quot;The given boundary_id &quot;&lt;&lt; arg1&lt;&lt; &quot; is not defined in this Triangulation!&quot;)</td></tr>
<tr class="separator:ga9880263a1f12cd1dfecf45ac55c75c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95a456ec8242cdf9109491510534f13d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga95a456ec8242cdf9109491510534f13d">DeclExceptionMsg</a> (ExcInconsistentCoarseningFlags, &quot;A cell is flagged for coarsening, but either not all of its siblings &quot; &quot;are active or flagged for coarsening as well. Please clean up all &quot; &quot;coarsen flags on your triangulation via &quot; &quot;<a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement</a>() beforehand!&quot;)</td></tr>
<tr class="separator:ga95a456ec8242cdf9109491510534f13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9e3e5c077024f40355432c771ccf541"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9e3e5c077024f40355432c771ccf541">write_bool_vector</a> (const unsigned <a class="el" href="classint.html">int</a> magic_number1, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned <a class="el" href="classint.html">int</a> magic_number2, std::ostream &amp;out)</td></tr>
<tr class="separator:gaf9e3e5c077024f40355432c771ccf541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20c92032e652bdafdfd7624a55aa2866"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga20c92032e652bdafdfd7624a55aa2866">read_bool_vector</a> (const unsigned <a class="el" href="classint.html">int</a> magic_number1, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned <a class="el" href="classint.html">int</a> magic_number2, std::istream &amp;in)</td></tr>
<tr class="separator:ga20c92032e652bdafdfd7624a55aa2866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609fee9e79ae50f4c348a39838c7eb0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga609fee9e79ae50f4c348a39838c7eb0c">update_periodic_face_map</a> ()</td></tr>
<tr class="separator:ga609fee9e79ae50f4c348a39838c7eb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ecff6fdc386de47c156781fb4217bcc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5ecff6fdc386de47c156781fb4217bcc">update_reference_cells</a> ()</td></tr>
<tr class="separator:ga5ecff6fdc386de47c156781fb4217bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Cell iterator functions for internal use</h2></td></tr>
<tr class="memitem:a5977e64adfde9e63f274be77bb34dddc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> = <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:a5977e64adfde9e63f274be77bb34dddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39637491c7d7e9f7bc4b7ea40a0d72b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad39637491c7d7e9f7bc4b7ea40a0d72b">raw_face_iterator</a> = <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ad39637491c7d7e9f7bc4b7ea40a0d72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099dd8d123778fdadd882415d639d1b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a099dd8d123778fdadd882415d639d1b4">raw_vertex_iterator</a> = <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:a099dd8d123778fdadd882415d639d1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0f7bc0b40113139b244a54591e9d53"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a> = typename IteratorSelector::raw_line_iterator</td></tr>
<tr class="separator:a0e0f7bc0b40113139b244a54591e9d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80735fd291dca4e5f958ee5876289aa4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a> = typename IteratorSelector::raw_quad_iterator</td></tr>
<tr class="separator:a80735fd291dca4e5f958ee5876289aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2be382ff40558d007dd767a1288dc1e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a> = typename IteratorSelector::raw_hex_iterator</td></tr>
<tr class="separator:ac2be382ff40558d007dd767a1288dc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bb19508b89ac6ed237b14bf7a506ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a45bb19508b89ac6ed237b14bf7a506ef">begin_raw</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:a45bb19508b89ac6ed237b14bf7a506ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbfc1e5187c6ad0a47d1b616f9f5149"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5cbfc1e5187c6ad0a47d1b616f9f5149">end_raw</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a5cbfc1e5187c6ad0a47d1b616f9f5149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Hex iterator functions for internal use</h2></td></tr>
<tr class="memitem:ae8e877e2e60025d306a75bb58e7ad68e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt;::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaLevel.html">internal::TriangulationImplementation::TriaLevel</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae8e877e2e60025d306a75bb58e7ad68e">levels</a></td></tr>
<tr class="separator:ae8e877e2e60025d306a75bb58e7ad68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706b242073a65dd1e4fe15c58d272671"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaFaces.html">internal::TriangulationImplementation::TriaFaces</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a706b242073a65dd1e4fe15c58d272671">faces</a></td></tr>
<tr class="separator:a706b242073a65dd1e4fe15c58d272671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51469854babb27752dc9f26ed9d5ee30"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a51469854babb27752dc9f26ed9d5ee30">vertices</a></td></tr>
<tr class="separator:a51469854babb27752dc9f26ed9d5ee30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d0610e5c578ced9903db01a70f466f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12d0610e5c578ced9903db01a70f466f">vertices_used</a></td></tr>
<tr class="separator:a12d0610e5c578ced9903db01a70f466f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf716af5de623e392f8a9f61cc313f5"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>, std::unique_ptr&lt; const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abbf716af5de623e392f8a9f61cc313f5">manifold</a></td></tr>
<tr class="separator:abbf716af5de623e392f8a9f61cc313f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dc6feb50966969856aa359f6fa316a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12dc6feb50966969856aa359f6fa316a">anisotropic_refinement</a></td></tr>
<tr class="separator:a12dc6feb50966969856aa359f6fa316a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c55287cc4c709190b521fd98a4f5e02"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5c55287cc4c709190b521fd98a4f5e02">check_for_distorted_cells</a></td></tr>
<tr class="separator:a5c55287cc4c709190b521fd98a4f5e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8607590a4a1eddce07f6570c53e1c3f3"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1NumberCache.html">internal::TriangulationImplementation::NumberCache</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8607590a4a1eddce07f6570c53e1c3f3">number_cache</a></td></tr>
<tr class="separator:a8607590a4a1eddce07f6570c53e1c3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3c27fe127e4b1d7de6bc67bb1eae97"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5d3c27fe127e4b1d7de6bc67bb1eae97">vertex_to_boundary_id_map_1d</a></td></tr>
<tr class="separator:a5d3c27fe127e4b1d7de6bc67bb1eae97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c156f5743dad8cd571f0c63ce0b39e6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1c156f5743dad8cd571f0c63ce0b39e6">vertex_to_manifold_id_map_1d</a></td></tr>
<tr class="separator:a1c156f5743dad8cd571f0c63ce0b39e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78484ccbc5d665a7ffc679fe62cecd7d"><td class="memTemplParams" colspan="2">template&lt;int , int , int &gt; </td></tr>
<tr class="memitem:a78484ccbc5d665a7ffc679fe62cecd7d"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a78484ccbc5d665a7ffc679fe62cecd7d">TriaAccessorBase</a></td></tr>
<tr class="separator:a78484ccbc5d665a7ffc679fe62cecd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c0730c894c987ae4e06de5f80bae12"><td class="memTemplParams" colspan="2">template&lt;int , int , int &gt; </td></tr>
<tr class="memitem:a43c0730c894c987ae4e06de5f80bae12"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a43c0730c894c987ae4e06de5f80bae12">TriaAccessor</a></td></tr>
<tr class="separator:a43c0730c894c987ae4e06de5f80bae12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f9b1157ed4068cc2ff016ceb0050fb"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a97f9b1157ed4068cc2ff016ceb0050fb">TriaAccessor&lt; 0, 1, spacedim &gt;</a></td></tr>
<tr class="separator:a97f9b1157ed4068cc2ff016ceb0050fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c6f26ee460554f57d2bbd3c5433c57"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a16c6f26ee460554f57d2bbd3c5433c57">CellAccessor&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:a16c6f26ee460554f57d2bbd3c5433c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bd8833f949eb9ac7a4dc4669177f26"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a66bd8833f949eb9ac7a4dc4669177f26">::internal::TriaAccessorImplementation::Implementation</a></td></tr>
<tr class="separator:a66bd8833f949eb9ac7a4dc4669177f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1173edf91a9d914373821b6117f32a8f"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1173edf91a9d914373821b6117f32a8f">::internal::TriangulationImplementation::Implementation</a></td></tr>
<tr class="separator:a1173edf91a9d914373821b6117f32a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5f94c07c2ca904c27c04ca38eac0e1"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8b5f94c07c2ca904c27c04ca38eac0e1">::internal::TriangulationImplementation::ImplementationMixedMesh</a></td></tr>
<tr class="separator:a8b5f94c07c2ca904c27c04ca38eac0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb04678e4ae6087bc934b8d6acdeef3f"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abb04678e4ae6087bc934b8d6acdeef3f">::internal::TriangulationImplementation::TriaObjects</a></td></tr>
<tr class="separator:abb04678e4ae6087bc934b8d6acdeef3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26795906ff2742c5f2109113b79d6744"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a26795906ff2742c5f2109113b79d6744">begin_raw_hex</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:a26795906ff2742c5f2109113b79d6744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae764c732cc0de8322257d13912552b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aae764c732cc0de8322257d13912552b8">begin_hex</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:aae764c732cc0de8322257d13912552b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e876cdf1cdae06aa793cc5081b4fe31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1e876cdf1cdae06aa793cc5081b4fe31">begin_active_hex</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:a1e876cdf1cdae06aa793cc5081b4fe31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd003c8d0a9d5839488ee2ad1313703"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aadd003c8d0a9d5839488ee2ad1313703">end_hex</a> () const</td></tr>
<tr class="separator:aadd003c8d0a9d5839488ee2ad1313703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d0ea3487d046b34de4ee8f60abf1b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a61d0ea3487d046b34de4ee8f60abf1b2">clear_despite_subscriptions</a> ()</td></tr>
<tr class="separator:a61d0ea3487d046b34de4ee8f60abf1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42c164ad82da9629eab01f90ef2a360"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af42c164ad82da9629eab01f90ef2a360">reset_policy</a> ()</td></tr>
<tr class="separator:af42c164ad82da9629eab01f90ef2a360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365332f11d26e60c46a1f9bbb3e5e1c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a365332f11d26e60c46a1f9bbb3e5e1c1">reset_active_cell_indices</a> ()</td></tr>
<tr class="separator:a365332f11d26e60c46a1f9bbb3e5e1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34500f2c5a91afc92a178b27fff212bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a34500f2c5a91afc92a178b27fff212bf">reset_global_cell_indices</a> ()</td></tr>
<tr class="separator:a34500f2c5a91afc92a178b27fff212bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76af9cf5bbd5811b3f6ee8ca03ac8df6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76af9cf5bbd5811b3f6ee8ca03ac8df6">reset_cell_vertex_indices_cache</a> ()</td></tr>
<tr class="separator:a76af9cf5bbd5811b3f6ee8ca03ac8df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a73cdc08e502d9a140a625184526b89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8a73cdc08e502d9a140a625184526b89">execute_refinement</a> ()</td></tr>
<tr class="separator:a8a73cdc08e502d9a140a625184526b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeebb271c1406d688a1ffb802a7bb509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afeebb271c1406d688a1ffb802a7bb509">execute_coarsening</a> ()</td></tr>
<tr class="separator:afeebb271c1406d688a1ffb802a7bb509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dc87bf8f3793947ba51f2da20b8442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a37dc87bf8f3793947ba51f2da20b8442">fix_coarsen_flags</a> ()</td></tr>
<tr class="separator:a37dc87bf8f3793947ba51f2da20b8442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01ec1d50a410f7cc29c543b212edefc"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af01ec1d50a410f7cc29c543b212edefc">coarse_cell_id_to_coarse_cell_index</a> (const <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a> coarse_cell_id) const</td></tr>
<tr class="separator:af01ec1d50a410f7cc29c543b212edefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef633762716a14deb9a4dcda02a26f0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9ef633762716a14deb9a4dcda02a26f0">coarse_cell_index_to_coarse_cell_id</a> (const unsigned <a class="el" href="classint.html">int</a> coarse_cell_index) const</td></tr>
<tr class="separator:a9ef633762716a14deb9a4dcda02a26f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class Triangulation&lt; dim, spacedim &gt;</h3>

<p>A triangulation is a collection of cells that, jointly, cover the domain on which one typically wants to solve a partial differential equation. This domain, and the mesh that covers it, represents a <code>dim</code> -dimensional manifold and lives in <code>spacedim</code> spatial dimensions, where <code>dim</code> and <code>spacedim</code> are the template arguments of this class. (If <code>spacedim</code> is not specified, it takes the default value <code>spacedim=dim</code>.)</p>
<p>Thus, for example, an object of type <code>Triangulation&lt;1,1&gt;</code> (or simply <code>Triangulation&lt;1&gt;</code> since <code>spacedim==dim</code> by default) is used to represent and handle the usual one-dimensional triangulation used in the finite element method (so, segments on a straight line). On the other hand, objects such as <code>Triangulation&lt;1,2&gt;</code> or <code>Triangulation&lt;2,3&gt;</code> (that are associated with curves in 2D or surfaces in 3D) are the ones one wants to use in the boundary element method.</p>
<p>The name of the class is mostly hierarchical and is not meant to imply that a <a class="el" href="classTriangulation.html">Triangulation</a> can only consist of triangles. Instead, triangulations consist of line segments in 1d (i.e., if <code>dim==1</code>), and of three-dimensional cells (if <code>dim==3</code>). Moreover, historically, deal.II only supported quadrilaterals (cells with four vertices: deformed rectangles) in 2d and hexahedra (cells with six sides and eight vertices that are deformed boxes), neither of which are triangles. In other words, the term "triangulation" in the deal.II language is synonymous with "mesh" and is to be understood separate from its linguistic origin.</p>
<p>This class is written to be as independent of the dimension as possible (thus the complex construction of the <a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaLevel.html">internal::TriangulationImplementation::TriaLevel</a> classes) to allow code-sharing, to allow reducing the need to mirror changes in the code for one dimension to the code for other dimensions. Nonetheless, some of the functions are dependent of the dimension and there only exist specialized versions for distinct dimensions.</p>
<p>This class satisfies the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a> requirements.</p>
<h3>Structure and iterators</h3>
<p>The actual data structure of a <a class="el" href="classTriangulation.html">Triangulation</a> object is rather complex and quite inconvenient if one attempted to operate on it directly, since data is spread over quite a lot of arrays and other places. However, there are ways powerful enough to work on these data structures without knowing their exact relations. deal.II uses class local alias (see below) to make things as easy and dimension independent as possible.</p>
<p>The <a class="el" href="classTriangulation.html">Triangulation</a> class provides iterators which enable looping over all cells without knowing the exact representation used to describe them. For more information see the documentation of <code><a class="el" href="classTriaIterator.html">TriaIterator</a></code>. Their names are alias imported from the Iterators class (thus making them local types to this class) and are as follows:</p>
<ul>
<li>
<code>cell_iterator</code>: loop over all cells used in the <a class="el" href="classTriangulation.html">Triangulation</a> </li>
<li>
<code>active_cell_iterator</code>: loop over all active cells </li>
</ul>
<p>For <code>dim==1</code>, these iterators are mapped as follows: </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> = <a class="code" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> = <a class="code" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a>;</div></div><!-- fragment --><p> while for <code>dim==2</code> we have the additional face iterator: </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> = <a class="code" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> = <a class="code" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="code" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> = <a class="code" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> = <a class="code" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a>;</div></div><!-- fragment --><p>By using the cell iterators, you can write code independent of the spatial dimension. The same applies for substructure iterators, where a substructure is defined as a face of a cell. The face of a cell is a vertex in 1D and a line in 2D; however, vertices are handled in a different way and therefore lines have no faces.</p>
<p>The <a class="el" href="classTriangulation.html">Triangulation</a> class offers functions like <a class="el" href="classTriangulation.html#afe6c58805fe436a94b141c1585606c7f">begin_active()</a> which gives you an iterator to the first active cell. There are quite a lot of functions returning iterators. Take a look at the class doc to get an overview.</p>
<p>Usage of these iterators is similar to usage of standard container iterators. Some examples taken from the <a class="el" href="classTriangulation.html">Triangulation</a> source code follow (notice that in the last two examples the template parameter <code>spacedim</code> has been omitted, so it takes the default value <code>dim</code>).</p>
<ul>
<li>
<p class="startli"><em>Counting the number of cells on a specific level</em> </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line"><a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">Triangulation&lt;dim, spacedim&gt;::n_cells</a> (<span class="keyword">const</span> <span class="keywordtype">int</span> level)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">int</span> n=0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : <a class="code" href="group__CPP11.html#gae69f18aa4845bfe513fd51a39755b9d6">cell_iterators_on_level</a>(level))</div><div class="line">    ++n;</div><div class="line">  <span class="keywordflow">return</span> n;</div><div class="line">}</div></div><!-- fragment --><p> Another way, which uses <code>std::distance</code>, would be to write </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line"><a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">Triangulation&lt;dim&gt;::n_cells</a> (<span class="keyword">const</span> <span class="keywordtype">int</span> level)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordtype">int</span> n=0;</div><div class="line">  <a class="code" href="namespacemystl.html#a5ecb09f5cd83c4465b4645b381730651">distance</a> (<a class="code" href="classTriangulation.html#a36fb6b15f119483143c433dd10df9b26">begin</a>(level),</div><div class="line">            (level == <a class="code" href="classTriangulation.html#ae8e877e2e60025d306a75bb58e7ad68e">levels</a>.size()-1 ?</div><div class="line">             <a class="code" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>(<a class="code" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end</a>()) :</div><div class="line">             <a class="code" href="classTriangulation.html#a36fb6b15f119483143c433dd10df9b26">begin</a> (level+1)),</div><div class="line">            n);</div><div class="line">  <span class="keywordflow">return</span> n;</div><div class="line">}</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<em>Refining all cells of a triangulation</em> <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">Triangulation&lt;dim&gt;::refine_global</a> ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : <a class="code" href="group__CPP11.html#ga23e860c5192f6501650dda8bb3e2b497">active_cell_iterators</a>())</div><div class="line">    cell-&gt;set_refine_flag ();</div><div class="line">  <a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div><div class="line">}</div></div><!-- fragment --> </li>
</ul>
<h3>Usage</h3>
<p>Usage of a <a class="el" href="classTriangulation.html">Triangulation</a> is mainly done through the use of iterators. An example probably shows best how to use it: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria;</div><div class="line"></div><div class="line">  <span class="comment">// read in a coarse grid file</span></div><div class="line"></div><div class="line">  <span class="comment">// we want to log the refinement history</span></div><div class="line">  ofstream history (<span class="stringliteral">&quot;mesh.history&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// refine first cell</span></div><div class="line">  tria.<a class="code" href="classTriangulation.html#afe6c58805fe436a94b141c1585606c7f">begin_active</a>()-&gt;set_refine_flag();</div><div class="line">  tria.<a class="code" href="classTriangulation.html#aca5cfa9068a5d3ad32dfca87e2901a87">save_refine_flags</a> (history);</div><div class="line">  tria.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div><div class="line"></div><div class="line">  <span class="comment">// refine first active cell on coarsest level</span></div><div class="line">  tria.<a class="code" href="classTriangulation.html#afe6c58805fe436a94b141c1585606c7f">begin_active</a>()-&gt;set_refine_flag ();</div><div class="line">  tria.<a class="code" href="classTriangulation.html#aca5cfa9068a5d3ad32dfca87e2901a87">save_refine_flags</a> (history);</div><div class="line">  tria.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div><div class="line"></div><div class="line">  <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;2&gt;::active_cell_iterator</a> cell;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;17; ++i)</div><div class="line">    {</div><div class="line">      <span class="comment">// refine the presently second last cell 17 times</span></div><div class="line">      cell = tria.<a class="code" href="classTriangulation.html#a2eb00096abe5ef91413440e1e1b66c00">last_active</a>(tria.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>()-1);</div><div class="line">      --cell;</div><div class="line">      cell-&gt;set_refine_flag ();</div><div class="line">      tria.<a class="code" href="classTriangulation.html#aca5cfa9068a5d3ad32dfca87e2901a87">save_refine_flags</a> (history);</div><div class="line">      tria.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div><div class="line">    };</div><div class="line">  <span class="comment">// output the grid</span></div><div class="line">  ofstream out(<span class="stringliteral">&quot;grid.1&quot;</span>);</div><div class="line">  <a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">GridOut::write_gnuplot</a> (tria, out);</div><div class="line">}</div></div><!-- fragment --><h3>Creating a triangulation</h3>
<p>There are several possibilities to create a triangulation: </p><ul>
<li>
<p class="startli">The most common domains, such as hypercubes (i.e. lines, squares, cubes, etc), hyper-balls (circles, balls, ...) and some other, more weird domains such as the L-shape region and higher dimensional generalizations and others, are provided by the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> class which takes a triangulation and fills it by a division of the required domain.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Reading in a triangulation: By using an object of the <a class="el" href="classGridIn.html">GridIn</a> class, you can read in fairly general triangulations. See there for more information. The mentioned class uses the interface described directly below to transfer the data into the triangulation.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Explicitly creating a triangulation: you can create a triangulation by providing a list of vertices and a list of cells. Each such cell consists of a vector storing the indices of the vertices of this cell in the vertex list. To see how this works, you can take a look at the GridIn&lt;dim&gt;::read_* functions. The appropriate function to be called is <a class="el" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">create_triangulation()</a>.</p>
<p>Creating the hierarchical information needed for this library from cells storing only vertex information can be quite a complex task. For example in 2D, we have to create lines between vertices (but only once, though there are two cells which link these two vertices) and we have to create neighborhood information. Grids being read in should therefore not be too large, reading refined grids would be inefficient (although there is technically no problem in reading grids with several 10.000 or 100.000 cells; the library can handle this without much problems). Apart from the performance aspect, refined grids do not lend too well to multigrid algorithms, since solving on the coarsest level is expensive. It is wiser in any case to read in a grid as coarse as possible and then do the needed refinement steps.</p>
<p>It is your duty to guarantee that cells have the correct orientation. To guarantee this, in the input vector keeping the cell list, the vertex indices for each cell have to be in a defined order, see the documentation of GeometryInfo&lt;dim&gt;. In one dimension, the first vertex index must refer to that vertex with the lower coordinate value. In 2D and 3D, the corresponding conditions are not easy to verify and no full attempt to do so is made. If you violate this condition, you may end up with matrix entries having the wrong sign (clockwise vertex numbering, which results in a negative area element) of with wrong matrix elements (twisted quadrilaterals, i.e. two vertices interchanged; this results in a wrong area element).</p>
<p>There are more subtle conditions which must be imposed upon the vertex numbering within cells. They do not only hold for the data read from an UCD or any other input file, but also for the data passed to <a class="el" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">create_triangulation()</a>. See the documentation for the <a class="el" href="classGridIn.html">GridIn</a> class for more details on this, and above all to the <a class="el" href="classGridReordering.html">GridReordering</a> class that explains many of the problems and an algorithm to reorder cells such that they satisfy the conditions outlined above.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Copying a triangulation: when computing on time dependent meshes or when using adaptive refinement, you will often want to create a new triangulation to be the same as another one. This is facilitated by the <code>copy_triangulation</code> function.</p>
<p class="endli">It is guaranteed that vertex, line or cell numbers in the two triangulations are the same and that two iterators walking on the two triangulations visit matching cells if they are incremented in parallel. It may be conceivable to implement a clean-up in the copy operation, which eliminates holes of unused memory, re-joins scattered data and so on. In principle this would be a useful operation but guaranteeing some parallelism in the two triangulations seems more important since usually data will have to be transferred between the grids. </p>
</li>
</ul>
<p>Finally, there is a special function for folks who like bad grids: <a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">distort_random()</a>. It moves all the vertices in the grid a bit around by a random value, leaving behind a distorted mesh. Note that you should apply this function to the final mesh, since refinement smoothes the mesh a bit.</p>
<p>The function will make sure that vertices on restricted faces (hanging nodes) will end up in the correct place, i.e. in the middle of the two other vertices of the mother line, and the analogue in higher space dimensions (vertices on the boundary are not corrected, so don't distort boundary vertices in more than two space dimension, i.e. in dimensions where boundary vertices can be hanging nodes). Applying the algorithm has another drawback related to the placement of cells, however: the children of a cell will not occupy the same region of the domain as the mother cell does. While this is the usual behavior with cells at the boundary, here you may get into trouble when using multigrid algorithms or when transferring solutions from coarse to fine grids and back. In general, the use of this function is only safe if you only use the most refined level of the triangulation for computations.</p>
<h3>Refinement and coarsening of a triangulation</h3>
<p>Refinement of a triangulation may be done through several ways. The most low-level way is directly through iterators: let <code>i</code> be an iterator to an active cell (i.e. the cell pointed to has no children), then the function call <code>i-&gt;set_refine_flag()</code> marks the respective cell for refinement. Marking non-active cells results in an error.</p>
<p>After all the cells you wanted to mark for refinement, call <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement()</a> to actually perform the refinement. This function itself first calls the <code>prepare_coarsening_and_refinement</code> function to regularize the resulting triangulation: since a face between two adjacent cells may only be subdivided once (i.e. the levels of two adjacent cells may differ by one at most; it is not possible to have a cell refined twice while the neighboring one is not refined), some additional cells are flagged for refinement to smooth the grid. This enlarges the number of resulting cells but makes the grid more regular, thus leading to better approximation properties and, above all, making the handling of data structures and algorithms much easier. To be honest, this is mostly an algorithmic step than one needed by the finite element method.</p>
<p>To coarsen a grid, the same way as above is possible by using <code>i-&gt;set_coarsen_flag</code> and calling <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement()</a>.</p>
<p>The reason for first coarsening, then refining is that the refinement usually adds some additional cells to keep the triangulation regular and thus satisfies all refinement requests, while the coarsening does not delete cells not requested for; therefore the refinement will often revert some effects of coarsening while the opposite is not true. The stated order of coarsening before refinement will thus normally lead to a result closer to the intended one.</p>
<p>Marking cells for refinement 'by hand' through iterators is one way to produce a new grid, especially if you know what kind of grid you are looking for, e.g. if you want to have a grid successively refined towards the boundary or always at the center (see the example programs, they do exactly these things). There are more advanced functions, however, which are more suitable for automatic generation of hierarchical grids in the context of a posteriori error estimation and adaptive finite elements. These functions can be found in the <a class="el" href="namespaceGridRefinement.html">GridRefinement</a> class.</p>
<h3>Smoothing of a triangulation</h3>
<p>Some degradation of approximation properties has been observed for grids which are too unstructured. Therefore, <a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">prepare_coarsening_and_refinement()</a> which is automatically called by <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement()</a> can do some smoothing of the triangulation. Note that mesh smoothing is only done for two or more space dimensions, no smoothing is available at present for one spatial dimension. In the following, let <code>execute_*</code> stand for <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement()</a>.</p>
<p>For the purpose of smoothing, the <a class="el" href="classTriangulation.html">Triangulation</a> constructor takes an argument specifying whether a smoothing step shall be performed on the grid each time <code>execute_*</code> is called. The default is that such a step not be done, since this results in additional cells being produced, which may not be necessary in all cases. If switched on, calling <code>execute_*</code> results in flagging additional cells for refinement to avoid vertices as the ones mentioned. The algorithms for both regularization and smoothing of triangulations are described below in the section on technical issues. The reason why this parameter must be given to the constructor rather than to <code>execute_*</code> is that it would result in algorithmic problems if you called <code>execute_*</code> once without and once with smoothing, since then in some refinement steps would need to be refined twice.</p>
<p>The parameter taken by the constructor is an integer which may be composed bitwise by the constants defined in the enum <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> (see there for the possibilities).</p>
<dl class="section note"><dt>Note</dt><dd>While it is possible to pass all of the flags in <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> to objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, it is not always possible to honor all of these smoothing options if they would require knowledge of refinement/coarsening flags on cells not locally owned by this processor. As a consequence, for some of these flags, the ultimate number of cells of the parallel triangulation may depend on the number of processors into which it is partitioned.</dd></dl>
<h3>Material and boundary information</h3>
<p>Each cell, face or edge stores information denoting the material or the part of the boundary that an object belongs to. The material id of a cell is typically used to identify which cells belong to a particular part of the domain, e.g., when you have different materials (steel, concrete, wood) that are all part of the same domain. One would then usually query the material id associated with a cell during assembly of the bilinear form, and use it to determine (e.g., by table lookup, or a sequence of if-else statements) what the correct material coefficients would be for that cell. See also <a class="el" href="DEALGlossary.html#GlossMaterialId">this glossary entry</a>.</p>
<p>This material_id may be set upon construction of a triangulation (through the <a class="el" href="structCellData.html">CellData</a> data structure), or later through use of cell iterators. For a typical use of this functionality, see the step-28 tutorial program. The functions of the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace typically set the material ID of all cells to zero. When reading a triangulation through the <a class="el" href="classGridIn.html">GridIn</a> class, different input file formats have different conventions, but typically either explicitly specify the material id, or if they don't, then <a class="el" href="classGridIn.html">GridIn</a> simply sets them to zero. Because the material of a cell is intended to pertain to a particular region of the domain, material ids are inherited by child cells from their parent upon mesh refinement.</p>
<p>Boundary indicators on lower dimensional objects (these have no material id) indicate the number of a boundary component. The weak formulation of the partial differential equation may have different boundary conditions on different parts of the boundary. The boundary indicator can be used in creating the matrix or the right hand side vector to indicate these different parts of the model (this use is like the material id of cells). Boundary indicators may be in the range from zero to <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>-1. The value <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> is reserved to denote interior lines (in 2D) and interior lines and quads (in 3D), which do not have a boundary indicator. This way, a program can easily determine, whether such an object is at the boundary or not. Material indicators may be in the range from zero to <a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>-1.</p>
<p>Lines in two dimensions and quads in three dimensions inherit their boundary indicator to their children upon refinement. You should therefore make sure that if you have different boundary parts, the different parts are separated by a vertex (in 2D) or a line (in 3D) such that each boundary line or quad has a unique boundary indicator.</p>
<p>By default (unless otherwise specified during creation of a triangulation), all parts of the boundary have boundary indicator zero. As a historical wart, this isn't true for 1d meshes, however: For these, leftmost vertices have boundary indicator zero while rightmost vertices have boundary indicator one. In either case, the boundary indicator of a face can be changed using a call of the kind <code>cell-&gt;face(1)-&gt;set_boundary_id(42);</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a></dd></dl>
<h3>History of a triangulation</h3>
<p>It is possible to reconstruct a grid from its refinement history, which can be stored and loaded through the <code>save_refine_flags</code> and <code>load_refine_flags</code> functions. Normally, the code will look like this: </p><div class="fragment"><div class="line"><span class="comment">// open output file</span></div><div class="line">std::ofstream history(<span class="stringliteral">&quot;mesh.history&quot;</span>);</div><div class="line"><span class="comment">// do 10 refinement steps</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step=0; step&lt;10; ++step)</div><div class="line">  {</div><div class="line">    ...;</div><div class="line">    <span class="comment">// flag cells according to some criterion</span></div><div class="line">    ...;</div><div class="line">    tria.<a class="code" href="classTriangulation.html#aca5cfa9068a5d3ad32dfca87e2901a87">save_refine_flags</a> (history);</div><div class="line">    tria.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div><div class="line">  }</div></div><!-- fragment --><p>If you want to re-create the grid from the stored information, you write: </p><div class="fragment"><div class="line"><span class="comment">// open input file</span></div><div class="line">std::ifstream history(<span class="stringliteral">&quot;mesh.history&quot;</span>);</div><div class="line"><span class="comment">// do 10 refinement steps</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step=0; step&lt;10; ++step)</div><div class="line">  {</div><div class="line">    tria.<a class="code" href="classTriangulation.html#a43fc07c3f9e1f02658ca556f41087c85">load_refine_flags</a> (history);</div><div class="line">    tria.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a> ();</div><div class="line">  }</div></div><!-- fragment --><p>The same scheme is employed for coarsening and the coarsening flags.</p>
<p>You may write other information to the output file between different sets of refinement information, as long as you read it upon re-creation of the grid. You should make sure that the other information in the new triangulation which is to be created from the saved flags, matches that of the old triangulation, for example the smoothing level; if not, the cells actually created from the flags may be other ones, since smoothing adds additional cells, but their number may be depending on the smoothing level.</p>
<p>There actually are two sets of <code>save_*_flags</code> and <code>load_*_flags</code> functions. One takes a stream as argument and reads/writes the information from/to the stream, thus enabling storing flags to files. The other set takes an argument of type <code>vector&lt;bool&gt;</code>. This enables the user to temporarily store some flags, e.g. if another function needs them, and restore them afterwards.</p>
<h3>User flags and data</h3>
<p>A triangulation offers one bit per line, quad, etc for user flags. This field can be accessed as all other data using iterators. Normally, this user flag is used if an algorithm walks over all cells and needs information whether another cell, e.g. a neighbor, has already been processed. See <a class="el" href="DEALGlossary.html#GlossUserFlags">the glossary for more information</a>.</p>
<p>There is another set of user data, which can be either an <code>unsigned int</code> or a <code>void *</code>, for each line, quad, etc. You can access these through the functions listed under <code>User data</code> in the accessor classes. Again, see <a class="el" href="DEALGlossary.html#GlossUserData">the glossary for more information</a>.</p>
<p>The value of these user indices or pointers is <code>nullptr</code> by default. Note that the pointers are not inherited to children upon refinement. Still, after a remeshing they are available on all cells, where they were set on the previous mesh.</p>
<p>The usual warning about the missing type safety of <code>void</code> pointers are obviously in place here; responsibility for correctness of types etc lies entirely with the user of the pointer.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are stored in the same place. In order to avoid unwanted conversions, <a class="el" href="classTriangulation.html">Triangulation</a> checks which one of them is in use and does not allow access to the other one, until <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">clear_user_data()</a> has been called.</dd></dl>
<h3>Describing curved geometries</h3>
<p>deal.II implements all geometries (curved and otherwise) with classes inheriting from <a class="el" href="classManifold.html">Manifold</a>; see the documentation of <a class="el" href="classManifold.html">Manifold</a>, step-49, or the <a class="el" href="group__manifold.html">Manifold description for triangulations</a> module for examples and a complete description of the algorithms. By default, all cells in a <a class="el" href="classTriangulation.html">Triangulation</a> have a flat geometry, meaning that all lines in the <a class="el" href="classTriangulation.html">Triangulation</a> are assumed to be straight. If a cell has a manifold_id that is not equal to <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a> then the <a class="el" href="classTriangulation.html">Triangulation</a> uses the associated <a class="el" href="classManifold.html">Manifold</a> object for computations on that cell (e.g., cell refinement). Here is a quick example, taken from the implementation of <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball()</a>, that sets up a polar grid:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point&lt;2&gt;&gt; <a class="code" href="classTriangulation.html#a51469854babb27752dc9f26ed9d5ee30">vertices</a> = {{-1.0,-1.0},</div><div class="line">                                          {+1.0,-1.0},</div><div class="line">                                          {-0.5,-0.5},</div><div class="line">                                          {+0.5,-0.5},</div><div class="line">                                          {-0.5,+0.5},</div><div class="line">                                          {+1.0,+1.0},</div><div class="line">                                          {-1.0,+1.0},</div><div class="line">                                          {+1.0,+1.0}};</div><div class="line">  <span class="keyword">const</span> std::vector&lt;std::array&lt;int,GeometryInfo&lt;2&gt;::vertices_per_cell&gt;&gt;</div><div class="line">    cell_vertices = {{0, 1, 2, 3},</div><div class="line">                     {0, 2, 6, 4},</div><div class="line">                     {2, 3, 4, 5},</div><div class="line">                     {1, 7, 3, 5},</div><div class="line">                     {6, 4, 7, 5}};</div><div class="line"></div><div class="line">  std::vector&lt;CellData&lt;2&gt;&gt; cells(cell_vertices.size(), <a class="code" href="structCellData.html">CellData&lt;2&gt;</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;cell_vertices.size(); ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;GeometryInfo&lt;2&gt;::vertices_per_cell; ++j)</div><div class="line">      cells[i].vertices[j] = cell_vertices[i][j];</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">create_triangulation</a> (vertices, cells, <a class="code" href="structSubCellData.html">SubCellData</a>());</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(42);</div><div class="line"></div><div class="line">  <span class="comment">// set_manifold stores a copy of its second argument,</span></div><div class="line">  <span class="comment">// so a temporary is okay</span></div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(42, <a class="code" href="classPolarManifold.html">PolarManifold&lt;2&gt;</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 4; ++i)</div><div class="line">    {</div><div class="line">      <span class="comment">// refine all boundary cells</span></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga23e860c5192f6501650dda8bb3e2b497">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;at_boundary())</div><div class="line">          cell-&gt;set_refine_flag();</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a>();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This will set up a grid where the boundary lines will be refined by performing calculations in polar coordinates. When the mesh is refined the cells adjacent to the boundary will use this new line midpoint (as well as the other three midpoints and original cell vertices) to calculate the cell midpoint with a transfinite interpolation: this propagates the curved boundary into the interior in a smooth way. It is possible to generate a better grid (which interpolates across all cells between two different <a class="el" href="classManifold.html">Manifold</a> descriptions, instead of just going one cell at a time) by using <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>; see the documentation of that class for more information.</p>
<p>You should take note of one caveat: if you have concave boundaries, you must make sure that a new boundary vertex does not lie too much inside the cell which is to be refined. The reason is that the center vertex is placed at the point which is a weighted average of the vertices of the original cell, new face midpoints, and (in 3D) new line midpoints. Therefore if your new boundary vertex is too near the center of the old quadrilateral or hexahedron, the distance to the midpoint vertex will become too small, thus generating distorted cells. This issue is discussed extensively in <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a>.</p>
<h3>Getting notice when a triangulation changes</h3>
<p>There are cases where one object would like to know whenever a triangulation is being refined, copied, or modified in a number of other ways. This could of course be achieved if, in your user code, you tell every such object whenever you are about to refine the triangulation, but this will get tedious and is error prone. The <a class="el" href="classTriangulation.html">Triangulation</a> class implements a more elegant way to achieve this: signals.</p>
<p>In essence, a signal is an object (a member of the <a class="el" href="classTriangulation.html">Triangulation</a> class) that another object can connect to. A connection is in essence that the connecting object passes a function object taking a certain number and kind of arguments. Whenever the owner of the signal wants to indicate a certain kind of event, it 'triggers' the signal, which in turn means that all connections of the signal are triggered: in other word, the function objects are executed and can take the action that is necessary.</p>
<p>As a simple example, the following code will print something to the output every time the triangulation has just been refined: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Triangulation has been refined.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a> ()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> triangulation;</div><div class="line">  <span class="comment">// fill it somehow</span></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ad136f601f63a6d1bd8e205edd93cbae3">signals</a>.<a class="code" href="structTriangulation_1_1Signals.html#aa65bc4587a433d690b9f29732f7a9466">post_refinement</a>.connect (&amp;f);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (2);</div><div class="line">}</div></div><!-- fragment --><p> This code will produce output twice, once for each refinement cycle.</p>
<p>A more interesting application would be the following, akin to what the <a class="el" href="classFEValues.html">FEValues</a> class does. This class stores a pointer to a triangulation and also an iterator to the cell last handled (so that it can compare the current cell with the previous one and, for example, decide that there is no need to re-compute the Jacobian matrix if the new cell is a simple translation of the previous one). However, whenever the triangulation is modified, the iterator to the previously handled cell needs to be invalidated since it now no longer points to any useful cell (or, at the very least, points to something that may not necessarily resemble the cells previously handled). The code would look something like this (the real code has some more error checking and has to handle the case that subsequent cells might actually belong to different triangulation, but that is of no concern to us here): </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classFEValues.html">FEValues</a></div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> current_cell, previous_cell;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a> (<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> &amp;cell);</div><div class="line">  <span class="keywordtype">void</span> invalidate_previous_cell ();</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line"><a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues&lt;dim&gt;::reinit</a> (<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> &amp;cell)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (previous_cell.status() != <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a457da025bc5a3a2231a667bd5c6f3c92">valid</a>)</div><div class="line">    {</div><div class="line">      <span class="comment">// previous_cell has not been set. set it now, and register with the</span></div><div class="line">      <span class="comment">// triangulation that we want to be informed about mesh refinement</span></div><div class="line">      previous_cell = current_cell;</div><div class="line">      previous_cell-&gt;get_triangulation().signals.post_refinement.connect(</div><div class="line">        [<span class="keyword">this</span>]()</div><div class="line">        {</div><div class="line">          this-&gt;invalidate_previous_cell();</div><div class="line">        });</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">   previous_cell = current_cell;</div><div class="line"></div><div class="line">  current_cell = cell;</div><div class="line">  <span class="comment">// ... do something with the cell...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;::invalidate_previous_cell</a> ()</div><div class="line">{</div><div class="line">  previous_cell = <a class="code" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">Triangulation&lt;dim&gt;::active_cell_iterator</a>();</div><div class="line">}</div></div><!-- fragment --><p> Here, whenever the triangulation is refined, it triggers the post- refinement signal which calls the function object attached to it. This function object is the member function <code>FEValues&lt;dim&gt;::invalidate_previous_cell</code> where we have bound the single argument (the <code>this</code> pointer of a member function that otherwise takes no arguments) to the <code>this</code> pointer of the <a class="el" href="classFEValues.html">FEValues</a> object. Note how here there is no need for the code that owns the triangulation and the <a class="el" href="classFEValues.html">FEValues</a> object to inform the latter if the former is refined. (In practice, the function would want to connect to some of the other signals that the triangulation offers as well, in particular to creation and deletion signals.)</p>
<p>The <a class="el" href="classTriangulation.html">Triangulation</a> class has a variety of signals that indicate different actions by which the triangulation can modify itself and potentially require follow-up action elsewhere. Please refer to <a class="el" href="structTriangulation_1_1Signals.html">Triangulation::Signals</a> for details.</p>
<h3>Serializing (loading or storing) triangulations</h3>
<p>Like many other classes in deal.II, the <a class="el" href="classTriangulation.html">Triangulation</a> class can stream its contents to an archive using BOOST's serialization facilities. The data so stored can later be retrieved again from the archive to restore the contents of this object. This facility is frequently used to save the state of a program to disk for possible later resurrection, often in the context of checkpoint/restart strategies for long running computations or on computers that aren't very reliable (e.g. on very large clusters where individual nodes occasionally fail and then bring down an entire MPI job).</p>
<p>For technical reasons, writing and restoring a <a class="el" href="classTriangulation.html">Triangulation</a> object is not trivial. The primary reason is that unlike many other objects, triangulations rely on many other objects to which they store pointers or with which they interface; for example, triangulations store pointers to objects describing boundaries and manifolds, and they have signals that store pointers to other objects so they can be notified of changes in the triangulation (see the section on signals in this introduction). Since these objects are owned by the user space (for example the user can create a custom manifold object), they may not be serializable. So in cases like this, boost::serialize can store a reference to an object instead of the pointer, but the reference will never be satisfied at write time because the object pointed to is not serialized. Clearly, at load time, boost::serialize will not know where to let the pointer point to because it never gets to re-create the object originally pointed to.</p>
<p>For these reasons, saving a triangulation to an archive does not store all information, but only certain parts. More specifically, the information that is stored is everything that defines the mesh such as vertex locations, vertex indices, how vertices are connected to cells, boundary indicators, subdomain ids, material ids, etc. On the other hand, the following information is not stored:</p><ul>
<li>signals</li>
<li>pointers to <a class="el" href="classManifold.html">Manifold</a> objects previously set using <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a></li>
</ul>
<p>On the other hand, since these are objects that are usually set in user code, they can typically easily be set again in that part of your code in which you re-load triangulations.</p>
<p>In a sense, this approach to serialization means that re-loading a triangulation is more akin to calling the <a class="el" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">Triangulation::create_triangulation()</a> function and filling it with some additional content, as that function also does not touch the signals and <a class="el" href="classManifold.html">Manifold</a> objects that belong to this triangulation. In keeping with this analogy, the <a class="el" href="classTriangulation.html#ae2f72d5fbb277ec65dbe0382ae72a929">Triangulation::load()</a> function also triggers the same kinds of signal as <a class="el" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">Triangulation::create_triangulation()</a>.</p>
<h3>Technical details</h3>
<h4>Algorithms for mesh regularization and smoothing upon refinement</h4>
<p>We chose an inductive point of view: since upon creation of the triangulation all cells are on the same level, all regularity assumptions regarding the maximum difference in level of cells sharing a common face, edge or vertex hold. Since we use the regularization and smoothing in each step of the mesh history, when coming to the point of refining it further the assumptions also hold.</p>
<p>The regularization and smoothing is done in the <code>prepare_coarsening_and_refinement</code> function, which is called by <code>execute_coarsening_and_refinement</code> at the very beginning. It decides which additional cells to flag for refinement by looking at the old grid and the refinement flags for each cell.</p>
<ul>
<li>
<p class="startli"><em>Regularization:</em> The algorithm walks over all cells checking whether the present cell is flagged for refinement and a neighbor of the present cell is refined once less than the present one. If so, flag the neighbor for refinement. Because of the induction above, there may be no neighbor with level two less than the present one.</p>
<p>The neighbor thus flagged for refinement may induce more cells which need to be refined. However, such cells which need additional refinement always are on one level lower than the present one, so we can get away with only one sweep over all cells if we do the loop in the reverse way, starting with those on the highest level. This way, we may flag additional cells on lower levels, but if these induce more refinement needed, this is performed later on when we visit them in out backward running loop.</p>
<p class="endli"></p>
</li>
<li>
<em>Smoothing:</em> <ul>
<li>
<p class="startli"><code>limit_level_difference_at_vertices:</code> First a list is set up which stores for each vertex the highest level one of the adjacent cells belongs to. Now, since we did smoothing in the previous refinement steps also, each cell may only have vertices with levels at most one greater than the level of the present cell.</p>
<p>However, if we store the level plus one for cells marked for refinement, we may end up with cells which have vertices of level two greater than the cells level. We need to refine this cell also, and need thus also update the levels of its vertices. This itself may lead to cells needing refinement, but these are on lower levels, as above, which is why we may do all kinds of additional flagging in one loop only.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>eliminate_unrefined_islands:</code> For each cell we count the number of neighbors which are refined or flagged for refinement. If this exceeds the number of neighbors which are not refined and not flagged for refinement, then the current cell is flagged for refinement. Since this may lead to cells on the same level which also will need refinement, we will need additional loops of regularization and smoothing over all cells until nothing changes any more.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>eliminate_refined_*_islands</code>: This one does much the same as the above one, but for coarsening. If a cell is flagged for refinement or if all of its children are active and if the number of neighbors which are either active and not flagged for refinement, or not active but all children flagged for coarsening equals the total number of neighbors, then this cell's children are flagged for coarsening or (if this cell was flagged for refinement) the refine flag is cleared.</p>
<p>For a description of the distinction between the two versions of the flag see above in the section about mesh smoothing in the general part of this classes description.</p>
<p class="endli">The same applies as above: several loops may be necessary. </p>
</li>
</ul>
</li>
</ul>
<p>Regularization and smoothing are a bit complementary in that we check whether we need to set additional refinement flags when being on a cell flagged for refinement (regularization) or on a cell not flagged for refinement. This makes readable programming easier.</p>
<p>All the described algorithms apply only for more than one space dimension, since for one dimension no restrictions apply. It may be necessary to apply some smoothing for multigrid algorithms, but this has to be decided upon later.</p>
<h3>Warning</h3>
<p>It seems impossible to preserve <code>constness</code> of a triangulation through iterator usage. Thus, if you declare pointers to a <code>const</code> triangulation object, you should be well aware that you might involuntarily alter the data stored in the triangulation. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01121">1121</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac6506c3f82279eed1dd2ee7f1ea66dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6506c3f82279eed1dd2ee7f1ea66dc7">&#9670;&nbsp;</a></span>IteratorSelector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ac6506c3f82279eed1dd2ee7f1ea66dc7">IteratorSelector</a> =  ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt;dim, spacedim&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An internal alias to make the definition of the iterator classes simpler. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01129">1129</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ad12cedb5139eeea73fb2a3eec16636f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12cedb5139eeea73fb2a3eec16636f8">&#9670;&nbsp;</a></span>level_cell_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ad12cedb5139eeea73fb2a3eec16636f8">level_cell_iterator</a> =  <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as above to allow the usage of the "MeshType concept" also on the refinement levels. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01361">1361</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a5977e64adfde9e63f274be77bb34dddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5977e64adfde9e63f274be77bb34dddc">&#9670;&nbsp;</a></span>raw_cell_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> =  <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare a number of iterator types for raw iterators, i.e., iterators that also iterate over holes in the list of cells left by cells that have been coarsened away in previous mesh refinement cycles.</p>
<p>Since users should never have to access these internal properties of how we store data, these iterator types are made private. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03616">3616</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ad39637491c7d7e9f7bc4b7ea40a0d72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39637491c7d7e9f7bc4b7ea40a0d72b">&#9670;&nbsp;</a></span>raw_face_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ad39637491c7d7e9f7bc4b7ea40a0d72b">raw_face_iterator</a> =  <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim - 1, dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03618">3618</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a099dd8d123778fdadd882415d639d1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099dd8d123778fdadd882415d639d1b4">&#9670;&nbsp;</a></span>raw_vertex_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a099dd8d123778fdadd882415d639d1b4">raw_vertex_iterator</a> =  <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;0, dim, spacedim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03620">3620</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a0e0f7bc0b40113139b244a54591e9d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0f7bc0b40113139b244a54591e9d53">&#9670;&nbsp;</a></span>raw_line_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a> =  typename IteratorSelector::raw_line_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03621">3621</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a80735fd291dca4e5f958ee5876289aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80735fd291dca4e5f958ee5876289aa4">&#9670;&nbsp;</a></span>raw_quad_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a> =  typename IteratorSelector::raw_quad_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03622">3622</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ac2be382ff40558d007dd767a1288dc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2be382ff40558d007dd767a1288dc1e">&#9670;&nbsp;</a></span>raw_hex_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a> =  typename IteratorSelector::raw_hex_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03623">3623</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a0633dd17e535a59162b79f338c6ff5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0633dd17e535a59162b79f338c6ff5ae">&#9670;&nbsp;</a></span>MeshSmoothing</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare some symbolic names for mesh smoothing algorithms. The meaning of these flags is documented in the <a class="el" href="classTriangulation.html">Triangulation</a> class. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea9828da1d84133b33b112afd4a0ac15ec"></a>none&#160;</td><td class="fielddoc"><p>No mesh smoothing at all, except that meshes have to remain one- irregular. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc"></a>limit_level_difference_at_vertices&#160;</td><td class="fielddoc"><p>It can be shown, that degradation of approximation occurs if the triangulation contains vertices which are member of cells with levels differing by more than one. One such example is the following:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt="limit_level_difference_at_vertices.png"/>
</div>
<p> It would seem that in two space dimensions, the maximum jump in levels between cells sharing a common vertex is two (as in the example above). However, this is not true if more than four cells meet at a vertex. It is not uncommon that a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse (initial) mesh</a> contains vertices at which six or even eight cells meet, when small features of the domain have to be resolved even on the coarsest mesh. In that case, the maximum difference in levels is three or four, respectively. The problem gets even worse in three space dimensions.</p>
<p>Looking at an interpolation of the second derivative of the finite element solution (assuming bilinear finite elements), one sees that the numerical solution is almost totally wrong, compared with the true second derivative. Indeed, on regular meshes, there exist sharp estimations that the H<sup>2</sup>-error is only of order one, so we should not be surprised; however, the numerical solution may show a value for the second derivative which may be a factor of ten away from the true value. These problems are located on the small cell adjacent to the center vertex, where cells of non-subsequent levels meet, as well as on the upper and right neighbor of this cell (but with a less degree of deviation from the true value).</p>
<p>If the smoothing indicator given to the constructor contains the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">limit_level_difference_at_vertices</a>, situations as the above one are eliminated by also marking the upper right cell for refinement.</p>
<p>In case of anisotropic refinement, the level of a cell is not linked to the refinement of a cell as directly as in case of isotropic refinement. Furthermore, a cell can be strongly refined in one direction and not or at least much less refined in another. Therefore, it is very difficult to decide, which cases should be excluded from the refinement process. As a consequence, when using anisotropic refinement, the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">limit_level_difference_at_vertices</a> flag must not be set. On the other hand, the implementation of multigrid methods in deal.II requires that this bit be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f"></a>eliminate_unrefined_islands&#160;</td><td class="fielddoc"><p>Single cells which are not refined and are surrounded by cells which are refined usually also lead to a sharp decline in approximation properties locally. The reason is that the nodes on the faces between unrefined and refined cells are not real degrees of freedom but carry constraints. The patch without additional degrees of freedom is thus significantly larger then the unrefined cell itself. If in the parameter passed to the constructor the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a> is set, all cells which are not flagged for refinement but which are surrounded by more refined cells than unrefined cells are flagged for refinement. Cells which are not yet refined but flagged for that are accounted for the number of refined neighbors. Cells on the boundary are not accounted for at all. An unrefined island is, by this definition also a cell which (in 2D) is surrounded by three refined cells and one unrefined one, or one surrounded by two refined cells, one unrefined one and is at the boundary on one side. It is thus not a true island, as the name of the flag may indicate. However, no better name came to mind to the author by now. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea37c283b96070dc09dde81f51d3ce1812"></a>patch_level_1&#160;</td><td class="fielddoc"><p>A triangulation of patch level 1 consists of patches, i.e. of cells that are refined once. This flag ensures that a mesh of patch level 1 is still of patch level 1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh is of patch level 1 before calling <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a> the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that if at least one of the children of a cell is or will be refined than all children need to be refined. If the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea37c283b96070dc09dde81f51d3ce1812">patch_level_1</a> flag is set, than the flags <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a>, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58">eliminate_refined_boundary_islands</a> will be ignored as they will be fulfilled automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeae94a75f4383724ef8f58639aef2eb6c0"></a>coarsest_level_1&#160;</td><td class="fielddoc"><p>Each <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse grid</a> cell is refined at least once, i.e., the triangulation might have active cells on level 1 but not on level 0. This flag ensures that a mesh which has coarsest_level_1 has still coarsest_level_1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh has coarsest_level_1 before calling execute_coarsening_and_refinement the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that active cells on level 1 may not be coarsened.</p>
<p>The main use of this flag is to ensure that each cell has at least one neighbor in each coordinate direction (i.e. each cell has at least a left or right, and at least an upper or lower neighbor in 2d). This is a necessary precondition for some algorithms that compute finite differences between cells. The <a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a> class is one of these algorithms that require that a triangulation is coarsest_level_1 unless all cells already have at least one neighbor in each coordinate direction on the coarsest level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaa44d17458e16327fb4b674745b883910"></a>allow_anisotropic_smoothing&#160;</td><td class="fielddoc"><p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined.</p>
<p>However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements.</p>
<p>The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to step-30. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e"></a>eliminate_refined_inner_islands&#160;</td><td class="fielddoc"><p>This algorithm seeks for isolated cells which are refined or flagged for refinement. This definition is unlike that for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a>, which would mean that an island is defined as a cell which is refined but more of its neighbors are not refined than are refined. For example, in 2D, a cell's refinement would be reverted if at most one of its neighbors is also refined (or refined but flagged for coarsening).</p>
<p>The reason for the change in definition of an island is, that this option would be a bit dangerous, since if you consider a chain of refined cells (e.g. along a kink in the solution), the cells at the two ends would be coarsened, after which the next outermost cells would need to be coarsened. Therefore, only one loop of flagging cells like this could be done to avoid eating up the whole chain of refined cells (`chain reaction'...).</p>
<p>This algorithm also takes into account cells which are not actually refined but are flagged for refinement. If necessary, it takes away the refinement flag.</p>
<p>Actually there are two versions of this flag, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58">eliminate_refined_boundary_islands</a>. The first eliminates islands defined by the definition above which are in the interior of the domain, while the second eliminates only those islands if the cell is at the boundary. The reason for this split of flags is that one often wants to eliminate such islands in the interior while those at the boundary may well be wanted, for example if one refines the mesh according to a criterion associated with a boundary integral or if one has rough boundary data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58"></a>eliminate_refined_boundary_islands&#160;</td><td class="fielddoc"><p>The result of this flag is very similar to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a>. See the documentation there. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea75171630dec90d241c811d2732410303"></a>do_not_produce_unrefined_islands&#160;</td><td class="fielddoc"><p>This flag prevents the occurrence of unrefined islands. In more detail: It prohibits the coarsening of a cell if 'most of the neighbors' will be refined after the step. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea3fb6b9153821aefc45661f67f22e232a"></a>smoothing_on_refinement&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon refinement by flagging some more cells for refinement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea8d8dbaaa62136a7e51c7bf5c02d6e1e7"></a>smoothing_on_coarsening&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon coarsening by flagging some more cells for coarsening. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaf64b535fd0fad99b6032412d2cccac36"></a>maximum_smoothing&#160;</td><td class="fielddoc"><p>This flag includes all the above ones (therefore combines all smoothing algorithms implemented), with the exception of anisotropic smoothing. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01136">1136</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a1f047c753e5299ed179b042b1d014ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f047c753e5299ed179b042b1d014ee2">&#9670;&nbsp;</a></span>CellStatus</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">Triangulation::CellStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to inform functions in derived classes how the cell with the given cell_iterator is going to change. Note that this may me different than the refine_flag() and coarsen_flag() in the cell_iterator in parallel calculations because of refinement constraints that this machine does not see. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1f047c753e5299ed179b042b1d014ee2a94cffc65673af17059d03284f1f4528a"></a>CELL_PERSIST&#160;</td><td class="fielddoc"><p>The cell will not be refined or coarsened and might or might not move to a different processor. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1f047c753e5299ed179b042b1d014ee2a499cef1e66d839e3344b256fd5feb117"></a>CELL_REFINE&#160;</td><td class="fielddoc"><p>The cell will be or was refined. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1f047c753e5299ed179b042b1d014ee2a37a57cd1b9fd76f736f5e9e810011824"></a>CELL_COARSEN&#160;</td><td class="fielddoc"><p>The children of this cell will be or were coarsened into this cell. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1f047c753e5299ed179b042b1d014ee2a77e3cf6150ed62cd551424de92cc880b"></a>CELL_INVALID&#160;</td><td class="fielddoc"><p>Invalid status. Will not occur for the user. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l02025">2025</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a67f431ce66c6df985caf5587bf329ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f431ce66c6df985caf5587bf329ebc">&#9670;&nbsp;</a></span>Triangulation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td>
          <td class="paramname"><em>smooth_grid</em> = <code><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9828da1d84133b33b112afd4a0ac15ec">none</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>check_for_distorted_cells</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an empty triangulation. Do not create any cells.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">smooth_grid</td><td>Determines the level of smoothness of the mesh size function that should be enforced upon mesh refinement.</td></tr>
    <tr><td class="paramname">check_for_distorted_cells</td><td>Determines whether the triangulation should check whether any of the cells that are created by <a class="el" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">create_triangulation()</a> or <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement()</a> are distorted (see <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a>). If set, these two functions may throw an exception if they encounter distorted cells. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc766f8def6774029a22aa635270ebce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc766f8def6774029a22aa635270ebce">&#9670;&nbsp;</a></span>Triangulation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor.</p>
<p>You should really use the <code>copy_triangulation</code> function, so this constructor is deleted. The reason for this is that we may want to use triangulation objects in collections. However, C++ containers require that the objects stored in them are copyable, so we need to provide a copy constructor. On the other hand, copying triangulations is so expensive that we do not want such objects copied by accident, for example in compiler-generated temporary objects. By defining a copy constructor but throwing an error, we satisfy the formal requirements of containers, but at the same time disallow actual copies. Finally, through the exception, one easily finds the places where code has to be changed to avoid copies. </p>

</div>
</div>
<a id="af7ac8a261c841e50cddfff066c28498b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ac8a261c841e50cddfff066c28498b">&#9670;&nbsp;</a></span>Triangulation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor.</p>
<p>Create a new triangulation by stealing the internal data of another triangulation. </p>

</div>
</div>
<a id="ad9931013dff6e9094c5b525359b6e1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9931013dff6e9094c5b525359b6e1c5">&#9670;&nbsp;</a></span>~Triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::~<a class="el" href="classTriangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete the object and all levels of the hierarchy. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a9642af7c003232f90b2c2b38bf665ac4">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a98dce975e1b3377222ad0a4a14492cc7">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a98dce975e1b3377222ad0a4a14492cc7">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#ab45cc8297f71b18172a8e8442efba3fd">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#af4c6a72a040aa81c8e1b6300da184dee">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a518a862e7c4547dfb860f3cba47f534b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518a862e7c4547dfb860f3cba47f534b">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator. </p>

</div>
</div>
<a id="a12d54b7dae635d867bf8d2c4b3605817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d54b7dae635d867bf8d2c4b3605817">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset this triangulation into a virgin state by deleting all data.</p>
<p>Note that this operation is only allowed if no subscriptions to this object exist any more, such as <a class="el" href="classDoFHandler.html">DoFHandler</a> objects using it. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#af8b346b087dd89464415ecb7d2775a61">parallel::DistributedTriangulationBase&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#af8b346b087dd89464415ecb7d2775a61">parallel::DistributedTriangulationBase&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#af8b346b087dd89464415ecb7d2775a61">parallel::DistributedTriangulationBase&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a1005ad6002b51c5bc4592da7246b6a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1005ad6002b51c5bc4592da7246b6a49">&#9670;&nbsp;</a></span>get_communicator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMPI__Comm.html">MPI_Comm</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return MPI communicator used by this triangulation. In the case of a serial <a class="el" href="classTriangulation.html">Triangulation</a> object, MPI_COMM_SELF is returned. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1TriangulationBase.html#a77b606a3f26f71603f7759dc16d33db9">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a4a302f66ccc9bd281cf850fdc4f76e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a302f66ccc9bd281cf850fdc4f76e50">&#9670;&nbsp;</a></span>set_mesh_smoothing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_mesh_smoothing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td>
          <td class="paramname"><em>mesh_smoothing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the mesh smoothing to <code>mesh_smoothing</code>. This overrides the MeshSmoothing given to the constructor. It is allowed to call this function only if the triangulation is empty. </p>

</div>
</div>
<a id="a06df95bfd43216e389a132786f87474f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06df95bfd43216e389a132786f87474f">&#9670;&nbsp;</a></span>get_mesh_smoothing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_mesh_smoothing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the mesh smoothing requirements that are obeyed. </p>

</div>
</div>
<a id="a05662a55166596efb520479b495275f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05662a55166596efb520479b495275f8">&#9670;&nbsp;</a></span>get_boundary_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_boundary_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector containing all boundary indicators assigned to boundary faces of active cells of this <a class="el" href="classTriangulation.html">Triangulation</a> object. Note, that each boundary indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1TriangulationBase.html#a1e1acf0c97fceec538c4552ee300213c">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a1bca327fa47f88b58086dacc20028064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bca327fa47f88b58086dacc20028064">&#9670;&nbsp;</a></span>copy_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::copy_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other_tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy <code>other_tria</code> to this triangulation. This operation is not cheap, so you should be careful with using this. We do not implement this function as a copy constructor, since it makes it easier to maintain collections of triangulations if you can assign them values later on.</p>
<p>Keep in mind that this function also copies the pointer to the boundary descriptor previously set by the <code>set_manifold</code> function. You must therefore also guarantee that the <a class="el" href="classManifold.html">Manifold</a> objects describing the boundary have a lifetime at least as long as the copied triangulation.</p>
<p>This triangulation must be empty beforehand.</p>
<p>The function is made <code>virtual</code> since some derived classes might want to disable or extend the functionality of this function.</p>
<dl class="section note"><dt>Note</dt><dd>Calling this function triggers the 'copy' signal on other_tria, i.e. the triangulation being copied <em>from</em>. It also triggers the 'create' signal of the current triangulation. See the section on signals in the general documentation for more information.</dd>
<dd>
The list of connections to signals is not copied from the old to the new triangulation since these connections were established to monitor how the old triangulation changes, not how any triangulation it may be copied to changes. </dd></dl>

<p>Reimplemented in <a class="el" href="classPersistentTriangulation.html#a62d8ee4421ec25e3408f15613a7a9b3f">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a1b191fa3249c9c3641492b6eedebf456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b191fa3249c9c3641492b6eedebf456">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a triangulation from a list of vertices and a list of cells, each of the latter being a list of <code>1&lt;&lt;dim</code> vertex indices. The triangulation must be empty upon calling this function and the cell list should be useful (connected domain, etc.). The result of calling this function is a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse mesh</a>.</p>
<p>Material data for the cells is given within the <code>cells</code> array, while boundary information is given in the <code>subcelldata</code> field.</p>
<p>The numbering of vertices within the <code>cells</code> array is subject to some constraints; see the general class documentation for this.</p>
<p>For conditions when this function can generate a valid triangulation, see the documentation of this class, and the <a class="el" href="classGridIn.html">GridIn</a> and <a class="el" href="classGridReordering.html">GridReordering</a> class.</p>
<p>If the <code>check_for_distorted_cells</code> flag was specified upon creation of this object, at the very end of its operation, the current function walks over all cells and verifies that none of the cells is deformed (see the entry on <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a> in the glossary), where we call a cell deformed if the determinant of the Jacobian of the mapping from reference cell to real cell is negative at least at one of the vertices (this computation is done using the GeometryInfo::jacobian_determinants_at_vertices function). If there are deformed cells, this function throws an exception of kind <a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a>. Since this happens after all data structures have been set up, you can catch and ignore this exception if you know what you do &ndash; for example, it may be that the determinant is zero (indicating that you have collapsed edges in a cell) but that this is ok because you didn't intend to integrate on this cell anyway. On the other hand, deformed cells are often a sign of a mesh that is too coarse to resolve the geometry of the domain, and in this case ignoring the exception is probably unwise.</p>
<dl class="section note"><dt>Note</dt><dd>This function is used in step-14 and step-19.</dd>
<dd>
This function triggers the "create" signal after doing its work. See the section on signals in the general documentation of this class. For example as a consequence of this, all <a class="el" href="classDoFHandler.html">DoFHandler</a> objects connected to this triangulation will be reinitialized via <a class="el" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">DoFHandler::reinit()</a>.</dd>
<dd>
The check for distorted cells is only done if dim==spacedim, as otherwise cells can legitimately be twisted if the manifold they describe is twisted. </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a85f8516b5fe9b8fc6e8784c987f9263f">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#acfae842f71530f4671a96f1ab3cc4080">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPersistentTriangulation.html#ac411e19b10ae782223450271c249358b">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aa80c37d5d647831736e40e4ffb0e0ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80c37d5d647831736e40e4ffb0e0ee2">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>construction_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a triangulation from the provided <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Don't forget to attach the manifolds with <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold()</a> before calling this function if manifolds are needed.</dd>
<dd>
The namespace <a class="el" href="namespaceTriangulationDescription_1_1Utilities.html">TriangulationDescription::Utilities</a> contains functions to create <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">construction_data</td><td>The data needed for this process. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a80369486f903cb4477e46b3e63ce18df">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a1ed7dd9e6b28eed51e33c72ff302746d">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#ac497f405da11cf43ab7e7256aba7fff4">PersistentTriangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ab48fdb4ee1b3e1bd162a7ab09adcfa3c">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="abbbee6e665998c3e4a745cd7836df364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbee6e665998c3e4a745cd7836df364">&#9670;&nbsp;</a></span>create_triangulation_compatibility()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_triangulation_compatibility </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For backward compatibility, only. This function takes the cell data in the ordering as requested by deal.II versions up to 5.2, converts it to the new (lexicographic) ordering and calls <a class="el" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">create_triangulation()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function internally calls create_triangulation and therefore can throw the same exception as the other function. </dd></dl>

<p>Reimplemented in <a class="el" href="classPersistentTriangulation.html#ad6215eb2339ec45320d5858ccae5aab6">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="afdc34248a9ba0c38fd0020256a8def5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc34248a9ba0c38fd0020256a8def5c">&#9670;&nbsp;</a></span>flip_all_direction_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::flip_all_direction_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Revert or flip the direction_flags of a dim&lt;spacedim triangulation, see <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a>.</p>
<p>This function throws an exception if dim equals spacedim. </p>

</div>
</div>
<a id="aed8e461d4b2b23a0e1730afdef36e694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8e461d4b2b23a0e1730afdef36e694">&#9670;&nbsp;</a></span>set_all_refine_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_refine_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag all active cells for refinement. This will refine all cells of all levels which are not already refined (i.e. only cells are refined which do not yet have children). The cells are only flagged, not refined, thus you have the chance to save the refinement flags. </p>

</div>
</div>
<a id="a6ad0b3fb24aae17f4668427a433dea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad0b3fb24aae17f4668427a433dea19">&#9670;&nbsp;</a></span>refine_global()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::refine_global </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine all cells <code>times</code> times. In other words, in each one of the <code>times</code> iterations, loop over all cells and refine each cell uniformly into \(2^\text{dim}\) children. In practice, this function repeats the following operations <code>times</code> times: call <a class="el" href="classTriangulation.html#aed8e461d4b2b23a0e1730afdef36e694">set_all_refine_flags()</a> followed by <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement()</a>. The end result is that the number of cells increases by a factor of \((2^\text{dim})^\text{times}=2^{\text{dim} \times \text{times}}\).</p>
<p>The <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement()</a> function called in this loop may throw an exception if it creates cells that are distorted (see its documentation for an explanation). This exception will be propagated through this function if that happens, and you may not get the actual number of refinement steps in that case.</p>
<dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing each individual refinement cycle (i.e. more than once if <code>times &gt; 1</code>) . See the section on signals in the general documentation of this class. </dd></dl>

</div>
</div>
<a id="a6552fa04ee753657bd9f92571d76cf09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6552fa04ee753657bd9f92571d76cf09">&#9670;&nbsp;</a></span>coarsen_global()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarsen_global </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Coarsen all cells the given number of times.</p>
<p>In each of one of the <code>times</code> iterations, all cells will be marked for coarsening. If an active cell is already on the coarsest level, it will be ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing each individual coarsening cycle (i.e. more than once if <code>times &gt; 1</code>) . See the section on signals in the general documentation of this class. </dd></dl>

</div>
</div>
<a id="aaedd900205c1879d8d9ef6ffe7d1a554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaedd900205c1879d8d9ef6ffe7d1a554">&#9670;&nbsp;</a></span>execute_coarsening_and_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute both refinement and coarsening of the triangulation.</p>
<p>The function resets all refinement and coarsening flags to false. It uses the user flags for internal purposes. They will therefore be overwritten by undefined content.</p>
<p>To allow user programs to fix up these cells if that is desired, this function after completing all other work may throw an exception of type <a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a> that contains a list of those cells that have been refined and have at least one child that is distorted. The function does not create such an exception if no cells have created distorted children. Note that for the check for distorted cells to happen, the <code>check_for_distorted_cells</code> flag has to be specified upon creation of a triangulation object.</p>
<p>See the general docs for more information.</p>
<dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing its work. See the section on signals in the general documentation of this class.</dd>
<dd>
If the boundary description is sufficiently irregular, it can happen that some of the children produced by mesh refinement are distorted (see the extensive discussion on <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a>).</dd>
<dd>
This function is <code>virtual</code> to allow derived classes to insert hooks, such as saving refinement flags and the like (see e.g. the <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a> class). </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a9dba428552f512e0859a9b6a06ad3b7e">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#af70d34d31ac2cc97cd8a650b7a82f5bc">parallel::shared::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a735a59b65d44af0081dc06a2e58facb2">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPersistentTriangulation.html#a3db24bddb2e9013086c7a33a4fc506d5">PersistentTriangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="abf55199c30b0330cf9bf98e2582078e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf55199c30b0330cf9bf98e2582078e1">&#9670;&nbsp;</a></span>prepare_coarsening_and_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::prepare_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do both preparation for refinement and coarsening as well as mesh smoothing.</p>
<p>Regarding the refinement process it fixes the closure of the refinement in <code>dim&gt;=2</code> (make sure that no two cells are adjacent with a refinement level differing with more than one), etc. It performs some mesh smoothing if the according flag was given to the constructor of this class. The function returns whether additional cells have been flagged for refinement.</p>
<p>See the general doc of this class for more information on smoothing upon refinement.</p>
<p>Regarding the coarsening part, flagging and deflagging cells in preparation of the actual coarsening step are done. This includes deleting coarsen flags from cells which may not be deleted (e.g. because one neighbor is more refined than the cell), doing some smoothing, etc.</p>
<p>The effect is that only those cells are flagged for coarsening which will actually be coarsened. This includes the fact that all flagged cells belong to parent cells of which all children are flagged.</p>
<p>The function returns whether some cells' flagging has been changed in the process.</p>
<p>This function uses the user flags, so store them if you still need them afterwards. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a72f1055d0943aa43610c131091159cbe">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aca5cfa9068a5d3ad32dfca87e2901a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5cfa9068a5d3ad32dfca87e2901a87">&#9670;&nbsp;</a></span>save_refine_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the addresses of the cells which are flagged for refinement to <code>out</code>. For usage, read the general documentation for this class. </p>

</div>
</div>
<a id="affce5fca29acccbb2dc1294ebe404a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affce5fca29acccbb2dc1294ebe404a03">&#9670;&nbsp;</a></span>save_refine_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

</div>
</div>
<a id="a43fc07c3f9e1f02658ca556f41087c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fc07c3f9e1f02658ca556f41087c85">&#9670;&nbsp;</a></span>load_refine_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="ac924a05e66d5e76458ad088a2b7b5583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac924a05e66d5e76458ad088a2b7b5583">&#9670;&nbsp;</a></span>load_refine_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="af64b6155fd89f8f29d4c02795c1a10d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64b6155fd89f8f29d4c02795c1a10d9">&#9670;&nbsp;</a></span>save_coarsen_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analogue to <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="abaaecbe89311fdaa8a9b999209ff9155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaaecbe89311fdaa8a9b999209ff9155">&#9670;&nbsp;</a></span>save_coarsen_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

</div>
</div>
<a id="aa4029122ffe741f843f2f3a7deeceea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4029122ffe741f843f2f3a7deeceea9">&#9670;&nbsp;</a></span>load_coarsen_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

</div>
</div>
<a id="a48a9463dcf9aeb3a69831e5e1a321053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a9463dcf9aeb3a69831e5e1a321053">&#9670;&nbsp;</a></span>load_coarsen_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

</div>
</div>
<a id="a178e9ce017916f190ddf7a734ef15902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178e9ce017916f190ddf7a734ef15902">&#9670;&nbsp;</a></span>get_anisotropic_refinement_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_anisotropic_refinement_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this triangulation has ever undergone anisotropic (as opposed to only isotropic) refinement. </p>

</div>
</div>
<a id="aaa726b33b52f694cfca48fae8e761661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa726b33b52f694cfca48fae8e761661">&#9670;&nbsp;</a></span>clear_user_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all user flags. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a6a9971ee882f15fe521afc4e079383b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9971ee882f15fe521afc4e079383b5">&#9670;&nbsp;</a></span>save_user_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save all user flags. See the general documentation for this class and the documentation for the <code>save_refine_flags</code> for more details. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="aad25280beb6c2607418a0d3e903819a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad25280beb6c2607418a0d3e903819a3">&#9670;&nbsp;</a></span>save_user_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="af3612ed3c7f7f9cccd3003d85b6f7350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3612ed3c7f7f9cccd3003d85b6f7350">&#9670;&nbsp;</a></span>load_user_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="ac17946286639b12a03804ebc400eab51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17946286639b12a03804ebc400eab51">&#9670;&nbsp;</a></span>load_user_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="af8896f8e838dd34ed5b7c1aa351f76f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8896f8e838dd34ed5b7c1aa351f76f5">&#9670;&nbsp;</a></span>clear_user_flags_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a2b7d8e059d6f8f903879eea858215fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7d8e059d6f8f903879eea858215fb8">&#9670;&nbsp;</a></span>save_user_flags_line() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a02adea7b298cd5047ee5a5755f87ae36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02adea7b298cd5047ee5a5755f87ae36">&#9670;&nbsp;</a></span>save_user_flags_line() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a25190c31d16cde2a01fa0f2318aa0b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25190c31d16cde2a01fa0f2318aa0b74">&#9670;&nbsp;</a></span>load_user_flags_line() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a87294511c2f203a57531aaaf2bd2ce39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87294511c2f203a57531aaaf2bd2ce39">&#9670;&nbsp;</a></span>load_user_flags_line() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a1dd263157214206ceb637c402552f0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd263157214206ceb637c402552f0eb">&#9670;&nbsp;</a></span>clear_user_flags_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="acf4a2db0492d38971366bfcd159cbbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4a2db0492d38971366bfcd159cbbc1">&#9670;&nbsp;</a></span>save_user_flags_quad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a431026974872f49e59f6a799ee0a19d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431026974872f49e59f6a799ee0a19d6">&#9670;&nbsp;</a></span>save_user_flags_quad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a5e868cde85c04bcc8cec82ba09f24e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e868cde85c04bcc8cec82ba09f24e7b">&#9670;&nbsp;</a></span>load_user_flags_quad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a8651e0def48d61e3f8f0aa8051ae5985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8651e0def48d61e3f8f0aa8051ae5985">&#9670;&nbsp;</a></span>load_user_flags_quad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a7cbe198bb49c3135378bb680582afd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbe198bb49c3135378bb680582afd46">&#9670;&nbsp;</a></span>clear_user_flags_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a1d5512376f914359303ce7d4666d550b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5512376f914359303ce7d4666d550b">&#9670;&nbsp;</a></span>save_user_flags_hex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user flags on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="ae57c92493d66995cf29bef79f0e8e09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57c92493d66995cf29bef79f0e8e09b">&#9670;&nbsp;</a></span>save_user_flags_hex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a6e15f4d848adbe6c8bf1af374e467a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e15f4d848adbe6c8bf1af374e467a31">&#9670;&nbsp;</a></span>load_user_flags_hex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a77e827086d26927d08129c8489fdcd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e827086d26927d08129c8489fdcd45">&#9670;&nbsp;</a></span>load_user_flags_hex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a26562806fd764afdffb973dce92554e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26562806fd764afdffb973dce92554e8">&#9670;&nbsp;</a></span>clear_user_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all user pointers and indices and allow the use of both for next access. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="ae3794cd2d7f80bd81f69fcb828535412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3794cd2d7f80bd81f69fcb828535412">&#9670;&nbsp;</a></span>save_user_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save all user indices. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a12a2359968a027a8b14ae381c8886d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a2359968a027a8b14ae381c8886d30">&#9670;&nbsp;</a></span>load_user_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#ae3794cd2d7f80bd81f69fcb828535412">save_user_indices()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a03a41f6c10b5db7d540a9df15742ebf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a41f6c10b5db7d540a9df15742ebf0">&#9670;&nbsp;</a></span>save_user_pointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save all user pointers. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a2f8891e8277a047b9dd4fe86943d1321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8891e8277a047b9dd4fe86943d1321">&#9670;&nbsp;</a></span>load_user_pointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#a03a41f6c10b5db7d540a9df15742ebf0">save_user_pointers()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a451b2af8e62783f4780552088fd9ad88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451b2af8e62783f4780552088fd9ad88">&#9670;&nbsp;</a></span>save_user_indices_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a7b2160dd04545294d138ca00deb4af42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2160dd04545294d138ca00deb4af42">&#9670;&nbsp;</a></span>load_user_indices_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user indices located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a8d65cc99c33ea13361700a58ff9d6686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d65cc99c33ea13361700a58ff9d6686">&#9670;&nbsp;</a></span>save_user_indices_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user indices on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a1020c09b32fbb78156b00b833271e21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1020c09b32fbb78156b00b833271e21d">&#9670;&nbsp;</a></span>load_user_indices_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user indices located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a8a18d1c25ca9c0b7cef07c6e92fdd28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a18d1c25ca9c0b7cef07c6e92fdd28f">&#9670;&nbsp;</a></span>save_user_indices_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user indices on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="abad8869b9c8234d6c81c24c69dd97d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad8869b9c8234d6c81c24c69dd97d39">&#9670;&nbsp;</a></span>load_user_indices_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user indices located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a699d7c1b73eccc41bc53009003ab3d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699d7c1b73eccc41bc53009003ab3d28">&#9670;&nbsp;</a></span>save_user_pointers_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a879d77427982a2d69d2dd9512d4ba6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879d77427982a2d69d2dd9512d4ba6c9">&#9670;&nbsp;</a></span>load_user_pointers_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user pointers located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a7d27b23e1d873b38817d08b7bb6884f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d27b23e1d873b38817d08b7bb6884f8">&#9670;&nbsp;</a></span>save_user_pointers_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user pointers on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a4f771811ec221a4ca0c49f3a09164fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f771811ec221a4ca0c49f3a09164fec">&#9670;&nbsp;</a></span>load_user_pointers_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user pointers located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="ac42ad416119dff0589b8b67dd3de02e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42ad416119dff0589b8b67dd3de02e8">&#9670;&nbsp;</a></span>save_user_pointers_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the user pointers on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a03dad0c49d2423e8c4410efcc773ad82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03dad0c49d2423e8c4410efcc773ad82">&#9670;&nbsp;</a></span>load_user_pointers_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the user pointers located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a36fb6b15f119483143c433dd10df9b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fb6b15f119483143c433dd10df9b26">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator to the first used cell on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="afe6c58805fe436a94b141c1585606c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6c58805fe436a94b141c1585606c7f">&#9670;&nbsp;</a></span>begin_active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator to the first active cell on level <code>level</code>. If the given level does not contain any active cells (i.e., all cells on this level are further refined, then this function returns <code>end_active(level)</code> so that loops of the kind </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> cell=tria.<a class="code" href="classTriangulation.html#afe6c58805fe436a94b141c1585606c7f">begin_active</a>(level);</div><div class="line">     cell!=tria.<a class="code" href="classTriangulation.html#ab0967cc6653ea9a08e94fe9da4d11793">end_active</a>(level);</div><div class="line">     ++cell)</div><div class="line">  {</div><div class="line">    ...</div><div class="line">  }</div></div><!-- fragment --><p> have zero iterations, as may be expected if there are no active cells on this level.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a92c41c89a9cf1e020050985822196dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c41c89a9cf1e020050985822196dff">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a9597b118c84fce0addf7f4db3b067659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9597b118c84fce0addf7f4db3b067659">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator which is the first iterator not on level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="ab0967cc6653ea9a08e94fe9da4d11793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0967cc6653ea9a08e94fe9da4d11793">&#9670;&nbsp;</a></span>end_active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an active iterator which is the first active iterator not on the given level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="ab51f6fbd9bcd9e41757039a7b4954d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51f6fbd9bcd9e41757039a7b4954d2a">&#9670;&nbsp;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last used cell. </p>

</div>
</div>
<a id="a2eb00096abe5ef91413440e1e1b66c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb00096abe5ef91413440e1e1b66c00">&#9670;&nbsp;</a></span>last_active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last active cell. </p>

</div>
</div>
<a id="a367c0bd718b0ae9316f3b6f52d0ff4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367c0bd718b0ae9316f3b6f52d0ff4c6">&#9670;&nbsp;</a></span>create_cell_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_cell_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCellId.html">CellId</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to a cell of this <a class="el" href="classTriangulation.html">Triangulation</a> object constructed from an independent <a class="el" href="classCellId.html">CellId</a> object.</p>
<p>If the given argument corresponds to a valid cell in this triangulation, this operation will always succeed for sequential triangulations where the current processor stores all cells that are part of the triangulation. On the other hand, if this is a parallel triangulation, then the current processor may not actually know about this cell. In this case, this operation will succeed for locally relevant cells, but may not for artificial cells that are less refined on the current processor. </p>

</div>
</div>
<a id="abd8e77917e8512bd1e70bf180929f407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8e77917e8512bd1e70bf180929f407">&#9670;&nbsp;</a></span>begin_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator to the first used face. </p>

</div>
</div>
<a id="af7e8d4115aad4a2a5c97a7f7c06d34d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e8d4115aad4a2a5c97a7f7c06d34d5">&#9670;&nbsp;</a></span>begin_active_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator to the first active face. </p>

</div>
</div>
<a id="a359dfdc82f2269b68b1d30c8a2286c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359dfdc82f2269b68b1d30c8a2286c6f">&#9670;&nbsp;</a></span>end_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="aa76498325599ace7304627cb64e5fcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76498325599ace7304627cb64e5fcd2">&#9670;&nbsp;</a></span>begin_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator to the first used vertex. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="a0e8705fe160c08af9a2372c605525ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8705fe160c08af9a2372c605525ef0">&#9670;&nbsp;</a></span>begin_active_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator to the first active vertex. Because all vertices are active, <a class="el" href="classTriangulation.html#aa76498325599ace7304627cb64e5fcd2">begin_vertex()</a> and <a class="el" href="classTriangulation.html#a0e8705fe160c08af9a2372c605525ef0">begin_active_vertex()</a> return the same vertex. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="aaad93f466afba9b3f003d09a685a615f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad93f466afba9b3f003d09a685a615f">&#9670;&nbsp;</a></span>end_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="a46edbe1027405ca9545e3c2289eb3938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46edbe1027405ca9545e3c2289eb3938">&#9670;&nbsp;</a></span>n_lines() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the following, most functions are provided in two versions, with and without an argument describing the level. The versions with this argument are only applicable for objects describing the cells of the present triangulation. For example: in 2D <code>n_lines(level)</code> cannot be called, only <code><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a></code>, as lines are faces in 2D and therefore have no level. Return the total number of used lines, active or not. </p>

</div>
</div>
<a id="aee5ba9d51dfdd307da590e31c9262c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5ba9d51dfdd307da590e31c9262c28">&#9670;&nbsp;</a></span>n_lines() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of used lines, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="a76c9d6f7b2068f5afa429020086b6b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c9d6f7b2068f5afa429020086b6b8c">&#9670;&nbsp;</a></span>n_active_lines() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of active lines. </p>

</div>
</div>
<a id="a21d30203bdeaa3b9e2b416f24b7e9d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d30203bdeaa3b9e2b416f24b7e9d6d">&#9670;&nbsp;</a></span>n_active_lines() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of active lines, on level <code>level</code>. </p>

</div>
</div>
<a id="a105d0305d8c801076bea2404087f29a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105d0305d8c801076bea2404087f29a7">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of used quads, active or not. </p>

</div>
</div>
<a id="af0817fceed7429359f89928eec87d381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0817fceed7429359f89928eec87d381">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of used quads, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="ab7a0837c6dabdda21930bf3d49e9852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a0837c6dabdda21930bf3d49e9852d">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of active quads, active or not. </p>

</div>
</div>
<a id="abf97ad6187b553b2980043dd1c8d75db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf97ad6187b553b2980043dd1c8d75db">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of active quads, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="aaa75fe811e9d1707ce798f874aa2e117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa75fe811e9d1707ce798f874aa2e117">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of used hexahedra, active or not. </p>

</div>
</div>
<a id="a015bc7a2fecb2cba52050a8f2bfbafe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015bc7a2fecb2cba52050a8f2bfbafe1">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of used hexahedra, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="aee621a8e59e259c252ccc64f19e37301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee621a8e59e259c252ccc64f19e37301">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of active hexahedra, active or not. </p>

</div>
</div>
<a id="ade8bbb4c8ffd9f8adb683b39a82a9b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8bbb4c8ffd9f8adb683b39a82a9b1e">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of active hexahedra, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="abea687f123f3f5a8b09d7485cf03be72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea687f123f3f5a8b09d7485cf03be72">&#9670;&nbsp;</a></span>n_cells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of used cells, active or not. Maps to <code><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a></code> in one space dimension and so on. </p>

</div>
</div>
<a id="a40c5623c62d2e43aa63f1eb4904eeec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c5623c62d2e43aa63f1eb4904eeec8">&#9670;&nbsp;</a></span>n_cells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of used cells, active or not, on level <code>level</code>. Maps to <code>n_lines(level)</code> in one space dimension and so on. </p>

</div>
</div>
<a id="a5ea5c9957dbb566a562bbe2c0f3971e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea5c9957dbb566a562bbe2c0f3971e9">&#9670;&nbsp;</a></span>n_active_cells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of active cells. Maps to <code><a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines()</a></code> in one space dimension and so on. </p>

</div>
</div>
<a id="a05502400e5b4bdd3bb7e0fd410fdf0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05502400e5b4bdd3bb7e0fd410fdf0fb">&#9670;&nbsp;</a></span>n_global_active_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_global_active_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active cells. For the current class, this is the same as <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells()</a>. However, the function may be overloaded in derived classes (e.g., in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>) where it may return a value greater than the number of active cells reported by the triangulation object on the current processor. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1TriangulationBase.html#a46548d5ed479030dbc75d8fbb2b68d11">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a3d106ed8c9a29d6bb7d2bfb636f8df62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d106ed8c9a29d6bb7d2bfb636f8df62">&#9670;&nbsp;</a></span>n_active_cells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of active cells on level <code>level</code>. Maps to <code>n_active_lines(level)</code> in one space dimension and so on. </p>

</div>
</div>
<a id="a1bff048d1ed54471bbd2dcfc76a46523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bff048d1ed54471bbd2dcfc76a46523">&#9670;&nbsp;</a></span>n_global_coarse_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_global_coarse_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of coarse cells. If the coarse mesh is replicated on each process, this simply returns <code>n_cells(0)</code>. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1TriangulationBase.html#ae5d830897853a1098344e718dd878147">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a1e297d311818e3a79bcede5804f51065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e297d311818e3a79bcede5804f51065">&#9670;&nbsp;</a></span>n_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of used faces, active or not. In 2D, the result equals <a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a>, in 3D it equals <a class="el" href="classTriangulation.html#a105d0305d8c801076bea2404087f29a7">n_quads()</a>, while in 1D it equals the number of used vertices. </p>

</div>
</div>
<a id="a5ae907d55b3b12c5c75e58174c1781ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae907d55b3b12c5c75e58174c1781ff">&#9670;&nbsp;</a></span>n_active_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of active faces. In 2D, the result equals <a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines()</a>, in 3D it equals <a class="el" href="classTriangulation.html#ab7a0837c6dabdda21930bf3d49e9852d">n_active_quads()</a>, while in 1D it equals the number of used vertices. </p>

</div>
</div>
<a id="a777f035a17e91a4d822971516ca11db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777f035a17e91a4d822971516ca11db5">&#9670;&nbsp;</a></span>n_levels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_levels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of levels in this triangulation.</p>
<dl class="section note"><dt>Note</dt><dd>Internally, triangulations store data in levels, and there may be more levels in this data structure than one may think &ndash; for example, imagine a triangulation that we just got by coarsening the highest level so that it was completely depopulated. That level is not removed, since it will most likely be repopulated soon by the next refinement process. As a consequence, if you happened to run through raw cell iterators (which you can't do as a user of this class, but can internally), then the number of objects in the levels hierarchy is larger than the level of the most refined cell plus one. On the other hand, since this is rarely what a user of this class cares about, the function really just returns the level of the most refined active cell plus one. (The plus one is because in a coarse, unrefined mesh, all cells have level zero &ndash; making the number of levels equal to one.) </dd></dl>

</div>
</div>
<a id="aafd960d483675c4eb2c538529350e56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd960d483675c4eb2c538529350e56b">&#9670;&nbsp;</a></span>n_global_levels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_global_levels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of levels in use. This function is equivalent to <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> for a serial <a class="el" href="classTriangulation.html">Triangulation</a>, but gives the maximum of <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> over all processors for a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> and therefore can be larger than <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1TriangulationBase.html#ab94c22b8116e1b5f4284ae01b221a2e2">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a935cc3b953d71fe4081fa8f88820f034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935cc3b953d71fe4081fa8f88820f034">&#9670;&nbsp;</a></span>has_hanging_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::has_hanging_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the triangulation has hanging nodes.</p>
<p>The function is made virtual since the result can be interpreted in different ways, depending on whether the triangulation lives only on a single processor, or may be distributed as done in the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class (see there for a description of what the function is supposed to do in the parallel context). </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a569306c9c8e694e3006f8fafa035f0ce">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a569306c9c8e694e3006f8fafa035f0ce">parallel::distributed::Triangulation&lt; dim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ad8f243bcd205946abc5c9bea8ad323af">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ae1aadc2300ef9a6f2368fe7bc5926fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1aadc2300ef9a6f2368fe7bc5926fe8">&#9670;&nbsp;</a></span>n_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of vertices. Some of them may not be used, which usually happens upon coarsening of a triangulation when some vertices are discarded, but we do not want to renumber the remaining ones, leading to holes in the numbers of used vertices. You can get the number of used vertices using <code>n_used_vertices</code> function. </p>

</div>
</div>
<a id="afb3059d54432e0d739534e5330bb7b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3059d54432e0d739534e5330bb7b3a">&#9670;&nbsp;</a></span>get_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant reference to all the vertices present in this triangulation. Note that not necessarily all vertices in this array are actually used; for example, if you coarsen a mesh, then some vertices are deleted, but their positions in this array are unchanged as the indices of vertices are only allocated once. You can find out about which vertices are actually used by the function <a class="el" href="classTriangulation.html#a07690a619d2817f4c8ef3bb74c43b80a">get_used_vertices()</a>. </p>

</div>
</div>
<a id="a76937acd9dfc3ade1fb885c7ab1ae776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76937acd9dfc3ade1fb885c7ab1ae776">&#9670;&nbsp;</a></span>n_used_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_used_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of vertices that are presently in use, i.e. belong to at least one used element. </p>

</div>
</div>
<a id="aab2295fdb4bfc8ab41f51cdbc34de449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2295fdb4bfc8ab41f51cdbc34de449">&#9670;&nbsp;</a></span>vertex_used()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertex_used </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <code>true</code> if the vertex with this <code>index</code> is used. </p>

</div>
</div>
<a id="a07690a619d2817f4c8ef3bb74c43b80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07690a619d2817f4c8ef3bb74c43b80a">&#9670;&nbsp;</a></span>get_used_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_used_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant reference to the array of <code>bools</code> indicating whether an entry in the vertex array is used or not. </p>

</div>
</div>
<a id="aa6313a19a8cc20e07249978218b5ca6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6313a19a8cc20e07249978218b5ca6a">&#9670;&nbsp;</a></span>max_adjacent_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::max_adjacent_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximum number of cells meeting at a common vertex. Since this number is an invariant under refinement, only the cells on the coarsest level are considered. The operation is thus reasonably fast. The invariance is only true for sufficiently many cells in the coarsest triangulation (e.g. for a single cell one would be returned), so a minimum of four is returned in two dimensions, 8 in three dimensions, etc, which is how many cells meet if the triangulation is refined.</p>
<p>In one space dimension, two is returned. </p>

</div>
</div>
<a id="a5827cdfafd5fef99803cde97b70e86bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5827cdfafd5fef99803cde97b70e86bc">&#9670;&nbsp;</a></span>locally_owned_subdomain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::locally_owned_subdomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function always returns <code>invalid_subdomain_id</code> but is there for compatibility with the derived <code><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a></code> class. For distributed parallel triangulations this function returns the subdomain id of those cells that are owned by the current processor. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1TriangulationBase.html#a41b129156d89f37482d2095de5751d9c">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="acbcac8668993d582f192d3c85b642dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcac8668993d582f192d3c85b642dd3">&#9670;&nbsp;</a></span>get_triangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the current object.</p>
<p>This doesn't seem to be very useful but allows to write code that can access the underlying triangulation for anything that satisfies the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a> (which may not only be a triangulation, but also a <a class="el" href="classDoFHandler.html">DoFHandler</a>, for example). </p>

</div>
</div>
<a id="aae427477f592d34c1bf3367e408f90c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae427477f592d34c1bf3367e408f90c3">&#9670;&nbsp;</a></span>get_triangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the current object. This is the const-version of the previous function. </p>

</div>
</div>
<a id="a4a466c6b1755b353d43ce8827b1518e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a466c6b1755b353d43ce8827b1518e3">&#9670;&nbsp;</a></span>n_raw_lines() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Total number of lines, used or unused.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a615e8e8877a420fede76cea831f6ca52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615e8e8877a420fede76cea831f6ca52">&#9670;&nbsp;</a></span>n_raw_lines() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of lines, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="abbcdcdaea38195ba043370ddc6202224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcdcdaea38195ba043370ddc6202224">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Total number of quads, used or unused.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a9f590c6799cf3bb79c3c810f972a117e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f590c6799cf3bb79c3c810f972a117e">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of quads, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="aed5a359c972a4679b5ff1be96b68efc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5a359c972a4679b5ff1be96b68efc1">&#9670;&nbsp;</a></span>n_raw_hexs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of hexs, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a947c26f9d04c1b4a4fb190334ebd1542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947c26f9d04c1b4a4fb190334ebd1542">&#9670;&nbsp;</a></span>n_raw_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of cells, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a5a7926c72a24cc478de8217c1f6988e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7926c72a24cc478de8217c1f6988e0">&#9670;&nbsp;</a></span>n_raw_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of faces, used or not. In 2d, the result equals <a class="el" href="classTriangulation.html#a4a466c6b1755b353d43ce8827b1518e3">n_raw_lines()</a>, in 3d it equals <a class="el" href="classTriangulation.html#abbcdcdaea38195ba043370ddc6202224">n_raw_quads()</a>, while in 1D it equals the number of vertices.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a4a63bdde5124e79a1370f29499128518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a63bdde5124e79a1370f29499128518">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object.</p>
<p>This function is made virtual, since a triangulation object might be accessed through a pointer to this base class, even if the actual object is a derived class. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#afa0357cc88e13176507540d7f2524123">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#afa0357cc88e13176507540d7f2524123">parallel::distributed::Triangulation&lt; dim &gt;</a>, <a class="el" href="classPersistentTriangulation.html#a17b9533b25ed580656f17c823bad0cf9">PersistentTriangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a4206cfa0fd0e262368df09b97199d183">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1TriangulationBase.html#ad8baa2e614b9868460a7a0f3cbc6d3de">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a2f0c10f7a8cd32d961e9367173685047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0c10f7a8cd32d961e9367173685047">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not save <em>all</em> member variables of the current triangulation. Rather, only certain kinds of information are stored. For more information see the general documentation of this class. </dd></dl>

</div>
</div>
<a id="ae2f72d5fbb277ec65dbe0382ae72a929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f72d5fbb277ec65dbe0382ae72a929">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. Throw away the previous content.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not reset <em>all</em> member variables of the current triangulation to the ones of the triangulation that was previously stored to an archive. Rather, only certain kinds of information are loaded. For more information see the general documentation of this class.</dd>
<dd>
This function calls the <a class="el" href="classTriangulation.html#a12d54b7dae635d867bf8d2c4b3605817">Triangulation::clear()</a> function and consequently triggers the "clear" signal. After loading all data from the archive, it then triggers the "create" signal. For more information on signals, see the general documentation of this class. </dd></dl>

</div>
</div>
<a id="a7117ea716b516ef11a205a5d0020fe40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7117ea716b516ef11a205a5d0020fe40">&#9670;&nbsp;</a></span>add_periodicity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::add_periodicity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare the (coarse) face pairs given in the argument of this function as periodic. This way it is possible to obtain neighbors across periodic boundaries.</p>
<p>The vector can be filled by the function <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>.</p>
<p>For more information on periodic boundary conditions see <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>, <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints</a> and step-45.</p>
<dl class="section note"><dt>Note</dt><dd>Before this function can be used the <a class="el" href="classTriangulation.html">Triangulation</a> has to be initialized and must not be refined. </dd></dl>

</div>
</div>
<a id="ac34318b9fb11fa49f10ba7c5155960c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34318b9fb11fa49f10ba7c5155960c6">&#9670;&nbsp;</a></span>get_periodic_face_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::pair&lt;<a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, std::pair&lt;std::pair&lt;<a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, std::bitset&lt;3&gt; &gt; &gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_periodic_face_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the periodic_face_map. </p>

</div>
</div>
<a id="af4f08d0df83f6455dbdac86c1a0736b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f08d0df83f6455dbdac86c1a0736b8">&#9670;&nbsp;</a></span>get_reference_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classReferenceCell.html">ReferenceCell</a>&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_reference_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return vector filled with the used reference-cell types of this triangulation. </p>

</div>
</div>
<a id="a24c84e9fa932ccd35820fe68abfe1348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c84e9fa932ccd35820fe68abfe1348">&#9670;&nbsp;</a></span>all_reference_cells_are_hyper_cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::all_reference_cells_are_hyper_cube </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicate if the triangulation only consists of hypercube-like cells, i.e., lines, quadrilaterals, or hexahedra. </p>

</div>
</div>
<a id="ac70afc9a4f52455c18183ab31dd6789f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70afc9a4f52455c18183ab31dd6789f">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization. using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="a45bb19508b89ac6ed237b14bf7a506ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bb19508b89ac6ed237b14bf7a506ef">&#9670;&nbsp;</a></span>begin_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first cell, used or not, on level <code>level</code>. If a level has no cells, a past-the-end iterator is returned. </p>

</div>
</div>
<a id="a5cbfc1e5187c6ad0a47d1b616f9f5149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbfc1e5187c6ad0a47d1b616f9f5149">&#9670;&nbsp;</a></span>end_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a5977e64adfde9e63f274be77bb34dddc">raw_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_raw </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a raw iterator which is the first iterator not on level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a></code>. </p>

</div>
</div>
<a id="af97878288a5eca64303abe53572ea159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97878288a5eca64303abe53572ea159">&#9670;&nbsp;</a></span>begin_raw_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a0e0f7bc0b40113139b244a54591e9d53">raw_line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first line, used or not, on level <code>level</code>. If a level has no lines, a past-the-end iterator is returned. If lines are no cells, i.e. for <code>dim&gt;1</code> no <code>level</code> argument must be given. The same applies for all the other functions above, of course. </p>

</div>
</div>
<a id="aa50f2b3deed6e5f99e91768266df1d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50f2b3deed6e5f99e91768266df1d6e">&#9670;&nbsp;</a></span>begin_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used line on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a8d3efa7416e6b56419ffab72ac227a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3efa7416e6b56419ffab72ac227a4a">&#9670;&nbsp;</a></span>begin_active_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active line on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a5cf640d5b174cae0f46e415c3fe39db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf640d5b174cae0f46e415c3fe39db2">&#9670;&nbsp;</a></span>end_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a52db7f90cd64a56e55383bef561aa7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52db7f90cd64a56e55383bef561aa7d1">&#9670;&nbsp;</a></span>begin_raw_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#a80735fd291dca4e5f958ee5876289aa4">raw_quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first quad, used or not, on the given level. If a level has no quads, a past-the-end iterator is returned. If quads are no cells, i.e. for \(dim&gt;2\) no level argument must be given.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a09ee8cea6762ae96b484436de70b3983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ee8cea6762ae96b484436de70b3983">&#9670;&nbsp;</a></span>begin_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used quad on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a169e053e788e4d1b6abf7fb7cee6ba3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169e053e788e4d1b6abf7fb7cee6ba3c">&#9670;&nbsp;</a></span>begin_active_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active quad on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="aa4f723b45ffdd6bfefec560fd333dadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f723b45ffdd6bfefec560fd333dadf">&#9670;&nbsp;</a></span>end_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a26795906ff2742c5f2109113b79d6744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26795906ff2742c5f2109113b79d6744">&#9670;&nbsp;</a></span>begin_raw_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html#ac2be382ff40558d007dd767a1288dc1e">raw_hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_raw_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first hex, used or not, on level <code>level</code>. If a level has no hexes, a past-the-end iterator is returned.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="aae764c732cc0de8322257d13912552b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae764c732cc0de8322257d13912552b8">&#9670;&nbsp;</a></span>begin_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used hex on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a1e876cdf1cdae06aa793cc5081b4fe31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e876cdf1cdae06aa793cc5081b4fe31">&#9670;&nbsp;</a></span>begin_active_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_hex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active hex on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="aadd003c8d0a9d5839488ee2ad1313703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd003c8d0a9d5839488ee2ad1313703">&#9670;&nbsp;</a></span>end_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a61d0ea3487d046b34de4ee8f60abf1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d0ea3487d046b34de4ee8f60abf1b2">&#9670;&nbsp;</a></span>clear_despite_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_despite_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The (public) function <a class="el" href="classTriangulation.html#a12d54b7dae635d867bf8d2c4b3605817">clear()</a> will only work when the triangulation is not subscribed to by other users. The <a class="el" href="classTriangulation.html#a61d0ea3487d046b34de4ee8f60abf1b2">clear_despite_subscriptions()</a> function now allows the triangulation being cleared even when there are subscriptions.</p>
<p>Make sure, you know what you do, when calling this function, as its use is reasonable in very rare cases, only. For example, when the subscriptions were for the initially empty <a class="el" href="classTriangulation.html">Triangulation</a> and the <a class="el" href="classTriangulation.html">Triangulation</a> object wants to release its memory before throwing an assertion due to input errors (e.g. in the <a class="el" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">create_triangulation()</a> function). </p>

</div>
</div>
<a id="af42c164ad82da9629eab01f90ef2a360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42c164ad82da9629eab01f90ef2a360">&#9670;&nbsp;</a></span>reset_policy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_policy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset triangulation policy. </p>

</div>
</div>
<a id="a365332f11d26e60c46a1f9bbb3e5e1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365332f11d26e60c46a1f9bbb3e5e1c1">&#9670;&nbsp;</a></span>reset_active_cell_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_active_cell_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For all cells, set the active cell indices so that active cells know the how many-th active cell they are, and all other cells have an invalid value. This function is called after mesh creation, refinement, and serialization. </p>

</div>
</div>
<a id="a34500f2c5a91afc92a178b27fff212bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34500f2c5a91afc92a178b27fff212bf">&#9670;&nbsp;</a></span>reset_global_cell_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_global_cell_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset global cell ids and globale level cell ids. </p>

</div>
</div>
<a id="a76af9cf5bbd5811b3f6ee8ca03ac8df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76af9cf5bbd5811b3f6ee8ca03ac8df6">&#9670;&nbsp;</a></span>reset_cell_vertex_indices_cache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_cell_vertex_indices_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset cache for the cells' vertex indices. </p>

</div>
</div>
<a id="a8a73cdc08e502d9a140a625184526b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a73cdc08e502d9a140a625184526b89">&#9670;&nbsp;</a></span>execute_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTriangulation_1_1DistortedCellList.html">DistortedCellList</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refine all cells on all levels which were previously flagged for refinement.</p>
<p>Note, that this function uses the <code>line-&gt;user_flags</code> for <code>dim=2,3</code> and the <code>quad-&gt;user_flags</code> for <code>dim=3</code>.</p>
<p>The function returns a list of cells that have produced children that satisfy the criteria of <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a> if the <code>check_for_distorted_cells</code> flag was specified upon creation of this object, at </p>

</div>
</div>
<a id="afeebb271c1406d688a1ffb802a7bb509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeebb271c1406d688a1ffb802a7bb509">&#9670;&nbsp;</a></span>execute_coarsening()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::execute_coarsening </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen all cells which were flagged for coarsening, or rather: delete all children of those cells of which all child cells are flagged for coarsening and several other constraints hold (see the general doc of this class). </p>

</div>
</div>
<a id="a37dc87bf8f3793947ba51f2da20b8442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dc87bf8f3793947ba51f2da20b8442">&#9670;&nbsp;</a></span>fix_coarsen_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::fix_coarsen_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make sure that either all or none of the children of a cell are tagged for coarsening. </p>

</div>
</div>
<a id="af01ec1d50a410f7cc29c543b212edefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01ec1d50a410f7cc29c543b212edefc">&#9670;&nbsp;</a></span>coarse_cell_id_to_coarse_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarse_cell_id_to_coarse_cell_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a>&#160;</td>
          <td class="paramname"><em>coarse_cell_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate the unique id of a coarse cell to its index. See the glossary entry on <a class="el" href="DEALGlossary.html#GlossCoarseCellId">coarse cell IDs</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>For serial and shared triangulation both id and index are the same. For distributed triangulations setting both might differ, since the id might correspond to a global id and the index to a local id.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coarse_cell_id</td><td>Unique id of the coarse cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the coarse cell within the current triangulation. </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#a5df64951002ee2af4f115ca55786b199">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#acc6af7d3e309cef138d916aa6e0b3494">parallel::distributed::Triangulation&lt; dim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a6eaada04b6139e1578964e1057946bcc">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a9ef633762716a14deb9a4dcda02a26f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef633762716a14deb9a4dcda02a26f0">&#9670;&nbsp;</a></span>coarse_cell_index_to_coarse_cell_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarse_cell_index_to_coarse_cell_id </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarse_cell_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translate the index of coarse cell to its unique id. See the glossary entry on <a class="el" href="DEALGlossary.html#GlossCoarseCellId">coarse cell IDs</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>See the note of the method <a class="el" href="classTriangulation.html#af01ec1d50a410f7cc29c543b212edefc">coarse_cell_id_to_coarse_cell_index()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coarse_cell_index</td><td>Index of the coarse cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of the coarse cell. </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation_3_011_00_01spacedim_01_4.html#af096d40a30000900095891ff04d2d52c">parallel::distributed::Triangulation&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ee4a0a9c73acef08adae3cdfabf60f2">parallel::distributed::Triangulation&lt; dim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a2606d3174c3bbef8378d0b74d2f765ed">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a78484ccbc5d665a7ffc679fe62cecd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78484ccbc5d665a7ffc679fe62cecd7d">&#9670;&nbsp;</a></span>TriaAccessorBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;int , int , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04072">4072</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a43c0730c894c987ae4e06de5f80bae12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c0730c894c987ae4e06de5f80bae12">&#9670;&nbsp;</a></span>TriaAccessor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;int , int , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTriaAccessor.html">TriaAccessor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04074">4074</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a97f9b1157ed4068cc2ff016ceb0050fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f9b1157ed4068cc2ff016ceb0050fb">&#9670;&nbsp;</a></span>TriaAccessor< 0, 1, spacedim ></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, 1, spacedim &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04075">4075</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a16c6f26ee460554f57d2bbd3c5433c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c6f26ee460554f57d2bbd3c5433c57">&#9670;&nbsp;</a></span>CellAccessor< dim, spacedim ></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04077">4077</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a66bd8833f949eb9ac7a4dc4669177f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bd8833f949eb9ac7a4dc4669177f26">&#9670;&nbsp;</a></span>::internal::TriaAccessorImplementation::Implementation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::internal::TriaAccessorImplementation::Implementation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04079">4079</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a1173edf91a9d914373821b6117f32a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1173edf91a9d914373821b6117f32a8f">&#9670;&nbsp;</a></span>::internal::TriangulationImplementation::Implementation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::internal::TriangulationImplementation::Implementation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04081">4081</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a8b5f94c07c2ca904c27c04ca38eac0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5f94c07c2ca904c27c04ca38eac0e1">&#9670;&nbsp;</a></span>::internal::TriangulationImplementation::ImplementationMixedMesh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::internal::TriangulationImplementation:: ImplementationMixedMesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04083">4083</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="abb04678e4ae6087bc934b8d6acdeef3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb04678e4ae6087bc934b8d6acdeef3f">&#9670;&nbsp;</a></span>::internal::TriangulationImplementation::TriaObjects</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaObjects.html">internal::TriangulationImplementation::TriaObjects</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04085">4085</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aefd8ddbf96799abebb6c05dced569329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd8ddbf96799abebb6c05dced569329">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the dimension available in function templates. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01542">1542</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a3414a986e63a95d54e961b9b35d756fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3414a986e63a95d54e961b9b35d756fb">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the space-dimension available in function templates. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01547">1547</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ad136f601f63a6d1bd8e205edd93cbae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad136f601f63a6d1bd8e205edd93cbae3">&#9670;&nbsp;</a></span>signals</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTriangulation_1_1Signals.html">Signals</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::signals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="structTriangulation_1_1Signals.html">Signals</a> for the various actions that a triangulation can do to itself. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l02289">2289</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ae8e877e2e60025d306a75bb58e7ad68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e877e2e60025d306a75bb58e7ad68e">&#9670;&nbsp;</a></span>levels</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt;::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaLevel.html">internal::TriangulationImplementation::TriaLevel</a>&gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::levels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of pointers pointing to the objects storing the cell data on the different levels. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03979">3979</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a706b242073a65dd1e4fe15c58d272671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706b242073a65dd1e4fe15c58d272671">&#9670;&nbsp;</a></span>faces</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaFaces.html">internal::TriangulationImplementation::TriaFaces</a>&gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::faces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the faces of the triangulation. In 1d this contains nothing, in 2D it contains data concerning lines and in 3D quads and lines. All of these have no level and are therefore treated separately. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03987">3987</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a51469854babb27752dc9f26ed9d5ee30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51469854babb27752dc9f26ed9d5ee30">&#9670;&nbsp;</a></span>vertices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of the vertices of this triangulation. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03993">3993</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a12d0610e5c578ced9903db01a70f466f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d0610e5c578ced9903db01a70f466f">&#9670;&nbsp;</a></span>vertices_used</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertices_used</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array storing a bit-pattern which vertices are used. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l03998">3998</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="abbf716af5de623e392f8a9f61cc313f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf716af5de623e392f8a9f61cc313f5">&#9670;&nbsp;</a></span>manifold</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>, std::unique_ptr&lt;const <a class="el" href="classManifold.html">Manifold</a>&lt;dim, spacedim&gt; &gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::manifold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collection of manifold objects. We store only objects, which are not of type <a class="el" href="classFlatManifold.html">FlatManifold</a>. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04005">4005</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a12dc6feb50966969856aa359f6fa316a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12dc6feb50966969856aa359f6fa316a">&#9670;&nbsp;</a></span>anisotropic_refinement</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::anisotropic_refinement</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag indicating whether anisotropic refinement took place. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04010">4010</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a5c55287cc4c709190b521fd98a4f5e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c55287cc4c709190b521fd98a4f5e02">&#9670;&nbsp;</a></span>check_for_distorted_cells</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::check_for_distorted_cells</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A flag that determines whether we are to check for distorted cells upon creation and refinement of a mesh. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04017">4017</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a8607590a4a1eddce07f6570c53e1c3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8607590a4a1eddce07f6570c53e1c3f3">&#9670;&nbsp;</a></span>number_cache</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1NumberCache.html">internal::TriangulationImplementation::NumberCache</a>&lt;dim&gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::number_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cache to hold the numbers of lines, quads, hexes, etc. These numbers are set at the end of the refinement and coarsening functions and enable faster access later on. In the old days, whenever one wanted to access one of these numbers, one had to perform a loop over all lines, e.g., and count the elements until we hit the end iterator. This is time consuming and since access to the number of lines etc is a rather frequent operation, this was not an optimal solution. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04028">4028</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a5d3c27fe127e4b1d7de6bc67bb1eae97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3c27fe127e4b1d7de6bc67bb1eae97">&#9670;&nbsp;</a></span>vertex_to_boundary_id_map_1d</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;std::map&lt;unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertex_to_boundary_id_map_1d</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A map that relates the number of a boundary vertex to the boundary indicator. This field is only used in 1d. We have this field because we store boundary indicator information with faces in 2d and higher where we have space in the structures that store data for faces, but in 1d there is no such space for faces.</p>
<p>The field is declared as a pointer for a rather mundane reason: all other fields of this class that can be modified by the <a class="el" href="classTriaAccessor.html">TriaAccessor</a> hierarchy are pointers, and so these accessor classes store a const pointer to the triangulation. We could no longer do so for <a class="el" href="classTriaAccessor_3_010_00_011_00_01spacedim_01_4.html">TriaAccessor&lt;0,1,spacedim&gt;</a> if this field (that can be modified by <a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">TriaAccessor::set_boundary_id</a>) were not a pointer. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04045">4045</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a1c156f5743dad8cd571f0c63ce0b39e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c156f5743dad8cd571f0c63ce0b39e6">&#9670;&nbsp;</a></span>vertex_to_manifold_id_map_1d</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;std::map&lt;unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&gt; &gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertex_to_manifold_id_map_1d</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A map that relates the number of a boundary vertex to the manifold indicator. This field is only used in 1d. We have this field because we store manifold indicator information with faces in 2d and higher where we have space in the structures that store data for faces, but in 1d there is no such space for faces.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classManifold.html">Manifold</a> objects are pretty useless for points since they are neither refined nor are their interiors mapped. We nevertheless allow storing manifold ids for points to be consistent in dimension-independent programs.</dd></dl>
<p>The field is declared as a pointer for a rather mundane reason: all other fields of this class that can be modified by the <a class="el" href="classTriaAccessor.html">TriaAccessor</a> hierarchy are pointers, and so these accessor classes store a const pointer to the triangulation. We could no longer do so for <a class="el" href="classTriaAccessor_3_010_00_011_00_01spacedim_01_4.html">TriaAccessor&lt;0,1,spacedim&gt;</a> if this field (that can be modified by <a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">TriaAccessor::set_manifold_id</a>) were not a pointer. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l04068">4068</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/grid/<a class="el" href="grid_2tria_8h_source.html">tria.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
