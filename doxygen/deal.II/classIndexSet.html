<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classIndexSet.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: IndexSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classIndexSet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IndexSet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="index__set_8h_source.html">deal.II/base/index_set.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet_1_1ElementIterator.html">ElementIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet_1_1IntervalAccessor.html">IntervalAccessor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet_1_1IntervalIterator.html">IntervalIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIndexSet_1_1Range.html">Range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afd0c161cdaaa0600f22339af5900ac77"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:afd0c161cdaaa0600f22339af5900ac77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7923832556d89fd2ff2a0e8778f3dceb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a7923832556d89fd2ff2a0e8778f3dceb">value_type</a> = signed <a class="el" href="classint.html">int</a></td></tr>
<tr class="separator:a7923832556d89fd2ff2a0e8778f3dceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a765acb4655708ac63f0b58fef14a617e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a765acb4655708ac63f0b58fef14a617e">IndexSet</a> ()</td></tr>
<tr class="separator:a765acb4655708ac63f0b58fef14a617e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253ebbddd491659f7f94d59a208b6afb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a253ebbddd491659f7f94d59a208b6afb">IndexSet</a> (const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> <a class="el" href="classIndexSet.html#a3ff4b23d197760f6426f262d7d4b8b3c">size</a>)</td></tr>
<tr class="separator:a253ebbddd491659f7f94d59a208b6afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1eca28240fa7a52db960c0556d4b37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a2b1eca28240fa7a52db960c0556d4b37">IndexSet</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;)=default</td></tr>
<tr class="separator:a2b1eca28240fa7a52db960c0556d4b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd22c10da45f68a350eaf6f944d8336"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a2cd22c10da45f68a350eaf6f944d8336">operator=</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;)=default</td></tr>
<tr class="separator:a2cd22c10da45f68a350eaf6f944d8336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72296545420901fe50c8132d3d5429b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#aa72296545420901fe50c8132d3d5429b">IndexSet</a> (<a class="el" href="classIndexSet.html">IndexSet</a> &amp;&amp;is) noexcept</td></tr>
<tr class="separator:aa72296545420901fe50c8132d3d5429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d94743a56721cacd8f5cec16458316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a10d94743a56721cacd8f5cec16458316">operator=</a> (<a class="el" href="classIndexSet.html">IndexSet</a> &amp;&amp;is) noexcept</td></tr>
<tr class="separator:a10d94743a56721cacd8f5cec16458316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e79feddf209595a8730f21c1ea8aec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a50e79feddf209595a8730f21c1ea8aec">IndexSet</a> (const Epetra_BlockMap &amp;map)</td></tr>
<tr class="separator:a50e79feddf209595a8730f21c1ea8aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3d75a9cba3f1a50866691327aa7609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a8a3d75a9cba3f1a50866691327aa7609">clear</a> ()</td></tr>
<tr class="separator:a8a3d75a9cba3f1a50866691327aa7609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a1afb1562b694669943ebaf977a3b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a79a1afb1562b694669943ebaf977a3b0">set_size</a> (const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> <a class="el" href="classIndexSet.html#a3ff4b23d197760f6426f262d7d4b8b3c">size</a>)</td></tr>
<tr class="separator:a79a1afb1562b694669943ebaf977a3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff4b23d197760f6426f262d7d4b8b3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a3ff4b23d197760f6426f262d7d4b8b3c">size</a> () const</td></tr>
<tr class="separator:a3ff4b23d197760f6426f262d7d4b8b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf69c0bec3f1e748fec802e0dc0d2dd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#adf69c0bec3f1e748fec802e0dc0d2dd0">add_range</a> (const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> <a class="el" href="classIndexSet.html#a6aef7f65ac8202ca1ed0a1bc7f337b32">begin</a>, const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> <a class="el" href="classIndexSet.html#ac1d1faec5b48fcab21c307293c33ffb1">end</a>)</td></tr>
<tr class="separator:adf69c0bec3f1e748fec802e0dc0d2dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a9df936f1d4a5098af7cbda4a9a21a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a91a9df936f1d4a5098af7cbda4a9a21a">add_index</a> (const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> index)</td></tr>
<tr class="separator:a91a9df936f1d4a5098af7cbda4a9a21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3cb227b79aee79b10da86b6841399d"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:afd3cb227b79aee79b10da86b6841399d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIndexSet.html#afd3cb227b79aee79b10da86b6841399d">add_indices</a> (const ForwardIterator &amp;<a class="el" href="classIndexSet.html#a6aef7f65ac8202ca1ed0a1bc7f337b32">begin</a>, const ForwardIterator &amp;<a class="el" href="classIndexSet.html#ac1d1faec5b48fcab21c307293c33ffb1">end</a>)</td></tr>
<tr class="separator:afd3cb227b79aee79b10da86b6841399d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d83fedaa2722e6e721d2ee0fc4f3a8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a3d83fedaa2722e6e721d2ee0fc4f3a8b">add_indices</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;other, const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> offset=0)</td></tr>
<tr class="separator:a3d83fedaa2722e6e721d2ee0fc4f3a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c79fc7f17b2eeff0f0fb757e77e0c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a66c79fc7f17b2eeff0f0fb757e77e0c3">is_element</a> (const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> index) const</td></tr>
<tr class="separator:a66c79fc7f17b2eeff0f0fb757e77e0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6f9e915aae833a0c245226bfdf67b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a1d6f9e915aae833a0c245226bfdf67b8">is_contiguous</a> () const</td></tr>
<tr class="separator:a1d6f9e915aae833a0c245226bfdf67b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bd384cde09feffb0259eebb2a6e811"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a49bd384cde09feffb0259eebb2a6e811">is_empty</a> () const</td></tr>
<tr class="separator:a49bd384cde09feffb0259eebb2a6e811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f94fa42b0a17b33f4ae1cb42a0d98f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ae6f94fa42b0a17b33f4ae1cb42a0d98f">is_ascending_and_one_to_one</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator) const</td></tr>
<tr class="separator:ae6f94fa42b0a17b33f4ae1cb42a0d98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efff8155d2f7abe987547a731ecb43a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements</a> () const</td></tr>
<tr class="separator:a4efff8155d2f7abe987547a731ecb43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c4da2486b3c1bb2dfdd8940b42ec61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ae1c4da2486b3c1bb2dfdd8940b42ec61">nth_index_in_set</a> (const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> local_index) const</td></tr>
<tr class="separator:ae1c4da2486b3c1bb2dfdd8940b42ec61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d924bea58d98feebf99fc714b14b7d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a4d924bea58d98feebf99fc714b14b7d0">index_within_set</a> (const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> global_index) const</td></tr>
<tr class="separator:a4d924bea58d98feebf99fc714b14b7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2981b8f29b849ee7b8e82486271a7fcd"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a2981b8f29b849ee7b8e82486271a7fcd">n_intervals</a> () const</td></tr>
<tr class="separator:a2981b8f29b849ee7b8e82486271a7fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf451a98515434e0c05ce2b6574ba55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a8bf451a98515434e0c05ce2b6574ba55">largest_range_starting_index</a> () const</td></tr>
<tr class="separator:a8bf451a98515434e0c05ce2b6574ba55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d579d3585ade55e22714e7dc9968a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#af0d579d3585ade55e22714e7dc9968a7">compress</a> () const</td></tr>
<tr class="separator:af0d579d3585ade55e22714e7dc9968a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54eb30afd552d5d36e495c904d1293eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a54eb30afd552d5d36e495c904d1293eb">operator==</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;is) const</td></tr>
<tr class="separator:a54eb30afd552d5d36e495c904d1293eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b07303c406893c498d4f5703626360b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a7b07303c406893c498d4f5703626360b">operator!=</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;is) const</td></tr>
<tr class="separator:a7b07303c406893c498d4f5703626360b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3a69c62e220adaf4f3046c4402c7ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a3d3a69c62e220adaf4f3046c4402c7ec">operator &amp;</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;is) const</td></tr>
<tr class="separator:a3d3a69c62e220adaf4f3046c4402c7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add590b083cdde3fa61e637a058b51835"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a> (const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> <a class="el" href="classIndexSet.html#a6aef7f65ac8202ca1ed0a1bc7f337b32">begin</a>, const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> <a class="el" href="classIndexSet.html#ac1d1faec5b48fcab21c307293c33ffb1">end</a>) const</td></tr>
<tr class="separator:add590b083cdde3fa61e637a058b51835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e65ac88f057604a7777f2fe12bf3c8c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a4e65ac88f057604a7777f2fe12bf3c8c">split_by_block</a> (const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;n_indices_per_block) const</td></tr>
<tr class="separator:a4e65ac88f057604a7777f2fe12bf3c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15601b7c5742d386127b3ecabf61cf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ac15601b7c5742d386127b3ecabf61cf8">subtract_set</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;other)</td></tr>
<tr class="separator:ac15601b7c5742d386127b3ecabf61cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919aabc634e406438ec287af481aed05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a919aabc634e406438ec287af481aed05">tensor_product</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;other) const</td></tr>
<tr class="separator:a919aabc634e406438ec287af481aed05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60a73a88772a72fa040318728d710f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#af60a73a88772a72fa040318728d710f9">pop_back</a> ()</td></tr>
<tr class="separator:af60a73a88772a72fa040318728d710f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c77c84e1654d502125a5798583b22e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a6c77c84e1654d502125a5798583b22e9">pop_front</a> ()</td></tr>
<tr class="separator:a6c77c84e1654d502125a5798583b22e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466dfb316d6475e548e19912eeda3a90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a466dfb316d6475e548e19912eeda3a90">fill_index_vector</a> (std::vector&lt; <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> &gt; &amp;indices) const</td></tr>
<tr class="separator:a466dfb316d6475e548e19912eeda3a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb838e6617d2a8edb889e643302a719"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:abeb838e6617d2a8edb889e643302a719"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIndexSet.html#abeb838e6617d2a8edb889e643302a719">fill_binary_vector</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;vector) const</td></tr>
<tr class="separator:abeb838e6617d2a8edb889e643302a719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc2165a730a210ce7b3a852bfc5bd76"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:aedc2165a730a210ce7b3a852bfc5bd76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIndexSet.html#aedc2165a730a210ce7b3a852bfc5bd76">print</a> (StreamType &amp;out) const</td></tr>
<tr class="separator:aedc2165a730a210ce7b3a852bfc5bd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b8fd6987dda61ec6269d79ef20086b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a91b8fd6987dda61ec6269d79ef20086b">write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a91b8fd6987dda61ec6269d79ef20086b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80613305bf8a26f68dfe841e084d5045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a80613305bf8a26f68dfe841e084d5045">read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a80613305bf8a26f68dfe841e084d5045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fcb21afa51b047f5a045619535b2aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ad9fcb21afa51b047f5a045619535b2aa">block_write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ad9fcb21afa51b047f5a045619535b2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9975dcc4ba3b7f5a5e22b52ff44db8bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a9975dcc4ba3b7f5a5e22b52ff44db8bd">block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a9975dcc4ba3b7f5a5e22b52ff44db8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bdeb655af418206563c8016f82280c"><td class="memItemLeft" align="right" valign="top">Epetra_Map&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ad8bdeb655af418206563c8016f82280c">make_trilinos_map</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> overlapping=false) const</td></tr>
<tr class="separator:ad8bdeb655af418206563c8016f82280c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc4cc28c84961f6eebcaa9169d1a722"><td class="memItemLeft" align="right" valign="top">Tpetra::Map&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a8cc4cc28c84961f6eebcaa9169d1a722">make_tpetra_map</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> overlapping=false) const</td></tr>
<tr class="separator:a8cc4cc28c84961f6eebcaa9169d1a722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba0ce6187639b3c253cb8d9379aaf9d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#aeba0ce6187639b3c253cb8d9379aaf9d">memory_consumption</a> () const</td></tr>
<tr class="separator:aeba0ce6187639b3c253cb8d9379aaf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6996bfbeb7950e706a46a755b4600dcb"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a6996bfbeb7950e706a46a755b4600dcb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a6996bfbeb7950e706a46a755b4600dcb">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a6996bfbeb7950e706a46a755b4600dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309aa2408235350293adce28e489d0b1"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a309aa2408235350293adce28e489d0b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a309aa2408235350293adce28e489d0b1">fill_binary_vector</a> (<a class="el" href="classVector.html">Vector</a> &amp;vector) const</td></tr>
<tr class="separator:a309aa2408235350293adce28e489d0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a6aef7f65ac8202ca1ed0a1bc7f337b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet_1_1ElementIterator.html">ElementIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a6aef7f65ac8202ca1ed0a1bc7f337b32">begin</a> () const</td></tr>
<tr class="separator:a6aef7f65ac8202ca1ed0a1bc7f337b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cabd1809f49e118b55f86098077ef22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet_1_1ElementIterator.html">ElementIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a3cabd1809f49e118b55f86098077ef22">at</a> (const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> global_index) const</td></tr>
<tr class="separator:a3cabd1809f49e118b55f86098077ef22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d1faec5b48fcab21c307293c33ffb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet_1_1ElementIterator.html">ElementIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ac1d1faec5b48fcab21c307293c33ffb1">end</a> () const</td></tr>
<tr class="separator:ac1d1faec5b48fcab21c307293c33ffb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27cc09e326df9bcb0cf8b5e258eafad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet_1_1IntervalIterator.html">IntervalIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ab27cc09e326df9bcb0cf8b5e258eafad">begin_intervals</a> () const</td></tr>
<tr class="separator:ab27cc09e326df9bcb0cf8b5e258eafad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1df1bf40b6777cee20265d53025738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet_1_1IntervalIterator.html">IntervalIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a3a1df1bf40b6777cee20265d53025738">end_intervals</a> () const</td></tr>
<tr class="separator:a3a1df1bf40b6777cee20265d53025738"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga2defd7bc95353f811627bfb2773db73f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga2defd7bc95353f811627bfb2773db73f">ExcIndexNotPresent</a> (<a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> arg1)</td></tr>
<tr class="separator:ga2defd7bc95353f811627bfb2773db73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3b9f4f812f31c5719bc0ab244e2a5f7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a3b9f4f812f31c5719bc0ab244e2a5f7c">do_compress</a> () const</td></tr>
<tr class="separator:a3b9f4f812f31c5719bc0ab244e2a5f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac1473031a61493d84806614ac902bb59"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structIndexSet_1_1Range.html">Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ac1473031a61493d84806614ac902bb59">ranges</a></td></tr>
<tr class="separator:ac1473031a61493d84806614ac902bb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa971e41b981640576254569d9a75530f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#aa971e41b981640576254569d9a75530f">is_compressed</a></td></tr>
<tr class="separator:aa971e41b981640576254569d9a75530f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34ede8282350f0713b13505c2189029"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ad34ede8282350f0713b13505c2189029">index_space_size</a></td></tr>
<tr class="separator:ad34ede8282350f0713b13505c2189029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172ec8f06243cdc7d3e97a397bbead04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#a172ec8f06243cdc7d3e97a397bbead04">largest_range</a></td></tr>
<tr class="separator:a172ec8f06243cdc7d3e97a397bbead04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac283586a1a4c9d38b024e05b10913df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1Mutex.html">Threads::Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ac283586a1a4c9d38b024e05b10913df7">compress_mutex</a></td></tr>
<tr class="separator:ac283586a1a4c9d38b024e05b10913df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ad28b2e725afda38ffdef1bf61d5cadd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a> (const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a> N)</td></tr>
<tr class="separator:ad28b2e725afda38ffdef1bf61d5cadd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that represents a subset of indices among a larger set. For example, it can be used to denote the set of degrees of freedom within the range \([0,\mathrm{dof\_handler.n\_dofs()})\) that belongs to a particular subdomain, or those among all degrees of freedom that are stored on a particular processor in a distributed parallel computation.</p>
<p>This class can represent a collection of half-open ranges of indices as well as individual elements. For practical purposes it also stores the overall range these indices can assume. In other words, you need to specify the size of the index space \([0,\text{size})\) of which objects of this class are a subset.</p>
<p>There are two ways to iterate over the IndexSets: First, <a class="el" href="classIndexSet.html#a6aef7f65ac8202ca1ed0a1bc7f337b32">begin()</a> and <a class="el" href="classIndexSet.html#ac1d1faec5b48fcab21c307293c33ffb1">end()</a> allow iteration over individual indices in the set. Second, begin_interval() and end_interval() allow iteration over the half-open ranges as described above.</p>
<p>The data structures used in this class along with a rationale can be found in the <a class="el" href="DEALGlossary.html#distributed_paper">Distributed Computing paper</a>. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l00072">72</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afd0c161cdaaa0600f22339af5900ac77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0c161cdaaa0600f22339af5900ac77">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>size_type</code> is the type used for storing the size and the individual entries in the <a class="el" href="classIndexSet.html">IndexSet</a>. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l00083">83</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a7923832556d89fd2ff2a0e8778f3dceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7923832556d89fd2ff2a0e8778f3dceb">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIndexSet.html#a7923832556d89fd2ff2a0e8778f3dceb">IndexSet::value_type</a> =  signed <a class="el" href="classint.html">int</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>One can see an <a class="el" href="classIndexSet.html">IndexSet</a> as a container of size <a class="el" href="classIndexSet.html#a3ff4b23d197760f6426f262d7d4b8b3c">size()</a>, where the elements of the containers are bool values that are either false or true, depending on whether a particular index is an element of the <a class="el" href="classIndexSet.html">IndexSet</a> or not. In other words, an <a class="el" href="classIndexSet.html">IndexSet</a> is a bit like a vector in which the elements we store are booleans. In this view, the correct local alias indicating the type of the elements of the vector would then be <code>bool</code>.</p>
<p>On the other hand, <code>bool</code> has the disadvantage that it is not a numerical type that, for example, allows multiplication with a <code>double</code>. In other words, one can not easily use a vector of booleans in a place where other vectors are allowed. Consequently, we declare the type of the elements of such a vector as a signed integer. This uses the fact that in the C++ language, booleans are implicitly convertible to integers. In other words, declaring the type of the elements of the vector as a signed integer is only a small lie, but it is a useful one. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l00102">102</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a765acb4655708ac63f0b58fef14a617e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765acb4655708ac63f0b58fef14a617e">&#9670;&nbsp;</a></span>IndexSet() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IndexSet::IndexSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01465">1465</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a253ebbddd491659f7f94d59a208b6afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253ebbddd491659f7f94d59a208b6afb">&#9670;&nbsp;</a></span>IndexSet() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IndexSet::IndexSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor that also sets the overall size of the index range. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01473">1473</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a2b1eca28240fa7a52db960c0556d4b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1eca28240fa7a52db960c0556d4b37">&#9670;&nbsp;</a></span>IndexSet() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IndexSet::IndexSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a id="aa72296545420901fe50c8132d3d5429b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72296545420901fe50c8132d3d5429b">&#9670;&nbsp;</a></span>IndexSet() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IndexSet::IndexSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Create a new <a class="el" href="classIndexSet.html">IndexSet</a> by transferring the internal data of the input set. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01481">1481</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a50e79feddf209595a8730f21c1ea8aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e79feddf209595a8730f21c1ea8aec">&#9670;&nbsp;</a></span>IndexSet() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IndexSet::IndexSet </td>
          <td>(</td>
          <td class="paramtype">const Epetra_BlockMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor from a Trilinos Epetra_BlockMap. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00068">68</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2cd22c10da45f68a350eaf6f944d8336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd22c10da45f68a350eaf6f944d8336">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a>&amp; IndexSet::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy assignment operator. </p>

</div>
</div>
<a id="a10d94743a56721cacd8f5cec16458316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d94743a56721cacd8f5cec16458316">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> &amp; IndexSet::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIndexSet.html">IndexSet</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator. Transfer the internal data of the input set into the current one. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01498">1498</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a8a3d75a9cba3f1a50866691327aa7609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3d75a9cba3f1a50866691327aa7609">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove all indices from this index set. The index set retains its size, however. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01610">1610</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a79a1afb1562b694669943ebaf977a3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a1afb1562b694669943ebaf977a3b0">&#9670;&nbsp;</a></span>set_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::set_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the maximal size of the indices upon which this object operates.</p>
<p>This function can only be called if the index set does not yet contain any elements. This can be achieved by calling <a class="el" href="classIndexSet.html#a8a3d75a9cba3f1a50866691327aa7609">clear()</a>, for example. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01622">1622</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a3ff4b23d197760f6426f262d7d4b8b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff4b23d197760f6426f262d7d4b8b3c">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a> IndexSet::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the size of the index space of which this index set is a subset of.</p>
<p>Note that the result is not equal to the number of indices within this set. The latter information is returned by <a class="el" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements()</a>. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01634">1634</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="adf69c0bec3f1e748fec802e0dc0d2dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf69c0bec3f1e748fec802e0dc0d2dd0">&#9670;&nbsp;</a></span>add_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::add_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add the half-open range \([\text{begin},\text{end})\) to the set of indices represented by this class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>The first element of the range to be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The past-the-end element of the range to be added. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01673">1673</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a91a9df936f1d4a5098af7cbda4a9a21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a9df936f1d4a5098af7cbda4a9a21a">&#9670;&nbsp;</a></span>add_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::add_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an individual index to the set of indices. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01653">1653</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="afd3cb227b79aee79b10da86b6841399d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3cb227b79aee79b10da86b6841399d">&#9670;&nbsp;</a></span>add_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::add_indices </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a whole set of indices described by dereferencing every element of the iterator range <code>[begin,end)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>Iterator to the first element of range of indices to be added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The past-the-end iterator for the range of elements to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The condition <code>begin&lt;=end</code> needs to be satisfied. </dd></dl>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01703">1703</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a3d83fedaa2722e6e721d2ee0fc4f3a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d83fedaa2722e6e721d2ee0fc4f3a8b">&#9670;&nbsp;</a></span>add_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::add_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the given <a class="el" href="classIndexSet.html">IndexSet</a> <code>other</code> to the current one, constructing the union of *this and <code>other</code>.</p>
<p>If the <code>offset</code> argument is nonzero, then every index in <code>other</code> is shifted by <code>offset</code> before being added to the current index set. This allows to construct, for example, one index set from several others that are supposed to represent index sets corresponding to different ranges (e.g., when constructing the set of nonzero entries of a block vector from the sets of nonzero elements of the individual blocks of a vector).</p>
<p>This function will generate an exception if any of the (possibly shifted) indices of the <code>other</code> index set lie outside the range <code>[0,<a class="el" href="classIndexSet.html#a3ff4b23d197760f6426f262d7d4b8b3c">size()</a>)</code> represented by the current object. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00382">382</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="a66c79fc7f17b2eeff0f0fb757e77e0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c79fc7f17b2eeff0f0fb757e77e0c3">&#9670;&nbsp;</a></span>is_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IndexSet::is_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the specified index is an element of the index set. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01765">1765</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a1d6f9e915aae833a0c245226bfdf67b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6f9e915aae833a0c245226bfdf67b8">&#9670;&nbsp;</a></span>is_contiguous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IndexSet::is_contiguous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the index set stored by this object defines a contiguous range. This is true also if no indices are stored at all. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01815">1815</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a49bd384cde09feffb0259eebb2a6e811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bd384cde09feffb0259eebb2a6e811">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IndexSet::is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the index set stored by this object contains no elements. This is similar, but faster than checking <code><a class="el" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements()</a> == 0</code>. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01824">1824</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="ae6f94fa42b0a17b33f4ae1cb42a0d98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f94fa42b0a17b33f4ae1cb42a0d98f">&#9670;&nbsp;</a></span>is_ascending_and_one_to_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IndexSet::is_ascending_and_one_to_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the IndexSets are ascending with respect to MPI process number and 1:1, i.e., each index is contained in exactly one <a class="el" href="classIndexSet.html">IndexSet</a> (among those stored on the different processes), each process stores contiguous subset of indices, and the index set on process \(p+1\) starts at the index one larger than the last one stored on process \(p\). In case there is only one MPI process, this just means that the <a class="el" href="classIndexSet.html">IndexSet</a> is complete. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00666">666</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="a4efff8155d2f7abe987547a731ecb43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efff8155d2f7abe987547a731ecb43a">&#9670;&nbsp;</a></span>n_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a> IndexSet::n_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of elements stored in this index set. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01832">1832</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="ae1c4da2486b3c1bb2dfdd8940b42ec61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c4da2486b3c1bb2dfdd8940b42ec61">&#9670;&nbsp;</a></span>nth_index_in_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a> IndexSet::nth_index_in_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td>
          <td class="paramname"><em>local_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global index of the local index with number <code>local_index</code> stored in this index set. <code>local_index</code> obviously needs to be less than <a class="el" href="classIndexSet.html#a4efff8155d2f7abe987547a731ecb43a">n_elements()</a>. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01880">1880</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a4d924bea58d98feebf99fc714b14b7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d924bea58d98feebf99fc714b14b7d0">&#9670;&nbsp;</a></span>index_within_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a> IndexSet::index_within_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the how-manyth element of this set (counted in ascending order) <code>global_index</code> is. <code>global_index</code> needs to be less than the <a class="el" href="classIndexSet.html#a3ff4b23d197760f6426f262d7d4b8b3c">size()</a>. This function returns <a class="el" href="namespacenumbers.html#ae99f39edfc25decfbafd43b65e95860d">numbers::invalid_dof_index</a> if the index <code>global_index</code> is not actually a member of this index set, i.e. if is_element(global_index) is false. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01921">1921</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a2981b8f29b849ee7b8e82486271a7fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2981b8f29b849ee7b8e82486271a7fcd">&#9670;&nbsp;</a></span>n_intervals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> IndexSet::n_intervals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Each index set can be represented as the union of a number of contiguous intervals of indices, where if necessary intervals may only consist of individual elements to represent isolated members of the index set.</p>
<p>This function returns the minimal number of such intervals that are needed to represent the index set under consideration. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01857">1857</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a8bf451a98515434e0c05ce2b6574ba55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf451a98515434e0c05ce2b6574ba55">&#9670;&nbsp;</a></span>largest_range_starting_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a> IndexSet::largest_range_starting_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the local index of the beginning of the largest range.</p>
<p>In other words, the return value is nth_index_in_set(x), where x is the first index of the largest contiguous range of indices in the <a class="el" href="classIndexSet.html">IndexSet</a>. The return value is therefore equal to the number of elements in the set that come before the largest range.</p>
<p>This call assumes that the <a class="el" href="classIndexSet.html">IndexSet</a> is nonempty. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01866">1866</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="af0d579d3585ade55e22714e7dc9968a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d579d3585ade55e22714e7dc9968a7">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compress the internal representation by merging individual elements with contiguous ranges, etc. This function does not have any external effect. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01642">1642</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a54eb30afd552d5d36e495c904d1293eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54eb30afd552d5d36e495c904d1293eb">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IndexSet::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison for equality of index sets. This operation is only allowed if the size of the two sets is the same (though of course they do not have to have the same number of indices). </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01969">1969</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a7b07303c406893c498d4f5703626360b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b07303c406893c498d4f5703626360b">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IndexSet::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison for inequality of index sets. This operation is only allowed if the size of the two sets is the same (though of course they do not have to have the same number of indices). </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01982">1982</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a3d3a69c62e220adaf4f3046c4402c7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3a69c62e220adaf4f3046c4402c7ec">&#9670;&nbsp;</a></span>operator &()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> IndexSet::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the intersection of the current index set and the argument given, i.e. a set of indices that are elements of both index sets. The two index sets must have the same size (though of course they do not have to have the same number of indices). </p>

</div>
</div>
<a id="add590b083cdde3fa61e637a058b51835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add590b083cdde3fa61e637a058b51835">&#9670;&nbsp;</a></span>get_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> IndexSet::get_view </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This command takes an interval <code>[begin, end)</code> and returns the intersection of the current index set with the interval, shifted to the range <code>[0, end-begin)</code>.</p>
<p>In other words, the result of this operation is the intersection of the set represented by the current object and the interval <code>[begin, end)</code>, as seen <em>within the interval <code>[begin, end)</code></em> by shifting the result of the intersection operation to the left by <code>begin</code>. This corresponds to the notion of a <em>view</em>: The interval <code>[begin, end)</code> is a <em>window</em> through which we see the set represented by the current object. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00211">211</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="a4e65ac88f057604a7777f2fe12bf3c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e65ac88f057604a7777f2fe12bf3c8c">&#9670;&nbsp;</a></span>split_by_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; IndexSet::split_by_block </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_indices_per_block</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split the set indices represented by this object into blocks given by the <code>n_indices_per_block</code> structure. The sum of its entries must match the global size of the current object. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00238">238</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="ac15601b7c5742d386127b3ecabf61cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15601b7c5742d386127b3ecabf61cf8">&#9670;&nbsp;</a></span>subtract_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::subtract_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all elements contained in <code>other</code> from this set. In other words, if \(x\) is the current object and \(o\) the argument, then we compute \(x \leftarrow x \backslash o\). </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00258">258</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="a919aabc634e406438ec287af481aed05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919aabc634e406438ec287af481aed05">&#9670;&nbsp;</a></span>tensor_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> IndexSet::tensor_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a new <a class="el" href="classIndexSet.html">IndexSet</a>, with global size equal to <code>this-&gt;<a class="el" href="classIndexSet.html#a3ff4b23d197760f6426f262d7d4b8b3c">size()</a>*other.<a class="el" href="classIndexSet.html#a3ff4b23d197760f6426f262d7d4b8b3c">size()</a></code>, containing for every element <code>n</code> of this <a class="el" href="classIndexSet.html">IndexSet</a>, the entries in the half open range <code>[n*other.<a class="el" href="classIndexSet.html#a3ff4b23d197760f6426f262d7d4b8b3c">size()</a>, (n+1)*other.<a class="el" href="classIndexSet.html#a3ff4b23d197760f6426f262d7d4b8b3c">size()</a>)</code> of the <code>other</code> <a class="el" href="classIndexSet.html">IndexSet</a>.</p>
<p>The name results from the perspective that one starts with an <a class="el" href="classIndexSet.html">IndexSet</a> and takes the tensor product with another <a class="el" href="classIndexSet.html">IndexSet</a> with <code>other.size()</code> elements; this results in a matrix of size <code>this-&gt;<a class="el" href="classIndexSet.html#a3ff4b23d197760f6426f262d7d4b8b3c">size()</a></code> times <code>other.size()</code> that has ones in exactly the rows for which this <a class="el" href="classIndexSet.html">IndexSet</a> contained an index and in the columns for which the <code>other</code> <a class="el" href="classIndexSet.html">IndexSet</a> contained an index. This matrix is then "unrolled" again by going through each row one by one and reindexing the entries of the matrix in consecutive order. A one in the matrix then corresponds to an entry in the reindexed <a class="el" href="classIndexSet.html">IndexSet</a> that is returned by this function. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00330">330</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="af60a73a88772a72fa040318728d710f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60a73a88772a72fa040318728d710f9">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a> IndexSet::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove and return the last element of the last range. This function throws an exception if the <a class="el" href="classIndexSet.html">IndexSet</a> is empty. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00342">342</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="a6c77c84e1654d502125a5798583b22e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c77c84e1654d502125a5798583b22e9">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a> IndexSet::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove and return the first element of the first range. This function throws an exception if the <a class="el" href="classIndexSet.html">IndexSet</a> is empty. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00360">360</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="a466dfb316d6475e548e19912eeda3a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466dfb316d6475e548e19912eeda3a90">&#9670;&nbsp;</a></span>fill_index_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::fill_index_vector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill the given vector with all indices contained in this <a class="el" href="classIndexSet.html">IndexSet</a>. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00507">507</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="abeb838e6617d2a8edb889e643302a719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb838e6617d2a8edb889e643302a719">&#9670;&nbsp;</a></span>fill_binary_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::fill_binary_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill the given vector with either zero or one elements, providing a binary representation of this index set. The given vector is assumed to already have the correct size.</p>
<p>The given argument is filled with integer values zero and one, using <code>vector.operator[]</code>. Thus, any object that has such an operator can be used as long as it allows conversion of integers zero and one to elements of the vector. Specifically, this is the case for classes <a class="el" href="classVector.html">Vector</a>, <a class="el" href="classBlockVector.html">BlockVector</a>, but also std::vector&lt;bool&gt;, std::vector&lt;int&gt;, and std::vector&lt;double&gt;. </p>

</div>
</div>
<a id="aedc2165a730a210ce7b3a852bfc5bd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc2165a730a210ce7b3a852bfc5bd76">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::print </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output a text representation of this <a class="el" href="classIndexSet.html">IndexSet</a> to the given stream. Used for testing. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l02015">2015</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a91b8fd6987dda61ec6269d79ef20086b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b8fd6987dda61ec6269d79ef20086b">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the <a class="el" href="classIndexSet.html">IndexSet</a> into a text based file format, that can be read in again using the <a class="el" href="classIndexSet.html#a80613305bf8a26f68dfe841e084d5045">read()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00436">436</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="a80613305bf8a26f68dfe841e084d5045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80613305bf8a26f68dfe841e084d5045">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct the <a class="el" href="classIndexSet.html">IndexSet</a> from a text based representation given by the stream <code>in</code> written by the <a class="el" href="classIndexSet.html#a91b8fd6987dda61ec6269d79ef20086b">write()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00451">451</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="ad9fcb21afa51b047f5a045619535b2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fcb21afa51b047f5a045619535b2aa">&#9670;&nbsp;</a></span>block_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::block_write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the <a class="el" href="classIndexSet.html">IndexSet</a> into a binary, compact representation, that can be read in again using the <a class="el" href="classIndexSet.html#a9975dcc4ba3b7f5a5e22b52ff44db8bd">block_read()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00473">473</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="a9975dcc4ba3b7f5a5e22b52ff44db8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9975dcc4ba3b7f5a5e22b52ff44db8bd">&#9670;&nbsp;</a></span>block_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::block_read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct the <a class="el" href="classIndexSet.html">IndexSet</a> from a binary representation given by the stream <code>in</code> written by the write_block() function. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00487">487</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="ad8bdeb655af418206563c8016f82280c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bdeb655af418206563c8016f82280c">&#9670;&nbsp;</a></span>make_trilinos_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_Map IndexSet::make_trilinos_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>overlapping</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an MPI communicator, create a Trilinos map object that represents a distribution of vector elements or matrix rows in which we will locally store those elements or rows for which we store the index in the current index set, and all the other elements/rows elsewhere on one of the other MPI processes.</p>
<p>The last argument only plays a role if the communicator is a parallel one, distributing computations across multiple processors. In that case, if the last argument is false, then it is assumed that the index sets this function is called with on all processors are mutually exclusive but together enumerate each index exactly once. In other words, if you call this function on two processors, then the index sets this function is called with must together have all possible indices from zero to <a class="el" href="classIndexSet.html#a3ff4b23d197760f6426f262d7d4b8b3c">size()</a>-1, and no index must appear in both index sets. This corresponds, for example, to the case where we want to split the elements of vectors into unique subsets to be stored on different processors &ndash; no element should be owned by more than one processor, but each element must be owned by one.</p>
<p>On the other hand, if the second argument is true, then the index sets can be overlapping, and they also do not need to span the whole index set. This is a useful operation if we want to create vectors that not only contain the locally owned indices, but for example also the elements that correspond to degrees of freedom located on ghost cells. Another application of this method is to select a subset of the elements of a vector, e.g. for extracting only certain solution components. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00596">596</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="a8cc4cc28c84961f6eebcaa9169d1a722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc4cc28c84961f6eebcaa9169d1a722">&#9670;&nbsp;</a></span>make_tpetra_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tpetra::Map&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; IndexSet::make_tpetra_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>overlapping</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00527">527</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="aeba0ce6187639b3c253cb8d9379aaf9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba0ce6187639b3c253cb8d9379aaf9d">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t IndexSet::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00732">732</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="a6996bfbeb7950e706a46a755b4600dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6996bfbeb7950e706a46a755b4600dcb">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write or read the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l02046">2046</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a6aef7f65ac8202ca1ed0a1bc7f337b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aef7f65ac8202ca1ed0a1bc7f337b32">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet_1_1ElementIterator.html">IndexSet::ElementIterator</a> IndexSet::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator that points at the first index that is contained in this <a class="el" href="classIndexSet.html">IndexSet</a>. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01518">1518</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a3cabd1809f49e118b55f86098077ef22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cabd1809f49e118b55f86098077ef22">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet_1_1ElementIterator.html">IndexSet::ElementIterator</a> IndexSet::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an element iterator pointing to the element with global index <code>global_index</code> or the next larger element if the index is not in the set. This is equivalent to </p><div class="fragment"><div class="line"><span class="keyword">auto</span> p = <a class="code" href="classIndexSet.html#a6aef7f65ac8202ca1ed0a1bc7f337b32">begin</a>();</div><div class="line"><span class="keywordflow">while</span> (*p&lt;<a class="code" href="namespaceTrilinosWrappers.html#a0fa35a38e466d9c3b2dab8beca1df5b2">global_index</a>)</div><div class="line">  ++p;</div><div class="line"><span class="keywordflow">return</span> p;</div></div><!-- fragment --><p>If there is no element in this <a class="el" href="classIndexSet.html">IndexSet</a> at or behind <code>global_index</code>, this method will return <a class="el" href="classIndexSet.html#ac1d1faec5b48fcab21c307293c33ffb1">end()</a>. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01530">1530</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="ac1d1faec5b48fcab21c307293c33ffb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d1faec5b48fcab21c307293c33ffb1">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet_1_1ElementIterator.html">IndexSet::ElementIterator</a> IndexSet::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator that points one after the last index that is contained in this <a class="el" href="classIndexSet.html">IndexSet</a>. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01580">1580</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="ab27cc09e326df9bcb0cf8b5e258eafad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27cc09e326df9bcb0cf8b5e258eafad">&#9670;&nbsp;</a></span>begin_intervals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet_1_1IntervalIterator.html">IndexSet::IntervalIterator</a> IndexSet::begin_intervals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an Iterator that points at the first interval of this <a class="el" href="classIndexSet.html">IndexSet</a>. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01589">1589</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a3a1df1bf40b6777cee20265d53025738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1df1bf40b6777cee20265d53025738">&#9670;&nbsp;</a></span>end_intervals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet_1_1IntervalIterator.html">IndexSet::IntervalIterator</a> IndexSet::end_intervals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an Iterator that points one after the last interval of this <a class="el" href="classIndexSet.html">IndexSet</a>. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01601">1601</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a3b9f4f812f31c5719bc0ab244e2a5f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9f4f812f31c5719bc0ab244e2a5f7c">&#9670;&nbsp;</a></span>do_compress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::do_compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Actually perform the <a class="el" href="classIndexSet.html#af0d579d3585ade55e22714e7dc9968a7">compress()</a> operation. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8cc_source.html#l00098">98</a> of file <a class="el" href="index__set_8cc_source.html">index_set.cc</a>.</p>

</div>
</div>
<a id="a309aa2408235350293adce28e489d0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309aa2408235350293adce28e489d0b1">&#9670;&nbsp;</a></span>fill_binary_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void IndexSet::fill_binary_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01996">1996</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad28b2e725afda38ffdef1bf61d5cadd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28b2e725afda38ffdef1bf61d5cadd4">&#9670;&nbsp;</a></span>complete_index_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> complete_index_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a>&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create and return an index set of size \(N\) that contains every single index within this range. In essence, this function returns an index set created by </p><div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> is (<a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>);</div><div class="line">is.add_range(0, <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>);</div></div><!-- fragment --><p> This function exists so that one can create and initialize index sets that are complete in one step, or so one can write code like </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (my_index_set == <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(my_index_set.size())</div><div class="line">  ...</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l01013">1013</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac1473031a61493d84806614ac902bb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1473031a61493d84806614ac902bb59">&#9670;&nbsp;</a></span>ranges</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structIndexSet_1_1Range.html">Range</a>&gt; IndexSet::ranges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A set of contiguous ranges of indices that make up (part of) this index set. This variable is always kept sorted.</p>
<p>The variable is marked "mutable" so that it can be changed by <a class="el" href="classIndexSet.html#af0d579d3585ade55e22714e7dc9968a7">compress()</a>, though this of course doesn't change anything about the external representation of this index set. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l00952">952</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="aa971e41b981640576254569d9a75530f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa971e41b981640576254569d9a75530f">&#9670;&nbsp;</a></span>is_compressed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> IndexSet::is_compressed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>True if <a class="el" href="classIndexSet.html#af0d579d3585ade55e22714e7dc9968a7">compress()</a> has been called after the last change in the set of indices.</p>
<p>The variable is marked "mutable" so that it can be changed by <a class="el" href="classIndexSet.html#af0d579d3585ade55e22714e7dc9968a7">compress()</a>, though this of course doesn't change anything about the external representation of this index set. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l00962">962</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="ad34ede8282350f0713b13505c2189029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34ede8282350f0713b13505c2189029">&#9670;&nbsp;</a></span>index_space_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> IndexSet::index_space_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The overall size of the index range. Elements of this index set have to have a smaller number than this value. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l00968">968</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="a172ec8f06243cdc7d3e97a397bbead04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172ec8f06243cdc7d3e97a397bbead04">&#9670;&nbsp;</a></span>largest_range</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">size_type</a> IndexSet::largest_range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This integer caches the index of the largest range in <code>ranges</code>. This gives <code>O(1)</code> access to the range with most elements, while general access costs <code>O(log(n_ranges))</code>. The largest range is needed for the methods <code><a class="el" href="classIndexSet.html#a66c79fc7f17b2eeff0f0fb757e77e0c3">is_element()</a></code>, <code><a class="el" href="classIndexSet.html#a4d924bea58d98feebf99fc714b14b7d0">index_within_set()</a></code>, <code>nth_index_in_set</code>. In many applications, the largest range contains most elements (the locally owned range), whereas there are only a few other elements (ghosts). </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l00979">979</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<a id="ac283586a1a4c9d38b024e05b10913df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac283586a1a4c9d38b024e05b10913df7">&#9670;&nbsp;</a></span>compress_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreads_1_1Mutex.html">Threads::Mutex</a> IndexSet::compress_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A mutex that is used to synchronize operations of the <a class="el" href="classIndexSet.html#a3b9f4f812f31c5719bc0ab244e2a5f7c">do_compress()</a> function that is called from many 'const' functions via <a class="el" href="classIndexSet.html#af0d579d3585ade55e22714e7dc9968a7">compress()</a>. </p>

<p class="definition">Definition at line <a class="el" href="index__set_8h_source.html#l00985">985</a> of file <a class="el" href="index__set_8h_source.html">index_set.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="index__set_8h_source.html">index_set.h</a></li>
<li>source/base/<a class="el" href="index__set_8cc_source.html">index_set.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
