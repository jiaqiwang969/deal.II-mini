<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/vectorization_8h.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: include/deal.II/base/vectorization.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_ee90d91a514b839c31faec7a1d916f67.html">deal.II</a></li><li class="navelem"><a class="el" href="dir_90a2ad6518b731f1dc196d14153b8b6b.html">base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vectorization.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="config_8h_source.html">deal.II/base/config.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="include_2deal_8II_2base_2exceptions_8h_source.html">deal.II/base/exceptions.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="template__constraints_8h_source.html">deal.II/base/template_constraints.h</a>&gt;</code><br />
<code>#include &lt;array&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;x86intrin.h&gt;</code><br />
</div>
<p><a href="vectorization_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEnableIfScalar_3_01VectorizedArray_3_01Number_00_01width_01_4_01_4.html">EnableIfScalar&lt; VectorizedArray&lt; Number, width &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArrayIterator.html">VectorizedArrayIterator&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArrayBase.html">VectorizedArrayBase&lt; T, width &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html">VectorizedArray&lt; Number, width &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1iterator__traits_3_1_1VectorizedArrayIterator_3_01T_01_4_01_4.html">std::iterator_traits&lt;::VectorizedArrayIterator&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad9b7aa5c50bf9ce988a0f756a3f2baa5"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ad9b7aa5c50bf9ce988a0f756a3f2baa5"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:ad9b7aa5c50bf9ce988a0f756a3f2baa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c48f86a4f2adf21555e64049ecde8c"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a11c48f86a4f2adf21555e64049ecde8c"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:a11c48f86a4f2adf21555e64049ecde8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d0134a018bfda1707088d44fa20a86"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ac2d0134a018bfda1707088d44fa20a86"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#ac2d0134a018bfda1707088d44fa20a86">std::tan</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:ac2d0134a018bfda1707088d44fa20a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f846bda83b7e3f4531daacb40c64e1"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a19f846bda83b7e3f4531daacb40c64e1"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:a19f846bda83b7e3f4531daacb40c64e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa674852f105b0ed1b35f569c19fea6"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a2aa674852f105b0ed1b35f569c19fea6"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:a2aa674852f105b0ed1b35f569c19fea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303f564e3c189251976da401ee2e44fa"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a303f564e3c189251976da401ee2e44fa"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:a303f564e3c189251976da401ee2e44fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac114cf7bf36e485eb78fedea2488a0d5"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ac114cf7bf36e485eb78fedea2488a0d5"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#ac114cf7bf36e485eb78fedea2488a0d5">std::pow</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x, const Number p)</td></tr>
<tr class="separator:ac114cf7bf36e485eb78fedea2488a0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c8b2cd70b2640bab8f1ee4ccb7f4cc"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ae5c8b2cd70b2640bab8f1ee4ccb7f4cc"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x, const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;p)</td></tr>
<tr class="separator:ae5c8b2cd70b2640bab8f1ee4ccb7f4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbdfdd72b6cfe4eae5fa7a16385582f"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:aafbdfdd72b6cfe4eae5fa7a16385582f"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:aafbdfdd72b6cfe4eae5fa7a16385582f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a4b202af7a0b7a652d6572c422663f"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a93a4b202af7a0b7a652d6572c422663f"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a93a4b202af7a0b7a652d6572c422663f">std::max</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x, const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;y)</td></tr>
<tr class="separator:a93a4b202af7a0b7a652d6572c422663f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42ab6dd95b8becedec9f3fb4afb0203"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:aa42ab6dd95b8becedec9f3fb4afb0203"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#aa42ab6dd95b8becedec9f3fb4afb0203">std::min</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x, const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;y)</td></tr>
<tr class="separator:aa42ab6dd95b8becedec9f3fb4afb0203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">矢量数组的打包和拆包</div></td></tr>
<tr class="memitem:ad7d7e08942faeecf438c75a254e06cbe"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width = internal::VectorizedArrayWidthSpecifier&lt;Number&gt;::max_width&gt; </td></tr>
<tr class="memitem:ad7d7e08942faeecf438c75a254e06cbe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#ad7d7e08942faeecf438c75a254e06cbe">make_vectorized_array</a> (const Number &amp;u)</td></tr>
<tr class="separator:ad7d7e08942faeecf438c75a254e06cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5618abfc968e28f587c4fcfa1fdb34"><td class="memTemplParams" colspan="2">template&lt;typename VectorizedArrayType &gt; </td></tr>
<tr class="memitem:a1e5618abfc968e28f587c4fcfa1fdb34"><td class="memTemplItemLeft" align="right" valign="top">VectorizedArrayType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a1e5618abfc968e28f587c4fcfa1fdb34">make_vectorized_array</a> (const typename VectorizedArrayType::value_type &amp;u)</td></tr>
<tr class="separator:a1e5618abfc968e28f587c4fcfa1fdb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078ca5de8d3a59aedc130823be15ad26"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a078ca5de8d3a59aedc130823be15ad26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a078ca5de8d3a59aedc130823be15ad26">gather</a> (<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;out, const std::array&lt; Number *, width &gt; &amp;ptrs, const unsigned <a class="el" href="classint.html">int</a> offset)</td></tr>
<tr class="separator:a078ca5de8d3a59aedc130823be15ad26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14da4327264fd3a88a9f73a8f72a9094"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a14da4327264fd3a88a9f73a8f72a9094"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a14da4327264fd3a88a9f73a8f72a9094">vectorized_load_and_transpose</a> (const unsigned <a class="el" href="classint.html">int</a> n_entries, const Number *in, const unsigned <a class="el" href="classint.html">int</a> *offsets, <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *out)</td></tr>
<tr class="separator:a14da4327264fd3a88a9f73a8f72a9094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7f7b3cdcf7b71718bee43a9cbc27f8"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a6e7f7b3cdcf7b71718bee43a9cbc27f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a6e7f7b3cdcf7b71718bee43a9cbc27f8">vectorized_load_and_transpose</a> (const unsigned <a class="el" href="classint.html">int</a> n_entries, const std::array&lt; Number *, width &gt; &amp;in, <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *out)</td></tr>
<tr class="separator:a6e7f7b3cdcf7b71718bee43a9cbc27f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af396b43c783502e8acd2ca7d071a7325"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:af396b43c783502e8acd2ca7d071a7325"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#af396b43c783502e8acd2ca7d071a7325">vectorized_transpose_and_store</a> (const <a class="el" href="classbool.html">bool</a> add_into, const unsigned <a class="el" href="classint.html">int</a> n_entries, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *in, const unsigned <a class="el" href="classint.html">int</a> *offsets, Number *out)</td></tr>
<tr class="separator:af396b43c783502e8acd2ca7d071a7325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e4c80a49c6df42c3831655bdb318ab"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a63e4c80a49c6df42c3831655bdb318ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a63e4c80a49c6df42c3831655bdb318ab">vectorized_transpose_and_store</a> (const <a class="el" href="classbool.html">bool</a> add_into, const unsigned <a class="el" href="classint.html">int</a> n_entries, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *in, std::array&lt; Number *, width &gt; &amp;out)</td></tr>
<tr class="separator:a63e4c80a49c6df42c3831655bdb318ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">用VectorizedArray进行算术运算</div></td></tr>
<tr class="memitem:a60e4e5dd338cf4353bbdccc117fa883d"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a60e4e5dd338cf4353bbdccc117fa883d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a60e4e5dd338cf4353bbdccc117fa883d">operator==</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;lhs, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;rhs)</td></tr>
<tr class="separator:a60e4e5dd338cf4353bbdccc117fa883d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad938a80e7098f4bf2193b14a14e73460"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ad938a80e7098f4bf2193b14a14e73460"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#ad938a80e7098f4bf2193b14a14e73460">operator+</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:ad938a80e7098f4bf2193b14a14e73460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655230f65541b3787d1f71fa57a44072"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a655230f65541b3787d1f71fa57a44072"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a655230f65541b3787d1f71fa57a44072">operator-</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:a655230f65541b3787d1f71fa57a44072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab848bd1da37f381f87cb5eaf51de6019"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ab848bd1da37f381f87cb5eaf51de6019"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#ab848bd1da37f381f87cb5eaf51de6019">operator*</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:ab848bd1da37f381f87cb5eaf51de6019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92490d85f7b45a7e55a1a77b1e070b1"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ad92490d85f7b45a7e55a1a77b1e070b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#ad92490d85f7b45a7e55a1a77b1e070b1">operator/</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:ad92490d85f7b45a7e55a1a77b1e070b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b8b0dc43deb68af60df1a76f8badb3"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a53b8b0dc43deb68af60df1a76f8badb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a53b8b0dc43deb68af60df1a76f8badb3">operator+</a> (const Number &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:a53b8b0dc43deb68af60df1a76f8badb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1ad99276a124e6b2262e6adc2621a4"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:abd1ad99276a124e6b2262e6adc2621a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#abd1ad99276a124e6b2262e6adc2621a4">operator+</a> (const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v)</td></tr>
<tr class="separator:abd1ad99276a124e6b2262e6adc2621a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfc4e9feda79490243911ac8389abeb"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a1bfc4e9feda79490243911ac8389abeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a1bfc4e9feda79490243911ac8389abeb">operator+</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v, const Number &amp;u)</td></tr>
<tr class="separator:a1bfc4e9feda79490243911ac8389abeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041de227d36132ca524ee4178d98093b"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:a041de227d36132ca524ee4178d98093b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a041de227d36132ca524ee4178d98093b">operator+</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v, const <a class="el" href="classdouble.html">double</a> u)</td></tr>
<tr class="separator:a041de227d36132ca524ee4178d98093b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad492519b2494af83eaa083eee9a7d7f"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:aad492519b2494af83eaa083eee9a7d7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#aad492519b2494af83eaa083eee9a7d7f">operator-</a> (const Number &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:aad492519b2494af83eaa083eee9a7d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c891c4bdf89ab5fece2d15da7f7e21a"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:a4c891c4bdf89ab5fece2d15da7f7e21a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a4c891c4bdf89ab5fece2d15da7f7e21a">operator-</a> (const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v)</td></tr>
<tr class="separator:a4c891c4bdf89ab5fece2d15da7f7e21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bda9e065a143791d3a12c41843c603d"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a3bda9e065a143791d3a12c41843c603d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a3bda9e065a143791d3a12c41843c603d">operator-</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v, const Number &amp;u)</td></tr>
<tr class="separator:a3bda9e065a143791d3a12c41843c603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9740a3e31e10c1a08e1c3d0a673da29e"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:a9740a3e31e10c1a08e1c3d0a673da29e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a9740a3e31e10c1a08e1c3d0a673da29e">operator-</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v, const <a class="el" href="classdouble.html">double</a> u)</td></tr>
<tr class="separator:a9740a3e31e10c1a08e1c3d0a673da29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd70ba108142e51cf551ef397538d319"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:abd70ba108142e51cf551ef397538d319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#abd70ba108142e51cf551ef397538d319">operator*</a> (const Number &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:abd70ba108142e51cf551ef397538d319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88298154660a2544e69a5d98e9c1347"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:af88298154660a2544e69a5d98e9c1347"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#af88298154660a2544e69a5d98e9c1347">operator*</a> (const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v)</td></tr>
<tr class="separator:af88298154660a2544e69a5d98e9c1347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e38a9fd6c14af630fd5d2ce05a90a7"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a36e38a9fd6c14af630fd5d2ce05a90a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a36e38a9fd6c14af630fd5d2ce05a90a7">operator*</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v, const Number &amp;u)</td></tr>
<tr class="separator:a36e38a9fd6c14af630fd5d2ce05a90a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c6e2d4507e185ef3e691897d068885"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:a67c6e2d4507e185ef3e691897d068885"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a67c6e2d4507e185ef3e691897d068885">operator*</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v, const <a class="el" href="classdouble.html">double</a> u)</td></tr>
<tr class="separator:a67c6e2d4507e185ef3e691897d068885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b532bf8e52de9bdf6f50a32e0e7850"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ac8b532bf8e52de9bdf6f50a32e0e7850"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#ac8b532bf8e52de9bdf6f50a32e0e7850">operator/</a> (const Number &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:ac8b532bf8e52de9bdf6f50a32e0e7850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f25b89d500cb7729727d9fb88aba1d"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:af6f25b89d500cb7729727d9fb88aba1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#af6f25b89d500cb7729727d9fb88aba1d">operator/</a> (const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v)</td></tr>
<tr class="separator:af6f25b89d500cb7729727d9fb88aba1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250c9df8da4b13efaab02e1302dfc60f"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a250c9df8da4b13efaab02e1302dfc60f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a250c9df8da4b13efaab02e1302dfc60f">operator/</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v, const Number &amp;u)</td></tr>
<tr class="separator:a250c9df8da4b13efaab02e1302dfc60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba8c9defa578058e48dde1e112a67da"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:a2ba8c9defa578058e48dde1e112a67da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a2ba8c9defa578058e48dde1e112a67da">operator/</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v, const <a class="el" href="classdouble.html">double</a> u)</td></tr>
<tr class="separator:a2ba8c9defa578058e48dde1e112a67da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f68552b3739e75e9ff533277174863"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a55f68552b3739e75e9ff533277174863"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a55f68552b3739e75e9ff533277174863">operator+</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u)</td></tr>
<tr class="separator:a55f68552b3739e75e9ff533277174863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00794d026f4360efda32d2e3a0c0ce72"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a00794d026f4360efda32d2e3a0c0ce72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a00794d026f4360efda32d2e3a0c0ce72">operator-</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u)</td></tr>
<tr class="separator:a00794d026f4360efda32d2e3a0c0ce72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3676d2de40d79d2ab01808334e9a69b9"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a3676d2de40d79d2ab01808334e9a69b9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a3676d2de40d79d2ab01808334e9a69b9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;p)</td></tr>
<tr class="separator:a3676d2de40d79d2ab01808334e9a69b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
对VectorizedArray的三元操作</h2></td></tr>
<tr class="memitem:a31b02447b71a04a1ec9bdd1358751e45"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45">SIMDComparison</a> : int { <br />
&#160;&#160;<a class="el" href="vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">SIMDComparison::equal</a>, 
<a class="el" href="vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a96ee5c0e2a7149613e7fd0b83316486e">SIMDComparison::not_equal</a>, 
<a class="el" href="vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a7875e44acb1bebecb46c929deb43cef4">SIMDComparison::less_than</a>, 
<a class="el" href="vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a9f6a1c1739ff468513ed276436f3db72">SIMDComparison::less_than_or_equal</a>, 
<br />
&#160;&#160;<a class="el" href="vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45af9001e5685fe6f7cb467dc66269470b2">SIMDComparison::greater_than</a>, 
<a class="el" href="vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45ae69e99a9a1111b6a811f8e5bd832454f">SIMDComparison::greater_than_or_equal</a>
<br />
 }</td></tr>
<tr class="separator:a31b02447b71a04a1ec9bdd1358751e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac274b257ee3ff9666b2062b8ba56db8f"><td class="memTemplParams" colspan="2">template&lt;SIMDComparison predicate, typename Number &gt; </td></tr>
<tr class="memitem:ac274b257ee3ff9666b2062b8ba56db8f"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#ac274b257ee3ff9666b2062b8ba56db8f">compare_and_apply_mask</a> (const Number &amp;left, const Number &amp;right, const Number &amp;true_value, const Number &amp;false_value)</td></tr>
<tr class="separator:ac274b257ee3ff9666b2062b8ba56db8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a14956ceb21a6bc048b2c5ced72845"><td class="memTemplParams" colspan="2">template&lt;SIMDComparison predicate, typename Number &gt; </td></tr>
<tr class="memitem:a67a14956ceb21a6bc048b2c5ced72845"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="vectorization_8h.html#a67a14956ceb21a6bc048b2c5ced72845">compare_and_apply_mask</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;left, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;right, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;true_value, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;false_value)</td></tr>
<tr class="separator:a67a14956ceb21a6bc048b2c5ced72845"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a31b02447b71a04a1ec9bdd1358751e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b02447b71a04a1ec9bdd1358751e45">&#9670;&nbsp;</a></span>SIMDComparison</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45">SIMDComparison</a> : <a class="el" href="classint.html">int</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>编码二进制操作的枚举类，用于对VectorizedArray数据类型进行组件式比较。</p>
<dl class="section note"><dt>Note</dt><dd>在SIMD矢量化（sse, avx, av512）的情况下，我们选择相应的有序、非信号（ <code>OQ</code> ）变体。 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f"></a>equal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a96ee5c0e2a7149613e7fd0b83316486e"></a>not_equal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a7875e44acb1bebecb46c929deb43cef4"></a>less_than&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a9f6a1c1739ff468513ed276436f3db72"></a>less_than_or_equal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45af9001e5685fe6f7cb467dc66269470b2"></a>greater_than&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45ae69e99a9a1111b6a811f8e5bd832454f"></a>greater_than_or_equal&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05027">5027</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad7d7e08942faeecf438c75a254e06cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d7e08942faeecf438c75a254e06cbe">&#9670;&nbsp;</a></span>make_vectorized_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width = internal::VectorizedArrayWidthSpecifier&lt;Number&gt;::max_width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; make_vectorized_array </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建一个矢量数组，将数组中的所有条目设置为给定的标量，也就是说，将标量广播到所有数组元素。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00693">693</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a1e5618abfc968e28f587c4fcfa1fdb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5618abfc968e28f587c4fcfa1fdb34">&#9670;&nbsp;</a></span>make_vectorized_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorizedArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType make_vectorized_array </td>
          <td>(</td>
          <td class="paramtype">const typename VectorizedArrayType::value_type &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建一个给定类型的矢量数组，并将标量值广播给所有数组元素。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00709">709</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a078ca5de8d3a59aedc130823be15ad26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078ca5de8d3a59aedc130823be15ad26">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Number *, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从内存中加载size()数据项到VectorizedArray <code>out</code>, ，从给定的地址和给定的偏移量开始，从偏移量开始的每个条目提供一个矢量化数组的元素。 这个操作对应于以下代码。</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;VectorizedArray&lt;Number&gt;::size(); ++v)</div><div class="line">out.data[v] = ptrs[v][offset];</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00738">738</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a14da4327264fd3a88a9f73a8f72a9094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14da4327264fd3a88a9f73a8f72a9094">&#9670;&nbsp;</a></span>vectorized_load_and_transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vectorized_load_and_transpose </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个方法从给定的数组 <code>in</code>. 中加载 <a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray::size()</a> 数据流，输入数组的偏移量由数组 <code>偏移量给出。从每个数据流中读取n_entries。然后数据被转置并存储到一个VectorizedArray类型的数组中。输出数组</code> <code>out预计是一个大小为</code> <code>n_entries</code>. 的数组。这个方法在普通数组上操作，所以没有检查有效的数据访问。用户有责任确保给定的数组根据下面的访问布局是有效的。 该操作对应于根据以下公式将一个结构数组（输入）转换为一个数组结构（输出）。</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_entries; ++i)</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;VectorizedArray&lt;Number&gt;::size(); ++v)</div><div class="line">  out[i][v] = in[offsets[v]+i];</div></div><!-- fragment --><p>该代码的一个更优化的版本将用于支持的类型。 这是对vectorized_transpose_and_store()的逆向操作。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00771">771</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a6e7f7b3cdcf7b71718bee43a9cbc27f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7f7b3cdcf7b71718bee43a9cbc27f8">&#9670;&nbsp;</a></span>vectorized_load_and_transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vectorized_load_and_transpose </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Number *, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与上面的函数相同，不同的是将一个指针数组作为输入参数传入 <code>in</code>. 。 与上面的函数类比，可以认为 "in+offset[v]"是预先计算并作为输入参数传递的。 然而，如果某些函数返回一个指针数组，并且不能假设它们属于同一个数组，也就是说，它们可以在不同的内存分配中获得原点，那么也可以使用这个函数。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00792">792</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="af396b43c783502e8acd2ca7d071a7325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af396b43c783502e8acd2ca7d071a7325">&#9670;&nbsp;</a></span>vectorized_transpose_and_store() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vectorized_transpose_and_store </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>add_into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>该方法以转置的形式将矢量数组存储到给定的输出数组 <code>out</code> 中，并给定偏移量 <code>offsets</code>. ，该操作相当于将一个数组结构（输入）转换为一个数组结构（输出）。该方法对纯数组进行操作，所以没有对有效的数据访问进行检查。用户有责任确保给定的数组根据下面的访问布局是有效的。 该方法假设指定的偏移量不重叠。否则，在矢量化的情况下，该行为是未定义的。用户有责任确保访问不重叠，避免未定义的行为。 参数 <code>add_into</code> 选择哪里的条目应该只被写入输出数组，或者结果应该被添加到输出的现有条目中。对于 <code>add_into == false</code> ，假设以下代码。</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_entries; ++i)</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;VectorizedArray&lt;Number&gt;::size(); ++v)</div><div class="line">  out[offsets[v]+i] = in[i][v];</div></div><!-- fragment --><p>对于 <code>add_into == true</code> ，代码实现了以下动作。 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_entries; ++i)</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;VectorizedArray&lt;Number&gt;::size(); ++v)</div><div class="line">  out[offsets[v]+i] += in[i][v];</div></div><!-- fragment --><p>对于支持的类型，将使用该代码的一个更优化的版本。 这是对vectorized_load_and_transpose()的逆向操作。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00834">834</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a63e4c80a49c6df42c3831655bdb318ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e4c80a49c6df42c3831655bdb318ab">&#9670;&nbsp;</a></span>vectorized_transpose_and_store() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vectorized_transpose_and_store </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>add_into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Number *, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>和上面一样，不同的是，一个指针数组被作为输入参数传入 <code>out</code>. 。 与上面的函数相类似，可以认为<code>out+offset[v]</code>是预先计算好的，并作为输入参数传入。 然而，如果某些函数返回一个指针数组，并且不能假设它们属于同一个数组，也就是说，它们可以在不同的内存分配中拥有自己的原点，那么也可以使用这个函数。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00861">861</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a60e4e5dd338cf4353bbdccc117fa883d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e4e5dd338cf4353bbdccc117fa883d">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对VectorizedArray的关系运算符== </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04644">4644</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ad938a80e7098f4bf2193b14a14e73460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad938a80e7098f4bf2193b14a14e73460">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用操作符+对两个矢量数组进行加法。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04663">4663</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a655230f65541b3787d1f71fa57a44072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655230f65541b3787d1f71fa57a44072">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>两个矢量数组的减法，用操作符</p>
<ul>
<li></li>
</ul>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04680">4680</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ab848bd1da37f381f87cb5eaf51de6019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab848bd1da37f381f87cb5eaf51de6019">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用运算符对两个矢量数组进行乘法。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04695">4695</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ad92490d85f7b45a7e55a1a77b1e070b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92490d85f7b45a7e55a1a77b1e070b1">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用运算符/对两个矢量数组进行除法。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04710">4710</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a53b8b0dc43deb68af60df1a76f8badb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b8b0dc43deb68af60df1a76f8badb3">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个标量（用 <code>size()相等的条目扩展为一个向量数组）和一个向量数组的加法。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04726">4726</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="abd1ad99276a124e6b2262e6adc2621a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1ad99276a124e6b2262e6adc2621a4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在标量是双数的情况下，标量的加法（扩展为矢量数组， <code>size()相等的条目）和矢量数组的加法（为了能够用通常是双数的常量编写简单的代码而需要）。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04742">4742</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a1bfc4e9feda79490243911ac8389abeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfc4e9feda79490243911ac8389abeb">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矢量数组和标量的相加（扩展为一个具有 <code>size()</code> 等量项的矢量数组）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04757">4757</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a041de227d36132ca524ee4178d98093b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041de227d36132ca524ee4178d98093b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在标量为双数的情况下，将一个矢量数组和一个标量相加（扩展为一个具有 <code>size()</code> 相等条目的矢量数组）（为了能够用通常为双数的常量编写简单的代码而需要）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04772">4772</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="aad492519b2494af83eaa083eee9a7d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad492519b2494af83eaa083eee9a7d7f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从标量中减去一个矢量数组（扩展为一个具有 <code>size()</code> 相等条目的矢量数组）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04786">4786</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a4c891c4bdf89ab5fece2d15da7f7e21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c891c4bdf89ab5fece2d15da7f7e21a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在标量为双数的情况下，从标量中减去一个矢量数组（扩展为一个具有 <code>size()</code> 相等条目的矢量数组）（为了能够用通常为双数的常数编写简单的代码而需要）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04802">4802</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a3bda9e065a143791d3a12c41843c603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bda9e065a143791d3a12c41843c603d">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一个矢量数组中减去一个标量（扩展为一个矢量数组， <code>size()等于条目）。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04817">4817</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a9740a3e31e10c1a08e1c3d0a673da29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9740a3e31e10c1a08e1c3d0a673da29e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一个矢量数组中减去一个标量（扩展为一个矢量数组， <code>size()相等的条目），如果该标量是一个双数（为了能够用通常是双数的常量编写简单的代码而需要）。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04833">4833</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="abd70ba108142e51cf551ef397538d319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd70ba108142e51cf551ef397538d319">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个标量（扩展为一个具有 <code>size()等分项的向量数组）和一个向量数组的乘法。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04848">4848</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="af88298154660a2544e69a5d98e9c1347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88298154660a2544e69a5d98e9c1347">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在标量是双数的情况下，标量（扩展为一个矢量数组， <code>size()相等的条目）和矢量数组的乘法（为了能够用通常是双数的常量编写简单的代码而需要）。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04863">4863</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a36e38a9fd6c14af630fd5d2ce05a90a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e38a9fd6c14af630fd5d2ce05a90a7">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矢量数组和标量的乘法（扩展为具有 <code>size()</code> 相等条目的矢量数组）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04878">4878</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a67c6e2d4507e185ef3e691897d068885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c6e2d4507e185ef3e691897d068885">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在标量为双数的情况下，矢量数组和标量的乘法（扩展为具有 <code>size()</code> 相等条目的矢量数组）（为了能够用通常为双数的常量编写简单的代码而需要）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04893">4893</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ac8b532bf8e52de9bdf6f50a32e0e7850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b532bf8e52de9bdf6f50a32e0e7850">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>标量（扩展为矢量数组， <code>size()等于条目）与矢量数组之间的商。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04907">4907</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="af6f25b89d500cb7729727d9fb88aba1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f25b89d500cb7729727d9fb88aba1d">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在标量是双数的情况下，标量（扩展为具有 <code>size()相等条目的向量数组）和向量数组之间的商（为了能够用通常为双数的常量编写简单的代码，需要）。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04922">4922</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a250c9df8da4b13efaab02e1302dfc60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250c9df8da4b13efaab02e1302dfc60f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矢量数组和标量之间的商（扩展为具有 <code>size()</code> 相等条目的矢量数组）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04937">4937</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a2ba8c9defa578058e48dde1e112a67da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba8c9defa578058e48dde1e112a67da">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在标量为双数的情况下，矢量数组和标量之间的商（扩展为具有 <code>size()</code> 相等条目的矢量数组）（为了能够用通常为双数的常量编写简单的代码而需要）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04953">4953</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a55f68552b3739e75e9ff533277174863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f68552b3739e75e9ff533277174863">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矢量化数组上的单项运算符+。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04967">4967</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a00794d026f4360efda32d2e3a0c0ce72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00794d026f4360efda32d2e3a0c0ce72">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>单元运算符</p>
<ul>
<li>在一个矢量化数组上。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04982">4982</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a3676d2de40d79d2ab01808334e9a69b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3676d2de40d79d2ab01808334e9a69b9">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矢量化数组的输出运算符。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04997">4997</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ac274b257ee3ff9666b2062b8ba56db8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac274b257ee3ff9666b2062b8ba56db8f">&#9670;&nbsp;</a></span>compare_and_apply_mask() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SIMDComparison predicate, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number compare_and_apply_mask </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>true_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>false_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算以下三元操作的矢量等价物。</p>
<div class="fragment"><div class="line">(left OP right) ? true_value : false_value</div></div><!-- fragment --><p> 其中 <code>OP</code> is a binary operator (such as <code>=</code> , <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> , 和 <code>&gt;=</code> )。 当控制流本身取决于（计算的）数据时，这样的计算成语作为分支的替代是很有用的。例如，在标量数据类型的情况下，语句 <code>(left &lt; right) ? true_value : false_value</code> 也可以使用 <code>if</code> 语句来实现。</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (left &lt; right)</div><div class="line">  result = true_value;</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  result = false_value;</div></div><!-- fragment --><p> 然而，这在向量化的情况下是根本不可能的，因为不同的向量条目（通道）需要不同的决定，所以必须使用第一个变体（基于三元运算符）来代替。</p>
<div class="fragment"><div class="line">result = compare_and_apply_mask&lt;SIMDComparison::less_than&gt;</div><div class="line">  (left, right, true_value, false_value);</div></div><!-- fragment --><p> 一些更具说明性的例子（比专用的 <code>std::max</code> and <code>std::abs</code> 重载效率低）。</p>
<div class="fragment"><div class="line"><a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> left;</div><div class="line"><a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> right;</div><div class="line"></div><div class="line"><span class="comment">// std::max</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> maximum = compare_and_apply_mask&lt;SIMDComparison::greater_than&gt;</div><div class="line">  (left, right, left, right);</div><div class="line"></div><div class="line"><span class="comment">// std::abs</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> absolute = compare_and_apply_mask&lt;SIMDComparison::less_than&gt;</div><div class="line">  (left, <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a>(0.),</div><div class="line"></div><div class="line">-left, left);</div></div><!-- fragment --><p>更确切地说，这个函数首先计算一个（布尔）掩码，它是二进制运算符 <code>OP</code> 应用于VectorizedArray参数 <code>left</code> 和 <code>right</code>. 的所有元素的结果，然后掩码被用来选择 <code>true_value</code> 的相应组件（如果二进制运算相当于真），或者 <code>false_value</code>. 二进制运算符通过SIMDComparison模板参数 <code>predicate</code>. 编码。 为了方便通用编程方法，该函数为所有VectorizedArray&lt;Number&gt;变体以及通用POD类型（如double和float）提供重载。</p>
<dl class="section note"><dt>Note</dt><dd>为了使这个函数工作，二进制操作必须通过SIMDComparison模板参数进行编码。这也解释了为什么 <code>predicate</code> 是一个编译时常量模板参数，而不是一个常量函数参数。为了能够发出正确的低级指令，编译器必须在编译时知道比较的情况。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05108">5108</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a67a14956ceb21a6bc048b2c5ced72845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a14956ceb21a6bc048b2c5ced72845">&#9670;&nbsp;</a></span>compare_and_apply_mask() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SIMDComparison predicate, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, 1&gt; compare_and_apply_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>true_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>false_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数对非矢量化的VectorizedArray&lt;Number, 1&gt;变体的特殊化。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05148">5148</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="file_ad9b7aa5c50bf9ce988a0f756a3f2baa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ad9b7aa5c50bf9ce988a0f756a3f2baa5">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::sin </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算一个矢量数据域的正弦。结果将以<code>{sin(x[0]), sin(x[1]), ..., sin(x[<a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray::size()</a>-1])}</code>. VectorizedArray的形式返回。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05334">5334</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="file_a11c48f86a4f2adf21555e64049ecde8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a11c48f86a4f2adf21555e64049ecde8c">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::cos </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算一个矢量数据域的余弦。结果以矢量数组的形式返回<code>{cos(x[0]), cos(x[1]), ..., cos(x[size()-1]) }</code>。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05359">5359</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="file_ac2d0134a018bfda1707088d44fa20a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ac2d0134a018bfda1707088d44fa20a86">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::tan </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算一个矢量数据域的正切。结果以矢量数组的形式返回<code>{tan(x[0]), tan(x[1]), ..., tan(x[size()-1]) }</code>。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05379">5379</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="file_a19f846bda83b7e3f4531daacb40c64e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a19f846bda83b7e3f4531daacb40c64e1">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::exp </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算一个矢量数据域的指数。结果以矢量数组的形式返回<code>{exp(x[0]), exp(x[1]), ..., exp(x[size()-1]) }</code>。 <a class="el" href="classVectorizedArray.html">VectorizedArray</a> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05400">5400</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="file_a2aa674852f105b0ed1b35f569c19fea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a2aa674852f105b0ed1b35f569c19fea6">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::log </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算一个矢量数据域的自然对数。结果以矢量数组的形式返回<code>{log(x[0]), log(x[1]), ..., log(x[size()-1])}</code>。 <a class="el" href="classVectorizedArray.html">VectorizedArray</a> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05421">5421</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="file_a303f564e3c189251976da401ee2e44fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a303f564e3c189251976da401ee2e44fa">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::sqrt </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算一个矢量数据域的平方根。结果以矢量数组的形式返回<code>{sqrt(x[0]), sqrt(x[1]), ..., sqrt(x[size()-1]) }</code>。 矢量Array </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05442">5442</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="file_ac114cf7bf36e485eb78fedea2488a0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ac114cf7bf36e485eb78fedea2488a0d5">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::pow </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的数字 <code>x</code> 提高到幂数 <code>p</code> ，用于一个矢量数据域。结果以矢量数组的形式返回<code>{pow(x[0],p), pow(x[1],p), ..., pow(x[size()-1], p)}</code>。 矢量Array </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05458">5458</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="file_ae5c8b2cd70b2640bab8f1ee4ccb7f4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::pow </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的数字 <code>x</code> 提高到幂数 <code>p</code> ，用于一个矢量数据域。结果以矢量数组的形式返回<code>{pow(x[0],p[0]), pow(x[1],p[1]), ..., pow(x[size()-1],p[size()-1]) }</code>。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05480">5480</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="file_aafbdfdd72b6cfe4eae5fa7a16385582f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_aafbdfdd72b6cfe4eae5fa7a16385582f">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::abs </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算一个矢量数据字段的绝对值（模数）。结果以矢量数组的形式返回<code>{abs(x[0]), abs(x[1]), ..., abs(x[size()-1]) }</code>。 <a class="el" href="classVectorizedArray.html">VectorizedArray</a> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05502">5502</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="file_a93a4b202af7a0b7a652d6572c422663f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_a93a4b202af7a0b7a652d6572c422663f">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::max </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算两个矢量数据域的分量最大。结果以矢量数组的形式返回<code>{max(x[0],y[0]), max(x[1],y[1), ...}</code>。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05516">5516</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="file_aa42ab6dd95b8becedec9f3fb4afb0203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#file_aa42ab6dd95b8becedec9f3fb4afb0203">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::min </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算两个矢量数据域的分量最小值。结果以矢量数组的形式返回<code>{min(x[0],y[0]), min(x[1],y[1), ...}</code>。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05531">5531</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
