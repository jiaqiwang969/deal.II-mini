<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classParticles_1_1Particle.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Particles::Particle&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceParticles.html">Particles</a></li><li class="navelem"><a class="el" href="classParticles_1_1Particle.html">Particle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classParticles_1_1Particle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Particles::Particle&lt; dim, spacedim &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="particle_8h_source.html">deal.II/particles/particle.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9d21199ff7647463d85c4f926a1db99a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a9d21199ff7647463d85c4f926a1db99a">Particle</a> ()</td></tr>
<tr class="separator:a9d21199ff7647463d85c4f926a1db99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d99f2a2d1a950e5692478ea377f9499"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a2d99f2a2d1a950e5692478ea377f9499">Particle</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;location, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;reference_location, const <a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a> id)</td></tr>
<tr class="separator:a2d99f2a2d1a950e5692478ea377f9499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cefce1f23c8439b77664d407c07d05"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a25cefce1f23c8439b77664d407c07d05">Particle</a> (const <a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt; &amp;particle)</td></tr>
<tr class="separator:a25cefce1f23c8439b77664d407c07d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d76f39851eaefd086baf983599971b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a7d76f39851eaefd086baf983599971b3">Particle</a> (const void *&amp;begin_data, <a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt; dim, spacedim &gt; *const <a class="el" href="classParticles_1_1Particle.html#a074d6cc8b4aef38ba5863d4057f2e027">property_pool</a>=nullptr)</td></tr>
<tr class="separator:a7d76f39851eaefd086baf983599971b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dba9dac9ff84ef2bbbeb0a179493e8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a5dba9dac9ff84ef2bbbeb0a179493e8a">Particle</a> (<a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt; &amp;&amp;particle) noexcept</td></tr>
<tr class="separator:a5dba9dac9ff84ef2bbbeb0a179493e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fce5e73bf2104b712025e4f288fa4b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a3fce5e73bf2104b712025e4f288fa4b3">operator=</a> (const <a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt; &amp;particle)</td></tr>
<tr class="separator:a3fce5e73bf2104b712025e4f288fa4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5a9f0f50a2d9cbc7c22830d8de6fc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a7b5a9f0f50a2d9cbc7c22830d8de6fc2">operator=</a> (<a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt; &amp;&amp;particle) noexcept</td></tr>
<tr class="separator:a7b5a9f0f50a2d9cbc7c22830d8de6fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9171a9887d416b823ac86082853425f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a9171a9887d416b823ac86082853425f4">~Particle</a> ()</td></tr>
<tr class="separator:a9171a9887d416b823ac86082853425f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1db4febc1aca752fabd0a55d3b60d8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a1c1db4febc1aca752fabd0a55d3b60d8">write_particle_data_to_memory</a> (void *data) const</td></tr>
<tr class="separator:a1c1db4febc1aca752fabd0a55d3b60d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ba1e93a3ecdb6094024957df4daef3"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a94ba1e93a3ecdb6094024957df4daef3">read_particle_data_from_memory</a> (const void *data)</td></tr>
<tr class="separator:a94ba1e93a3ecdb6094024957df4daef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe52b594cf4a8dd11431679c4ef2b52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#afbe52b594cf4a8dd11431679c4ef2b52">set_location</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;new_location)</td></tr>
<tr class="separator:afbe52b594cf4a8dd11431679c4ef2b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a743cf6f5bc6fca3e9542f5d6e1120f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a1a743cf6f5bc6fca3e9542f5d6e1120f">get_location</a> () const</td></tr>
<tr class="separator:a1a743cf6f5bc6fca3e9542f5d6e1120f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57efa2034baca617ba3160ccfbbc7cd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a57efa2034baca617ba3160ccfbbc7cd7">set_reference_location</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;new_reference_location)</td></tr>
<tr class="separator:a57efa2034baca617ba3160ccfbbc7cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f64953c7ec8ff0faceae5a29669d9c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a0f64953c7ec8ff0faceae5a29669d9c6">get_reference_location</a> () const</td></tr>
<tr class="separator:a0f64953c7ec8ff0faceae5a29669d9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9627b1ebd43abb055816adc57e7cf8f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a9627b1ebd43abb055816adc57e7cf8f6">get_id</a> () const</td></tr>
<tr class="separator:a9627b1ebd43abb055816adc57e7cf8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af792bce47ec4746ad2c78e7e800299a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#af792bce47ec4746ad2c78e7e800299a8">set_id</a> (const <a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a> &amp;new_id)</td></tr>
<tr class="separator:af792bce47ec4746ad2c78e7e800299a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f7db69aaa3e8d861a60b44ca9ec279"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a09f7db69aaa3e8d861a60b44ca9ec279">set_property_pool</a> (<a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classParticles_1_1Particle.html#a074d6cc8b4aef38ba5863d4057f2e027">property_pool</a>)</td></tr>
<tr class="separator:a09f7db69aaa3e8d861a60b44ca9ec279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7b93d7c9670ac760386cbe64773fec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a2b7b93d7c9670ac760386cbe64773fec">has_properties</a> () const</td></tr>
<tr class="separator:a2b7b93d7c9670ac760386cbe64773fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da7bfae83b0c75fcd6a5457e5fae64c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a7da7bfae83b0c75fcd6a5457e5fae64c">set_properties</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;new_properties)</td></tr>
<tr class="separator:a7da7bfae83b0c75fcd6a5457e5fae64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fe2147753d060e95be08fe76a463b7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a46fe2147753d060e95be08fe76a463b7">get_properties</a> ()</td></tr>
<tr class="separator:a46fe2147753d060e95be08fe76a463b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918096fc38e5e26f650aced662809d7a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a918096fc38e5e26f650aced662809d7a">get_properties</a> () const</td></tr>
<tr class="separator:a918096fc38e5e26f650aced662809d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639e04d8078a0c31d964fa48764134ac"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a639e04d8078a0c31d964fa48764134ac">serialized_size_in_bytes</a> () const</td></tr>
<tr class="separator:a639e04d8078a0c31d964fa48764134ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65392a702c578682a2e7f0b92435a053"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a65392a702c578682a2e7f0b92435a053"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a65392a702c578682a2e7f0b92435a053">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:a65392a702c578682a2e7f0b92435a053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7d2296e18b3339ec2ee32e2738818c"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:acd7d2296e18b3339ec2ee32e2738818c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#acd7d2296e18b3339ec2ee32e2738818c">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:acd7d2296e18b3339ec2ee32e2738818c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af307e61f872fc0223939865c5725be7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#af307e61f872fc0223939865c5725be7d">free_properties</a> ()</td></tr>
<tr class="separator:af307e61f872fc0223939865c5725be7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85d00534692892558504b899f769a96"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:af85d00534692892558504b899f769a96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#af85d00534692892558504b899f769a96">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:af85d00534692892558504b899f769a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a074d6cc8b4aef38ba5863d4057f2e027"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt; dim, spacedim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a074d6cc8b4aef38ba5863d4057f2e027">property_pool</a></td></tr>
<tr class="separator:a074d6cc8b4aef38ba5863d4057f2e027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa822d7240695551e9c95b1139cfe7bb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt; dim, spacedim &gt;::Handle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#aa822d7240695551e9c95b1139cfe7bb6">property_pool_handle</a></td></tr>
<tr class="separator:aa822d7240695551e9c95b1139cfe7bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a40323e77410c5f2a65a36d8a12b6364b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt; dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParticles_1_1Particle.html#a40323e77410c5f2a65a36d8a12b6364b">global_property_pool</a></td></tr>
<tr class="separator:a40323e77410c5f2a65a36d8a12b6364b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class Particles::Particle&lt; dim, spacedim &gt;</h3>

<p>A class that represents a particle in a domain that is meshed by a triangulation of some kind. The data this class stores is the position of the particle in the overall space, the position of the particle in the reference coordinate system of the cell it is currently in, an ID number that is unique among all particles, and a variable number of "properties".</p>
<p>The "properties" attached to each object of this class are stored by a <a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a> object. These properties are stored as an array of <code>double</code> variables that can be accessed via an <a class="el" href="classArrayView.html">ArrayView</a> object. For example, if one wanted to equip each particle with a "temperature" and "chemical composition" property that is advected along with the particle (and may change from time step to time step based on some differential equation, for example), then one would allocate two properties per particle in the <a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a> object.</p>
<p>In practice, however, one often wants to associate properties with particles that are not just independent numbers as in the situation above. An example would be if one wanted to track the stress or strain that a particle is subjected to &ndash; a tensor-valued quantity. In these cases, one would <em>interpret</em> these scalar properties as the <em>components of the stress or strain</em>. In other words, one would first tell the <a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a> to allocate as many properties per particle as there are components in the tensor one wants to track, and then write small conversion functions that take the <a class="el" href="classArrayView.html">ArrayView</a> of scalar properties returned by the <a class="el" href="classParticles_1_1Particle.html#a46fe2147753d060e95be08fe76a463b7">get_properties()</a> function and convert it to a tensor of the appropriate type. This can then be evaluated and evolved in each time step. A second conversion function would convert back from a tensor to an <a class="el" href="classArrayView.html">ArrayView</a> object to store the updated data back in the particle via the <a class="el" href="classParticles_1_1Particle.html#a7da7bfae83b0c75fcd6a5457e5fae64c">set_properties()</a> function.</p>
<p>There are of course cases where the properties one cares about are not real (or, in computers, floating point) numbers but rather categorical: For example, one may want to mark some particles as "red", "blue", or "green". The property might then either be represented as an integer, or as an element of an <code>enum</code>. In these cases, one would need to come up with a way to <em>represent</em> these sorts of categorical fields in terms of floating point numbers. For example, one could map "red" to the floating point number 1.0, "blue" to 2.0, and "green" to 3.0. The conversion functions to translate between these two representations should then not be very difficult to write either. </p>

<p class="definition">Definition at line <a class="el" href="particle_8h_source.html#l00094">94</a> of file <a class="el" href="particle_8h_source.html">particle.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9d21199ff7647463d85c4f926a1db99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d21199ff7647463d85c4f926a1db99a">&#9670;&nbsp;</a></span>Particle() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1Particle.html">Particle</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty constructor for <a class="el" href="classParticles_1_1Particle.html">Particle</a>, creates a particle at the origin. </p>

</div>
</div>
<a id="a2d99f2a2d1a950e5692478ea377f9499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d99f2a2d1a950e5692478ea377f9499">&#9670;&nbsp;</a></span>Particle() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1Particle.html">Particle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>reference_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for <a class="el" href="classParticles_1_1Particle.html">Particle</a>. This function creates a particle with the specified ID at the specified location. Note that there is no check for duplicate particle IDs so the user must make sure the IDs are unique over all processes. Data is stored in a global <a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a> object (corresponding to the global "heap") but can later be transferred to another property pool by calling <a class="el" href="classParticles_1_1Particle.html#a09f7db69aaa3e8d861a60b44ca9ec279">set_property_pool()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">location</td><td>Initial location of particle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reference_location</td><td>Initial location of the particle in the coordinate system of the reference cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Globally unique ID number of particle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25cefce1f23c8439b77664d407c07d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cefce1f23c8439b77664d407c07d05">&#9670;&nbsp;</a></span>Particle() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1Particle.html">Particle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>particle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy-constructor for <a class="el" href="classParticles_1_1Particle.html">Particle</a>. This function creates a particle with exactly the state of the input argument. The copied data is stored in a global <a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a> object (corresponding to the global "heap") but can later be transferred to another property pool by calling <a class="el" href="classParticles_1_1Particle.html#a09f7db69aaa3e8d861a60b44ca9ec279">set_property_pool()</a>. </p>

</div>
</div>
<a id="a7d76f39851eaefd086baf983599971b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d76f39851eaefd086baf983599971b3">&#9670;&nbsp;</a></span>Particle() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1Particle.html">Particle</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&amp;&#160;</td>
          <td class="paramname"><em>begin_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt; dim, spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>property_pool</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for <a class="el" href="classParticles_1_1Particle.html">Particle</a>. This function creates a particle from a data vector. Data is stored in a global <a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a> object (corresponding to the global "heap") but can later be transferred to another property pool by calling <a class="el" href="classParticles_1_1Particle.html#a09f7db69aaa3e8d861a60b44ca9ec279">set_property_pool()</a>. This constructor is usually called after serializing a particle by calling the <a class="el" href="namespaceDataOutBase.html#a5d19d285f4429a9d2827bf49c37a6e3d">write_data()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">begin_data</td><td>A pointer to a memory location from which to read the information that completely describes a particle. This class then de-serializes its data from this memory location and advances the pointer beyond the data that has been read to initialize the particle information.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">property_pool</td><td>An optional pointer to a property pool that is used to manage the property data used by this particle. If this argument is not provided, then a global property pool is used; on the other hand, if a non-null pointer is provided, this constructor assumes <code>begin_data</code> contains serialized data of the same length and type that is allocated by <code>property_pool</code>. If the data pointer provided here corresponds to data for a particle that has properties, then this function will only succeed if a property pool is provided as second argument that is able to store the correct number of properties per particle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dba9dac9ff84ef2bbbeb0a179493e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dba9dac9ff84ef2bbbeb0a179493e8a">&#9670;&nbsp;</a></span>Particle() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::<a class="el" href="classParticles_1_1Particle.html">Particle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>particle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor for <a class="el" href="classParticles_1_1Particle.html">Particle</a>, creates a particle from an existing one by stealing its state. </p>

</div>
</div>
<a id="a9171a9887d416b823ac86082853425f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9171a9887d416b823ac86082853425f4">&#9670;&nbsp;</a></span>~Particle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::~<a class="el" href="classParticles_1_1Particle.html">Particle</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. Releases the property handle if it is valid, and therefore frees that memory space for other particles. (Note: the memory is managed by the property pool, and the pool is responsible for what happens to the memory. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3fce5e73bf2104b712025e4f288fa4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fce5e73bf2104b712025e4f288fa4b3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>particle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy assignment operator. </p>

</div>
</div>
<a id="a7b5a9f0f50a2d9cbc7c22830d8de6fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5a9f0f50a2d9cbc7c22830d8de6fc2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticles_1_1Particle.html">Particle</a>&lt; dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>particle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator. </p>

</div>
</div>
<a id="a1c1db4febc1aca752fabd0a55d3b60d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1db4febc1aca752fabd0a55d3b60d8">&#9670;&nbsp;</a></span>write_particle_data_to_memory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::write_particle_data_to_memory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write particle data into a data array. The array is expected to be large enough to take the data, and the void pointer should point to the first entry of the array to which the data should be written. This function is meant for serializing all particle properties and later de-serializing the properties by calling the appropriate constructor <a class="el" href="classParticles_1_1Particle.html">Particle</a>(void *&amp;data, <a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a> *property_pool = nullptr);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The memory location to write particle data into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next byte after the array to which data has been written. </dd></dl>

</div>
</div>
<a id="a94ba1e93a3ecdb6094024957df4daef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ba1e93a3ecdb6094024957df4daef3">&#9670;&nbsp;</a></span>read_particle_data_from_memory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const void* <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::read_particle_data_from_memory </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update all of the data associated with a particle: id, location, reference location and, if any, properties by using a data array. The array is expected to be large enough to take the data, and the void pointer should point to the first entry of the array to which the data should be written. This function is meant for de-serializing the particle data without requiring that a new <a class="el" href="classParticles_1_1Particle.html">Particle</a> class be built. This is used in the <a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a> to update the ghost particles without de-allocating and re-allocating memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A pointer to a memory location from which to read the information that completely describes a particle. This class then de-serializes its data from this memory location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next byte after the array from which data has been read. </dd></dl>

</div>
</div>
<a id="afbe52b594cf4a8dd11431679c4ef2b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe52b594cf4a8dd11431679c4ef2b52">&#9670;&nbsp;</a></span>set_location()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::set_location </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the location of this particle. Note that this does not check whether this is a valid location in the simulation domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_location</td><td>The new location for this particle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In parallel programs, the <a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a> class stores particles on both the locally owned cells, as well as on ghost cells. The particles on the latter are <em>copies</em> of particles owned on other processors, and should therefore be treated in the same way as ghost entries in <a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> or <a class="el" href="DEALGlossary.html#GlossGhostCell">ghost cells</a>: In both cases, one should treat the ghost elements or cells as <code>const</code> objects that shouldn't be modified even if the objects allow for calls that modify properties. Rather, properties should only be modified on processors that actually <em>own</em> the particle. </dd></dl>

<p class="definition">Definition at line <a class="el" href="particle_8h_source.html#l00510">510</a> of file <a class="el" href="particle_8h_source.html">particle.h</a>.</p>

</div>
</div>
<a id="a1a743cf6f5bc6fca3e9542f5d6e1120f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a743cf6f5bc6fca3e9542f5d6e1120f">&#9670;&nbsp;</a></span>get_location()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp; <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::get_location </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the location of this particle.</p>
<dl class="section return"><dt>Returns</dt><dd>The location of this particle. </dd></dl>

<p class="definition">Definition at line <a class="el" href="particle_8h_source.html#l00519">519</a> of file <a class="el" href="particle_8h_source.html">particle.h</a>.</p>

</div>
</div>
<a id="a57efa2034baca617ba3160ccfbbc7cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57efa2034baca617ba3160ccfbbc7cd7">&#9670;&nbsp;</a></span>set_reference_location()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::set_reference_location </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_reference_location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the reference location of this particle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_reference_location</td><td>The new reference location for this particle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In parallel programs, the <a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a> class stores particles on both the locally owned cells, as well as on ghost cells. The particles on the latter are <em>copies</em> of particles owned on other processors, and should therefore be treated in the same way as ghost entries in <a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> or <a class="el" href="DEALGlossary.html#GlossGhostCell">ghost cells</a>: In both cases, one should treat the ghost elements or cells as <code>const</code> objects that shouldn't be modified even if the objects allow for calls that modify properties. Rather, properties should only be modified on processors that actually <em>own</em> the particle. </dd></dl>

<p class="definition">Definition at line <a class="el" href="particle_8h_source.html#l00528">528</a> of file <a class="el" href="particle_8h_source.html">particle.h</a>.</p>

</div>
</div>
<a id="a0f64953c7ec8ff0faceae5a29669d9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f64953c7ec8ff0faceae5a29669d9c6">&#9670;&nbsp;</a></span>get_reference_location()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp; <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::get_reference_location </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the reference location of this particle in its current cell. </p>

<p class="definition">Definition at line <a class="el" href="particle_8h_source.html#l00537">537</a> of file <a class="el" href="particle_8h_source.html">particle.h</a>.</p>

</div>
</div>
<a id="a9627b1ebd43abb055816adc57e7cf8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9627b1ebd43abb055816adc57e7cf8f6">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a> <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::get_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the ID number of this particle. The ID of a particle is intended to be a property that is globally unique even in parallel computations and is transferred along with other properties of a particle if it moves from a cell owned by the current processor to a cell owned by a different processor, or if ownership of the cell it is on is transferred to a different processor. </p>

<p class="definition">Definition at line <a class="el" href="particle_8h_source.html#l00546">546</a> of file <a class="el" href="particle_8h_source.html">particle.h</a>.</p>

</div>
</div>
<a id="af792bce47ec4746ad2c78e7e800299a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af792bce47ec4746ad2c78e7e800299a8">&#9670;&nbsp;</a></span>set_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::set_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#ae4ea18e3efb31f0312a9e754873d71b8">types::particle_index</a> &amp;&#160;</td>
          <td class="paramname"><em>new_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the ID number of this particle. The ID of a particle is intended to be a property that is globally unique even in parallel computations and is transferred along with other properties of a particle if it moves from a cell owned by the current processor to a cell owned by a different processor, or if ownership of the cell it is on is transferred to a different processor. As a consequence, when setting the ID of a particle, care needs to be taken to ensure that particles have globally unique IDs. (The <a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a> does not itself check whether particle IDs so set are globally unique in a parallel setting since this would be a very expensive operation.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_id</td><td>The new ID number for this particle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In parallel programs, the <a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a> class stores particles on both the locally owned cells, as well as on ghost cells. The particles on the latter are <em>copies</em> of particles owned on other processors, and should therefore be treated in the same way as ghost entries in <a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> or <a class="el" href="DEALGlossary.html#GlossGhostCell">ghost cells</a>: In both cases, one should treat the ghost elements or cells as <code>const</code> objects that shouldn't be modified even if the objects allow for calls that modify properties. Rather, properties should only be modified on processors that actually <em>own</em> the particle. </dd></dl>

<p class="definition">Definition at line <a class="el" href="particle_8h_source.html#l00555">555</a> of file <a class="el" href="particle_8h_source.html">particle.h</a>.</p>

</div>
</div>
<a id="a09f7db69aaa3e8d861a60b44ca9ec279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f7db69aaa3e8d861a60b44ca9ec279">&#9670;&nbsp;</a></span>set_property_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::set_property_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>property_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell the particle where to store its properties (even if it does not own properties). Usually this is only done once per particle, but since the particle does not know about the properties, we want to do it not at construction time. Another use for this function is after particle transfer to a new process.</p>
<p>If a particle already stores properties in a property pool, then their values are saved, the memory is released in the previous property pool, and a copy of the particle's properties will be allocated in the new property pool. </p>

<p class="definition">Definition at line <a class="el" href="particle_8h_source.html#l00564">564</a> of file <a class="el" href="particle_8h_source.html">particle.h</a>.</p>

</div>
</div>
<a id="a2b7b93d7c9670ac760386cbe64773fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7b93d7c9670ac760386cbe64773fec">&#9670;&nbsp;</a></span>has_properties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::has_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this particle has a valid property pool and a valid handle to properties. </p>

<p class="definition">Definition at line <a class="el" href="particle_8h_source.html#l00626">626</a> of file <a class="el" href="particle_8h_source.html">particle.h</a>.</p>

</div>
</div>
<a id="a7da7bfae83b0c75fcd6a5457e5fae64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da7bfae83b0c75fcd6a5457e5fae64c">&#9670;&nbsp;</a></span>set_properties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::set_properties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_properties</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the properties of this particle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_properties</td><td>An <a class="el" href="classArrayView.html">ArrayView</a> containing the new properties for this particle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In parallel programs, the <a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a> class stores particles on both the locally owned cells, as well as on ghost cells. The particles on the latter are <em>copies</em> of particles owned on other processors, and should therefore be treated in the same way as ghost entries in <a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> or <a class="el" href="DEALGlossary.html#GlossGhostCell">ghost cells</a>: In both cases, one should treat the ghost elements or cells as <code>const</code> objects that shouldn't be modified even if the objects allow for calls that modify properties. Rather, properties should only be modified on processors that actually <em>own</em> the particle. </dd></dl>

</div>
</div>
<a id="a46fe2147753d060e95be08fe76a463b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fe2147753d060e95be08fe76a463b7">&#9670;&nbsp;</a></span>get_properties() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArrayView.html">ArrayView</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::get_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get write-access to properties of this particle. If the particle has no properties yet, but has access to a <a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a> object it will allocate properties to allow writing into them. If it has no properties and has no access to a <a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a> this function will throw an exception.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classArrayView.html">ArrayView</a> of the properties of this particle. </dd></dl>

</div>
</div>
<a id="a918096fc38e5e26f650aced662809d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918096fc38e5e26f650aced662809d7a">&#9670;&nbsp;</a></span>get_properties() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::get_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get read-access to properties of this particle. If the particle has no properties this function throws an exception.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classArrayView.html">ArrayView</a> of the properties of this particle. </dd></dl>

<p class="definition">Definition at line <a class="el" href="particle_8h_source.html#l00614">614</a> of file <a class="el" href="particle_8h_source.html">particle.h</a>.</p>

</div>
</div>
<a id="a639e04d8078a0c31d964fa48764134ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639e04d8078a0c31d964fa48764134ac">&#9670;&nbsp;</a></span>serialized_size_in_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::serialized_size_in_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the size in bytes this particle occupies if all of its data is serialized (i.e. the number of bytes that is written by the write_data function of this class). </p>

</div>
</div>
<a id="a65392a702c578682a2e7f0b92435a053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65392a702c578682a2e7f0b92435a053">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

<p class="definition">Definition at line <a class="el" href="particle_8h_source.html#l00488">488</a> of file <a class="el" href="particle_8h_source.html">particle.h</a>.</p>

</div>
</div>
<a id="acd7d2296e18b3339ec2ee32e2738818c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7d2296e18b3339ec2ee32e2738818c">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. Note that in order to store the properties correctly, the property pool of this particle has to be known at the time of reading, i.e. <a class="el" href="classParticles_1_1Particle.html#a09f7db69aaa3e8d861a60b44ca9ec279">set_property_pool()</a> has to have been called, before this function is called. </p>

<p class="definition">Definition at line <a class="el" href="particle_8h_source.html#l00454">454</a> of file <a class="el" href="particle_8h_source.html">particle.h</a>.</p>

</div>
</div>
<a id="af307e61f872fc0223939865c5725be7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af307e61f872fc0223939865c5725be7d">&#9670;&nbsp;</a></span>free_properties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::free_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the memory of the property pool </p>

</div>
</div>
<a id="af85d00534692892558504b899f769a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85d00534692892558504b899f769a96">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a40323e77410c5f2a65a36d8a12b6364b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40323e77410c5f2a65a36d8a12b6364b">&#9670;&nbsp;</a></span>global_property_pool</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt;dim, spacedim&gt; <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::global_property_pool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A global property pool used when a particle is not associated with a property pool that belongs to, for example, a <a class="el" href="classParticles_1_1ParticleHandler.html">ParticleHandler</a>. </p>

<p class="definition">Definition at line <a class="el" href="particle_8h_source.html#l00433">433</a> of file <a class="el" href="particle_8h_source.html">particle.h</a>.</p>

</div>
</div>
<a id="a074d6cc8b4aef38ba5863d4057f2e027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074d6cc8b4aef38ba5863d4057f2e027">&#9670;&nbsp;</a></span>property_pool</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt;dim, spacedim&gt;* <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::property_pool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the property pool. Necessary to translate from the handle to the actual memory locations. </p>

<p class="definition">Definition at line <a class="el" href="particle_8h_source.html#l00439">439</a> of file <a class="el" href="particle_8h_source.html">particle.h</a>.</p>

</div>
</div>
<a id="aa822d7240695551e9c95b1139cfe7bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa822d7240695551e9c95b1139cfe7bb6">&#9670;&nbsp;</a></span>property_pool_handle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParticles_1_1PropertyPool.html">PropertyPool</a>&lt;dim, spacedim&gt;::Handle <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>&lt; dim, spacedim &gt;::property_pool_handle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A handle to all particle properties </p>

<p class="definition">Definition at line <a class="el" href="particle_8h_source.html#l00444">444</a> of file <a class="el" href="particle_8h_source.html">particle.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/particles/<a class="el" href="particle_8h_source.html">particle.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
