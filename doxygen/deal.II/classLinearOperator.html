<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classLinearOperator.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: LinearOperator&lt; Range, Domain, Payload &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classLinearOperator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LinearOperator&lt; Range, Domain, Payload &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__LAOperators.html">Linear Operators &lt;h3&gt;Linear Operator&lt;/h3&gt;</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="linear__operator_8h_source.html">deal.II/lac/linear_operator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for LinearOperator&lt; Range, Domain, Payload &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classLinearOperator__inherit__graph.svg" width="350" height="352"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8bbef5913bea7cc53edc818f9c6064d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a8bbef5913bea7cc53edc818f9c6064d9">LinearOperator</a> (const <a class="el" href="classPayload.html">Payload</a> &amp;payload=<a class="el" href="classPayload.html">Payload</a>())</td></tr>
<tr class="separator:a8bbef5913bea7cc53edc818f9c6064d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb31a2e963acd1a5bf11f78ad19398e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#aeeb31a2e963acd1a5bf11f78ad19398e">LinearOperator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;)=default</td></tr>
<tr class="separator:aeeb31a2e963acd1a5bf11f78ad19398e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66e28a7288c9ac79d00a9357f82c945"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename  = typename std::enable_if&lt;              !std::is_base_of&lt;LinearOperator&lt;Range, Domain, Payload&gt;,                               Op&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ad66e28a7288c9ac79d00a9357f82c945"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#ad66e28a7288c9ac79d00a9357f82c945">LinearOperator</a> (const Op &amp;op)</td></tr>
<tr class="separator:ad66e28a7288c9ac79d00a9357f82c945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce51f284d093109562cad98df31209a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#adce51f284d093109562cad98df31209a">operator=</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;)=default</td></tr>
<tr class="separator:adce51f284d093109562cad98df31209a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2a768360b0903b3745056c3eebd7a1"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename  = typename std::enable_if&lt;              !std::is_base_of&lt;LinearOperator&lt;Range, Domain, Payload&gt;,                               Op&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:adb2a768360b0903b3745056c3eebd7a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#adb2a768360b0903b3745056c3eebd7a1">operator=</a> (const Op &amp;op)</td></tr>
<tr class="separator:adb2a768360b0903b3745056c3eebd7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a995891407aca97d53bbb2a80b9e0b3db"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Range &amp;v, const Domain &amp;u)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">vmult</a></td></tr>
<tr class="separator:a995891407aca97d53bbb2a80b9e0b3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb6da2c4b33b66c23ea2679ff100de3"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Range &amp;v, const Domain &amp;u)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a5eb6da2c4b33b66c23ea2679ff100de3">vmult_add</a></td></tr>
<tr class="separator:a5eb6da2c4b33b66c23ea2679ff100de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6968174d73bf018f6d0c9181c730e217"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Domain &amp;v, const Range &amp;u)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a6968174d73bf018f6d0c9181c730e217">Tvmult</a></td></tr>
<tr class="separator:a6968174d73bf018f6d0c9181c730e217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36a8841e61b3dbea54cf3745e56c140"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Domain &amp;v, const Range &amp;u)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#ad36a8841e61b3dbea54cf3745e56c140">Tvmult_add</a></td></tr>
<tr class="separator:ad36a8841e61b3dbea54cf3745e56c140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa470d7770714cfe9a64bf0f0d817d71f"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Range &amp;v, <a class="el" href="classbool.html">bool</a> omit_zeroing_entries)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#aa470d7770714cfe9a64bf0f0d817d71f">reinit_range_vector</a></td></tr>
<tr class="separator:aa470d7770714cfe9a64bf0f0d817d71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818a9e4c7d8bf0edbb253b938d831e43"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Domain &amp;v, <a class="el" href="classbool.html">bool</a> omit_zeroing_entries)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a818a9e4c7d8bf0edbb253b938d831e43">reinit_domain_vector</a></td></tr>
<tr class="separator:a818a9e4c7d8bf0edbb253b938d831e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td colspan="2"><div class="groupHeader">间接对LinearOperator施加约束</div></td></tr>
<tr class="memitem:ga814d426ef355ed315bb57cea21a7630a"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga814d426ef355ed315bb57cea21a7630a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga814d426ef355ed315bb57cea21a7630a">distribute_constraints_linear_operator</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;exemplar)</td></tr>
<tr class="separator:ga814d426ef355ed315bb57cea21a7630a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52c9bbeff68309fdc7e4975eddba5eea"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga52c9bbeff68309fdc7e4975eddba5eea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga52c9bbeff68309fdc7e4975eddba5eea">project_to_constrained_linear_operator</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;exemplar)</td></tr>
<tr class="separator:ga52c9bbeff68309fdc7e4975eddba5eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4787b401a7e601750d85b8b4fc84c8a5"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga4787b401a7e601750d85b8b4fc84c8a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga4787b401a7e601750d85b8b4fc84c8a5">constrained_linear_operator</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;linop)</td></tr>
<tr class="separator:ga4787b401a7e601750d85b8b4fc84c8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1985f642cfa97d522ffe9d21d2313ce2"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga1985f642cfa97d522ffe9d21d2313ce2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga1985f642cfa97d522ffe9d21d2313ce2">constrained_right_hand_side</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;linop, const Range &amp;right_hand_side)</td></tr>
<tr class="separator:ga1985f642cfa97d522ffe9d21d2313ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">矢量空间操作</div></td></tr>
<tr class="memitem:gad5b7eee8927ffd58475199d70e445b16"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:gad5b7eee8927ffd58475199d70e445b16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gad5b7eee8927ffd58475199d70e445b16">operator+</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:gad5b7eee8927ffd58475199d70e445b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19125a34d76f661b3da533c97afda332"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga19125a34d76f661b3da533c97afda332"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga19125a34d76f661b3da533c97afda332">operator-</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:ga19125a34d76f661b3da533c97afda332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga87b07e6da906c2a1a5ec6a45be2d5d7c">operator*</a> (typename Range::value_type number, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88637d015b1e6962c60305e7e739ffa9"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga88637d015b1e6962c60305e7e739ffa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga88637d015b1e6962c60305e7e739ffa9">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, typename Domain::value_type number)</td></tr>
<tr class="separator:ga88637d015b1e6962c60305e7e739ffa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LinearOperator的组成和操作</div></td></tr>
<tr class="memitem:ga148e5775d722a0e051f1b4a815650431"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Intermediate , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga148e5775d722a0e051f1b4a815650431"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga148e5775d722a0e051f1b4a815650431">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Intermediate, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Intermediate, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:ga148e5775d722a0e051f1b4a815650431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e38fbde431397c069a88692bd24ae7"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Preconditioner , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga87e38fbde431397c069a88692bd24ae7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver, const Preconditioner &amp;preconditioner)</td></tr>
<tr class="separator:ga87e38fbde431397c069a88692bd24ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484b23159d208db5fc2706b470bf3863"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga484b23159d208db5fc2706b470bf3863"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga484b23159d208db5fc2706b470bf3863">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;preconditioner)</td></tr>
<tr class="separator:ga484b23159d208db5fc2706b470bf3863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga058953c3b4cfae4a9cd6fa75509960a2">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver)</td></tr>
<tr class="separator:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3deff1665b4dad59643251895e7f5239"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga3deff1665b4dad59643251895e7f5239"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga3deff1665b4dad59643251895e7f5239">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver, const <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> &amp;)</td></tr>
<tr class="separator:ga3deff1665b4dad59643251895e7f5239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">创建一个LinearOperator</div></td></tr>
<tr class="memitem:ga1a0a3fb15266869710e63e78658cfaed"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </td></tr>
<tr class="memitem:ga1a0a3fb15266869710e63e78658cfaed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga1a0a3fb15266869710e63e78658cfaed">identity_operator</a> (const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;reinit_vector)</td></tr>
<tr class="separator:ga1a0a3fb15266869710e63e78658cfaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373310de5b48d5a70b9cdd47834da48f"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga373310de5b48d5a70b9cdd47834da48f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga373310de5b48d5a70b9cdd47834da48f">identity_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga373310de5b48d5a70b9cdd47834da48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2043a16b6855670766f46780a39f03f3"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga2043a16b6855670766f46780a39f03f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga2043a16b6855670766f46780a39f03f3">null_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga2043a16b6855670766f46780a39f03f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad49906c99b700ca6cafdef67977d0c"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </td></tr>
<tr class="memitem:gacad49906c99b700ca6cafdef67977d0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gacad49906c99b700ca6cafdef67977d0c">mean_value_filter</a> (const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;reinit_vector)</td></tr>
<tr class="separator:gacad49906c99b700ca6cafdef67977d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cedb0a75c51801a6052bf7343b90685"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga6cedb0a75c51801a6052bf7343b90685"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6cedb0a75c51801a6052bf7343b90685">mean_value_filter</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga6cedb0a75c51801a6052bf7343b90685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b74b7ed76e4aeea2c67c0bbb03e3e24"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload , typename Matrix &gt; </td></tr>
<tr class="memitem:ga6b74b7ed76e4aeea2c67c0bbb03e3e24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a> (const Matrix &amp;matrix)</td></tr>
<tr class="separator:ga6b74b7ed76e4aeea2c67c0bbb03e3e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14dbc8c2c27ea3fd45576528a891c6e2"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload , typename OperatorExemplar , typename Matrix &gt; </td></tr>
<tr class="memitem:ga14dbc8c2c27ea3fd45576528a891c6e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga14dbc8c2c27ea3fd45576528a891c6e2">linear_operator</a> (const OperatorExemplar &amp;operator_exemplar, const Matrix &amp;matrix)</td></tr>
<tr class="separator:ga14dbc8c2c27ea3fd45576528a891c6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac20bebeb1b53fd00f838b63baac0456"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload , typename Matrix &gt; </td></tr>
<tr class="memitem:gaac20bebeb1b53fd00f838b63baac0456"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaac20bebeb1b53fd00f838b63baac0456">linear_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;operator_exemplar, const Matrix &amp;matrix)</td></tr>
<tr class="separator:gaac20bebeb1b53fd00f838b63baac0456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">创建一个与舒尔补码有关的LinearOperator</div></td></tr>
<tr class="memitem:ga76acca911f21089cd3bb385d20ccc995"><td class="memTemplParams" colspan="2">template&lt;typename Range_1 , typename Domain_1 , typename Range_2 , typename Domain_2 , typename Payload &gt; </td></tr>
<tr class="memitem:ga76acca911f21089cd3bb385d20ccc995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain_1, Range_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;A_inv, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;B, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;C, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;D)</td></tr>
<tr class="separator:ga76acca911f21089cd3bb385d20ccc995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">创建一个LinearOperator</div></td></tr>
<tr class="memitem:gaf2a467ed50213dea8c580b67ee466c7c"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain  = Range, typename Matrix &gt; </td></tr>
<tr class="memitem:gaf2a467ed50213dea8c580b67ee466c7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TrilinosWrappers.html#gaf2a467ed50213dea8c580b67ee466c7c">linear_operator</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;operator_exemplar, const Matrix &amp;matrix)</td></tr>
<tr class="separator:gaf2a467ed50213dea8c580b67ee466c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab54eadb16250f94319528968b4975874"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain  = Range&gt; </td></tr>
<tr class="memitem:gab54eadb16250f94319528968b4975874"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TrilinosWrappers.html#gab54eadb16250f94319528968b4975874">linear_operator</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;matrix)</td></tr>
<tr class="separator:gab54eadb16250f94319528968b4975874"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
原地向量空间操作</h2></td></tr>
<tr class="memitem:a99cd172538d9f6d20474deea30ab43f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a99cd172538d9f6d20474deea30ab43f0">is_null_operator</a></td></tr>
<tr class="separator:a99cd172538d9f6d20474deea30ab43f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a00069fdcd76bd6f0323ddb0f9421da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a9a00069fdcd76bd6f0323ddb0f9421da">operator+=</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:a9a00069fdcd76bd6f0323ddb0f9421da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c73c9d7a1b1b95cdd50a35af95b6cba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a3c73c9d7a1b1b95cdd50a35af95b6cba">operator-=</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:a3c73c9d7a1b1b95cdd50a35af95b6cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a0fe40dda4bc65ec1b7d57f52388bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a07a0fe40dda4bc65ec1b7d57f52388bb">operator*=</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:a07a0fe40dda4bc65ec1b7d57f52388bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b305867e831f96aaabe7a7aee8b774e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a2b305867e831f96aaabe7a7aee8b774e">operator*=</a> (typename Domain::value_type number)</td></tr>
<tr class="separator:a2b305867e831f96aaabe7a7aee8b774e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Range, typename Domain, typename Payload&gt;<br />
class LinearOperator&lt; Range, Domain, Payload &gt;</h3>

<p>一个用于存储线性算子的抽象概念的类。 该类本质上由 <code>std::function</code> 对象组成，这些对象通过实现抽象的 <code>Matrix</code> 接口来存储如何应用线性运算符的知识。</p>
<div class="fragment"><div class="line">std::function&lt;void(Range &amp;, const Domain &amp;)&gt; <a class="code" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">vmult</a>;</div><div class="line">std::function&lt;void(Range &amp;, const Domain &amp;)&gt; <a class="code" href="classLinearOperator.html#a5eb6da2c4b33b66c23ea2679ff100de3">vmult_add</a>;</div><div class="line">std::function&lt;void(Domain &amp;, const Range &amp;)&gt; <a class="code" href="classLinearOperator.html#a6968174d73bf018f6d0c9181c730e217">Tvmult</a>;</div><div class="line">std::function&lt;void(Domain &amp;, const Range &amp;)&gt; <a class="code" href="classLinearOperator.html#ad36a8841e61b3dbea54cf3745e56c140">Tvmult_add</a>;</div></div><!-- fragment --><p>但是，与通常的矩阵对象不同，线性运算符的域和范围也被绑定到类型级别的LinearOperator类上。因为这个原因， <code><a class="el" href="classLinearOperator.html">LinearOperator</a> &lt;Range, Domain&gt;</code> 有两个额外的函数对象</p>
<div class="fragment"><div class="line">std::function&lt;void(Range &amp;, bool)&gt; <a class="code" href="classLinearOperator.html#aa470d7770714cfe9a64bf0f0d817d71f">reinit_range_vector</a>;</div><div class="line">std::function&lt;void(Domain &amp;, bool)&gt; <a class="code" href="classLinearOperator.html#a818a9e4c7d8bf0edbb253b938d831e43">reinit_domain_vector</a>;</div></div><!-- fragment --><p> 储存了如何初始化（调整大小+内部数据结构） <code>Range</code> 和 <code>Domain</code> 空间的任意矢量的知识。 这个类的主要目的是为复杂的矩阵-向量操作提供语法糖，使用户不必手工创建、设置和处理中间存储位置。 作为一个例子，考虑操作 \((A+k\,B)\,C\) ，其中 \(A\) 、 \(B\) 和 \(C\) 表示（可能不同的）矩阵。为了构造一个LinearOperator <code>op</code> 来存储这个操作的知识，我们可以这样写。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="classSparseMatrix.html">::SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>, B, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> k = ...;</div><div class="line"></div><div class="line"><span class="comment">// Setup and assembly of matrices</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op_a = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(A);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op_b = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(B);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op_c = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(C);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op = (op_a + k op_b) op_c;</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>这个类大量使用了 <code>std::function</code> 对象和lambda函数。这种灵活性带来了运行时间的惩罚。只用这个对象来封装大中型的矩阵对象（作为经验法则，稀疏矩阵的大小为 \(1000\times1000\) ，或更大）。</dd>
<dd>
为了将Trilinos或PETSc稀疏矩阵和预处理程序与LinearOperator类结合使用，有必要通过一个额外的Payload来扩展LinearOperator类的功能。 例如。代表矩阵求逆的LinearOperator实例通常需要调用一些线性求解器。这些求解器可能没有与LinearOperator的接口（例如，它可能代表一个复合操作）。因此， <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> 为LinearOperator提供了一个接口扩展，以便它可以被传递给求解器并被求解器使用，就像它是一个Trilinos算子一样。这意味着特定Trilinos算子的所有必要功能都在Payload类中被重载。这包括算子-向量乘法和反算子-向量乘法，其中算子可以是 <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> 或 <a class="el" href="classTrilinosWrappers_1_1PreconditionBase.html">TrilinosWrappers::PreconditionBase</a> ，向量是本地Trilinos向量。 另一种情况是，当构建复合运算时（通过运算符重载），有效载荷为LinearOperator类提供了重要补充。在这种情况下，又有必要提供一个接口，以产生与Trilinos求解器使用的Trilinos算子兼容的这种复合操作的结果。</dd>
<dd>
LinearOperator的许多用例会导致中间表达式需要一个PackagedOperation。为了一次性包含所有必要的头文件，可以考虑使用</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div></div><!-- fragment --><p>为了使用完整的LinearOperator和PackagedOperation</p>
<dl class="section note"><dt>Note</dt><dd>为了确保提供正确的有效载荷，在各自的TrilinosWrappers（以及未来的PETScWrappers）命名空间中提供了线性操作符的封装函数。</dd>
<dd>
<a class="el" href="step_20.html">step-20</a> 教程中有一个LinearOperator类的详细使用例子。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00165">165</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8bbef5913bea7cc53edc818f9c6064d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bbef5913bea7cc53edc818f9c6064d9">&#9670;&nbsp;</a></span>LinearOperator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::<a class="el" href="classLinearOperator.html">LinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPayload.html">Payload</a> &amp;&#160;</td>
          <td class="paramname"><em>payload</em> = <code><a class="el" href="classPayload.html">Payload</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建一个空的LinearOperator对象。 当一个有效载荷被传递给这个构造函数时，产生的运算器会被构造成一个功能性的有效载荷。 在这两种情况下，这个构造函数产生的对象实际上不能用于任何线性运算符的操作，并且在调用时将抛出一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00174">174</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="aeeb31a2e963acd1a5bf11f78ad19398e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb31a2e963acd1a5bf11f78ad19398e">&#9670;&nbsp;</a></span>LinearOperator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::<a class="el" href="classLinearOperator.html">LinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>默认的复制构造函数。 </p>

</div>
</div>
<a id="ad66e28a7288c9ac79d00a9357f82c945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66e28a7288c9ac79d00a9357f82c945">&#9670;&nbsp;</a></span>LinearOperator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
<div class="memtemplate">
template&lt;typename Op , typename  = typename std::enable_if&lt;              !std::is_base_of&lt;LinearOperator&lt;Range, Domain, Payload&gt;,                               Op&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::<a class="el" href="classLinearOperator.html">LinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>模板化的复制构造函数，从定义了转换函数 <code>linear_operator</code> 的对象 <code>op</code> 中创建一个LinearOperator对象。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00231">231</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adce51f284d093109562cad98df31209a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce51f284d093109562cad98df31209a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;Range, Domain, <a class="el" href="classPayload.html">Payload</a>&gt;&amp; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>默认的复制赋值运算符。 </p>

</div>
</div>
<a id="adb2a768360b0903b3745056c3eebd7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2a768360b0903b3745056c3eebd7a1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
<div class="memtemplate">
template&lt;typename Op , typename  = typename std::enable_if&lt;              !std::is_base_of&lt;LinearOperator&lt;Range, Domain, Payload&gt;,                               Op&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;Range, Domain, <a class="el" href="classPayload.html">Payload</a>&gt;&amp; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>定义了转换函数 <code>linear_operator</code> 的对象 <code>op</code> 的模板化的复制赋值运算符。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00253">253</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a9a00069fdcd76bd6f0323ddb0f9421da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a00069fdcd76bd6f0323ddb0f9421da">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;Range, Domain, <a class="el" href="classPayload.html">Payload</a>&gt;&amp; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用LinearOperator <code>second_op</code> 进行加法运算，同 <code>Domain</code> 和 <code>Range</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00312">312</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a3c73c9d7a1b1b95cdd50a35af95b6cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c73c9d7a1b1b95cdd50a35af95b6cba">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;Range, Domain, <a class="el" href="classPayload.html">Payload</a>&gt;&amp; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用LinearOperator <code>second_op</code> 和 <code>Range</code>. 做减法。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00323">323</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a07a0fe40dda4bc65ec1b7d57f52388bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a0fe40dda4bc65ec1b7d57f52388bb">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;Range, Domain, <a class="el" href="classPayload.html">Payload</a>&gt;&amp; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与 <code>Domain</code> 空间的内形态 <code>second_op</code> 的LinearOperator的构成。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00335">335</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a2b305867e831f96aaabe7a7aee8b774e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b305867e831f96aaabe7a7aee8b774e">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;Range, Domain, <a class="el" href="classPayload.html">Payload</a>&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">typename Domain::value_type&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>LinearOperator与 <code>number</code> 从右边开始的标量乘法。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00346">346</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a995891407aca97d53bbb2a80b9e0b3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995891407aca97d53bbb2a80b9e0b3db">&#9670;&nbsp;</a></span>vmult</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Range &amp;v, const Domain &amp;u)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::vmult</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将LinearOperator对象应用于 <code>Domain</code> 空间的向量u，得到 <code>Range</code> 空间的向量v。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00264">264</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a5eb6da2c4b33b66c23ea2679ff100de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb6da2c4b33b66c23ea2679ff100de3">&#9670;&nbsp;</a></span>vmult_add</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Range &amp;v, const Domain &amp;u)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::vmult_add</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将LinearOperator对象应用于 <code>Domain</code> 空间的向量u。其结果被添加到向量v中。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00271">271</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a6968174d73bf018f6d0c9181c730e217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6968174d73bf018f6d0c9181c730e217">&#9670;&nbsp;</a></span>Tvmult</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Domain &amp;v, const Range &amp;u)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::Tvmult</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对 <code>Range</code> 空间的向量u应用转置LinearOperator对象，得到 <code>Domain</code> 空间的向量v。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00278">278</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ad36a8841e61b3dbea54cf3745e56c140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36a8841e61b3dbea54cf3745e56c140">&#9670;&nbsp;</a></span>Tvmult_add</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Domain &amp;v, const Range &amp;u)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::Tvmult_add</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对 <code>Range</code> 空间的向量 <code>u</code> 应用转置LinearOperator对象。结果被添加到向量 <code>v</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00285">285</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="aa470d7770714cfe9a64bf0f0d817d71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa470d7770714cfe9a64bf0f0d817d71f">&#9670;&nbsp;</a></span>reinit_range_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Range &amp;v, <a class="el" href="classbool.html">bool</a> omit_zeroing_entries)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::reinit_range_vector</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>初始化Range空间的一个向量v，可以直接作为vmult应用中的目标参数使用。与向量类的reinit函数类似，布尔值决定是否进行快速初始化，也就是说，如果它被设置为false，向量的内容就被设置为0。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00291">291</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a818a9e4c7d8bf0edbb253b938d831e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818a9e4c7d8bf0edbb253b938d831e43">&#9670;&nbsp;</a></span>reinit_domain_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Domain &amp;v, <a class="el" href="classbool.html">bool</a> omit_zeroing_entries)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::reinit_domain_vector</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>初始化域空间的一个向量，以便在vmult的应用中可以直接作为源参数使用。与向量类的reinit函数类似，布尔值决定是否进行快速初始化，也就是说，如果它被设置为false，向量的内容就被设置为0。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00298">298</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a99cd172538d9f6d20474deea30ab43f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cd172538d9f6d20474deea30ab43f0">&#9670;&nbsp;</a></span>is_null_operator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename Payload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;::is_null_operator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个bool用于确定线性运算符是否是空运算符。在这种情况下，该类能够优化一些操作，如乘法或加法。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00356">356</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="linear__operator_8h_source.html">linear_operator.h</a></li>
<li>include/deal.II/lac/<a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a></li>
<li>include/deal.II/lac/<a class="el" href="schur__complement_8h_source.html">schur_complement.h</a></li>
<li>include/deal.II/lac/<a class="el" href="trilinos__linear__operator_8h_source.html">trilinos_linear_operator.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
