<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceHDF5.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: HDF5 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">HDF5 Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceHDF5_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHDF5_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHDF5_1_1DataSet.html">DataSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHDF5_1_1File.html">File</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHDF5_1_1Group.html">Group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHDF5_1_1HDF5Object.html">HDF5Object</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace containing deal.II's <a class="el" href="namespaceHDF5.html">HDF5</a> interface.</p>
<p>The <a href="https://www.hdfgroup.org/">Hierarchical Data Format (HDF)</a> is a cross platform and a high I/O performance format designed to store large amounts of data. It supports serial and MPI I/O access. This set of classes provides an interface to the <a href="https://www.hdfgroup.org/downloads/hdf5/">HDF5 library</a>.</p>
<p>The tutorial step-62 shows how to use deal.II's <a class="el" href="namespaceHDF5.html">HDF5</a> interface.</p>
<h1>Groups, Datasets and attributes</h1>
<p>An <a class="el" href="namespaceHDF5.html">HDF5</a> file is organized in <a href="https://bitbucket.hdfgroup.org/pages/HDFFV/hdf5doc/master/browse/html/UG/HDF5_Users_Guide-Responsive%20HTML5/HDF5_Users_Guide/Groups/HDF5_Groups.htm">groups</a> and <a href="https://bitbucket.hdfgroup.org/pages/HDFFV/hdf5doc/master/browse/html/UG/HDF5_Users_Guide-Responsive%20HTML5/HDF5_Users_Guide/Datasets/HDF5_Datasets.htm">datasets</a>. Groups can contain datasets and other groups. Datasets are objects composed by a collection of data elements. Datasets are equivalent to tensors and matrices. In addition, attributes can be attached to the root file, a group or a dataset. An <a href="https://bitbucket.hdfgroup.org/pages/HDFFV/hdf5doc/master/browse/html/UG/HDF5_Users_Guide-Responsive%20HTML5/HDF5_Users_Guide/Attributes/HDF5_Attributes.htm">HDF5 attribute</a> is a small meta data. The methods <a class="el" href="classHDF5_1_1HDF5Object.html#a25c71292aba2399ad5a21d5d855ea2eb">HDF5Object::get_attribute()</a> and <a class="el" href="classHDF5_1_1HDF5Object.html#a655831e44bf7595fbc984a8126e44172">HDF5Object::set_attribute()</a> can be used to get and set attributes.</p>
<p>An example is shown below </p><div class="fragment"><div class="line"><a class="code" href="classHDF5_1_1File.html">HDF5::File</a> data_file(filename, <a class="code" href="classHDF5_1_1File.html#ac3dc680d4e4ca3dd7139085c5056ff5fa76ea0bebb3c22822b4f0dd9c9fd021c5">HDF5::File::FileAccessMode::create</a>);</div><div class="line"><span class="keywordtype">double</span> double_attribute = 2.2;</div><div class="line">data_file.set_attribute(<span class="stringliteral">&quot;double_attribute&quot;</span>, double_attribute);</div><div class="line"><span class="keyword">auto</span> group = data_file.create_group(<span class="stringliteral">&quot;group&quot;</span>);</div><div class="line">group.set_attribute(<span class="stringliteral">&quot;simulation_type&quot;</span>, <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a>(<span class="stringliteral">&quot;elastic_equation&quot;</span>));</div><div class="line"><span class="keyword">auto</span> dataset = group.create_dataset&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;dataset_name&quot;</span>, dimensions);</div><div class="line">dataset.set_attribute(<span class="stringliteral">&quot;complex_double_attribute&quot;</span>,</div><div class="line">                      std::complex&lt;double&gt;(2,2.3));</div></div><!-- fragment --><h1>MPI I/O</h1>
<p>An <a class="el" href="namespaceHDF5.html">HDF5</a> file can be opened/created with serial (one single process) or MPI support (several processes access the same <a class="el" href="namespaceHDF5.html">HDF5</a> file). <a class="el" href="classHDF5_1_1File.html#a360b2be6dd0f15627ecc329bf718dc71">File::File(const std::string &amp;, const FileAccessMode)</a> opens/creates an <a class="el" href="namespaceHDF5.html">HDF5</a> file for serial operations. <a class="el" href="classHDF5_1_1File.html#a06cc6f8f60f8f52d5bc42427dd127a1c">File::File(const std::string &amp;, const FileAccessMode, const MPI_Comm &amp;)</a> creates or opens an <a class="el" href="namespaceHDF5.html">HDF5</a> file in parallel using MPI. The <a class="el" href="namespaceHDF5.html">HDF5</a> calls that modify the structure of the file are always collective, whereas writing and reading raw data in a dataset can be done independently or collectively. <a href="https://www.hdfgroup.org/2015/08/parallel-io-with-hdf5/">Collective access is usually faster</a> since it allows MPI to do optimizations. In the deal.II's <a class="el" href="namespaceHDF5.html">HDF5</a> interface all the calls are set to collective in order to maximize the performance. This means that all the MPI processes have to contribute to every single call, even if they don't have data to write. MPI <a class="el" href="namespaceHDF5.html">HDF5</a> requires that deal.II and <a class="el" href="namespaceHDF5.html">HDF5</a> have been compiled with MPI support.</p>
<h2>Write a hyperslab in parallel</h2>
<p>Hyperslabs are portions of datasets. A hyperslab can be a contiguous collection of points in a dataset, or it can be a regular pattern of points or blocks in a datataset. Hyperslabs are equivalent to python numpy and h5py <a href="http://docs.h5py.org/en/latest/high/dataset.html#reading-writing-data">slices</a>. See the <a href="https://support.hdfgroup.org/HDF5/doc/UG/HDF5_Users_Guide-Responsive%20HTML5/HDF5_Users_Guide/Dataspaces/HDF5_Dataspaces_and_Partial_I_O.htm?rhtocid=7.2#TOC_7_4_Dataspaces_and_Databc-6">Dataspaces and Data Transfer</a> section in the <a class="el" href="namespaceHDF5.html">HDF5</a> User's Guide. See as well the <a href="https://support.hdfgroup.org/HDF5/doc1.8/RM/RM_H5S.html#Dataspace-SelectHyperslab">H5Sselect_hyperslab definition</a>.</p>
<p>The example below shows how to write a simple rectangular hyperslab. The offset defines the origin of the hyperslab in the original dataset. The dimensions of the hyperslab are <code>hyperslab_dimensions = {2, 5}</code>. Note that each process can write a hyperslab with a different size. If a process does not write any data at all, the process should call the function <a class="el" href="classHDF5_1_1DataSet.html#a9ca9525c41fe37c9c64f2b41ad0b871e">DataSet::write_none()</a> because the operation is <em>collective</em> and all the MPI processes have to contribute to the call, even if they don't have data to write. </p><div class="fragment"><div class="line">std::vector&lt;hsize_t&gt; dataset_dimensions = {50, 30};</div><div class="line"><span class="keyword">auto</span> dataset = group.create_dataset&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;name&quot;</span>, dataset_dimensions);</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">  {</div><div class="line">    <span class="comment">// hyperslab_data can be std::vector, FullMatrix or Vector</span></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> hyperslab_data = {...};</div><div class="line">    std::vector&lt;hsize_t&gt; hyperslab_offset     = {1, 2};</div><div class="line">    std::vector&lt;hsize_t&gt; hyperslab_dimensions = {2, 3};</div><div class="line">    dataset.write_hyperslab(hyperslab_data,</div><div class="line">                            hyperslab_offset,</div><div class="line">                            hyperslab_dimensions);</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    dataset.write_none&lt;<span class="keywordtype">double</span>&gt;();</div><div class="line">  }</div></div><!-- fragment --><p>The function <a class="el" href="classHDF5_1_1DataSet.html#a5e262c54c334a1788c209f4a5366369d">DataSet::write_hyperslab(const Container &amp;,const std::vector&lt;hsize_t&gt; &amp;, const std::vector&lt;hsize_t&gt; &amp;)</a> is used to write simple hyperslabs and the function <a class="el" href="classHDF5_1_1DataSet.html#a09a6303c147cec0051e6e84bf548c237">DataSet::write_hyperslab(const Container &amp;,const std::vector&lt;hsize_t&gt; &amp;, const std::vector&lt;hsize_t&gt; &amp;, const std::vector&lt;hsize_t&gt; &amp;, const std::vector&lt;hsize_t&gt; &amp;, const std::vector&lt;hsize_t&gt; &amp;)</a> is used to write complex hyperslabs.</p>
<h2>Write unordered data in parallel</h2>
<p>The example below shows how to write a selection of data. Note that each process can write a different amount of data. If a process does not write any data at all, the process should call the function <a class="el" href="classHDF5_1_1DataSet.html#a9ca9525c41fe37c9c64f2b41ad0b871e">DataSet::write_none()</a> because the operation is <em>collective</em> and all the MPI processes have to contribute to the call, even if they don't have data to write. A more detailed example can be found in step-62. </p><div class="fragment"><div class="line">std::vector&lt;hsize_t&gt; dataset_dimensions = {50, 30};</div><div class="line"><span class="keyword">auto</span> dataset = group.create_dataset&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;name&quot;</span>, dataset_dimensions);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">  {</div><div class="line">    std::vector&lt;hsize_t&gt; coordinates = {0,</div><div class="line">                                        0, <span class="comment">// first point</span></div><div class="line">                                        0,</div><div class="line">                                        2, <span class="comment">// second point</span></div><div class="line">                                        3,</div><div class="line">                                        4, <span class="comment">// third point</span></div><div class="line">                                        25,</div><div class="line">                                        12}; <span class="comment">// fourth point</span></div><div class="line">    std::vector&lt;double&gt;  data        = {2, 3, 5, 6};</div><div class="line">    dataset.write_selection(data, coordinates);</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 1)</div><div class="line">  {</div><div class="line">    std::vector&lt;hsize_t&gt; coordinates = {5,</div><div class="line">                                        0, <span class="comment">// first point</span></div><div class="line">                                        0,</div><div class="line">                                        4, <span class="comment">// second point</span></div><div class="line">                                        5,</div><div class="line">                                        4, <span class="comment">// third point</span></div><div class="line">                                        26,</div><div class="line">                                        12}; <span class="comment">// fourth point</span></div><div class="line">    std::vector&lt;double&gt;  data        = {9, 4, 7, 6};</div><div class="line">    dataset.write_selection(data, coordinates);</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    dataset.write_none&lt;<span class="keywordtype">double</span>&gt;();</div><div class="line">  }</div></div><!-- fragment --><h2>Query the I/O mode that <a class="el" href="namespaceHDF5.html">HDF5</a> used in the last parallel I/O call</h2>
<p>The default access mode in the deal.II's <a class="el" href="namespaceHDF5.html">HDF5</a> C++ interface is collective which is typically faster since it allows MPI to do more optimizations. In some cases, such as when there is type conversion, the <a class="el" href="namespaceHDF5.html">HDF5</a> library can decide to do independent I/O instead of collective I/O, even if the user asks for collective I/O. See the following <a href="https://www.hdfgroup.org/2015/08/parallel-io-with-hdf5/">article</a>. In cases where maximum performance is a requirement, it is important to make sure that all MPI read/write operations are collective. The <a class="el" href="namespaceHDF5.html">HDF5</a> library provides API routines that can be used after the read/write I/O operations to query the I/O mode. If <a class="el" href="classHDF5_1_1DataSet.html#a264429d02334812d0b716bf551ca089f">DataSet::query_io_mode</a> is True, then after every read/write operation the deal.II's <a class="el" href="namespaceHDF5.html">HDF5</a> interface calls the routines <a href="https://support.hdfgroup.org/HDF5/doc/RM/RM_H5P.html#Property-GetMpioActualIoMode">H5Pget_mpio_actual_io_mode()</a> and <a href="https://support.hdfgroup.org/HDF5/doc/RM/RM_H5P.html#Property-GetMpioNoCollectiveCause">H5Pget_mpio_no_collective_cause()</a>. The results are stored in <a class="el" href="classHDF5_1_1DataSet.html#af84a23280db2a5fdede2a62c6f50d8cc">DataSet::io_mode</a>, <a class="el" href="classHDF5_1_1DataSet.html#a162b3a7bbbfcb6d575f4b186451cd8d7">DataSet::local_no_collective_cause</a> and <a class="el" href="classHDF5_1_1DataSet.html#a9aa6456a1b19508e87f3323f150c680c">DataSet::get_global_no_collective_cause</a>. We suggest to query the I/O mode only in Debug mode because it requires calling additional <a class="el" href="namespaceHDF5.html">HDF5</a> routines.</p>
<p>The following code can be used to query the I/O method. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> dataset = group.create_dataset&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;name&quot;</span>, dimensions);</div><div class="line"><span class="preprocessor">#ifdef DEBUG</span></div><div class="line">dataset.set_query_io_mode(<span class="keyword">true</span>);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">  {</div><div class="line">    dataset.write(data);</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    dataset.write_none&lt;<span class="keywordtype">double</span>&gt;();</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">if</span>(dataset.get_query_io_mode()){</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;IO mode: &quot;</span> &lt;&lt; dataset.io_mode() &lt;&lt; std::endl;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Local no collective cause: &quot;</span></div><div class="line">        &lt;&lt; dataset.local_no_collective_cause() &lt;&lt; std::endl;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Global no collective cause: &quot;</span></div><div class="line">        &lt;&lt; dataset.get_global_no_collective_cause() &lt;&lt;</div><div class="line">std::endl;</div><div class="line">}</div></div><!-- fragment --><p>If the write operation was collective then the output should be </p><div class="fragment"><div class="line">IO mode: H5D_MPIO_CONTIGUOUS_COLLECTIVE</div><div class="line">Local no collective cause: H5D_MPIO_COLLECTIVE</div><div class="line">Global no collective cause: H5D_MPIO_COLLECTIVE</div></div><!-- fragment --><p> See <a class="el" href="classHDF5_1_1DataSet.html#a8e8af126c36270de45e3ec0a474db095">DataSet::get_io_mode()</a>, <a class="el" href="classHDF5_1_1DataSet.html#a8c3e8f8c027042724d9c625be84ddecc">DataSet::get_local_no_collective_cause()</a> and <a class="el" href="classHDF5_1_1DataSet.html#a9aa6456a1b19508e87f3323f150c680c">DataSet::get_global_no_collective_cause()</a> for all the possible return codes.</p>
<h1>Rank of <a class="el" href="namespaceHDF5.html">HDF5</a> datasets and hyperslabs</h1>
<p>The deal.II's <a class="el" href="namespaceHDF5.html">HDF5</a> interface can be used to write/read data to datasets and hyperslabs of any particular rank. <code><a class="el" href="classFullMatrix.html">FullMatrix</a></code> can only be used to write/read data to datasets and hyperslabs of rank 2. In the other hand, <code>std::vector</code> and <code><a class="el" href="classVector.html">Vector</a></code> can be used to write/read data to datasets and hyperslabs of rank 1, 2, 3 and higher, the data is organized in <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">row-major order</a> which is commonly used in C and C++ matrices. We can re-write the code from the previous section using std::vector </p><div class="fragment"><div class="line"><span class="comment">// Dataset of rank 2. dim_0 = 50, dim_1 = 30</span></div><div class="line">std::vector&lt;hsize_t&gt; dataset_dimensions = {50, 30};</div><div class="line"><span class="keyword">auto</span> dataset = group.create_dataset&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;name&quot;</span>, dataset_dimensions);</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">  {</div><div class="line">    <span class="comment">// hyperslab_data can be std::vector, FullMatrix or Vector</span></div><div class="line">    std::vector&lt;double&gt; hyperslab_data = {0,1,2,3,4,5};</div><div class="line">    <span class="comment">// hyperslab of rank 2. dim_0 = 2 and dim_1 = 3</span></div><div class="line">    std::vector&lt;hsize_t&gt; hyperslab_offset     = {1, 2};</div><div class="line">    std::vector&lt;hsize_t&gt; hyperslab_dimensions = {2, 3};</div><div class="line">    dataset.write_hyperslab(hyperslab_data,</div><div class="line">                            hyperslab_offset,</div><div class="line">                            hyperslab_dimensions);</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    dataset.write_none&lt;<span class="keywordtype">double</span>&gt;();</div><div class="line">  }</div></div><!-- fragment --><p> The previous code writes the following hyperslab matrix </p><div class="fragment"><div class="line">0 1</div><div class="line">2 3</div><div class="line">4 5</div></div><!-- fragment --><h1>Datatypes</h1>
<p>Attribute datatypes can be float, <code>double</code>, <code>std::complex&lt;float&gt;</code>, <code>std::complex&lt;double&gt;</code>, <code>int</code>, <code>unsigned int</code>, <code>bool</code> and <code>std::string</code>. <a class="el" href="classHDF5_1_1HDF5Object.html#a25c71292aba2399ad5a21d5d855ea2eb">HDF5Object::get_attribute()</a> and <a class="el" href="classHDF5_1_1HDF5Object.html#a655831e44bf7595fbc984a8126e44172">HDF5Object::set_attribute()</a> can be used with all of these datatypes.</p>
<p>Dataset datatypes can be <code>float</code>, <code>double</code>, <code>std::complex&lt;float&gt;</code>, <code>std::complex&lt;double&gt;</code>, <code>int</code> and <code>unsigned int</code>. <a class="el" href="classHDF5_1_1DataSet.html#aa12f43acacd65cbbdcee89bfca52d7ab">DataSet::read()</a>, <a class="el" href="classHDF5_1_1DataSet.html#a0f51f04d2fcddac7c0c5f863d665253f">DataSet::write()</a>, <a class="el" href="classHDF5_1_1DataSet.html#aaeff1e3ce0d689acdf627ae151e26c17">DataSet::read_selection()</a>, etc. can be used with all of these datatypes. Note that the dataset datatype can not be <code>bool</code>, the reason is that it can not be assumed that <code>std::vector&lt;bool&gt;</code> stores the elements in a contiguous way.</p>
<h2>Complex numbers and <a class="el" href="namespaceHDF5.html">HDF5</a></h2>
<p>There is no official <a class="el" href="namespaceHDF5.html">HDF5</a> format to store <code>std::complex</code> numbers in a <a class="el" href="namespaceHDF5.html">HDF5</a> file. But the <em>de facto</em> standard is to store the <code>std::complex</code> number in a compound type in which <code>r</code> corresponds to the real part and <code>i</code> corresponds to the imaginary part. In this interface we define two compound types one for <code>std::complex&lt;double&gt;</code> which corresponds to <code>(double,double)</code> and another one for <code>std::complex&lt;float&gt;</code> which corresponds to <code>(float,float)</code>. These two types correspond respectively to the types of python/numpy/h5py: <code>complex128</code> and <code>complex64</code>. This means that the files generated by this interface will be read correctly by python/numpy/h5py and at the same time this interface is able to read the files generated by python/numpy/h5py.</p>
<h1>Data exchange with python scripts</h1>
<p>The <a class="el" href="namespaceHDF5.html">HDF5</a> format can be used to exchange data with python scripts. The strings are stored as <a class="el" href="namespaceHDF5.html">HDF5</a> variable-length UTF-8 strings and the complex numbers, as explained above, are stored as <a class="el" href="namespaceHDF5.html">HDF5</a> compound datatypes compatible with <a href="https://www.h5py.org/">h5py</a> and <a href="http://www.numpy.org/">numpy</a>.</p>
<p>The following python script writes the parameters for a deal.II simulation: </p><div class="fragment"><div class="line">h5_file = h5py.File(<span class="stringliteral">&#39;simulation.hdf5&#39;</span>,<span class="stringliteral">&#39;w&#39;</span>)</div><div class="line">data = h5_file.create_group(<span class="stringliteral">&#39;data&#39;</span>)</div><div class="line">data.attrs[<span class="stringliteral">&#39;nb_frequency_points&#39;</span>] = 50 <span class="comment"># int</span></div><div class="line">data.attrs[<span class="stringliteral">&#39;rho&#39;</span>] = 2300.5 <span class="comment"># double</span></div><div class="line">data.attrs[<span class="stringliteral">&#39;save_vtk_files&#39;</span>] = <span class="keyword">True</span> <span class="comment"># bool</span></div><div class="line">data.attrs[<span class="stringliteral">&#39;simulation_type&#39;</span>] = <span class="stringliteral">&#39;elastic_equation&#39;</span> <span class="comment"># utf8 string</span></div></div><!-- fragment --><p>C++ deal.II simulation with MPI <a class="el" href="namespaceHDF5.html">HDF5</a>: </p><div class="fragment"><div class="line"><a class="code" href="classHDF5_1_1File.html">HDF5::File</a> data_file(<span class="stringliteral">&quot;simulation.hdf5&quot;</span>,</div><div class="line">                     <a class="code" href="classHDF5_1_1File.html#ac3dc680d4e4ca3dd7139085c5056ff5fa7cef8a734855777c2a9d0caf42666e69">HDF5::File::FileAccessMode::open</a>,</div><div class="line">                     MPI_COMM_WORLD);</div><div class="line"><a class="code" href="classHDF5_1_1Group.html">HDF5::Group</a> data = data_file.open_group(<span class="stringliteral">&quot;data&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> nb_frequency_points = data.<a class="code" href="classHDF5_1_1HDF5Object.html#a25c71292aba2399ad5a21d5d855ea2eb">get_attribute</a>&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;nb_frequency_points&quot;</span>);</div><div class="line"><span class="keyword">auto</span> rho = data.<a class="code" href="classHDF5_1_1HDF5Object.html#a25c71292aba2399ad5a21d5d855ea2eb">get_attribute</a>&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;rho&quot;</span>);</div><div class="line"><span class="keyword">auto</span> save_vtk_files = data.<a class="code" href="classHDF5_1_1HDF5Object.html#a25c71292aba2399ad5a21d5d855ea2eb">get_attribute</a>&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;save_vtk_files&quot;</span>);</div><div class="line"><span class="keyword">auto</span> simulation_type = data.<a class="code" href="classHDF5_1_1HDF5Object.html#a25c71292aba2399ad5a21d5d855ea2eb">get_attribute</a>&lt;<a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a>&gt;(<span class="stringliteral">&quot;simulation_type&quot;</span>);</div><div class="line"></div><div class="line">std::vector&lt;std::complex&lt;double&gt;&gt; displacement = {...};</div><div class="line"></div><div class="line">data.<a class="code" href="classHDF5_1_1Group.html#af90cb30dc6f27aae41dd47008f7437f6">write_dataset</a>(<span class="stringliteral">&quot;displacement&quot;</span>, displacement);</div><div class="line"></div><div class="line"><span class="comment">// Write the simulation metadata</span></div><div class="line">data.<a class="code" href="classHDF5_1_1HDF5Object.html#a655831e44bf7595fbc984a8126e44172">set_attribute</a>(<span class="stringliteral">&quot;active_cells&quot;</span>, triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div></div><!-- fragment --><p>Read the simulation results with python: </p><div class="fragment"><div class="line">h5_file = h5py.File(<span class="stringliteral">&#39;simulation.hdf5&#39;</span>,<span class="stringliteral">&#39;r+&#39;</span>)</div><div class="line">data = h5_file[<span class="stringliteral">&#39;data&#39;</span>]</div><div class="line">displacement = data[<span class="stringliteral">&#39;displacement&#39;</span>] <span class="comment"># complex128 dtype</span></div><div class="line">active_cells = data.attrs[<span class="stringliteral">&#39;degrees_of_freedom&#39;</span>])</div></div><!-- fragment --><h1><a class="el" href="namespaceHDF5.html">HDF5</a> and thread safety</h1>
<p>By default <a class="el" href="namespaceHDF5.html">HDF5</a> is not thread-safe. The <a class="el" href="namespaceHDF5.html">HDF5</a> library can be configured to be thread-safe, see <a href="https://support.hdfgroup.org/HDF5/faq/threadsafe.html">the HDF5 documentation</a>. The thread-safe <a class="el" href="namespaceHDF5.html">HDF5</a> version serializes the API but does not provide any level of concurrency. To achieve high parallel performance with <a class="el" href="namespaceHDF5.html">HDF5</a>, we advice to use <a class="el" href="namespaceHDF5.html">HDF5</a> with MPI. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
