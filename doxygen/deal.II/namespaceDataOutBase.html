<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceDataOutBase.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DataOutBase Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DataOutBase Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutFilterFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1Deal__II__IntermediateFlags.html">Deal_II_IntermediateFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1DXFlags.html">DXFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1GmvFlags.html">GmvFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1GnuplotFlags.html">GnuplotFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1OutputFlagsBase.html">OutputFlagsBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1Patch.html">Patch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1Patch_3_010_00_01spacedim_01_4.html">Patch&lt; 0, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1PovrayFlags.html">PovrayFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1SvgFlags.html">SvgFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1TecplotFlags.html">TecplotFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1UcdFlags.html">UcdFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa3cbced9f1d4ae661f13018f4c980aa1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a> { <br />
&#160;&#160;<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">default_format</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">none</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1af54db6e70b60a249b36f803d0657b39e">dx</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a1a420a2edb82acdd6e8e214f2ed97721">ucd</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a74aee841ac4d429a660bbd1bfee6f298">povray</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acf35b7afd6a85044d32320355fbaabfe">eps</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a958eea3b2724c76d1c1ff20d69f7da4e">gmv</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a8c187cd13581e59b34d71645276a550c">tecplot</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a9b83a7bdbd793467207e0a8f151e15e0">tecplot_binary</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1ac41fd26a6a54c90d0d2062d859b8facf">vtk</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1ad512d1f704c4b56b7bf99e3f81ebc06f">svg</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1ab9c7fdc67b488efaf1b27b02985a40fb">deal_II_intermediate</a>, 
<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1af7b5982bac28c91f885940695ca47542">hdf5</a>
<br />
 }</td></tr>
<tr class="separator:aa3cbced9f1d4ae661f13018f4c980aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a75750d50e3d27159f8a1e4de7f0a8f32"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a75750d50e3d27159f8a1e4de7f0a8f32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a75750d50e3d27159f8a1e4de7f0a8f32">write_dx</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges, const <a class="el" href="structDataOutBase_1_1DXFlags.html">DXFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a75750d50e3d27159f8a1e4de7f0a8f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98914588b1516419a572a1718b1bf3d5"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a98914588b1516419a572a1718b1bf3d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a98914588b1516419a572a1718b1bf3d5">write_eps</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; 2, spacedim &gt;&gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges, const <a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a98914588b1516419a572a1718b1bf3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175a197c99b06d22f17e2efcbdd18a18"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a175a197c99b06d22f17e2efcbdd18a18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a175a197c99b06d22f17e2efcbdd18a18">write_eps</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges, const <a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a175a197c99b06d22f17e2efcbdd18a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4389cfc36770d2881867f6889bc348"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:afa4389cfc36770d2881867f6889bc348"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#afa4389cfc36770d2881867f6889bc348">write_gmv</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges, const <a class="el" href="structDataOutBase_1_1GmvFlags.html">GmvFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:afa4389cfc36770d2881867f6889bc348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfd561a7b5262f83e3cdc4020b377f4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3cfd561a7b5262f83e3cdc4020b377f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a3cfd561a7b5262f83e3cdc4020b377f4">write_gnuplot</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges, const <a class="el" href="structDataOutBase_1_1GnuplotFlags.html">GnuplotFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a3cfd561a7b5262f83e3cdc4020b377f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae661c9d7979da0c39b5f08fd715ed947"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae661c9d7979da0c39b5f08fd715ed947"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#ae661c9d7979da0c39b5f08fd715ed947">write_povray</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges, const <a class="el" href="structDataOutBase_1_1PovrayFlags.html">PovrayFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:ae661c9d7979da0c39b5f08fd715ed947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f9f33c200120450b6844d986a83604"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab9f9f33c200120450b6844d986a83604"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#ab9f9f33c200120450b6844d986a83604">write_tecplot</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges, const <a class="el" href="structDataOutBase_1_1TecplotFlags.html">TecplotFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:ab9f9f33c200120450b6844d986a83604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec32be3e3379b7c83dc339f52cf2ad6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5ec32be3e3379b7c83dc339f52cf2ad6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a5ec32be3e3379b7c83dc339f52cf2ad6">write_ucd</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges, const <a class="el" href="structDataOutBase_1_1UcdFlags.html">UcdFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a5ec32be3e3379b7c83dc339f52cf2ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336d97147011f5f8f3746cac0a3ca4ab"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a336d97147011f5f8f3746cac0a3ca4ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a336d97147011f5f8f3746cac0a3ca4ab">write_vtk</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges, const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a336d97147011f5f8f3746cac0a3ca4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aec479936b78bd0ec2ecc3674e24584"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3aec479936b78bd0ec2ecc3674e24584"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a3aec479936b78bd0ec2ecc3674e24584">write_vtu</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges, const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a3aec479936b78bd0ec2ecc3674e24584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb8c60785a483ffaf2644ab93508da9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a6cb8c60785a483ffaf2644ab93508da9">write_vtu_header</a> (std::ostream &amp;out, const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;flags)</td></tr>
<tr class="separator:a6cb8c60785a483ffaf2644ab93508da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8709fac9a9e37c808518888630b4e04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#aa8709fac9a9e37c808518888630b4e04">write_vtu_footer</a> (std::ostream &amp;out)</td></tr>
<tr class="separator:aa8709fac9a9e37c808518888630b4e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac502afe8d8c9fe9d1bdd8184f1f1291e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac502afe8d8c9fe9d1bdd8184f1f1291e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#ac502afe8d8c9fe9d1bdd8184f1f1291e">write_vtu_main</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges, const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:ac502afe8d8c9fe9d1bdd8184f1f1291e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c87832129884d0603e3ab9ae132741"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#ac8c87832129884d0603e3ab9ae132741">write_pvtu_record</a> (std::ostream &amp;out, const std::vector&lt; std::string &gt; &amp;piece_names, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges)</td></tr>
<tr class="separator:ac8c87832129884d0603e3ab9ae132741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1c052ba49fd44cd8e3f35ba871aebd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">write_pvd_record</a> (std::ostream &amp;out, const std::vector&lt; std::pair&lt; <a class="el" href="classdouble.html">double</a>, std::string &gt;&gt; &amp;times_and_names)</td></tr>
<tr class="separator:a6f1c052ba49fd44cd8e3f35ba871aebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c65120d0661fe57597ff0d13a296c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#ae4c65120d0661fe57597ff0d13a296c1">write_visit_record</a> (std::ostream &amp;out, const std::vector&lt; std::string &gt; &amp;piece_names)</td></tr>
<tr class="separator:ae4c65120d0661fe57597ff0d13a296c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a2666ee12e5b0364d888b18eb3ec8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a34a2666ee12e5b0364d888b18eb3ec8e">write_visit_record</a> (std::ostream &amp;out, const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;piece_names)</td></tr>
<tr class="separator:a34a2666ee12e5b0364d888b18eb3ec8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482d9621dcc87d6a43cf8a9651e16cd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a482d9621dcc87d6a43cf8a9651e16cd8">write_visit_record</a> (std::ostream &amp;out, const std::vector&lt; std::pair&lt; <a class="el" href="classdouble.html">double</a>, std::vector&lt; std::string &gt;&gt;&gt; &amp;times_and_piece_names)</td></tr>
<tr class="separator:a482d9621dcc87d6a43cf8a9651e16cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20ab1f2f5ec29122aefe1f016ff6eac"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:ad20ab1f2f5ec29122aefe1f016ff6eac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#ad20ab1f2f5ec29122aefe1f016ff6eac">write_svg</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; 2, spacedim &gt;&gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges, const <a class="el" href="structDataOutBase_1_1SvgFlags.html">SvgFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:ad20ab1f2f5ec29122aefe1f016ff6eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b0a895fd8b48c1555fa1c34f2cd176"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a70b0a895fd8b48c1555fa1c34f2cd176"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a70b0a895fd8b48c1555fa1c34f2cd176">write_deal_II_intermediate</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges, const <a class="el" href="structDataOutBase_1_1Deal__II__IntermediateFlags.html">Deal_II_IntermediateFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a70b0a895fd8b48c1555fa1c34f2cd176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a956cffba0fa383f85a82bb2a4ca63"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af5a956cffba0fa383f85a82bb2a4ca63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#af5a956cffba0fa383f85a82bb2a4ca63">write_hdf5_parallel</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;data_filter, const std::string &amp;filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm)</td></tr>
<tr class="separator:af5a956cffba0fa383f85a82bb2a4ca63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b63e70306e3d6671ac16b46f7d158e4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5b63e70306e3d6671ac16b46f7d158e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a5b63e70306e3d6671ac16b46f7d158e4">write_hdf5_parallel</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;data_filter, const <a class="el" href="classbool.html">bool</a> write_mesh_file, const std::string &amp;mesh_filename, const std::string &amp;solution_filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm)</td></tr>
<tr class="separator:a5b63e70306e3d6671ac16b46f7d158e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eae1562cccea12a7cc4be2bbf9830a7"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5eae1562cccea12a7cc4be2bbf9830a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a5eae1562cccea12a7cc4be2bbf9830a7">write_filtered_data</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges, <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;filtered_data)</td></tr>
<tr class="separator:a5eae1562cccea12a7cc4be2bbf9830a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e601aef19bd7d10884a1d25f07f3f8"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a14e601aef19bd7d10884a1d25f07f3f8">determine_intermediate_format_dimensions</a> (std::istream &amp;input)</td></tr>
<tr class="separator:a14e601aef19bd7d10884a1d25f07f3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf6308a89986d2081638ef3117699a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#abbf6308a89986d2081638ef3117699a9">parse_output_format</a> (const std::string &amp;format_name)</td></tr>
<tr class="separator:abbf6308a89986d2081638ef3117699a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add43d8f47ccf7052f0178e710ad4ca02"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#add43d8f47ccf7052f0178e710ad4ca02">get_output_format_names</a> ()</td></tr>
<tr class="separator:add43d8f47ccf7052f0178e710ad4ca02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed25a6ddf928a6904fd1ac942125ec86"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#aed25a6ddf928a6904fd1ac942125ec86">default_suffix</a> (const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a> output_format)</td></tr>
<tr class="separator:aed25a6ddf928a6904fd1ac942125ec86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ee90f94d79a99d58013199c0acf6034"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7ee90f94d79a99d58013199c0acf6034">ExcInvalidDatasetSize</a> (<a class="el" href="classint.html">int</a> arg1, <a class="el" href="classint.html">int</a> arg2)</td></tr>
<tr class="separator:ga7ee90f94d79a99d58013199c0acf6034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad06f77234d13c7c6d63d8fc54b524b3f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad06f77234d13c7c6d63d8fc54b524b3f">ExcNoPatches</a> ()</td></tr>
<tr class="separator:gad06f77234d13c7c6d63d8fc54b524b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5fe1fc60077930909828fa4344a9aa2"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa5fe1fc60077930909828fa4344a9aa2">ExcTecplotAPIError</a> ()</td></tr>
<tr class="separator:gaa5fe1fc60077930909828fa4344a9aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ecb35cb7c9815777fa989f17cfa3846"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1ecb35cb7c9815777fa989f17cfa3846">ExcErrorOpeningTecplotFile</a> (char *arg1)</td></tr>
<tr class="separator:ga1ecb35cb7c9815777fa989f17cfa3846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b471b212de843a0e7d1de8d6d631fea"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1b471b212de843a0e7d1de8d6d631fea"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a1b471b212de843a0e7d1de8d6d631fea">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &amp;patch)</td></tr>
<tr class="separator:a1b471b212de843a0e7d1de8d6d631fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f1da20fc706db32c3355d79fa819ae"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad5f1da20fc706db32c3355d79fa819ae"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#ad5f1da20fc706db32c3355d79fa819ae">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &amp;patch)</td></tr>
<tr class="separator:ad5f1da20fc706db32c3355d79fa819ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d2fc6fcad028f50919c86b635e368e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename StreamType &gt; </td></tr>
<tr class="memitem:aa9d2fc6fcad028f50919c86b635e368e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#aa9d2fc6fcad028f50919c86b635e368e">write_nodes</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, StreamType &amp;out)</td></tr>
<tr class="separator:aa9d2fc6fcad028f50919c86b635e368e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad7f3fa14924353348a60368c129a99"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename StreamType &gt; </td></tr>
<tr class="memitem:acad7f3fa14924353348a60368c129a99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#acad7f3fa14924353348a60368c129a99">write_cells</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, StreamType &amp;out)</td></tr>
<tr class="separator:acad7f3fa14924353348a60368c129a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada672e280a680b8a20dfb60d747e3fed"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename StreamType &gt; </td></tr>
<tr class="memitem:ada672e280a680b8a20dfb60d747e3fed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#ada672e280a680b8a20dfb60d747e3fed">write_high_order_cells</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, StreamType &amp;out)</td></tr>
<tr class="separator:ada672e280a680b8a20dfb60d747e3fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d19d285f4429a9d2827bf49c37a6e3d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class StreamType &gt; </td></tr>
<tr class="memitem:a5d19d285f4429a9d2827bf49c37a6e3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a5d19d285f4429a9d2827bf49c37a6e3d">write_data</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, unsigned <a class="el" href="classint.html">int</a> n_data_sets, const <a class="el" href="classbool.html">bool</a> double_precision, StreamType &amp;out)</td></tr>
<tr class="separator:a5d19d285f4429a9d2827bf49c37a6e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75caf324397dd942b2eec09b3bec7181"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a75caf324397dd942b2eec09b3bec7181"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#a75caf324397dd942b2eec09b3bec7181">write_tecplot_binary</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;patches, const std::vector&lt; std::string &gt; &amp;data_names, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;nonscalar_data_ranges, const <a class="el" href="structDataOutBase_1_1TecplotFlags.html">TecplotFlags</a> &amp;flags, std::ostream &amp;out)</td></tr>
<tr class="separator:a75caf324397dd942b2eec09b3bec7181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4758c1a6d19b99a12f01e56146535d5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac4758c1a6d19b99a12f01e56146535d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDataOutBase.html#ac4758c1a6d19b99a12f01e56146535d5">write_svg</a> (const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;, const std::vector&lt; std::string &gt; &amp;, const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;, const <a class="el" href="structDataOutBase_1_1SvgFlags.html">SvgFlags</a> &amp;, std::ostream &amp;)</td></tr>
<tr class="separator:ac4758c1a6d19b99a12f01e56146535d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>这是一个基类，用于输出非常一般形式的网格上的数据。输出数据被期望为一组<code>patches</code>，并以可视化工具所期望的格式写入输出流。对于输出格式的列表，请查看枚举::OutputFormat。对于其中列出的每一种格式，这个类包含一个函数&lt;tt&gt;write_format，写出输出。关于某种格式的细节，请参考这些函数的文档。 </p><h3>Structure of the output data</h3>
<p>数据不是用deal.II网状结构写入的。相反，它依赖于一组由派生类（例如DataOut、DataOutStack、DataOutFaces、DataOutRotation或MatrixOut类）创建的&lt;tt&gt;patches。 每个补丁描述一个网格的单一逻辑单元，可能会被细分若干次，以表示在这个单元上定义的高阶多项式。为此，一个补丁由一个<code>dim</code>维的规则网格组成，每个方向上的网格点数量相同。在最简单的情况下，它可能由单个网格单元的角点组成。对于这个局部网格的每个点，Patch包含任意数量的数据值，不过每个Patch上每个点的数据集数量必须相同。 通过为不同的输出格式提供这个接口，可以简单地将这个类扩展到新的格式，而不需要依赖诸如实际的三角计算和数据矢量的处理。这些东西应该由派生类提供，它有一个用户可调用的接口，然后。 在每个补丁中，数据是按照通常的词典顺序组织的，<em>x</em>运行最快，然后是<em>y</em>和<em>z</em>。节点是按照这个顺序存储的，单元也是如此。三维的每个单元都被存储，使其正面位于<em>xz</em>平面。为了提高这一概念的可理解性，以下两节是从本文档的前一版本中保留下来的。</p>
<h4>Patches</h4>
<p>网格可以被认为是一个单元格的集合；如果你想在这样的网格上写出数据，你可以通过一次写一个单元格来实现。因此，这个类中的函数接收一个描述每个单元格上的数据的对象列表。每个单元的数据通常包括这个单元的顶点列表，以及每个顶点的数据值（例如，解决方案数据、错误信息等）的列表。 然而，在某些情况下，单元格的这种接口过于局限。例如，你可能有高阶元素，只打印顶点的值是不够的。出于这个原因，我们不仅提供了只写顶点上的数据，而且还将数据组织成每个单元的张量积网格。参数<code>n_subdivisions</code>是为每个补丁单独给出的，它表示单元被分割输出的频率；例如，<code>n_subdivisions==1</code>产生的单元没有被分割，<code>n_subdivisions==2</code>将产生一个二维空间3乘3点的网格，三维空间3乘3点，<code>n_subdivisions==3</code>将产生4乘4（乘4）点，等等。这些点在补丁上的实际位置将通过多线性变换从为这个补丁给出的顶点计算出来。 对于边界上的单元，可能会使用一个映射来计算内部点的位置。在这种情况下，坐标被存储在补丁内，因为它们不容易被恢复。 鉴于这些注释，要在这个点的补丁上打印的实际数据由几个数据集组成，每个数据集在每个补丁点上都有一个值。例如在两个空间维度的<code>n_subdivisions==2</code>，每个数据集要提供9个值，由于补丁要被打印成张量积（或其向实空间单元的转化），其值要像&lt;i&gt;(x0,y0) (x0,y1) (x0,y2) (x1,y0) (x1,y1) (x1,y2) (x2,y0) (x2,y1) (x2,y2)那样排序，即z坐标运行最快，然后是y坐标，然后是x（如果有那么多空间方向）。</p>
<h4>Generalized patches</h4>
<p>一般来说，上面解释的补丁可能太受限制。例如，在一个三维计算中，如果人们对内部发生的事情不感兴趣，可能只想画出一个域的外表面。那么，在一个三维的世界中，应该绘制的对象是二维的。Patch类和相关的输出函数可以处理这些情况。因此，Patch类需要两个模板参数，第一个名为<code>dim</code>，表示对象的维度（在上面的例子中，这将是两个），而第二个名为<code>spacedim</code>，表示嵌入空间的维度（这将是三个）。一个补丁的角点具有空间的维度，而它们的数量则由补丁的维度决定。默认情况下，第二个模板参数的值与第一个相同，这将对应于输出一个单元，而不是一个面或其他东西。 </p><h3>DataOutBaseInterface</h3>
<p>这个命名空间的成员通常不会从用户代码中直接调用。相反，使用这里声明的函数的类通常是从DataOutInterface派生的。 这个类的接口基本上由一个描述补丁的数据类型的声明和一堆函数组成，这些函数接收一个补丁列表，并将它们以一种格式或其他方式写入流。派生类的责任是提供这个补丁列表。除了补丁列表之外，还可以给每个数据集起一个名字。</p>
<h3>Querying interface</h3>
<p>这个类还提供了几个函数（parse_output_format(), <a class="el" href="namespaceDataOutBase.html#add43d8f47ccf7052f0178e710ad4ca02">get_output_format_names()</a>, <a class="el" href="namespaceDataOutBase.html#aed25a6ddf928a6904fd1ac942125ec86">default_suffix()</a>），可以用来查询这个类支持哪些输出格式。这些函数提供了一个我们可以输出的所有格式的名称列表，解析一个字符串并返回一个表示每个格式的枚举，并提供一种方法将这个枚举的值转换为该名称的文件通常使用的后缀。使用这些函数，可以使应用程序完全摆脱对库目前允许输出的格式的了解；几个例子程序显示了如何做到这一点。 </p><h3>Output parameters</h3>
<p>所有的函数都有一个参数，是一个<code>XFlags</code>类型的结构，其中<code>X</code>是输出格式的名称。要知道目前支持哪些标志，请阅读不同结构的文档。 注意，通常用于科学可视化程序的输出格式没有或只有很少的参数（除了一些兼容性标志），因为在那里，输出的实际外观是由可视化程序决定的，这个类产生的文件或多或少只存储原始数据。 直接的输出格式，如Postscript或Povray，需要给予更多的参数，虽然，因为在那里，输出文件必须包含所有的观点、光源等细节。 </p><h3>Writing backends</h3>
<p>引入了一个抽象层，以方便其他可视化工具的编码后端。它适用于将信息分离成顶点字段、网格单元的连接信息字段和数据字段的数据格式。 对于每一个字段，都实现了输出函数，即write_nodes()、write_cells()和write_data()。为了使用这些函数，必须编写一个特定格式的输出流，遵循DXStream、GmvStream、VtkStream等的例子，在.cc文件中实现。 在这个框架中，一个新的输出格式的实现被简化为编写章节头和新的输出流类，用于编写单个网格对象。 </p><h3>Credits</h3>
<ul>
<li>
EPS输出基于Stefan Nauber对旧的DataOut类的早期实现 </li>
<li>
Thomas Richter的Povray输出。 </li>
<li>
Benjamin Shelton Kirk的Tecplot输出。 </li>
<li>
拉格朗日VTK输出 作者：Alexander Grayver </li>
</ul>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa3cbced9f1d4ae661f13018f4c980aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cbced9f1d4ae661f13018f4c980aa1">&#9670;&nbsp;</a></span>OutputFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提供一个数据类型，指定目前支持的输出格式。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07"></a>default_format&#160;</td><td class="fielddoc"><p>使用已经存储在对象中的格式。 </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1"></a>none&#160;</td><td class="fielddoc"><p>不写任何输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1af54db6e70b60a249b36f803d0657b39e"></a>dx&#160;</td><td class="fielddoc"><p>为OpenDX输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1a1a420a2edb82acdd6e8e214f2ed97721"></a>ucd&#160;</td><td class="fielddoc"><p>为AVS提供UCD格式的输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1"></a>gnuplot&#160;</td><td class="fielddoc"><p>为Gnuplot工具的输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1a74aee841ac4d429a660bbd1bfee6f298"></a>povray&#160;</td><td class="fielddoc"><p>为Povray光线跟踪器提供的输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1acf35b7afd6a85044d32320355fbaabfe"></a>eps&#160;</td><td class="fielddoc"><p>在封装的PostScript中输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1a958eea3b2724c76d1c1ff20d69f7da4e"></a>gmv&#160;</td><td class="fielddoc"><p>用于GMV的输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1a8c187cd13581e59b34d71645276a550c"></a>tecplot&#160;</td><td class="fielddoc"><p>为Tecplot提供文本格式的输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1a9b83a7bdbd793467207e0a8f151e15e0"></a>tecplot_binary&#160;</td><td class="fielddoc"><p>以二进制格式输出Tecplot。比文本格式更快、更小。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>使用Tecplot的二进制输出已被弃用。</dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1ac41fd26a6a54c90d0d2062d859b8facf"></a>vtk&#160;</td><td class="fielddoc"><p>以VTK格式输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e"></a>vtu&#160;</td><td class="fielddoc"><p>以VTK格式输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1ad512d1f704c4b56b7bf99e3f81ebc06f"></a>svg&#160;</td><td class="fielddoc"><p>以SVG格式输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1ab9c7fdc67b488efaf1b27b02985a40fb"></a>deal_II_intermediate&#160;</td><td class="fielddoc"><p>以deal.II中间格式输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3cbced9f1d4ae661f13018f4c980aa1af7b5982bac28c91f885940695ca47542"></a>hdf5&#160;</td><td class="fielddoc"><p>以HDF5格式输出。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l01307">1307</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a75750d50e3d27159f8a1e4de7f0a8f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75750d50e3d27159f8a1e4de7f0a8f32">&#9670;&nbsp;</a></span>write_dx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_dx </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1DXFlags.html">DXFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的补丁列表以OpenDX格式写入输出流。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l03285">3285</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a98914588b1516419a572a1718b1bf3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98914588b1516419a572a1718b1bf3d5">&#9670;&nbsp;</a></span>write_eps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_eps </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; 2, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的补丁列表以eps格式写到输出流中。 以这种格式输出可以规避使用辅助图形程序将一些输出格式转换为图形格式。这样做的好处是输出简单而快速，缺点是你必须给出一大堆参数，这些参数决定了视线的方向、着色的模式、高度轴的缩放等等（当然，所有这些参数都有合理的默认值，你可能想改变它们）。 这个函数只支持二维域的输出（即dim=2），垂直方向的数值取自数据矢量。 基本上，输出包含了网格和它们之间的单元。你可以画其中之一，或者两者都画，或者不画，如果你真的对一个空的图片感兴趣的话。如果写出来，网格使用黑线。网格之间的单元格要么不打印（这将导致隐线去除的损失，即你可以 "看穿
"单元格到后面的线条），要么打印成白色（除了隐线去除外没有任何作用），要么使用其中一个数据向量（不必与计算高度信息的向量相同）和一个可定制的颜色函数进行着色。默认的颜色函数在黑色、蓝色、绿色、红色和白色之间选择颜色，选择的数据字段的值越来越大，用于着色。目前，每个单元格只显示一种颜色，该颜色取自单元格中心的数据字段的值；不使用单元格上颜色的双线性插值。 默认情况下，视角的选择与GNUPLOT中的默认视角一样，即相对于正Z轴的角度为60度，相对于负Y轴的角度正向旋转30度（从上面看）。 当然，你可以改变这些设置。 编写EPS输出时，图片周围没有边界，也就是说，边界框在四面都靠近输出。坐标最多使用五位数来书写，以保持图片的合理尺寸。 所有的参数以及它们的默认值都列在这个类的<code><a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a></code>成员类的文档中。更多详细的信息请见那里。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l04121">4121</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a175a197c99b06d22f17e2efcbdd18a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175a197c99b06d22f17e2efcbdd18a18">&#9670;&nbsp;</a></span>write_eps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_eps </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1EpsFlags.html">EpsFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这是一个与上面相同的函数，除了用于非二维的域。这个函数没有被实现（如果被调用将抛出一个错误），但被声明是为了允许与维度无关的程序。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l04103">4103</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="afa4389cfc36770d2881867f6889bc348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4389cfc36770d2881867f6889bc348">&#9670;&nbsp;</a></span>write_gmv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_gmv </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1GmvFlags.html">GmvFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的补丁列表以GMV格式写到输出流中。 数据以如下格式写入：节点被认为是斑块的点。在空间维度小于3的情况下，缺失的坐标会插入0。数据向量被写成节点或单元数据，对于第一种，数据空间被内插为（双，三）线性元素。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l04438">4438</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a3cfd561a7b5262f83e3cdc4020b377f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfd561a7b5262f83e3cdc4020b377f4">&#9670;&nbsp;</a></span>write_gnuplot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_gnuplot </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1GnuplotFlags.html">GnuplotFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的补丁列表以gnuplot格式写到输出流中。 然后可以通过启动<code>gnuplot</code>并输入命令来实现二维数据的可视化 </p><pre class="fragment">* set data style lines
* splot "filename" using 1:2:n
* </pre><p> 本例假设显示的数据矢量的编号为<b>n-2</b>。 GNUPLOT格式不能直接处理非结构化网格上的数据。直接意味着你只给出顶点和其上的解值，而程序会构建自己的网格来表示这些数据。这只对二维的结构化张量积网格是可行的。然而，在一个文件内给出几个这样的补丁是可能的，这正是这个类的相应函数所做的：将每个单元格的数据写成一个数据补丁，至少在派生类传递的补丁代表单元格的情况下。请注意，补丁上的函数在补丁之间的界面上不需要是连续的，所以这个方法也适用于不连续的元素。还要注意的是，GNUPLOT可以对修补过的数据进行隐线去除。 虽然这个讨论适用于两个空间维度，但在三维空间中则更为复杂。原因是我们仍然可以使用补丁，但当我们试图将它们可视化时就很困难了，因为如果我们使用切开数据（例如，通过使用x和z坐标，一个固定的y值和z方向的绘图函数值，那么补丁数据就不是GNUPLOT想要的补丁了。因此，我们使用了另一种方法，即把数据写在三维网格上，作为一连串的线，即每两个点与一个或多个数据集有关。 因此，一个补丁的每个子单元有12条线。 鉴于上述的线条，在Gnuplot中可以实现对这些数据的切割，就像这样。 </p><pre class="fragment">* set data style lines
* splot [:][:][0:] "T" using 1:2:($3==.5 ? $4 :
*
* -1)
* </pre><p> 这个命令在 \(x\) -和 \(y\) -方向上无限制地绘制数据，但在 \(z\) -方向上只绘制那些在 \(x\) - \(y\) -平面以上的数据点（我们在这里假设一个正解，如果它有负值，你可能想减少下限）。此外，它只取z值（<code>&amp;3</code>）等于0.5的数据点，即在<code>z=0.5</code>处切过域。对于这个平面上的数据点，第一个数据集（<code>&amp;4</code>）的数据值在x-y平面上方的z方向上被提高；所有其他的点都被表示为<code>-1</code>的值，而不是数据向量的值，并且由于z绘图方向的下限，在第三对括号中给出，所以不被绘制。 更复杂的切割是可能的，包括非线性的切割。然而，请注意，只有那些实际在切割面上的点才被绘制出来。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l03568">3568</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ae661c9d7979da0c39b5f08fd715ed947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae661c9d7979da0c39b5f08fd715ed947">&#9670;&nbsp;</a></span>write_povray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_povray </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1PovrayFlags.html">PovrayFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的补丁列表写入Povray光线跟踪器的输出流中。 以这种格式输出会创建一个povray源文件，包括用povray 3.1渲染的标准相机和光源定义，目前，这种格式只支持二维数据的输出，第三个方向的数值取自数据矢量。 输出使用两个不同的povray-objects。 </p><ul>
<li>
<code>BICUBIC_PATCH</code> 一个<code>bicubic_patch</code>是一个3维的Bezier补丁。它由16个描述表面的点组成。4个角点被物体所接触，而其他12个点则拉动和拉伸补丁的形状。每个补丁上都会产生一个<code>bicubic_patch</code>。因此，细分的数量必须是3，以提供16个点的补丁。双三次元补丁并不精确，但能生成非常平滑的图像。 </li>
<li>
<code>MESH</code> 网格对象是用来存储大量的三角形的。补丁数据的每个正方形都被分割成一个左上角和一个右下角的三角形。如果细分的数量是3个，每个补丁就会产生32个三角形。 使用平滑标志povray在三角形上插值法线，模仿一个弯曲的表面 </li>
</ul>
<p>。这个纹理必须在对象数据之前的某个地方声明。这可能是在一个外部数据文件中或在输出文件的开头。将<code>external_data</code>标志设置为false，一个标准的摄像机、灯光和纹理（按比例调整以适应场景）会被添加到输出文件中。设置为 "true"，一个包含文件 "data.inc "会被包括在内。这个文件不是由deal生成的，必须包括摄像机、灯光和纹理定义Tex。 你需要povray（&gt;=3.0）来渲染这个场景。povray的最小选项是。 </p><pre class="fragment">* povray +I&lt;inputfile&gt; +W&lt;horiz. size&gt; +H&lt;ver. size&gt; +L&lt;include path&gt;
* </pre><p> 如果使用外部文件 "data.inc"，这个文件的路径必须包含在povray选项中。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l03776">3776</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ab9f9f33c200120450b6844d986a83604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f9f33c200120450b6844d986a83604">&#9670;&nbsp;</a></span>write_tecplot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_tecplot </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1TecplotFlags.html">TecplotFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的补丁列表以Tecplot ASCII格式（FEBLOCK）写入输出流。 更多信息请查阅Tecplot用户和参考手册。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l04575">4575</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a5ec32be3e3379b7c83dc339f52cf2ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec32be3e3379b7c83dc339f52cf2ad6">&#9670;&nbsp;</a></span>write_ucd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_ucd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1UcdFlags.html">UcdFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的补丁列表以AVS开发者指南（现在的AVS）中描述的UCD格式写到输出流中。由于目前格式的限制，只能输出基于节点的数据，这也是我们发明补丁概念的原因之一。为了编写高阶元素，你可以把它们分割成每个单元的几个子单元。 然而，这些子单元也会被理解UCD格式的程序显示为不同的单元。 我们没有利用提供模型数据的可能性，因为所有UCD程序都不支持这些数据。你可以在派生类中给出单元格数据，方法是将一个补丁上给定数据集的所有值设置为相同的值。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l03194">3194</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a336d97147011f5f8f3746cac0a3ca4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336d97147011f5f8f3746cac0a3ca4ab">&#9670;&nbsp;</a></span>write_vtk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_vtk </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的补丁列表以VTK格式写到输出流中。数据是以传统的VTK格式写入的，而不是write_vtu()产生的基于XML的格式。 nonscalar_data_ranges参数表示输出中的组件范围，被认为是一个矢量，而不是简单的标量字段的集合。VTK的输出格式有特殊的规定，允许这些组件用一个名字来输出，而不是在可视化程序中把几个标量字段归为一个矢量。 </p><dl class="section note"><dt>Note</dt><dd>VTK是一种遗留格式，在很大程度上已经被VTU格式（VTK的XML结构版本）所取代了。特别是，VTU允许对数据进行压缩，因此导致大文件的文件大小要比VTK文件小得多。由于所有支持VTK的可视化程序也支持VTU，你应该考虑使用后者的文件格式，通过使用write_vtu()函数来代替。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l05131">5131</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a3aec479936b78bd0ec2ecc3674e24584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aec479936b78bd0ec2ecc3674e24584">&#9670;&nbsp;</a></span>write_vtu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_vtu </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的补丁列表以VTU格式写入输出流中。数据是以基于XML的VTK格式写入的，而不是write_vtk()产生的传统格式。 nonscalar_data_ranges参数表示输出中组件的范围，被认为是一个矢量，而不是简单的标量字段的集合。VTK的输出格式有特殊的规定，允许这些组件用一个名字来输出，而不是在可视化程序中把几个标量字段归为一个矢量。 一些可视化程序，如ParaView，可以读取几个独立的VTU文件来实现可视化的并行化。在这种情况下，你需要一个 <code>.pvtu</code> 文件来描述哪些VTU文件构成一个组。 <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a> 函数可以生成这样一个集中的记录。同样， <a class="el" href="namespaceDataOutBase.html#a482d9621dcc87d6a43cf8a9651e16cd8">DataOutInterface::write_visit_record()</a> 对VisIt也有同样的作用（尽管VisIt从2.5.1版开始也可以读取 <code>pvtu</code> 记录）。最后，对于与时间有关的问题，你可能还想看看 <a class="el" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutInterface::write_pvd_record()</a> 这个函数的使用在 <a class="el" href="step_40.html">step-40</a> 中有解释。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l05427">5427</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a6cb8c60785a483ffaf2644ab93508da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb8c60785a483ffaf2644ab93508da9">&#9670;&nbsp;</a></span>write_vtu_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_vtu_header </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这是为基于xml的vtu文件格式写头。这个例程与 <a class="el" href="namespaceDataOutBase.html#aa8709fac9a9e37c808518888630b4e04">DataOutInterface::write_vtu_footer()</a> 和 <a class="el" href="namespaceDataOutBase.html#ac502afe8d8c9fe9d1bdd8184f1f1291e">DataOutInterface::write_vtu_main()</a> 一起被 <a class="el" href="namespaceDataOutBase.html#a3aec479936b78bd0ec2ecc3674e24584">DataOutBase::write_vtu()</a>. 内部使用。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l05383">5383</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="aa8709fac9a9e37c808518888630b4e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8709fac9a9e37c808518888630b4e04">&#9670;&nbsp;</a></span>write_vtu_footer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_vtu_footer </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>该函数为基于xml的vtu文件格式写入页脚。本例程与 <a class="el" href="namespaceDataOutBase.html#a6cb8c60785a483ffaf2644ab93508da9">DataOutInterface::write_vtu_header()</a> 和 <a class="el" href="namespaceDataOutBase.html#ac502afe8d8c9fe9d1bdd8184f1f1291e">DataOutInterface::write_vtu_main()</a> 一起被 <a class="el" href="namespaceDataOutBase.html#a3aec479936b78bd0ec2ecc3674e24584">DataOutBase::write_vtu()</a>. 内部使用。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l05416">5416</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ac502afe8d8c9fe9d1bdd8184f1f1291e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac502afe8d8c9fe9d1bdd8184f1f1291e">&#9670;&nbsp;</a></span>write_vtu_main()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_vtu_main </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1VtkFlags.html">VtkFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>该函数为基于xml的vtu文件格式写入主要部分。这个程序在内部与 <a class="el" href="namespaceDataOutBase.html#a6cb8c60785a483ffaf2644ab93508da9">DataOutInterface::write_vtu_header()</a> 和 <a class="el" href="namespaceDataOutBase.html#aa8709fac9a9e37c808518888630b4e04">DataOutInterface::write_vtu_footer()</a> 一起被 <a class="el" href="namespaceDataOutBase.html#a3aec479936b78bd0ec2ecc3674e24584">DataOutBase::write_vtu()</a>. 使用。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l05449">5449</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ac8c87832129884d0603e3ab9ae132741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c87832129884d0603e3ab9ae132741">&#9670;&nbsp;</a></span>write_pvtu_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_pvtu_record </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>piece_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一些可视化程序，如ParaView，可以读取几个独立的VTU文件，这些文件都是同一模拟的一部分，以实现可视化的并行。在这种情况下，你需要一个 <code>.pvtu</code> 文件来描述哪些VTU文件（例如，通过 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> 函数写入）构成一个组。 当前的函数可以生成这样一个集中的记录。 这个函数通常不会从用户空间自己调用，但你可能想通过 <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a> 调用它，因为DataOutInterface类可以访问你必须手工提供给当前函数的信息。 在任何情况下，不管是直接调用这个函数还是通过 <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a>, 调用，这样编写的中央记录文件都包含一个（标量或矢量）字段的列表，描述哪些字段实际上可以在构成平行VTU文件集的各个文件中找到，以及这些文件的名称。这个函数通过第三和第四个参数获得字段的名称和类型；你可以用手来确定这些，但在实践中，这个函数最容易通过调用 <a class="el" href="namespaceDataOutBase.html#ac8c87832129884d0603e3ab9ae132741">DataOutInterfaces::write_pvtu_record()</a>, 来调用，它通过调用 <a class="el" href="classDataOutInterface.html#a128e5dec286cc1a429b94e29dd55ab81">DataOutInterface::get_dataset_names()</a> 和 <a class="el" href="classDataOutInterface.html#a05d5d72abcf81f4174e15fd984f1267c">DataOutInterface::get_nonscalar_data_ranges()</a> 函数确定最后两个参数。这个函数的第二个参数指定了构成并行集的文件名称。 </p><dl class="section note"><dt>Note</dt><dd>使用 <a class="el" href="namespaceDataOutBase.html#a3aec479936b78bd0ec2ecc3674e24584">DataOutBase::write_vtu()</a> 和 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> 来写每一块。还要注意，只有一个并行进程需要调用当前函数，列出所有并行进程写入的文件名。 </dd>
<dd>
为了告诉Paraview将多个 <code>pvtu</code> 文件组合在一起，每个文件描述一个与时间有关的模拟的一个时间步骤，请参阅 <a class="el" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record()</a> 函数。 </dd>
<dd>
旧版本的VisIt（2.5.1之前），不能读取 <code>pvtu</code> 记录。然而，它可以读取由write_visit_record()函数写入的访问记录。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l05854">5854</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a6f1c052ba49fd44cd8e3f35ba871aebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1c052ba49fd44cd8e3f35ba871aebd">&#9670;&nbsp;</a></span>write_pvd_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_pvd_record </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="classdouble.html">double</a>, std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>times_and_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在ParaView中，可以将与时间有关的数据可视化，并将其标记为与时间有关的模拟的当前积分时间。为了使用这个功能，你需要一个 <code>.pvd</code> 文件，描述哪个VTU或PVTU文件属于哪个时间段。这个函数写入一个提供这种映射的文件，也就是说，它需要一个对的列表，每个对表示一个特定的时间瞬时和包含这个时间瞬时的图形数据的相应文件。 一个典型的用例，在计算与时间有关的解决方案的程序中，将是以下内容（ <code>time</code> and <code>time_step</code> 是类型为 <code>double</code> 和 <code>unsigned int</code> 的类的成员变量；变量 <code>times_and_names</code> 的类型是 <code>std::vector&lt;std::pair&lt;double,std::string&gt; &gt;</code> ）。 </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MyEquation&lt;dim&gt;::output_results ()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;U&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a> (timestep_n, 3) +</div><div class="line">                             <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">std::ofstream output(filename);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line"></div><div class="line">times_and_names.emplace_back (time, filename);</div><div class="line">std::ofstream pvd_output (<span class="stringliteral">&quot;solution.pvd&quot;</span>);</div><div class="line"><a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a> (pvd_output, times_and_names);</div><div class="line">}</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>参见 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu</a>, <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record</a>, 和 <a class="el" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">DataOutInterface::write_vtu_in_parallel</a> ，用于编写每个时间步长的解决方案。 </dd>
<dd>
每对文件的第二个元素，即储存每个时间的图形数据的文件，本身又可以是一个引用其他文件的文件。例如，它可以是一个 <code>.pvtu</code> 文件的名称，该文件引用了一个并行计算的多个部分。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l05963">5963</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ae4c65120d0661fe57597ff0d13a296c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c65120d0661fe57597ff0d13a296c1">&#9670;&nbsp;</a></span>write_visit_record() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_visit_record </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>piece_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数完全等同于write_pvtu_record()函数，但适用于旧版本的VisIt可视化程序和一个可视化图形（或仅一个时间步长）。关于这个函数的用途，见那里。 这个函数在 "将数据输入VisIt "报告中的 "创建并行的主文件
"部分（第5.7节）有记录，可以在这里找到： <a href="https://wci.llnl.gov/codes/visit/2.0.0/GettingDataIntoVisIt2.0.0.pdf">https://wci.llnl.gov/codes/visit/2.0.0/GettingDataIntoVisIt2.0.0.pdf</a> </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l06000">6000</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a34a2666ee12e5b0364d888b18eb3ec8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a2666ee12e5b0364d888b18eb3ec8e">&#9670;&nbsp;</a></span>write_visit_record() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_visit_record </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>piece_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数等同于上面的write_visit_record()，但用于多个时间步长。下面是一个如何使用该函数的例子。 </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_time_steps = 3;</div><div class="line">std::vector&lt;std::vector&lt;std::string &gt; &gt; piece_names(number_of_time_steps);</div><div class="line"></div><div class="line">piece_names[0].emplace_back(<span class="stringliteral">&quot;subdomain_01.time_step_0.vtk&quot;</span>);</div><div class="line">piece_names[0].emplace_back(<span class="stringliteral">&quot;subdomain_02.time_step_0.vtk&quot;</span>);</div><div class="line"></div><div class="line">piece_names[1].emplace_back(<span class="stringliteral">&quot;subdomain_01.time_step_1.vtk&quot;</span>);</div><div class="line">piece_names[1].emplace_back(<span class="stringliteral">&quot;subdomain_02.time_step_1.vtk&quot;</span>);</div><div class="line"></div><div class="line">piece_names[2].emplace_back(<span class="stringliteral">&quot;subdomain_01.time_step_2.vtk&quot;</span>);</div><div class="line">piece_names[2].emplace_back(<span class="stringliteral">&quot;subdomain_02.time_step_2.vtk&quot;</span>);</div><div class="line"></div><div class="line">std::ofstream visit_output (<span class="stringliteral">&quot;solution.visit&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="namespaceDataOutBase.html#ae4c65120d0661fe57597ff0d13a296c1">DataOutBase::write_visit_record</a>(visit_output, piece_names);</div></div><!-- fragment --><p> 这个函数在 "将数据输入VisIt "报告的 "创建一个并行的主文件
"一节（第5.7节）中有记录，可以在这里找到： <a href="https://wci.llnl.gov/codes/visit/2.0.0/GettingDataIntoVisIt2.0.0.pdf">https://wci.llnl.gov/codes/visit/2.0.0/GettingDataIntoVisIt2.0.0.pdf</a> </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l06013">6013</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a482d9621dcc87d6a43cf8a9651e16cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482d9621dcc87d6a43cf8a9651e16cd8">&#9670;&nbsp;</a></span>write_visit_record() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_visit_record </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="classdouble.html">double</a>, std::vector&lt; std::string &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>times_and_piece_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数等同于上面的write_visit_record()，但是对于多个时间步长，而且每个时间步长的时间的附加信息。下面是一个如何使用该函数的例子。 </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_time_steps = 3;</div><div class="line">std::vector&lt;std::pair&lt;double,std::vector&lt;std::string &gt; &gt; &gt;</div><div class="line">times_and_piece_names(number_of_time_steps);</div><div class="line"></div><div class="line">times_and_piece_names[0].first = 0.0;</div><div class="line">times_and_piece_names[0].second.emplace_back(<span class="stringliteral">&quot;subdomain_01.time_step_0.vtk&quot;</span>);</div><div class="line">times_and_piece_names[0].second.emplace_back(<span class="stringliteral">&quot;subdomain_02.time_step_0.vtk&quot;</span>);</div><div class="line"></div><div class="line">times_and_piece_names[1].first = 0.5;</div><div class="line">times_and_piece_names[1].second.emplace_back(<span class="stringliteral">&quot;subdomain_01.time_step_1.vtk&quot;</span>);</div><div class="line">times_and_piece_names[1].second.emplace_back(<span class="stringliteral">&quot;subdomain_02.time_step_1.vtk&quot;</span>);</div><div class="line"></div><div class="line">times_and_piece_names[2].first = 1.0;</div><div class="line">times_and_piece_names[2].second.emplace_back(<span class="stringliteral">&quot;subdomain_01.time_step_2.vtk&quot;</span>);</div><div class="line">times_and_piece_names[2].second.emplace_back(<span class="stringliteral">&quot;subdomain_02.time_step_2.vtk&quot;</span>);</div><div class="line"></div><div class="line">std::ofstream visit_output (<span class="stringliteral">&quot;solution.visit&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="namespaceDataOutBase.html#ae4c65120d0661fe57597ff0d13a296c1">DataOutBase::write_visit_record</a>(visit_output, times_and_piece_names);</div></div><!-- fragment --><p> 这个函数在 "将数据输入VisIt "报告的 "为并行创建主文件
"一节（第5.7节）中有记录，可以在这里找到： <a href="https://wci.llnl.gov/codes/visit/2.0.0/GettingDataIntoVisIt2.0.0.pdf">https://wci.llnl.gov/codes/visit/2.0.0/GettingDataIntoVisIt2.0.0.pdf</a> </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l06041">6041</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ad20ab1f2f5ec29122aefe1f016ff6eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20ab1f2f5ec29122aefe1f016ff6eac">&#9670;&nbsp;</a></span>write_svg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_svg </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; 2, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1SvgFlags.html">SvgFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的补丁列表以SVG格式写入输出流中。 SVG（Scalable <a class="el" href="classVector.html">Vector</a> Graphics）是一种基于XML的矢量图像格式，由万维网联盟（W3C）开发和维护。该功能符合2011年8月16日发布的最新规范SVG 1.1。通过设置或清除相应的标志（见SvgFlags结构），可以控制图形的输出。目前，这种格式只支持二维数据的输出，第三个方向的值取自数据矢量。 对于输出，每个补丁被细分为四个三角形，然后被写成多边形，并用线性颜色梯度填充。补丁产生的颜色使顶点的数据值从指定的数据向量中可视化。可以画一个色条来编码着色。 </p><dl class="section note"><dt>Note</dt><dd>这个函数到目前为止只在两个维度上实现，并为数据信息保留了一个附加维度。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l06093">6093</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a70b0a895fd8b48c1555fa1c34f2cd176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b0a895fd8b48c1555fa1c34f2cd176">&#9670;&nbsp;</a></span>write_deal_II_intermediate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_deal_II_intermediate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1Deal__II__IntermediateFlags.html">Deal_II_IntermediateFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的补丁列表以deal.II中间格式写到输出流中。这不是任何其他图形程序所能理解的格式，而是直接转储deal.II所使用的内部中间格式。这种内部格式是由可以使用DataOutBase类产生输出的各种类产生的，例如从有限元求解中产生，然后在本类中转换为最终的图形格式。 注意，中间格式就像它的名字一样：内部数据的直接表示。它不是标准化的，每当我们改变内部表示时就会改变。你只能期望使用用于写入的同一版本的deal.II来处理以这种格式写入的文件。 我们提供写出这种中间格式的原因是，它可以使用DataOutReader类读回deal.II程序中，这至少在两种情况下是有帮助的。首先，这可以用来在以后生成任何其他目前能理解的图形格式的图形输出；这样，在运行时就不需要知道要求哪种输出格式，或者是否需要不同格式的多个输出文件。其次，与几乎所有其他图形格式相比，有可能合并几个包含中间格式数据的文件，并从中生成一个单一的输出文件，该文件可以再次采用中间格式或任何最终格式。后一种选择对并行程序最有帮助：正如 <a class="el" href="step_17.html">step-17</a> 示例程序所演示的，可以只让一个处理器为整个并行程序生成图形输出，但如果涉及许多处理器，这可能会变得效率极低，因为负载不再平衡。出路是让每个处理器为它的那块领域生成中间图形输出，而后将不同的文件合并成一个，这是一个比生成中间数据便宜得多的操作。 中间格式的deal.II数据通常存储在以&lt;tt&gt;.d2结尾的文件中。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07056">7056</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="af5a956cffba0fa383f85a82bb2a4ca63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a956cffba0fa383f85a82bb2a4ca63">&#9670;&nbsp;</a></span>write_hdf5_parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将 <code>data_filter</code> 中的数据写入一个包含网格和求解值的HDF5文件。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07761">7761</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a5b63e70306e3d6671ac16b46f7d158e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b63e70306e3d6671ac16b46f7d158e4">&#9670;&nbsp;</a></span>write_hdf5_parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>write_mesh_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solution_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将 <code>data_filter</code> 中的数据写入HDF5文件。如果 <code>write_mesh_file</code> 为假，网格数据将不被写入，解文件将只包含解的数值。如果 <code>write_mesh_file</code> 为真，且文件名相同，生成的文件将同时包含网格数据和求解值。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07774">7774</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a5eae1562cccea12a7cc4be2bbf9830a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eae1562cccea12a7cc4be2bbf9830a7">&#9670;&nbsp;</a></span>write_filtered_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_filtered_data </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filtered_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DataOutFilter是一种中间数据格式，可以减少将被写入文件的数据量。这个函数所填充的对象随后可以再次用于写入具体文件格式的数据；例如，见 <a class="el" href="namespaceDataOutBase.html#af5a956cffba0fa383f85a82bb2a4ca63">DataOutBase::write_hdf5_parallel()</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07615">7615</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a14e601aef19bd7d10884a1d25f07f3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e601aef19bd7d10884a1d25f07f3f8">&#9670;&nbsp;</a></span>determine_intermediate_format_dimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; DataOutBase::determine_intermediate_format_dimensions </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出一个包含由write_deal_II_intermediate()写入的数据的输入流，确定调用该函数的<code>dim</code>和<code>spacedim</code>模板参数，并将它们作为一对值返回。 注意，这个函数在流的当前位置吃了一些元素，因此改变了它。为了使用例如DataOutReader类从它那里读取数据，你可能希望将流重置到它以前的位置，或者关闭并重新打开它。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07104">7104</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="abbf6308a89986d2081638ef3117699a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf6308a89986d2081638ef3117699a9">&#9670;&nbsp;</a></span>parse_output_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a> DataOutBase::parse_output_format </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回对应于给定字符串的OutputFormat值。如果该字符串与任何已知的格式不匹配，就会抛出一个异常。 这个函数的主要目的是允许程序使用任何已实现的输出格式，而不需要在每次实现新的格式时扩展程序的分析器。 要获得目前可用的格式名称的列表，例如，要把它交给ParameterHandler类，请使用函数get_output_format_names()。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02593">2593</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="add43d8f47ccf7052f0178e710ad4ca02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add43d8f47ccf7052f0178e710ad4ca02">&#9670;&nbsp;</a></span>get_output_format_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string DataOutBase::get_output_format_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个已实现的输出格式的列表。不同的名称由垂直条形符号（<code>`|'</code>）分开，正如ParameterHandler类所使用的那样。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02645">2645</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="aed25a6ddf928a6904fd1ac942125ec86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed25a6ddf928a6904fd1ac942125ec86">&#9670;&nbsp;</a></span>default_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string DataOutBase::default_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">OutputFormat</a>&#160;</td>
          <td class="paramname"><em>output_format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提供一个函数，告诉我们一个给定输出格式的文件通常有哪个后缀。目前定义了以下格式。 </p><ul>
<li>
<code>dx</code>: <code>.dx</code> </li>
<li>
<code>ucd</code>: <code>.inp</code> </li>
<li>
<code>gnuplot</code>: <code>.gnuplot</code> </li>
<li>
<code>povray</code>: <code>.pov</code> </li>
<li>
<code>eps</code>: <code>.eps</code> </li>
<li>
<code>gmv</code>: <code>.gmv</code> </li>
<li>
<code>tecplot</code>: <code>.dat</code> </li>
<li>
<code>tecplot_binary</code>: <code>.plt</code> </li>
<li>
<code>vtk</code>: <code>.vtk</code> </li>
<li>
<code>vtu</code>: <code>.vtu</code> </li>
<li>
<code>svg</code>: <code>.svg</code> </li>
<li>
<code>deal_II_intermediate</code>: <code>.d2</code>. </li>
</ul>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>使用Tecplot二进制输出已被废弃。</dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02653">2653</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a1b471b212de843a0e7d1de8d6d631fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b471b212de843a0e7d1de8d6d631fea">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DataOutBase::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code><a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a></code>. 类型对象的输出操作符 该操作符转储由补丁数据结构代表的中间图形格式。它以后可以被转换为一些图形程序的常规格式。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08876">8876</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ad5f1da20fc706db32c3355d79fa819ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f1da20fc706db32c3355d79fa819ae">&#9670;&nbsp;</a></span>operator>>()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; DataOutBase::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>类型对象的输入操作符 <code><a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a></code>. 该操作符读取由补丁数据结构代表的中间图形格式，使用操作符&lt;&lt;的格式写入。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08908">8908</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="aa9d2fc6fcad028f50919c86b635e368e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d2fc6fcad028f50919c86b635e368e">&#9670;&nbsp;</a></span>write_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_nodes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02696">2696</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="acad7f3fa14924353348a60368c129a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad7f3fa14924353348a60368c129a99">&#9670;&nbsp;</a></span>write_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_cells </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02733">2733</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ada672e280a680b8a20dfb60d747e3fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada672e280a680b8a20dfb60d747e3fed">&#9670;&nbsp;</a></span>write_high_order_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_high_order_cells </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02780">2780</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a5d19d285f4429a9d2827bf49c37a6e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d19d285f4429a9d2827bf49c37a6e3d">&#9670;&nbsp;</a></span>write_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_data </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_data_sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>double_precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l02848">2848</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a75caf324397dd942b2eec09b3bec7181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75caf324397dd942b2eec09b3bec7181">&#9670;&nbsp;</a></span>write_tecplot_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_tecplot_binary </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>nonscalar_data_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1TecplotFlags.html">TecplotFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l04806">4806</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ac4758c1a6d19b99a12f01e56146535d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4758c1a6d19b99a12f01e56146535d5">&#9670;&nbsp;</a></span>write_svg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DataOutBase::write_svg </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structDataOutBase_1_1Patch.html">Patch</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDataOutBase_1_1SvgFlags.html">SvgFlags</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l06077">6077</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
