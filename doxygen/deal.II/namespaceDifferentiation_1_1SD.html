<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceDifferentiation_1_1SD.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Differentiation::SD Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDifferentiation.html">Differentiation</a></li><li class="navelem"><a class="el" href="namespaceDifferentiation_1_1SD.html">SD</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Differentiation::SD Namespace Reference<div class="ingroups"><a class="el" href="group__auto__symb__diff.html">Automatic and symbolic differentiation</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDifferentiation_1_1SD_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDifferentiation_1_1SD_1_1types"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html">types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceDifferentiation_1_1SD_1_1Utilities"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD_1_1Utilities.html">Utilities</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">BatchOptimizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDifferentiation_1_1SD_1_1is__sd__number.html">is_sd_number</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDifferentiation_1_1SD_1_1is__sd__number_3_01Expression_01_4.html">is_sd_number&lt; Expression &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDifferentiation_1_1SD_1_1is__sd__number_3_01SymEngine_1_1Expression_01_4.html">is_sd_number&lt; SymEngine::Expression &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDifferentiation_1_1SD_1_1is__symengine__number.html">is_symengine_number</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDifferentiation_1_1SD_1_1is__symengine__number_3_01Expression_01_4.html">is_symengine_number&lt; Expression &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDifferentiation_1_1SD_1_1is__symengine__number_3_01SymEngine_1_1Expression_01_4.html">is_symengine_number&lt; SymEngine::Expression &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a841a7b84dc17bf2ba675522093a97e8b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">OptimizerType</a> { <a class="el" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8baabc20d7bde1df257f890e152af2e3470">OptimizerType::dictionary</a>, 
<a class="el" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c">OptimizerType::lambda</a>, 
<a class="el" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba7c7d2b9e8389cc541dc5a615e05bcf1e">OptimizerType::llvm</a>
 }</td></tr>
<tr class="separator:a841a7b84dc17bf2ba675522093a97e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af920b6488de218dea94f25b94ad08842"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> : unsigned char { <a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842abea01b791a14888764e22d110f6ea97f">OptimizationFlags::optimize_default</a> = 0, 
<a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842a3df84265620315a025367510c90d0474">OptimizationFlags::optimize_cse</a> = 0x0001, 
<a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842af08a168a64482d29e6ce023ab222a083">OptimizationFlags::optimize_aggressive</a> = 0x0002, 
<a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842a1ad0cce13bc606ad6742e9841ccdfe15">OptimizationFlags::optimize_all</a> = optimize_cse | optimize_aggressive
 }</td></tr>
<tr class="separator:af920b6488de218dea94f25b94ad08842"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7ad3513656cc7b78eb6dffd490429fe2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7ad3513656cc7b78eb6dffd490429fe2">DeclException1</a> (ExcSymEngineParserError, std::string,&lt;&lt; &quot;The string '&quot;&lt;&lt; arg1&lt;&lt; &quot;' could not be parsed successfully. Are you sure that (1) it &quot;&lt;&lt; &quot;consists of legitimate operations and syntax, and (2) you've &quot;&lt;&lt; &quot;previously declared all symbolic variables that are present &quot;&lt;&lt; &quot;in the expression?&quot;)</td></tr>
<tr class="separator:ga7ad3513656cc7b78eb6dffd490429fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab61b9fae9efffa088e5b0a46d6d3874e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab61b9fae9efffa088e5b0a46d6d3874e">DeclExceptionMsg</a> (ExcSymEngineLLVMNotAvailable, &quot;SymEngine has not been built with LLVM support.&quot;)</td></tr>
<tr class="separator:gab61b9fae9efffa088e5b0a46d6d3874e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a10411a7e3b66a76c57ddaad667b35e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9a10411a7e3b66a76c57ddaad667b35e">DeclExceptionMsg</a> (ExcSymEngineLLVMReturnTypeNotSupported, &quot;The SymEngine LLVM optimizer does not (yet) support the &quot; &quot;selected return type.&quot;)</td></tr>
<tr class="separator:ga9a10411a7e3b66a76c57ddaad667b35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b70c59222eaf89e4b362de26158ce4"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:a80b70c59222eaf89e4b362de26158ce4"><td class="memTemplItemLeft" align="right" valign="top">StreamType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a80b70c59222eaf89e4b362de26158ce4">operator&lt;&lt;</a> (StreamType &amp;s, <a class="el" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">OptimizerType</a> o)</td></tr>
<tr class="separator:a80b70c59222eaf89e4b362de26158ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6c34535268e98688dc577a9eb0ee90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#afc6c34535268e98688dc577a9eb0ee90">operator|</a> (const <a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> f1, const <a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> f2)</td></tr>
<tr class="separator:afc6c34535268e98688dc577a9eb0ee90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e27546f57a02a0994aeead1a1ce23a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a23e27546f57a02a0994aeead1a1ce23a">operator|=</a> (<a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> &amp;f1, const <a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> f2)</td></tr>
<tr class="separator:a23e27546f57a02a0994aeead1a1ce23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fff6fc47cc19131f951f2fc68921fa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a4fff6fc47cc19131f951f2fc68921fa3">operator &amp;</a> (const <a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> f1, const <a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> f2)</td></tr>
<tr class="separator:a4fff6fc47cc19131f951f2fc68921fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320deb187afe4738726b96f41b0f80d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a320deb187afe4738726b96f41b0f80d6">operator &amp;=</a> (<a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> &amp;f1, const <a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> f2)</td></tr>
<tr class="separator:a320deb187afe4738726b96f41b0f80d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6940959dfb13557d6cdc3c33a4b961"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:a2a6940959dfb13557d6cdc3c33a4b961"><td class="memTemplItemLeft" align="right" valign="top">StreamType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a2a6940959dfb13557d6cdc3c33a4b961">operator&lt;&lt;</a> (StreamType &amp;s, <a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> o)</td></tr>
<tr class="separator:a2a6940959dfb13557d6cdc3c33a4b961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63580cd7253055ea87706f9fe3c5f52d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a63580cd7253055ea87706f9fe3c5f52d">Expression::operator const SymEngine::RCP&lt; const SymEngine::Basic &gt; &amp;</a> () const</td></tr>
<tr class="separator:a63580cd7253055ea87706f9fe3c5f52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145415551e08d4e10d75683ccebe9e37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a145415551e08d4e10d75683ccebe9e37">operator &amp;</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a145415551e08d4e10d75683ccebe9e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650506d4f70b6fd7a72863a68de2a46a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a650506d4f70b6fd7a72863a68de2a46a">operator &amp;&amp;</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a650506d4f70b6fd7a72863a68de2a46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Power functions</div></td></tr>
<tr class="memitem:aa19e4a591917e9af8587ab37433d4f24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#aa19e4a591917e9af8587ab37433d4f24">pow</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;base, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;exponent)</td></tr>
<tr class="separator:aa19e4a591917e9af8587ab37433d4f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393ea06695141ece7a0fa0a641ea8c4e"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a393ea06695141ece7a0fa0a641ea8c4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a393ea06695141ece7a0fa0a641ea8c4e">pow</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;base, const <a class="el" href="classNumberType.html">NumberType</a> &amp;exponent)</td></tr>
<tr class="separator:a393ea06695141ece7a0fa0a641ea8c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1f0adc1684eb37d093630ddd16018a"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:abc1f0adc1684eb37d093630ddd16018a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#abc1f0adc1684eb37d093630ddd16018a">pow</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;base, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;exponent)</td></tr>
<tr class="separator:abc1f0adc1684eb37d093630ddd16018a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38c1aa2dfee8cc43920ef787d8bb393"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ae38c1aa2dfee8cc43920ef787d8bb393">sqrt</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:ae38c1aa2dfee8cc43920ef787d8bb393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9eaf1827ea15d79f9cbad4e9e5425a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a0a9eaf1827ea15d79f9cbad4e9e5425a">cbrt</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a0a9eaf1827ea15d79f9cbad4e9e5425a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964895bdb3715db4878051afcbfdc1fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a964895bdb3715db4878051afcbfdc1fc">exp</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;exponent)</td></tr>
<tr class="separator:a964895bdb3715db4878051afcbfdc1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35f613ffd73c1fc8e7806a4eef5579f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ae35f613ffd73c1fc8e7806a4eef5579f">log</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:ae35f613ffd73c1fc8e7806a4eef5579f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae073f52ff1d01c63ffeff65a0f29eba5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ae073f52ff1d01c63ffeff65a0f29eba5">log</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;base)</td></tr>
<tr class="separator:ae073f52ff1d01c63ffeff65a0f29eba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5eed58b71444c88a5a771665db3425c"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ae5eed58b71444c88a5a771665db3425c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ae5eed58b71444c88a5a771665db3425c">log</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x, const <a class="el" href="classNumberType.html">NumberType</a> &amp;base)</td></tr>
<tr class="separator:ae5eed58b71444c88a5a771665db3425c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30141949c304081e9b2f2f8f9e312634"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a30141949c304081e9b2f2f8f9e312634"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a30141949c304081e9b2f2f8f9e312634">log</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;x, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;base)</td></tr>
<tr class="separator:a30141949c304081e9b2f2f8f9e312634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3073c01113bca5a5e9a1b921643ced4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#af3073c01113bca5a5e9a1b921643ced4">log10</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:af3073c01113bca5a5e9a1b921643ced4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Trigonometric functions</div></td></tr>
<tr class="memitem:a907a3cabd7c1f251cc252ba5c9dd2c25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a907a3cabd7c1f251cc252ba5c9dd2c25">sin</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a907a3cabd7c1f251cc252ba5c9dd2c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd32c4b25ea499572dc34bcddf03c19b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#acd32c4b25ea499572dc34bcddf03c19b">cos</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:acd32c4b25ea499572dc34bcddf03c19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab202ef14f4d632f420dc24507376d510"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ab202ef14f4d632f420dc24507376d510">tan</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:ab202ef14f4d632f420dc24507376d510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da29a575519932d784e5240a6ae3a0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a2da29a575519932d784e5240a6ae3a0a">csc</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a2da29a575519932d784e5240a6ae3a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775d2e774698e280712d757c235f3edd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a775d2e774698e280712d757c235f3edd">sec</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a775d2e774698e280712d757c235f3edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca69936502b36a4aaf75cc89e95bac83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#aca69936502b36a4aaf75cc89e95bac83">cot</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:aca69936502b36a4aaf75cc89e95bac83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17229421811a17b2eb6145fe0f933ec2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a17229421811a17b2eb6145fe0f933ec2">asin</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a17229421811a17b2eb6145fe0f933ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbf69ffef5e5d013fc0be51d1cd88a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#aafbf69ffef5e5d013fc0be51d1cd88a6">acos</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:aafbf69ffef5e5d013fc0be51d1cd88a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803fcea270d7a523a91e3b7c173059f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">atan</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a803fcea270d7a523a91e3b7c173059f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130b20f2ea3522f1d123c75c63c0f67d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">atan2</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;y, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a130b20f2ea3522f1d123c75c63c0f67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faa3876e48efe1ead0794617005979b"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a8faa3876e48efe1ead0794617005979b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a8faa3876e48efe1ead0794617005979b">atan2</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;y, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a8faa3876e48efe1ead0794617005979b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecc3ac2de140bf35128149051a4c140"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3ecc3ac2de140bf35128149051a4c140"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a3ecc3ac2de140bf35128149051a4c140">atan2</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;y, const <a class="el" href="classNumberType.html">NumberType</a> &amp;x)</td></tr>
<tr class="separator:a3ecc3ac2de140bf35128149051a4c140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e663074348927c6757e45775873bc1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a8e663074348927c6757e45775873bc1a">acsc</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a8e663074348927c6757e45775873bc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d4063ff04a88f4201dc50dcdd7641c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ac9d4063ff04a88f4201dc50dcdd7641c">asec</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:ac9d4063ff04a88f4201dc50dcdd7641c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc744518dd554265fe610247958e7be2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#adc744518dd554265fe610247958e7be2">acot</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:adc744518dd554265fe610247958e7be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hyperbolic trigonometric functions</div></td></tr>
<tr class="memitem:a766e4d9bbfe24e99245081947db6a0c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a766e4d9bbfe24e99245081947db6a0c7">sinh</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a766e4d9bbfe24e99245081947db6a0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c1f7a69dc8ac2e16144493d3b3b896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">cosh</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a26c1f7a69dc8ac2e16144493d3b3b896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86151e4842702eb0b667b22122df4597"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">tanh</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a86151e4842702eb0b667b22122df4597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00f97e0273fefbafef4865f97213d8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ab00f97e0273fefbafef4865f97213d8b">csch</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:ab00f97e0273fefbafef4865f97213d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d7349600d504401a36f33f0dabd908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#aa9d7349600d504401a36f33f0dabd908">sech</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:aa9d7349600d504401a36f33f0dabd908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e76f1c4fdb9a31f4fabef8abee5f28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a66e76f1c4fdb9a31f4fabef8abee5f28">coth</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a66e76f1c4fdb9a31f4fabef8abee5f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb4eb9452e084d3c9128ea5fc25720b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a1fb4eb9452e084d3c9128ea5fc25720b">asinh</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a1fb4eb9452e084d3c9128ea5fc25720b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51a65b3c0995d2eb36c7c2e818c2349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ab51a65b3c0995d2eb36c7c2e818c2349">acosh</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:ab51a65b3c0995d2eb36c7c2e818c2349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6d5136ba07cf1ca9eca4cbff740e15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a0d6d5136ba07cf1ca9eca4cbff740e15">atanh</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a0d6d5136ba07cf1ca9eca4cbff740e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0e9c2926bf4359ec2effc24f20b4e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a3f0e9c2926bf4359ec2effc24f20b4e9">acsch</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a3f0e9c2926bf4359ec2effc24f20b4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba0a6e67e1f4c1241d9924b791c9dd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a9ba0a6e67e1f4c1241d9924b791c9dd6">asech</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a9ba0a6e67e1f4c1241d9924b791c9dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2949feffc15a59e204cbeafd55bfdd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ad2949feffc15a59e204cbeafd55bfdd0">acoth</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:ad2949feffc15a59e204cbeafd55bfdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other functions</div></td></tr>
<tr class="memitem:a3f3a70440b123a1f1e8c5b879c1c2c39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a3f3a70440b123a1f1e8c5b879c1c2c39">abs</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a3f3a70440b123a1f1e8c5b879c1c2c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592560ee80355620422a86087f11b9df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">fabs</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a592560ee80355620422a86087f11b9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55d50a1ffa79c27f9bd9ea104f15158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#aa55d50a1ffa79c27f9bd9ea104f15158">sign</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:aa55d50a1ffa79c27f9bd9ea104f15158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb732411693d0e4711ca3a17792a505d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#afb732411693d0e4711ca3a17792a505d">copysign</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;value, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;<a class="el" href="namespaceDifferentiation_1_1SD.html#aa55d50a1ffa79c27f9bd9ea104f15158">sign</a>)</td></tr>
<tr class="separator:afb732411693d0e4711ca3a17792a505d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860b730b2531e8c9adafc3e7bd7343fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a860b730b2531e8c9adafc3e7bd7343fa">floor</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a860b730b2531e8c9adafc3e7bd7343fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6545410ba18556ebf7c478b6ad9939f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a6545410ba18556ebf7c478b6ad9939f6">ceil</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a6545410ba18556ebf7c478b6ad9939f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922568e7a10acd3078e67b49712c60ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a922568e7a10acd3078e67b49712c60ca">max</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;a, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;b)</td></tr>
<tr class="separator:a922568e7a10acd3078e67b49712c60ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357402260ddae0b720e381b38988f87a"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a357402260ddae0b720e381b38988f87a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a357402260ddae0b720e381b38988f87a">max</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;a, const <a class="el" href="classNumberType.html">NumberType</a> &amp;b)</td></tr>
<tr class="separator:a357402260ddae0b720e381b38988f87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d888bdb03ec44c097789f03164a484b"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3d888bdb03ec44c097789f03164a484b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a3d888bdb03ec44c097789f03164a484b">max</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;a, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;b)</td></tr>
<tr class="separator:a3d888bdb03ec44c097789f03164a484b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2452236ed5f1ed06a3c52cd8dd6598e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ac2452236ed5f1ed06a3c52cd8dd6598e">min</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;a, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;b)</td></tr>
<tr class="separator:ac2452236ed5f1ed06a3c52cd8dd6598e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb936a268a242e7ac15184bf7fa99a5"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:acbb936a268a242e7ac15184bf7fa99a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#acbb936a268a242e7ac15184bf7fa99a5">min</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;a, const <a class="el" href="classNumberType.html">NumberType</a> &amp;b)</td></tr>
<tr class="separator:acbb936a268a242e7ac15184bf7fa99a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc2615d0f2b4fb3a29ed88565d965ca"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a2fc2615d0f2b4fb3a29ed88565d965ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a2fc2615d0f2b4fb3a29ed88565d965ca">min</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;a, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;b)</td></tr>
<tr class="separator:a2fc2615d0f2b4fb3a29ed88565d965ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2761bd9ab104a1a1852b7e6d54d986f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ad2761bd9ab104a1a1852b7e6d54d986f">erf</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:ad2761bd9ab104a1a1852b7e6d54d986f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95988d5123f1ffc15b951c613cf3d13b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a95988d5123f1ffc15b951c613cf3d13b">erfc</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a95988d5123f1ffc15b951c613cf3d13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bitwise operators</div></td></tr>
<tr class="memitem:ae4bf0df298733c58db90414b97ef3e53"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ae4bf0df298733c58db90414b97ef3e53">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;expression)</td></tr>
<tr class="separator:ae4bf0df298733c58db90414b97ef3e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af390ebb263b593b362a4cab8431e989e"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#af390ebb263b593b362a4cab8431e989e">operator&gt;&gt;</a> (std::istream &amp;stream, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;expression)</td></tr>
<tr class="separator:af390ebb263b593b362a4cab8431e989e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison operators</div></td></tr>
<tr class="memitem:aec0ebe7a7c159f3c127b6594b9fd34d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#aec0ebe7a7c159f3c127b6594b9fd34d2">operator==</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:aec0ebe7a7c159f3c127b6594b9fd34d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3b6d01b6938389fe5f7a6d51026e7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a8e3b6d01b6938389fe5f7a6d51026e7d">operator!=</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a8e3b6d01b6938389fe5f7a6d51026e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133df6e175eb4adca68ff82370e9fbe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a133df6e175eb4adca68ff82370e9fbe3">operator&lt;</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a133df6e175eb4adca68ff82370e9fbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab656e9d289ee3932b2700e340d552b0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ab656e9d289ee3932b2700e340d552b0b">operator&gt;</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:ab656e9d289ee3932b2700e340d552b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c7762f896bc0c0cb51e54c3915d6af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ac2c7762f896bc0c0cb51e54c3915d6af">operator&lt;=</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:ac2c7762f896bc0c0cb51e54c3915d6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff7f1660c1bf01d8b254a7e1381e7fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a7ff7f1660c1bf01d8b254a7e1381e7fe">operator&gt;=</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a7ff7f1660c1bf01d8b254a7e1381e7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Logical operators</div></td></tr>
<tr class="memitem:a4d5338f1b462a40964292a9b7d37aa44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a4d5338f1b462a40964292a9b7d37aa44">operator!</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;expression)</td></tr>
<tr class="separator:a4d5338f1b462a40964292a9b7d37aa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145415551e08d4e10d75683ccebe9e37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a145415551e08d4e10d75683ccebe9e37">operator &amp;</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a145415551e08d4e10d75683ccebe9e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a77a848266ea1158ac0fb7a0ad0181f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a9a77a848266ea1158ac0fb7a0ad0181f">operator|</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a9a77a848266ea1158ac0fb7a0ad0181f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb08eedf1aab8fa4ac80d52dd8b9f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a5cb08eedf1aab8fa4ac80d52dd8b9f88">operator^</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a5cb08eedf1aab8fa4ac80d52dd8b9f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650506d4f70b6fd7a72863a68de2a46a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a650506d4f70b6fd7a72863a68de2a46a">operator &amp;&amp;</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a650506d4f70b6fd7a72863a68de2a46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f752fd7475aee2b278ea901a6b8121a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a4f752fd7475aee2b278ea901a6b8121a">operator||</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a4f752fd7475aee2b278ea901a6b8121a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical operators</div></td></tr>
<tr class="memitem:a2b4a66bb5483046c29496a2d0176115a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a2b4a66bb5483046c29496a2d0176115a">operator+</a> (<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a2b4a66bb5483046c29496a2d0176115a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d9fd2312a4e0ee2cc4587ba55fbaf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a18d9fd2312a4e0ee2cc4587ba55fbaf9">operator-</a> (<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a18d9fd2312a4e0ee2cc4587ba55fbaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce35656c64f4d2959f14b7378eb555e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a0ce35656c64f4d2959f14b7378eb555e">operator*</a> (<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a0ce35656c64f4d2959f14b7378eb555e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d6a48ecaf77bb3ce535d50b53bc0f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ac1d6a48ecaf77bb3ce535d50b53bc0f4">operator/</a> (<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:ac1d6a48ecaf77bb3ce535d50b53bc0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05af0f673d789e3ef28728a7ae915a95"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a05af0f673d789e3ef28728a7ae915a95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a05af0f673d789e3ef28728a7ae915a95">operator+</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a05af0f673d789e3ef28728a7ae915a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bebb689f687906a02fc2f6dcf7d73e"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a08bebb689f687906a02fc2f6dcf7d73e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a08bebb689f687906a02fc2f6dcf7d73e">operator+</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classNumberType.html">NumberType</a> &amp;rhs)</td></tr>
<tr class="separator:a08bebb689f687906a02fc2f6dcf7d73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112f73c7e707cd37dae66646abc543ac"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a112f73c7e707cd37dae66646abc543ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a112f73c7e707cd37dae66646abc543ac">operator-</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a112f73c7e707cd37dae66646abc543ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba86e984e2823affc7fec6bfde82089"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a2ba86e984e2823affc7fec6bfde82089"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a2ba86e984e2823affc7fec6bfde82089">operator-</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classNumberType.html">NumberType</a> &amp;rhs)</td></tr>
<tr class="separator:a2ba86e984e2823affc7fec6bfde82089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a754edca4129fab7d2e22b59d7abae"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a85a754edca4129fab7d2e22b59d7abae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a85a754edca4129fab7d2e22b59d7abae">operator*</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a85a754edca4129fab7d2e22b59d7abae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7912b47a37c347e5b9dc5a78bb7deb"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:acf7912b47a37c347e5b9dc5a78bb7deb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#acf7912b47a37c347e5b9dc5a78bb7deb">operator*</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classNumberType.html">NumberType</a> &amp;rhs)</td></tr>
<tr class="separator:acf7912b47a37c347e5b9dc5a78bb7deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b63635e58ce342ddedf013224b583e"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa1b63635e58ce342ddedf013224b583e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#aa1b63635e58ce342ddedf013224b583e">operator/</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;lhs, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:aa1b63635e58ce342ddedf013224b583e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98150ecb3e12b1cea4106b65ff37cfe4"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a98150ecb3e12b1cea4106b65ff37cfe4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a98150ecb3e12b1cea4106b65ff37cfe4">operator/</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;lhs, const <a class="el" href="classNumberType.html">NumberType</a> &amp;rhs)</td></tr>
<tr class="separator:a98150ecb3e12b1cea4106b65ff37cfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Symbolic variable creation</div></td></tr>
<tr class="memitem:af71e229940cc126030592c5195289113"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#af71e229940cc126030592c5195289113">make_symbol</a> (const std::string &amp;symbol)</td></tr>
<tr class="separator:af71e229940cc126030592c5195289113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876041f6048705c7a8ad0855cdb1bd7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a876041f6048705c7a8ad0855cdb1bd7a">make_symbolic_function</a> (const std::string &amp;symbol, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a3851c361f9dae70bd4fa3c005ce295e0">types::symbol_vector</a> &amp;arguments)</td></tr>
<tr class="separator:a876041f6048705c7a8ad0855cdb1bd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca52d0daf28725a318c088ad5af47c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#aca52d0daf28725a318c088ad5af47c8f">make_symbolic_function</a> (const std::string &amp;symbol, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;arguments)</td></tr>
<tr class="separator:aca52d0daf28725a318c088ad5af47c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf16bdf4d5a0b48dd84496e379742426"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:acf16bdf4d5a0b48dd84496e379742426"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#acf16bdf4d5a0b48dd84496e379742426">make_vector_of_symbols</a> (const std::string &amp;symbol)</td></tr>
<tr class="separator:acf16bdf4d5a0b48dd84496e379742426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2a2f11a2a0d6d3aa773f92bea974f0"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:a2f2a2f11a2a0d6d3aa773f92bea974f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a2f2a2f11a2a0d6d3aa773f92bea974f0">make_tensor_of_symbols</a> (const std::string &amp;symbol)</td></tr>
<tr class="separator:a2f2a2f11a2a0d6d3aa773f92bea974f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97c3f1e51baf8bc4a96d563f2131e91"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:aa97c3f1e51baf8bc4a96d563f2131e91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a> (const std::string &amp;symbol)</td></tr>
<tr class="separator:aa97c3f1e51baf8bc4a96d563f2131e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfd282b55409799ef156075db8d0b3b"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a2bfd282b55409799ef156075db8d0b3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a2bfd282b55409799ef156075db8d0b3b">make_vector_of_symbolic_functions</a> (const std::string &amp;symbol, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;arguments)</td></tr>
<tr class="separator:a2bfd282b55409799ef156075db8d0b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368493d4c3226c9bbaf614b920476b9b"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:a368493d4c3226c9bbaf614b920476b9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a368493d4c3226c9bbaf614b920476b9b">make_tensor_of_symbolic_functions</a> (const std::string &amp;symbol, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;arguments)</td></tr>
<tr class="separator:a368493d4c3226c9bbaf614b920476b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7405fe0e432fb69cfb8dfbd2a2b6283d"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:a7405fe0e432fb69cfb8dfbd2a2b6283d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a7405fe0e432fb69cfb8dfbd2a2b6283d">make_symmetric_tensor_of_symbolic_functions</a> (const std::string &amp;symbol, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;arguments)</td></tr>
<tr class="separator:a7405fe0e432fb69cfb8dfbd2a2b6283d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Symbolic differentiation</div></td></tr>
<tr class="memitem:a5bb5de9e851544ae6b9a17170ab3f570"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">differentiate</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;f, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a5bb5de9e851544ae6b9a17170ab3f570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93a538c6480892ac66df149272893c2"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:ac93a538c6480892ac66df149272893c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ac93a538c6480892ac66df149272893c2">differentiate</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;f, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;T)</td></tr>
<tr class="separator:ac93a538c6480892ac66df149272893c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab10e86661304529ece5b17f379dee1"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:a0ab10e86661304529ece5b17f379dee1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a0ab10e86661304529ece5b17f379dee1">differentiate</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;f, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;S)</td></tr>
<tr class="separator:a0ab10e86661304529ece5b17f379dee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0f4c3763b9b5e4d53dd87bd65f4a89"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:a6e0f4c3763b9b5e4d53dd87bd65f4a89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a6e0f4c3763b9b5e4d53dd87bd65f4a89">differentiate</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;f, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;T)</td></tr>
<tr class="separator:a6e0f4c3763b9b5e4d53dd87bd65f4a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadceeeb5cdcf950a31c51bb855e5d257"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:aadceeeb5cdcf950a31c51bb855e5d257"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#aadceeeb5cdcf950a31c51bb855e5d257">differentiate</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;f, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;S)</td></tr>
<tr class="separator:aadceeeb5cdcf950a31c51bb855e5d257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3b1a30b1c609983ae0f191ba504cc8"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:a5d3b1a30b1c609983ae0f191ba504cc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a5d3b1a30b1c609983ae0f191ba504cc8">differentiate</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;T, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:a5d3b1a30b1c609983ae0f191ba504cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02faabf11ecdccda6a882d2e4492271"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:ac02faabf11ecdccda6a882d2e4492271"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ac02faabf11ecdccda6a882d2e4492271">differentiate</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;S, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;x)</td></tr>
<tr class="separator:ac02faabf11ecdccda6a882d2e4492271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac902fb9d64ebb96f61007b93e861a8a4"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:ac902fb9d64ebb96f61007b93e861a8a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ac902fb9d64ebb96f61007b93e861a8a4">differentiate</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;T, const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;x)</td></tr>
<tr class="separator:ac902fb9d64ebb96f61007b93e861a8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812215228c7af11a7334e29e42e77b99"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:a812215228c7af11a7334e29e42e77b99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a812215228c7af11a7334e29e42e77b99">differentiate</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;S, const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;x)</td></tr>
<tr class="separator:a812215228c7af11a7334e29e42e77b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7589166a2bc319c287c64166972f07"><td class="memTemplParams" colspan="2">template&lt;int rank_1, int rank_2, int dim&gt; </td></tr>
<tr class="memitem:a7d7589166a2bc319c287c64166972f07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a7d7589166a2bc319c287c64166972f07">differentiate</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;T1, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;T2)</td></tr>
<tr class="separator:a7d7589166a2bc319c287c64166972f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02211d5bbb95fe106f846fc7c982a776"><td class="memTemplParams" colspan="2">template&lt;int rank_1, int rank_2, int dim&gt; </td></tr>
<tr class="memitem:a02211d5bbb95fe106f846fc7c982a776"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_1+rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a02211d5bbb95fe106f846fc7c982a776">differentiate</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;S1, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;S2)</td></tr>
<tr class="separator:a02211d5bbb95fe106f846fc7c982a776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dea62bc85060b081c117fe3e10765a"><td class="memTemplParams" colspan="2">template&lt;int rank_1, int rank_2, int dim&gt; </td></tr>
<tr class="memitem:ae0dea62bc85060b081c117fe3e10765a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ae0dea62bc85060b081c117fe3e10765a">differentiate</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;T, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;S)</td></tr>
<tr class="separator:ae0dea62bc85060b081c117fe3e10765a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeead2841828227700989be04348ec74c"><td class="memTemplParams" colspan="2">template&lt;int rank_1, int rank_2, int dim&gt; </td></tr>
<tr class="memitem:aeead2841828227700989be04348ec74c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#aeead2841828227700989be04348ec74c">differentiate</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;S, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;T)</td></tr>
<tr class="separator:aeead2841828227700989be04348ec74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Symbol map creation and manipulation</div></td></tr>
<tr class="memitem:a8349584858c74f233cc2ca0151eecfad"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double, typename SymbolicType &gt; </td></tr>
<tr class="memitem:a8349584858c74f233cc2ca0151eecfad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a8349584858c74f233cc2ca0151eecfad">make_symbol_map</a> (const SymbolicType &amp;symbol)</td></tr>
<tr class="separator:a8349584858c74f233cc2ca0151eecfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d10d62b31ac6cf1768fd50486813987"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double, typename SymbolicType , typename... Args&gt; </td></tr>
<tr class="memitem:a3d10d62b31ac6cf1768fd50486813987"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a3d10d62b31ac6cf1768fd50486813987">make_symbol_map</a> (const SymbolicType &amp;symbol, const Args &amp;... other_symbols)</td></tr>
<tr class="separator:a3d10d62b31ac6cf1768fd50486813987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc4f6ff9d1bff45c3085ed9fd73aa18"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double&gt; </td></tr>
<tr class="memitem:abcc4f6ff9d1bff45c3085ed9fd73aa18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;symbol_map, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;symbol)</td></tr>
<tr class="separator:abcc4f6ff9d1bff45c3085ed9fd73aa18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6dc945fcdbc200181d868e7bb91c53"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double, typename SymbolicType , typename T  = typename std::enable_if&lt;                !std::is_base_of&lt;Expression, SymbolicType&gt;::value &amp;&amp;                ::internal::is_explicitly_convertible&lt;                  SymbolicType,                  const SymEngine::RCP&lt;const SymEngine::Basic&gt; &amp;&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:afc6dc945fcdbc200181d868e7bb91c53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#afc6dc945fcdbc200181d868e7bb91c53">add_to_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;symbol_map, const SymbolicType &amp;symbol)</td></tr>
<tr class="separator:afc6dc945fcdbc200181d868e7bb91c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd651d7c88f4d42cfbca60da549cb3f"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double, typename SymbolicType &gt; </td></tr>
<tr class="memitem:a6fd651d7c88f4d42cfbca60da549cb3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a6fd651d7c88f4d42cfbca60da549cb3f">add_to_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;symbol_map, const std::vector&lt; SymbolicType &gt; &amp;symbols)</td></tr>
<tr class="separator:a6fd651d7c88f4d42cfbca60da549cb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e00bfd0783385c0c431fef59346c3c"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double&gt; </td></tr>
<tr class="memitem:aa8e00bfd0783385c0c431fef59346c3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#aa8e00bfd0783385c0c431fef59346c3c">add_to_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;symbol_map, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;other_symbols)</td></tr>
<tr class="separator:aa8e00bfd0783385c0c431fef59346c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0649a36b9b18c401a0b535bb67868ed9"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double, typename SymbolicType , typename... Args&gt; </td></tr>
<tr class="memitem:a0649a36b9b18c401a0b535bb67868ed9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a0649a36b9b18c401a0b535bb67868ed9">add_to_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;symbol_map, const SymbolicType &amp;symbol, const Args &amp;... other_symbols)</td></tr>
<tr class="separator:a0649a36b9b18c401a0b535bb67868ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b1e479cf204c054932042095d31962"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ab0b1e479cf204c054932042095d31962">set_value_in_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;symbol, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;value)</td></tr>
<tr class="separator:ab0b1e479cf204c054932042095d31962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc58b401c4f2040eb58ee6433c7a8673"><td class="memTemplParams" colspan="2">template&lt;typename SymbolicType , typename ValueType , typename T  = typename std::enable_if&lt;                ::internal::is_explicitly_convertible&lt;                  SymbolicType,                  const SymEngine::RCP&lt;const SymEngine::Basic&gt; &amp;&gt;::value &amp;&amp;                std::is_constructible&lt;SymbolicType, ValueType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:acc58b401c4f2040eb58ee6433c7a8673"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#acc58b401c4f2040eb58ee6433c7a8673">set_value_in_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const SymbolicType &amp;symbol, const ValueType &amp;value)</td></tr>
<tr class="separator:acc58b401c4f2040eb58ee6433c7a8673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f79d80b7a6d1b1634271eb2ed5fcd68"><td class="memTemplParams" colspan="2">template&lt;typename SymbolicType , typename ValueType &gt; </td></tr>
<tr class="memitem:a2f79d80b7a6d1b1634271eb2ed5fcd68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a2f79d80b7a6d1b1634271eb2ed5fcd68">set_value_in_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const std::vector&lt; SymbolicType &gt; &amp;symbols, const std::vector&lt; ValueType &gt; &amp;values)</td></tr>
<tr class="separator:a2f79d80b7a6d1b1634271eb2ed5fcd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac839dc6fb678b16f65e963cdbbc4e6fa"><td class="memTemplParams" colspan="2">template&lt;typename SymbolicType , typename ValueType &gt; </td></tr>
<tr class="memitem:ac839dc6fb678b16f65e963cdbbc4e6fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ac839dc6fb678b16f65e963cdbbc4e6fa">set_value_in_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const std::pair&lt; SymbolicType, ValueType &gt; &amp;symbol_value)</td></tr>
<tr class="separator:ac839dc6fb678b16f65e963cdbbc4e6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a63033798b01c018314eb2699f356ce"><td class="memTemplParams" colspan="2">template&lt;typename SymbolicType , typename ValueType , typename... Args&gt; </td></tr>
<tr class="memitem:a4a63033798b01c018314eb2699f356ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a4a63033798b01c018314eb2699f356ce">set_value_in_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const std::pair&lt; SymbolicType, ValueType &gt; &amp;symbol_value, const Args &amp;... other_symbol_values)</td></tr>
<tr class="separator:a4a63033798b01c018314eb2699f356ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dff7cf6f0d7d19622837c258ba9817f"><td class="memTemplParams" colspan="2">template&lt;typename SymbolicType , typename ValueType &gt; </td></tr>
<tr class="memitem:a4dff7cf6f0d7d19622837c258ba9817f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a4dff7cf6f0d7d19622837c258ba9817f">set_value_in_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const std::vector&lt; std::pair&lt; SymbolicType, ValueType &gt;&gt; &amp;symbol_values)</td></tr>
<tr class="separator:a4dff7cf6f0d7d19622837c258ba9817f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab771f82adc3a0b146902aea99155d1bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ab771f82adc3a0b146902aea99155d1bf">set_value_in_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;symbol_values)</td></tr>
<tr class="separator:ab771f82adc3a0b146902aea99155d1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be6f297bb4c44760876b1788bce798b"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double, int rank, int dim, typename SymbolicType &gt; </td></tr>
<tr class="memitem:a8be6f297bb4c44760876b1788bce798b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a8be6f297bb4c44760876b1788bce798b">add_to_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;symbol_map, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, SymbolicType &gt; &amp;symbol_tensor)</td></tr>
<tr class="separator:a8be6f297bb4c44760876b1788bce798b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759b65e70890f3516bb5f9a45bbf407c"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double, int rank, int dim, typename SymbolicType &gt; </td></tr>
<tr class="memitem:a759b65e70890f3516bb5f9a45bbf407c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a759b65e70890f3516bb5f9a45bbf407c">add_to_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;symbol_map, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, SymbolicType &gt; &amp;symbol_tensor)</td></tr>
<tr class="separator:a759b65e70890f3516bb5f9a45bbf407c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa621416986e5d7eddc310002ebeacb"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename SymbolicType , typename ValueType &gt; </td></tr>
<tr class="memitem:abaa621416986e5d7eddc310002ebeacb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#abaa621416986e5d7eddc310002ebeacb">set_value_in_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, SymbolicType &gt; &amp;symbol_tensor, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, ValueType &gt; &amp;value_tensor)</td></tr>
<tr class="separator:abaa621416986e5d7eddc310002ebeacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcb3a9c34ab9417de2284ee19c54ff4"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename SymbolicType , typename ValueType &gt; </td></tr>
<tr class="memitem:abfcb3a9c34ab9417de2284ee19c54ff4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#abfcb3a9c34ab9417de2284ee19c54ff4">set_value_in_symbol_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, SymbolicType &gt; &amp;symbol_tensor, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, ValueType &gt; &amp;value_tensor)</td></tr>
<tr class="separator:abfcb3a9c34ab9417de2284ee19c54ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Symbol substitution map creation</div></td></tr>
<tr class="memitem:aecd8502f0296caba06f86c06bc449e51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;symbol, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;value)</td></tr>
<tr class="separator:aecd8502f0296caba06f86c06bc449e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c0ecc04f2bc13fbe1922457b04c7fe"><td class="memTemplParams" colspan="2">template&lt;typename ExpressionType , typename ValueType , typename T  = typename std::enable_if&lt;                ::internal::is_explicitly_convertible&lt;                  ExpressionType,                  const SymEngine::RCP&lt;const SymEngine::Basic&gt; &amp;&gt;::value &amp;&amp;                std::is_constructible&lt;ExpressionType, ValueType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a11c0ecc04f2bc13fbe1922457b04c7fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a11c0ecc04f2bc13fbe1922457b04c7fe">make_substitution_map</a> (const ExpressionType &amp;symbol, const ValueType &amp;value)</td></tr>
<tr class="separator:a11c0ecc04f2bc13fbe1922457b04c7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3212bdb3135c7fa3bf045e5403dabab1"><td class="memTemplParams" colspan="2">template&lt;typename ExpressionType , typename ValueType &gt; </td></tr>
<tr class="memitem:a3212bdb3135c7fa3bf045e5403dabab1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a3212bdb3135c7fa3bf045e5403dabab1">make_substitution_map</a> (const std::vector&lt; ExpressionType &gt; &amp;symbols, const std::vector&lt; ValueType &gt; &amp;values)</td></tr>
<tr class="separator:a3212bdb3135c7fa3bf045e5403dabab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7c5d9560b091512182a57e4c1eda30"><td class="memTemplParams" colspan="2">template&lt;typename ExpressionType , typename ValueType &gt; </td></tr>
<tr class="memitem:a6d7c5d9560b091512182a57e4c1eda30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a6d7c5d9560b091512182a57e4c1eda30">make_substitution_map</a> (const std::pair&lt; ExpressionType, ValueType &gt; &amp;symbol_value)</td></tr>
<tr class="separator:a6d7c5d9560b091512182a57e4c1eda30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64061c41c44b39b5e3375261c655672"><td class="memTemplParams" colspan="2">template&lt;typename ExpressionType , typename ValueType &gt; </td></tr>
<tr class="memitem:ac64061c41c44b39b5e3375261c655672"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ac64061c41c44b39b5e3375261c655672">make_substitution_map</a> (const std::vector&lt; std::pair&lt; ExpressionType, ValueType &gt;&gt; &amp;symbol_values)</td></tr>
<tr class="separator:ac64061c41c44b39b5e3375261c655672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305cfc857540b0ad7af4c12652ac6dce"><td class="memTemplParams" colspan="2">template&lt;typename ExpressionType , typename ValueType , typename... Args&gt; </td></tr>
<tr class="memitem:a305cfc857540b0ad7af4c12652ac6dce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a305cfc857540b0ad7af4c12652ac6dce">make_substitution_map</a> (const std::pair&lt; ExpressionType, ValueType &gt; &amp;symbol_value, const Args &amp;... other_symbol_values)</td></tr>
<tr class="separator:a305cfc857540b0ad7af4c12652ac6dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b13952c3d09aa1ae79ff8eab3773da7"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename ExpressionType , typename ValueType &gt; </td></tr>
<tr class="memitem:a7b13952c3d09aa1ae79ff8eab3773da7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a7b13952c3d09aa1ae79ff8eab3773da7">make_substitution_map</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, ExpressionType &gt; &amp;symbol_tensor, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, ValueType &gt; &amp;value_tensor)</td></tr>
<tr class="separator:a7b13952c3d09aa1ae79ff8eab3773da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2544f3556e6ceb1b19ce884908684990"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename ExpressionType , typename ValueType &gt; </td></tr>
<tr class="memitem:a2544f3556e6ceb1b19ce884908684990"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a2544f3556e6ceb1b19ce884908684990">make_substitution_map</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, ExpressionType &gt; &amp;symbol_tensor, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, ValueType &gt; &amp;value_tensor)</td></tr>
<tr class="separator:a2544f3556e6ceb1b19ce884908684990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Symbol substitution map enlargement</div></td></tr>
<tr class="memitem:ad0b015b556ca354a241a3b7f8e3a8248"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false&gt; </td></tr>
<tr class="memitem:ad0b015b556ca354a241a3b7f8e3a8248"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ad0b015b556ca354a241a3b7f8e3a8248">add_to_substitution_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;symbol, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;value)</td></tr>
<tr class="separator:ad0b015b556ca354a241a3b7f8e3a8248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3f4cfdae943581997ba68f1cbf8911"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, typename ExpressionType , typename ValueType , typename  = typename std::enable_if&lt;                ::internal::is_explicitly_convertible&lt;                  ExpressionType,                  const SymEngine::RCP&lt;const SymEngine::Basic&gt; &amp;&gt;::value &amp;&amp;                std::is_constructible&lt;ExpressionType, ValueType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a9d3f4cfdae943581997ba68f1cbf8911"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a9d3f4cfdae943581997ba68f1cbf8911">add_to_substitution_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const ExpressionType &amp;symbol, const ValueType &amp;value)</td></tr>
<tr class="separator:a9d3f4cfdae943581997ba68f1cbf8911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80e6c4720516092d4f5106ef28f1be1"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, typename ExpressionType , typename ValueType , typename  = typename std::enable_if&lt;                ::internal::is_explicitly_convertible&lt;                  ExpressionType,                  const SymEngine::RCP&lt;const SymEngine::Basic&gt; &amp;&gt;::value &amp;&amp;                std::is_constructible&lt;ExpressionType, ValueType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ab80e6c4720516092d4f5106ef28f1be1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ab80e6c4720516092d4f5106ef28f1be1">add_to_substitution_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const std::vector&lt; ExpressionType &gt; &amp;symbols, const std::vector&lt; ValueType &gt; &amp;values)</td></tr>
<tr class="separator:ab80e6c4720516092d4f5106ef28f1be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9f91f997c57f7c99ea56861b47288b"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false&gt; </td></tr>
<tr class="memitem:acc9f91f997c57f7c99ea56861b47288b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#acc9f91f997c57f7c99ea56861b47288b">add_to_substitution_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;symbol_values)</td></tr>
<tr class="separator:acc9f91f997c57f7c99ea56861b47288b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d37dc642ad6457ea2b4e3985ef8a94"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, typename ExpressionType , typename ValueType &gt; </td></tr>
<tr class="memitem:a05d37dc642ad6457ea2b4e3985ef8a94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a05d37dc642ad6457ea2b4e3985ef8a94">add_to_substitution_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const std::pair&lt; ExpressionType, ValueType &gt; &amp;symbol_value)</td></tr>
<tr class="separator:a05d37dc642ad6457ea2b4e3985ef8a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e9bcd3273f551163cc4adfd07ecc02"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, typename ExpressionType , typename ValueType &gt; </td></tr>
<tr class="memitem:a13e9bcd3273f551163cc4adfd07ecc02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a13e9bcd3273f551163cc4adfd07ecc02">add_to_substitution_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const std::vector&lt; std::pair&lt; ExpressionType, ValueType &gt;&gt; &amp;symbol_values)</td></tr>
<tr class="separator:a13e9bcd3273f551163cc4adfd07ecc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e3232db3c76af854a36b4a31ecf6fe"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, typename ExpressionType , typename ValueType , typename... Args&gt; </td></tr>
<tr class="memitem:ad1e3232db3c76af854a36b4a31ecf6fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ad1e3232db3c76af854a36b4a31ecf6fe">add_to_substitution_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const std::pair&lt; ExpressionType, ValueType &gt; &amp;symbol_value, const Args &amp;... other_symbol_values)</td></tr>
<tr class="separator:ad1e3232db3c76af854a36b4a31ecf6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5ba04d787e659f4b72565d82da814f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a2a5ba04d787e659f4b72565d82da814f">merge_substitution_maps</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map_out, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map_in)</td></tr>
<tr class="separator:a2a5ba04d787e659f4b72565d82da814f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a14780a49d970f6a8c9f43c4cf0628a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4a14780a49d970f6a8c9f43c4cf0628a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a4a14780a49d970f6a8c9f43c4cf0628a">merge_substitution_maps</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map_out, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map_in, const Args &amp;... other_substitution_maps_in)</td></tr>
<tr class="separator:a4a14780a49d970f6a8c9f43c4cf0628a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb976c7a9a19d1d86c4ff95a0ffab6f4"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:afb976c7a9a19d1d86c4ff95a0ffab6f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#afb976c7a9a19d1d86c4ff95a0ffab6f4">merge_substitution_maps</a> (const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map_in, const Args &amp;... other_substitution_maps_in)</td></tr>
<tr class="separator:afb976c7a9a19d1d86c4ff95a0ffab6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af7c430740ad0e2d879f2a3ffe810b2"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, int rank, int dim, typename ExpressionType , typename ValueType &gt; </td></tr>
<tr class="memitem:a9af7c430740ad0e2d879f2a3ffe810b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a9af7c430740ad0e2d879f2a3ffe810b2">add_to_substitution_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, ExpressionType &gt; &amp;symbol_tensor, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, ValueType &gt; &amp;value_tensor)</td></tr>
<tr class="separator:a9af7c430740ad0e2d879f2a3ffe810b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb4e8ce590dd97be2c5b01fad15d47f"><td class="memTemplParams" colspan="2">template&lt;bool ignore_invalid_symbols = false, int rank, int dim, typename ExpressionType , typename ValueType &gt; </td></tr>
<tr class="memitem:a1bb4e8ce590dd97be2c5b01fad15d47f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a1bb4e8ce590dd97be2c5b01fad15d47f">add_to_substitution_map</a> (<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, ExpressionType &gt; &amp;symbol_tensor, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, ValueType &gt; &amp;value_tensor)</td></tr>
<tr class="separator:a1bb4e8ce590dd97be2c5b01fad15d47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Symbol substitution and evaluation</div></td></tr>
<tr class="memitem:ad978861d8e1b008dae23cf8c99d82c13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ad978861d8e1b008dae23cf8c99d82c13">resolve_explicit_dependencies</a> (const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map, const <a class="el" href="classbool.html">bool</a> force_cyclic_dependency_resolution=false)</td></tr>
<tr class="separator:ad978861d8e1b008dae23cf8c99d82c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36339a4b0cde7f6ea62756c9851458db"><td class="memTemplParams" colspan="2">template&lt;typename ExpressionType , typename ValueType &gt; </td></tr>
<tr class="memitem:a36339a4b0cde7f6ea62756c9851458db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a36339a4b0cde7f6ea62756c9851458db">resolve_explicit_dependencies</a> (const std::vector&lt; std::pair&lt; ExpressionType, ValueType &gt;&gt; &amp;symbol_values, const <a class="el" href="classbool.html">bool</a> force_cyclic_dependency_resolution=false)</td></tr>
<tr class="separator:a36339a4b0cde7f6ea62756c9851458db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee79451c8fcfef0b37efbedd461756a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">substitute</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;expression, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map)</td></tr>
<tr class="separator:adee79451c8fcfef0b37efbedd461756a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fa25740f0fedca16330bb0046aff45"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a72fa25740f0fedca16330bb0046aff45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a72fa25740f0fedca16330bb0046aff45">substitute</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;expression, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;symbol, const ValueType &amp;value)</td></tr>
<tr class="separator:a72fa25740f0fedca16330bb0046aff45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ac6f9b4e7aa798c6efbb7964621e6c"><td class="memTemplParams" colspan="2">template&lt;typename ExpressionType , typename... Args&gt; </td></tr>
<tr class="memitem:a62ac6f9b4e7aa798c6efbb7964621e6c"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a62ac6f9b4e7aa798c6efbb7964621e6c">substitute</a> (const ExpressionType &amp;expression, const Args &amp;... symbol_values)</td></tr>
<tr class="separator:a62ac6f9b4e7aa798c6efbb7964621e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e50a66591b18a5b0df49603edcdfaca"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a6e50a66591b18a5b0df49603edcdfaca"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a6e50a66591b18a5b0df49603edcdfaca">substitute_and_evaluate</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;expression, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map)</td></tr>
<tr class="separator:a6e50a66591b18a5b0df49603edcdfaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabf0ce15f1ed9386272796e33266ed1"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename... Args&gt; </td></tr>
<tr class="memitem:acabf0ce15f1ed9386272796e33266ed1"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#acabf0ce15f1ed9386272796e33266ed1">substitute_and_evaluate</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;expression, const Args &amp;... symbol_values)</td></tr>
<tr class="separator:acabf0ce15f1ed9386272796e33266ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab297853eae55534a38638f7887348652"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:ab297853eae55534a38638f7887348652"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ab297853eae55534a38638f7887348652">substitute</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;expression_tensor, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map)</td></tr>
<tr class="separator:ab297853eae55534a38638f7887348652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc22550a817b46e0fb20ed207859aef3"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim&gt; </td></tr>
<tr class="memitem:abc22550a817b46e0fb20ed207859aef3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#abc22550a817b46e0fb20ed207859aef3">substitute</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;expression_tensor, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map)</td></tr>
<tr class="separator:abc22550a817b46e0fb20ed207859aef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410764be28925140b4345993acb40312"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , int rank, int dim&gt; </td></tr>
<tr class="memitem:a410764be28925140b4345993acb40312"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#a410764be28925140b4345993acb40312">substitute_and_evaluate</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;expression_tensor, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map)</td></tr>
<tr class="separator:a410764be28925140b4345993acb40312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7473afda8f91d4bc41b8d5d3a713f97"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , int rank, int dim&gt; </td></tr>
<tr class="memitem:ae7473afda8f91d4bc41b8d5d3a713f97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDifferentiation_1_1SD.html#ae7473afda8f91d4bc41b8d5d3a713f97">substitute_and_evaluate</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;expression_tensor, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_map)</td></tr>
<tr class="separator:ae7473afda8f91d4bc41b8d5d3a713f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>符号微分库的封装器。目前对以下库的支持。</p>
<ul>
<li>SymEngine </li>
</ul>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a841a7b84dc17bf2ba675522093a97e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841a7b84dc17bf2ba675522093a97e8b">&#9670;&nbsp;</a></span>OptimizerType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An enumeration to distinguish between different optimization methods that can be used by SymEngine to more rapidly evaluate complex symbolic expressions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a841a7b84dc17bf2ba675522093a97e8baabc20d7bde1df257f890e152af2e3470"></a>dictionary&#160;</td><td class="fielddoc"><p>Use dictionary substitution. This is SymEngine's default method. </p>
</td></tr>
<tr><td class="fieldname"><a id="a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c"></a>lambda&#160;</td><td class="fielddoc"><p>Convert the symbolic expression into a collection of <code>std::function</code>s. </p>
</td></tr>
<tr><td class="fieldname"><a id="a841a7b84dc17bf2ba675522093a97e8ba7c7d2b9e8389cc541dc5a615e05bcf1e"></a>llvm&#160;</td><td class="fielddoc"><p>Use the LLVM JIT compiler to compile the expression into an aggressively optimized, stand-alone function. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="symengine__optimizer_8h_source.html#l00099">99</a> of file <a class="el" href="symengine__optimizer_8h_source.html">symengine_optimizer.h</a>.</p>

</div>
</div>
<a id="af920b6488de218dea94f25b94ad08842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af920b6488de218dea94f25b94ad08842">&#9670;&nbsp;</a></span>OptimizationFlags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An enumeration to specify which special techniques, over and above those used with the chosen OptimizerType, to be applied to the set of expressions that are to be optimized. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af920b6488de218dea94f25b94ad08842abea01b791a14888764e22d110f6ea97f"></a>optimize_default&#160;</td><td class="fielddoc"><p>No additional optimization. </p>
</td></tr>
<tr><td class="fieldname"><a id="af920b6488de218dea94f25b94ad08842a3df84265620315a025367510c90d0474"></a>optimize_cse&#160;</td><td class="fielddoc"><p>Apply common subexpresson elimination. </p>
</td></tr>
<tr><td class="fieldname"><a id="af920b6488de218dea94f25b94ad08842af08a168a64482d29e6ce023ab222a083"></a>optimize_aggressive&#160;</td><td class="fielddoc"><p>Employ aggressive optimizations when compiling with the LLVM JIT compiler. </p>
</td></tr>
<tr><td class="fieldname"><a id="af920b6488de218dea94f25b94ad08842a1ad0cce13bc606ad6742e9841ccdfe15"></a>optimize_all&#160;</td><td class="fielddoc"><p>Apply all possible optimizations. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="symengine__optimizer_8h_source.html#l00145">145</a> of file <a class="el" href="symengine__optimizer_8h_source.html">symengine_optimizer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa19e4a591917e9af8587ab37433d4f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19e4a591917e9af8587ab37433d4f24">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents a <code>base</code> value raised to the power of an <code>exponent</code>.</p>
<p>Mimics the function <code> std::pow(base,exponent) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00042">42</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a393ea06695141ece7a0fa0a641ea8c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393ea06695141ece7a0fa0a641ea8c4e">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents a <code>base</code> value raised to the power of an <code>exponent</code>.</p>
<p>Mimics the function <code> std::pow(base,exponent) </code> using the standard math library.</p>
<p>This variant is used when the <code>exponent</code> is not a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8h_source.html#l00074">74</a> of file <a class="el" href="symengine__math_8h_source.html">symengine_math.h</a>.</p>

</div>
</div>
<a id="abc1f0adc1684eb37d093630ddd16018a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1f0adc1684eb37d093630ddd16018a">&#9670;&nbsp;</a></span>pow() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents a <code>base</code> value raised to the power of an <code>exponent</code>.</p>
<p>Mimics the function <code> std::pow(base,exponent) </code> using the standard math library.</p>
<p>This variant is used when the <code>base</code> is not a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8h_source.html#l00093">93</a> of file <a class="el" href="symengine__math_8h_source.html">symengine_math.h</a>.</p>

</div>
</div>
<a id="ae38c1aa2dfee8cc43920ef787d8bb393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38c1aa2dfee8cc43920ef787d8bb393">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the square root of some value <code>x</code>.</p>
<p>Mimics the function <code> std::sqrt(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00049">49</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a0a9eaf1827ea15d79f9cbad4e9e5425a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9eaf1827ea15d79f9cbad4e9e5425a">&#9670;&nbsp;</a></span>cbrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::cbrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the cubic root of some value <code>x</code>.</p>
<p>Mimics the function <code> std::cbrt(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00056">56</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a964895bdb3715db4878051afcbfdc1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964895bdb3715db4878051afcbfdc1fc">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>exponent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the Euler constant \(e \approx 2.71828\) raised to the given <code>exponent</code>.</p>
<p>Mimics the function <code> std::exp(exponent) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00063">63</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="ae35f613ffd73c1fc8e7806a4eef5579f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35f613ffd73c1fc8e7806a4eef5579f">&#9670;&nbsp;</a></span>log() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the natural logarithm of a value <code>x</code>.</p>
<p>Mimics the function <code> std::log(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00070">70</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="ae073f52ff1d01c63ffeff65a0f29eba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae073f52ff1d01c63ffeff65a0f29eba5">&#9670;&nbsp;</a></span>log() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the logarithm of a value <code>x</code> taken with respect to a <code>base</code> number.</p>
<p>Mimics the function <code> std::log(x,base) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00077">77</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="ae5eed58b71444c88a5a771665db3425c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5eed58b71444c88a5a771665db3425c">&#9670;&nbsp;</a></span>log() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the logarithm of a value <code>x</code> taken with respect to a <code>base</code> number.</p>
<p>Mimics the function <code> std::log(x,base) </code> using the standard math library.</p>
<p>This variant is used when the <code>base</code> is not a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8h_source.html#l00159">159</a> of file <a class="el" href="symengine__math_8h_source.html">symengine_math.h</a>.</p>

</div>
</div>
<a id="a30141949c304081e9b2f2f8f9e312634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30141949c304081e9b2f2f8f9e312634">&#9670;&nbsp;</a></span>log() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the logarithm of a value <code>x</code> taken with respect to a <code>base</code> number.</p>
<p>Mimics the function <code> std::log(x,base) </code> using the standard math library.</p>
<p>This variant is used when the <code>value</code> is not a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8h_source.html#l00178">178</a> of file <a class="el" href="symengine__math_8h_source.html">symengine_math.h</a>.</p>

</div>
</div>
<a id="af3073c01113bca5a5e9a1b921643ced4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3073c01113bca5a5e9a1b921643ced4">&#9670;&nbsp;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::log10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the base 10 logarithm of a value <code>x</code>.</p>
<p>Mimics the function <code> std::log10(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00084">84</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a907a3cabd7c1f251cc252ba5c9dd2c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907a3cabd7c1f251cc252ba5c9dd2c25">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the sine function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> std::sin(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00091">91</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="acd32c4b25ea499572dc34bcddf03c19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd32c4b25ea499572dc34bcddf03c19b">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the cosine function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> std::cos(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00098">98</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="ab202ef14f4d632f420dc24507376d510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab202ef14f4d632f420dc24507376d510">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the tangent function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> std::tan(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00105">105</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a2da29a575519932d784e5240a6ae3a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da29a575519932d784e5240a6ae3a0a">&#9670;&nbsp;</a></span>csc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::csc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the cosecant function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> 1.0/std::sin(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00112">112</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a775d2e774698e280712d757c235f3edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775d2e774698e280712d757c235f3edd">&#9670;&nbsp;</a></span>sec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::sec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the secant function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> 1.0/std::cos(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00119">119</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="aca69936502b36a4aaf75cc89e95bac83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca69936502b36a4aaf75cc89e95bac83">&#9670;&nbsp;</a></span>cot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::cot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the cotangent function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> 1.0/std::tan(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00126">126</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a17229421811a17b2eb6145fe0f933ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17229421811a17b2eb6145fe0f933ec2">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the inverse sine function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> std::asin(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00133">133</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="aafbf69ffef5e5d013fc0be51d1cd88a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbf69ffef5e5d013fc0be51d1cd88a6">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the inverse cosine function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> std::acos(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00140">140</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a803fcea270d7a523a91e3b7c173059f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803fcea270d7a523a91e3b7c173059f9">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the inverse tangent function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> std::atan(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00147">147</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a130b20f2ea3522f1d123c75c63c0f67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130b20f2ea3522f1d123c75c63c0f67d">&#9670;&nbsp;</a></span>atan2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the inverse tangent function with the given arguments <code>x</code> and <code>y</code>.</p>
<p>Mimics the function <code> std::atan2(y,x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00154">154</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a8faa3876e48efe1ead0794617005979b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8faa3876e48efe1ead0794617005979b">&#9670;&nbsp;</a></span>atan2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the inverse tangent function with the given arguments <code>x</code> and <code>y</code>.</p>
<p>Mimics the function <code> std::atan2(y,x) </code> using the standard math library.</p>
<p>This variant is used when the numerator <code>y</code> is not a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8h_source.html#l00318">318</a> of file <a class="el" href="symengine__math_8h_source.html">symengine_math.h</a>.</p>

</div>
</div>
<a id="a3ecc3ac2de140bf35128149051a4c140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecc3ac2de140bf35128149051a4c140">&#9670;&nbsp;</a></span>atan2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the inverse tangent function with the given arguments <code>x</code> and <code>y</code>.</p>
<p>Mimics the function <code> std::atan2(y,x) </code> using the standard math library.</p>
<p>This variant is used when the denominator <code>x</code> is not a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8h_source.html#l00338">338</a> of file <a class="el" href="symengine__math_8h_source.html">symengine_math.h</a>.</p>

</div>
</div>
<a id="a8e663074348927c6757e45775873bc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e663074348927c6757e45775873bc1a">&#9670;&nbsp;</a></span>acsc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::acsc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the inverse cosecant function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> 1.0/std::asin(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00161">161</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="ac9d4063ff04a88f4201dc50dcdd7641c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d4063ff04a88f4201dc50dcdd7641c">&#9670;&nbsp;</a></span>asec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::asec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the inverse secant function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> 1.0/std::acos(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00168">168</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="adc744518dd554265fe610247958e7be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc744518dd554265fe610247958e7be2">&#9670;&nbsp;</a></span>acot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::acot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the inverse cotangent function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> 1.0/std::atan(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00175">175</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a766e4d9bbfe24e99245081947db6a0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766e4d9bbfe24e99245081947db6a0c7">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the hyperbolic sine function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> std::sinh(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00182">182</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a26c1f7a69dc8ac2e16144493d3b3b896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c1f7a69dc8ac2e16144493d3b3b896">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the hyperbolic cosine function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> std::cosh(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00189">189</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a86151e4842702eb0b667b22122df4597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86151e4842702eb0b667b22122df4597">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the hyperbolic tangent function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> std::tanh(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00196">196</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="ab00f97e0273fefbafef4865f97213d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00f97e0273fefbafef4865f97213d8b">&#9670;&nbsp;</a></span>csch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::csch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the hyperbolic cosecant function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> 1.0/std::sinh(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00203">203</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="aa9d7349600d504401a36f33f0dabd908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d7349600d504401a36f33f0dabd908">&#9670;&nbsp;</a></span>sech()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::sech </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the hyperbolic secant function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> 1.0/std::cosh(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00210">210</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a66e76f1c4fdb9a31f4fabef8abee5f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e76f1c4fdb9a31f4fabef8abee5f28">&#9670;&nbsp;</a></span>coth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::coth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the hyperbolic cotangent function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> 1.0/std::tanh(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00217">217</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a1fb4eb9452e084d3c9128ea5fc25720b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb4eb9452e084d3c9128ea5fc25720b">&#9670;&nbsp;</a></span>asinh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::asinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the inverse hyperbolic sine function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> std::asinh(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00224">224</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="ab51a65b3c0995d2eb36c7c2e818c2349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51a65b3c0995d2eb36c7c2e818c2349">&#9670;&nbsp;</a></span>acosh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::acosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the inverse hyperbolic cosine function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> std::acosh(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00231">231</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a0d6d5136ba07cf1ca9eca4cbff740e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6d5136ba07cf1ca9eca4cbff740e15">&#9670;&nbsp;</a></span>atanh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::atanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the inverse hyperbolic tangent function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> std::atanh(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00238">238</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a3f0e9c2926bf4359ec2effc24f20b4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0e9c2926bf4359ec2effc24f20b4e9">&#9670;&nbsp;</a></span>acsch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::acsch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the inverse hyperbolic cosecant function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> 1.0/std::asin(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00245">245</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a9ba0a6e67e1f4c1241d9924b791c9dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba0a6e67e1f4c1241d9924b791c9dd6">&#9670;&nbsp;</a></span>asech()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::asech </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the inverse hyperbolic secant function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> 1.0/std::acos(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00252">252</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="ad2949feffc15a59e204cbeafd55bfdd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2949feffc15a59e204cbeafd55bfdd0">&#9670;&nbsp;</a></span>acoth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::acoth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the inverse hyperbolic cotangent function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> 1.0/std::atan(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00259">259</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a3f3a70440b123a1f1e8c5b879c1c2c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3a70440b123a1f1e8c5b879c1c2c39">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the absolute value of value <code>x</code>.</p>
<p>Mimics the function <code> std::abs(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00266">266</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a592560ee80355620422a86087f11b9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592560ee80355620422a86087f11b9df">&#9670;&nbsp;</a></span>fabs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::fabs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the absolute value of value <code>x</code>.</p>
<p>Mimics the function <code> std::fabs(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00273">273</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="aa55d50a1ffa79c27f9bd9ea104f15158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55d50a1ffa79c27f9bd9ea104f15158">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::sign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the sign of value <code>x</code>.</p>
<p>Although there is no such function in the standard library, it mimics the function <code> boost::sign(x) </code> using the boost math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00280">280</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="afb732411693d0e4711ca3a17792a505d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb732411693d0e4711ca3a17792a505d">&#9670;&nbsp;</a></span>copysign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::copysign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>sign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the <code>value</code> of the first argument that takes the <code>sign</code> of the second argument.</p>
<p>Mimics the function <code> std::copysign(value, sign) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00287">287</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a860b730b2531e8c9adafc3e7bd7343fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860b730b2531e8c9adafc3e7bd7343fa">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the floor of value <code>x</code>.</p>
<p>Mimics the function <code> std::floor(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00294">294</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a6545410ba18556ebf7c478b6ad9939f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6545410ba18556ebf7c478b6ad9939f6">&#9670;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the ceiling of value <code>x</code>.</p>
<p>Mimics the function <code> std::ceil(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00301">301</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a922568e7a10acd3078e67b49712c60ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922568e7a10acd3078e67b49712c60ca">&#9670;&nbsp;</a></span>max() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the maximum of two values <code>a</code> and <code>b</code>.</p>
<p>Mimics the function <code> std::max(a,b) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00308">308</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a357402260ddae0b720e381b38988f87a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357402260ddae0b720e381b38988f87a">&#9670;&nbsp;</a></span>max() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the maximum of two values <code>a</code> and <code>b</code>.</p>
<p>Mimics the function <code> std::max(a,b) </code> using the standard math library.</p>
<p>This variant is used when <code>b</code> is not a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8h_source.html#l00607">607</a> of file <a class="el" href="symengine__math_8h_source.html">symengine_math.h</a>.</p>

</div>
</div>
<a id="a3d888bdb03ec44c097789f03164a484b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d888bdb03ec44c097789f03164a484b">&#9670;&nbsp;</a></span>max() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the maximum of two values <code>a</code> and <code>b</code>.</p>
<p>Mimics the function <code> std::max(a,b) </code> using the standard math library.</p>
<p>This variant is used when <code>a</code> is not a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8h_source.html#l00626">626</a> of file <a class="el" href="symengine__math_8h_source.html">symengine_math.h</a>.</p>

</div>
</div>
<a id="ac2452236ed5f1ed06a3c52cd8dd6598e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2452236ed5f1ed06a3c52cd8dd6598e">&#9670;&nbsp;</a></span>min() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the minimum of two values <code>a</code> and <code>b</code>.</p>
<p>Mimics the function <code> std::min(a,b) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00315">315</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="acbb936a268a242e7ac15184bf7fa99a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb936a268a242e7ac15184bf7fa99a5">&#9670;&nbsp;</a></span>min() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the minimum of two values <code>a</code> and <code>b</code>.</p>
<p>Mimics the function <code> std::min(a,b) </code> using the standard math library.</p>
<p>This variant is used when <code>b</code> is not a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8h_source.html#l00655">655</a> of file <a class="el" href="symengine__math_8h_source.html">symengine_math.h</a>.</p>

</div>
</div>
<a id="a2fc2615d0f2b4fb3a29ed88565d965ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc2615d0f2b4fb3a29ed88565d965ca">&#9670;&nbsp;</a></span>min() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                !std::is_same&lt;NumberType, Expression&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents the minimum of two values <code>a</code> and <code>b</code>.</p>
<p>Mimics the function <code> std::min(a,b) </code> using the standard math library.</p>
<p>This variant is used when <code>a</code> is not a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8h_source.html#l00674">674</a> of file <a class="el" href="symengine__math_8h_source.html">symengine_math.h</a>.</p>

</div>
</div>
<a id="ad2761bd9ab104a1a1852b7e6d54d986f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2761bd9ab104a1a1852b7e6d54d986f">&#9670;&nbsp;</a></span>erf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::erf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents error function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> std::erf(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00322">322</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="a95988d5123f1ffc15b951c613cf3d13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95988d5123f1ffc15b951c613cf3d13b">&#9670;&nbsp;</a></span>erfc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::erfc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic number that represents complimentary error function with the given argument <code>x</code>.</p>
<p>Mimics the function <code> std::erfc(x) </code> using the standard math library. </p>

<p class="definition">Definition at line <a class="el" href="symengine__math_8cc_source.html#l00329">329</a> of file <a class="el" href="symengine__math_8cc_source.html">symengine_math.cc</a>.</p>

</div>
</div>
<a id="ae4bf0df298733c58db90414b97ef3e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4bf0df298733c58db90414b97ef3e53">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Differentiation::SD::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expression</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bitwise left shift operator.</p>
<p>This is used to output the <code>expression</code> to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00379">379</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="af390ebb263b593b362a4cab8431e989e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af390ebb263b593b362a4cab8431e989e">&#9670;&nbsp;</a></span>operator>>()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; Differentiation::SD::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expression</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bitwise right shift operator.</p>
<p>This is used to read in an <code>expression</code> from the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00387">387</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="aec0ebe7a7c159f3c127b6594b9fd34d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0ebe7a7c159f3c127b6594b9fd34d2">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equality operator.</p>
<p>Return whether the <code>lhs</code> is equal to the <code>rhs</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00397">397</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a8e3b6d01b6938389fe5f7a6d51026e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3b6d01b6938389fe5f7a6d51026e7d">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> <a class="el" href="namespaceDifferentiation_1_1SD.html#a4d5338f1b462a40964292a9b7d37aa44">Differentiation::SD::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non-equality operator.</p>
<p>Return whether the <code>lhs</code> is not equal to the <code>rhs</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00404">404</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a133df6e175eb4adca68ff82370e9fbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133df6e175eb4adca68ff82370e9fbe3">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Less than operator.</p>
<p>Return whether the <code>lhs</code> is less than the <code>rhs</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00411">411</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="ab656e9d289ee3932b2700e340d552b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab656e9d289ee3932b2700e340d552b0b">&#9670;&nbsp;</a></span>operator>()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Greater than operator.</p>
<p>Return whether the <code>lhs</code> is greater than the <code>rhs</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00418">418</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="ac2c7762f896bc0c0cb51e54c3915d6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c7762f896bc0c0cb51e54c3915d6af">&#9670;&nbsp;</a></span>operator<=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Less than or equals operator.</p>
<p>Return whether the <code>lhs</code> is less than, or equal to, the <code>rhs</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00425">425</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a7ff7f1660c1bf01d8b254a7e1381e7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff7f1660c1bf01d8b254a7e1381e7fe">&#9670;&nbsp;</a></span>operator>=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Greater than or equals operator.</p>
<p>Return whether the <code>lhs</code> is greater than, or equal to, the <code>rhs</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00432">432</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a4d5338f1b462a40964292a9b7d37aa44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5338f1b462a40964292a9b7d37aa44">&#9670;&nbsp;</a></span>operator!()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Logical not operator.</p>
<dl class="section note"><dt>Note</dt><dd>This operator can only be applied on boolean and conditional expressions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00438">438</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a145415551e08d4e10d75683ccebe9e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145415551e08d4e10d75683ccebe9e37">&#9670;&nbsp;</a></span>operator &() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Logical and operator.</p>
<dl class="section note"><dt>Note</dt><dd>This operator can only be applied on boolean and conditional expressions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00450">450</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a9a77a848266ea1158ac0fb7a0ad0181f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a77a848266ea1158ac0fb7a0ad0181f">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Logical inclusive or operator.</p>
<dl class="section note"><dt>Note</dt><dd>This operator can only be applied on boolean and conditional expressions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00467">467</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a5cb08eedf1aab8fa4ac80d52dd8b9f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb08eedf1aab8fa4ac80d52dd8b9f88">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Logical exclusive or (xor) operator.</p>
<dl class="section note"><dt>Note</dt><dd>This operator can only be applied on boolean and conditional expressions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00484">484</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a650506d4f70b6fd7a72863a68de2a46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650506d4f70b6fd7a72863a68de2a46a">&#9670;&nbsp;</a></span>operator &&() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>And operator.</p>
<dl class="section note"><dt>Note</dt><dd>This operator can only be applied on boolean and conditional expressions. This operator is a convenience wrapper for the logical and operator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00501">501</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a4f752fd7475aee2b278ea901a6b8121a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f752fd7475aee2b278ea901a6b8121a">&#9670;&nbsp;</a></span>operator||()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inclusive or operator.</p>
<dl class="section note"><dt>Note</dt><dd>This operator can only be applied on boolean and conditional expressions. This operator is a convenience wrapper for the logical or operator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00508">508</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a2b4a66bb5483046c29496a2d0176115a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4a66bb5483046c29496a2d0176115a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition operator.</p>
<p>Return the result of adding the <code>rhs</code> to the <code>lhs</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00515">515</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a18d9fd2312a4e0ee2cc4587ba55fbaf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d9fd2312a4e0ee2cc4587ba55fbaf9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtraction operator.</p>
<p>Return the result of subtracting the <code>rhs</code> from the <code>lhs</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00523">523</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a0ce35656c64f4d2959f14b7378eb555e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce35656c64f4d2959f14b7378eb555e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication operator.</p>
<p>Return the result of multiplying the <code>lhs</code> by the <code>rhs</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00530">530</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="ac1d6a48ecaf77bb3ce535d50b53bc0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d6a48ecaf77bb3ce535d50b53bc0f4">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Division operator.</p>
<p>Return the result of dividing the <code>lhs</code> by the <code>rhs</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00538">538</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a05af0f673d789e3ef28728a7ae915a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05af0f673d789e3ef28728a7ae915a95">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>General addition operator.</p>
<p>Return the result of adding the <code>rhs</code> to the <code>lhs</code>. The <code>lhs</code> type may be any supported number type, and the result is promoted to a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. The type conversion makes writing scalar expressions using <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> more natural. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8h_source.html#l01087">1087</a> of file <a class="el" href="symengine__number__types_8h_source.html">symengine_number_types.h</a>.</p>

</div>
</div>
<a id="a08bebb689f687906a02fc2f6dcf7d73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08bebb689f687906a02fc2f6dcf7d73e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>General addition operator.</p>
<p>Return the result of adding the <code>rhs</code> to the <code>lhs</code>. The <code>rhs</code> type may be any supported number type, and the result is promoted to a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. The type conversion makes writing scalar expressions using <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> more natural. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8h_source.html#l01104">1104</a> of file <a class="el" href="symengine__number__types_8h_source.html">symengine_number_types.h</a>.</p>

</div>
</div>
<a id="a112f73c7e707cd37dae66646abc543ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112f73c7e707cd37dae66646abc543ac">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>General subtraction operator.</p>
<p>Return the result of subtracting the <code>rhs</code> from the <code>lhs</code>. The <code>lhs</code> type may be any supported number type, and the result is promoted to a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. The type conversion makes writing scalar expressions using <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> more natural. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8h_source.html#l01121">1121</a> of file <a class="el" href="symengine__number__types_8h_source.html">symengine_number_types.h</a>.</p>

</div>
</div>
<a id="a2ba86e984e2823affc7fec6bfde82089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba86e984e2823affc7fec6bfde82089">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>General subtraction operator.</p>
<p>Return the result of subtracting the <code>rhs</code> from the <code>lhs</code>. The <code>rhs</code> type may be any supported number type, and the result is promoted to a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. The type conversion makes writing scalar expressions using <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> more natural. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8h_source.html#l01138">1138</a> of file <a class="el" href="symengine__number__types_8h_source.html">symengine_number_types.h</a>.</p>

</div>
</div>
<a id="a85a754edca4129fab7d2e22b59d7abae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a754edca4129fab7d2e22b59d7abae">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>General multiplication operator.</p>
<p>Return the result of multiplying the <code>lhs</code> by the <code>rhs</code>. The <code>lhs</code> type may be any supported number type, and the result is promoted to a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. The type conversion makes writing scalar expressions using <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> more natural. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8h_source.html#l01154">1154</a> of file <a class="el" href="symengine__number__types_8h_source.html">symengine_number_types.h</a>.</p>

</div>
</div>
<a id="acf7912b47a37c347e5b9dc5a78bb7deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7912b47a37c347e5b9dc5a78bb7deb">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>General multiplication operator.</p>
<p>Return the result of multiplying the <code>lhs</code> by the <code>rhs</code>. The <code>rhs</code> type may be any supported number type, and the result is promoted to a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. The type conversion makes writing scalar expressions using <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> more natural. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8h_source.html#l01170">1170</a> of file <a class="el" href="symengine__number__types_8h_source.html">symengine_number_types.h</a>.</p>

</div>
</div>
<a id="aa1b63635e58ce342ddedf013224b583e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b63635e58ce342ddedf013224b583e">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>General division operator.</p>
<p>Return the result of dividing the <code>lhs</code> by the <code>rhs</code>. The <code>lhs</code> type may be any supported number type, and the result is promoted to a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. The type conversion makes writing scalar expressions using <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> more natural. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8h_source.html#l01187">1187</a> of file <a class="el" href="symengine__number__types_8h_source.html">symengine_number_types.h</a>.</p>

</div>
</div>
<a id="a98150ecb3e12b1cea4106b65ff37cfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98150ecb3e12b1cea4106b65ff37cfe4">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                std::is_constructible&lt;Expression, NumberType&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>General division operator.</p>
<p>Return the result of dividing the <code>lhs</code> by the <code>rhs</code>. The <code>lhs</code> type may be any supported number type, and the result is promoted to a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>. The type conversion makes writing scalar expressions using <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> more natural. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8h_source.html#l01204">1204</a> of file <a class="el" href="symengine__number__types_8h_source.html">symengine_number_types.h</a>.</p>

</div>
</div>
<a id="a80b70c59222eaf89e4b362de26158ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b70c59222eaf89e4b362de26158ce4">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StreamType&amp; Differentiation::SD::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">OptimizerType</a>&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator that outputs the selected optimizer type. </p>

<p class="definition">Definition at line <a class="el" href="symengine__optimizer_8h_source.html#l00123">123</a> of file <a class="el" href="symengine__optimizer_8h_source.html">symengine_optimizer.h</a>.</p>

</div>
</div>
<a id="afc6c34535268e98688dc577a9eb0ee90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6c34535268e98688dc577a9eb0ee90">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> Differentiation::SD::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A global operator that returns an object in which all bits are individually set in the following way: If the corresponding bit in either the first or second argument are set, then the output bit it set. Otherwise the output bit remains unset. This <code>or</code> type operation is performed for each bit composing the input arguments (and output) in an individual manner. </p>

<p class="definition">Definition at line <a class="el" href="symengine__optimizer_8h_source.html#l00180">180</a> of file <a class="el" href="symengine__optimizer_8h_source.html">symengine_optimizer.h</a>.</p>

</div>
</div>
<a id="a23e27546f57a02a0994aeead1a1ce23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e27546f57a02a0994aeead1a1ce23a">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a>&amp; Differentiation::SD::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator that sets the bits from the second argument also in the first one. </p>

<p class="definition">Definition at line <a class="el" href="symengine__optimizer_8h_source.html#l00192">192</a> of file <a class="el" href="symengine__optimizer_8h_source.html">symengine_optimizer.h</a>.</p>

</div>
</div>
<a id="a4fff6fc47cc19131f951f2fc68921fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fff6fc47cc19131f951f2fc68921fa3">&#9670;&nbsp;</a></span>operator &() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> Differentiation::SD::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A global operator that returns an object in which all bits are individually set in the following way: If the corresponding bit in both the first or second argument are set, then the output bit it set. Otherwise the output bit remains unset. This <code>and</code> type operation is performed for each bit composing the input arguments (and output) in an individual manner. </p>

<p class="definition">Definition at line <a class="el" href="symengine__optimizer_8h_source.html#l00211">211</a> of file <a class="el" href="symengine__optimizer_8h_source.html">symengine_optimizer.h</a>.</p>

</div>
</div>
<a id="a320deb187afe4738726b96f41b0f80d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320deb187afe4738726b96f41b0f80d6">&#9670;&nbsp;</a></span>operator &=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a>&amp; Differentiation::SD::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator which clears all the bits in the first argument if they are not also set in the second argument. </p>

<p class="definition">Definition at line <a class="el" href="symengine__optimizer_8h_source.html#l00224">224</a> of file <a class="el" href="symengine__optimizer_8h_source.html">symengine_optimizer.h</a>.</p>

</div>
</div>
<a id="a2a6940959dfb13557d6cdc3c33a4b961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6940959dfb13557d6cdc3c33a4b961">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StreamType&amp; Differentiation::SD::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">OptimizationFlags</a>&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator that outputs optimization flags as a set of or'd text values. </p>

<p class="definition">Definition at line <a class="el" href="symengine__optimizer_8h_source.html#l00275">275</a> of file <a class="el" href="symengine__optimizer_8h_source.html">symengine_optimizer.h</a>.</p>

</div>
</div>
<a id="af71e229940cc126030592c5195289113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71e229940cc126030592c5195289113">&#9670;&nbsp;</a></span>make_symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::make_symbol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> representing a scalar symbolic variable with the identifier specified by <code>symbol</code>.</p>
<p>For example, if the <code>symbol</code> is the string <code>"x"</code> then the scalar symbolic variable that is returned represents the scalar \(x\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol</td><td>An identifier (or name) for the returned symbolic variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scalar symbolic variable with the name <code>symbol</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is up to the user to ensure that there is no ambiguity in the symbols used within a section of code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__scalar__operations_8cc_source.html#l00041">41</a> of file <a class="el" href="symengine__scalar__operations_8cc_source.html">symengine_scalar_operations.cc</a>.</p>

</div>
</div>
<a id="a876041f6048705c7a8ad0855cdb1bd7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a876041f6048705c7a8ad0855cdb1bd7a">&#9670;&nbsp;</a></span>make_symbolic_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::make_symbolic_function </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a3851c361f9dae70bd4fa3c005ce295e0">types::symbol_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> representing a scalar symbolic function with the identifier specified by <code>symbol</code>. The function's symbolic dependencies are specified by the input <code>arguments</code>.</p>
<p>For example, if the <code>symbol</code> is the string <code>"f"</code>, and the arguments to the function that is generated are the symbolic variable <code>x</code> and the symbolic expression <code>y+z</code>, then the generic symbolic function that is returned represents \(f(x, y+z)\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol</td><td>An identifier (or name) for the returned symbolic function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>A vector of input arguments to the returned symbolic function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generic symbolic function with the identifier <code>symbolic</code> and the number of input arguments equal to the length of <code>arguments</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is up to the user to ensure that there is no ambiguity in the symbols used within a section of code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__scalar__operations_8cc_source.html#l00048">48</a> of file <a class="el" href="symengine__scalar__operations_8cc_source.html">symengine_scalar_operations.cc</a>.</p>

</div>
</div>
<a id="aca52d0daf28725a318c088ad5af47c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca52d0daf28725a318c088ad5af47c8f">&#9670;&nbsp;</a></span>make_symbolic_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::make_symbolic_function </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> representing a scalar symbolic function with the identifier specified by <code>symbol</code>. The function's symbolic dependencies are specified by the keys to the input <code>arguments</code> map; the values stored in the map are ignored.</p>
<p>For example, if the <code>symbol</code> is the string <code>"f"</code>, and the arguments to the function that is generated are the symbolic variable <code>x</code> and the symbolic expression <code>y+z</code>, then the generic symbolic function that is returned represents \(f(x, y+z)\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol</td><td>An identifier (or name) for the returned symbolic function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>A map of input arguments to the returned symbolic function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generic symbolic function with the identifier <code>symbolic</code> and the number of input arguments equal to the length of <code>arguments</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is up to the user to ensure that there is no ambiguity in the symbols used within a section of code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__scalar__operations_8cc_source.html#l00056">56</a> of file <a class="el" href="symengine__scalar__operations_8cc_source.html">symengine_scalar_operations.cc</a>.</p>

</div>
</div>
<a id="a5bb5de9e851544ae6b9a17170ab3f570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb5de9e851544ae6b9a17170ab3f570">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::differentiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the symbolic result of computing the partial derivative of the scalar <code>f</code> with respect to the scalar <code>x</code>. In most use cases the function or variable <code>f</code> would be called the dependent variable, and <code>x</code> the independent variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>A scalar symbolic function or (dependent) expression. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A scalar symbolic (independent) variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The symbolic function or expression representing the result \(\frac{\partial f}{\partial x}\). </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__scalar__operations_8cc_source.html#l00068">68</a> of file <a class="el" href="symengine__scalar__operations_8cc_source.html">symengine_scalar_operations.cc</a>.</p>

</div>
</div>
<a id="a8349584858c74f233cc2ca0151eecfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8349584858c74f233cc2ca0151eecfad">&#9670;&nbsp;</a></span>make_symbol_map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double, typename SymbolicType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> Differentiation::SD::make_symbol_map </td>
          <td>(</td>
          <td class="paramtype">const SymbolicType &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic map that has a single entry with the key given by the <code>symbol</code>. It is expected that all entries to be added to the symbolic map are valid symbols or symbolic expressions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>See the <code><a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map(types::substitution_map &amp;, const Expression &amp;)</a></code> function for a detailed discussion on the role of this template argument.</td></tr>
    <tr><td class="paramname">SymbolicType</td><td>Any symbolic type that is understood by the <a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map()</a> functions. This includes individual <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>, std::vector&lt;Expression&gt;, as well as Tensors and SymmetricTensors of Expressions. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. This <code>ValueType</code> is somewhat arbitrary as it is only used to create default-constructed values as entries in the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d10d62b31ac6cf1768fd50486813987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d10d62b31ac6cf1768fd50486813987">&#9670;&nbsp;</a></span>make_symbol_map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double, typename SymbolicType , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> Differentiation::SD::make_symbol_map </td>
          <td>(</td>
          <td class="paramtype">const SymbolicType &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>other_symbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symbolic map that has the entry keys given by <code>symbol</code> and all <code>other_symbols</code>. It is expected that all entries to be added to the symbolic map are valid symbols or symbolic expressions.</p>
<p>With this function it is possible to construct a symbolic map from different types. An example may be as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> symbol_map</div><div class="line">  = <a class="code" href="namespaceDifferentiation_1_1SD.html#a8349584858c74f233cc2ca0151eecfad">make_symbol_map</a>(</div><div class="line">      Expression(...),</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1,dim,Expression&gt;</a>(...),</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim,Expression&gt;</a>(...));</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>See the <code><a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map(types::substitution_map &amp;, const Expression &amp;)</a></code> function for a detailed discussion on the role of this template argument.</td></tr>
    <tr><td class="paramname">SymbolicType</td><td>Any symbolic type that is understood by the <a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map()</a> functions. This includes individual <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>, std::vector&lt;Expression&gt;, as well as Tensors and SymmetricTensors of Expressions. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. This <code>ValueType</code> is somewhat arbitrary as it is only used to create default-constructed values as entries in the map. </td></tr>
    <tr><td class="paramname">Args</td><td>A type associated with the parameter pack that contains any number of other <code>SymbolicTypes</code>. All types held by the parameter pack share the same restriction as the <code>SymbolicType</code> documented above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcc4f6ff9d1bff45c3085ed9fd73aa18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc4f6ff9d1bff45c3085ed9fd73aa18">&#9670;&nbsp;</a></span>add_to_symbol_map() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for adding an empty entry, with the key value given by <code>symbol</code>, to the symbolic map <code>symbol_map</code>.</p>
<p>This function is guaranteed to create an ordering that is identical to the typical <a class="el" href="namespaceDifferentiation_1_1SD.html#ad0b015b556ca354a241a3b7f8e3a8248">add_to_substitution_map()</a> call that is used when constructing a map to perform symbol substitution. It exists primarily to create an initial map that can be used in the optimize() call to a <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">BatchOptimizer</a>, specifically if the values that are to be substituted into the map are not known at the time that the symbols used to construct symbolic expressions are defined. This helps one conform to the requirement that the arguments sent into lambda and LLVM JIT compiled functions (created by optimizing symbolic expressions) (i) be the same, and (ii) have a constant ordering.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>A template parameter that enforces whether or not the <code>symbol</code> has to be a valid one or not. In the overwhelming majority of cases, the default value of <code>false</code> should be selected, with the result that an exception will be thrown if the input <code>symbolic</code> is, in fact, not a symbolic value or expression. An exceptional case is, for example, when performing symbolic assembly on a finite element level. When extracting the symbolic equivalent of the shape function gradients using FEExtractors, the returned tensor will have some <em>a priori</em> determined zero-valued components. These trivial components are not valid symbols (as they are not symbolic expressions), and we would typically wish to guard against their (erroneous) inclusion. In this scenario, for convenience, one could set <code>ignore_invalid_symbols</code> to <code>true</code> and these zero-valued entries would be skipped over and ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In this function, the <code>ValueType</code> is somewhat arbitrary as it is only used to create default-constructed values as entries in the map. </dd></dl>

</div>
</div>
<a id="afc6dc945fcdbc200181d868e7bb91c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6dc945fcdbc200181d868e7bb91c53">&#9670;&nbsp;</a></span>add_to_symbol_map() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double, typename SymbolicType , typename T  = typename std::enable_if&lt;                !std::is_base_of&lt;Expression, SymbolicType&gt;::value &amp;&amp;                ::internal::is_explicitly_convertible&lt;                  SymbolicType,                  const SymEngine::RCP&lt;const SymEngine::Basic&gt; &amp;&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SymbolicType &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for adding an empty entry, with the key value given by <code>symbol</code>, to the symbolic map <code>symbol_map</code>.</p>
<p>For more context which this function is used, see the other <code><a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map(types::substitution_map &amp;, const Expression &amp;)</a></code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>See the other <code><a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map(types::substitution_map &amp;, const Expression &amp;)</a></code> function for a detailed discussion on the role of this template argument.</td></tr>
    <tr><td class="paramname">SymbolicType</td><td>A type that represents a symbolic variable. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>SymbolicType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. This <code>ValueType</code> is somewhat arbitrary as it is only used to create default-constructed values as entries in the map. </td></tr>
    <tr><td class="paramname">T</td><td>An arbitrary type resulting from the application of the SFINAE idiom to selectively specialize this class. The required condition is fulfilled when the <code>SymbolicType</code> can be explicitly converted to a <code>const SymEngine::RCP&lt;const SymEngine::Basic&gt; &amp;</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fd651d7c88f4d42cfbca60da549cb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd651d7c88f4d42cfbca60da549cb3f">&#9670;&nbsp;</a></span>add_to_symbol_map() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double, typename SymbolicType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; SymbolicType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for adding empty entries, with the key values equal to the entries in <code>symbols</code>, to the symbolic map <code>symbol_map</code>. It is expected that all entries in the input vector <code>symbols</code> be of <code>SymbolicType</code>, compatible with the other <a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map()</a> functions.</p>
<p>For more context which this function is used, see the other <code><a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map(types::substitution_map &amp;, const Expression &amp;)</a></code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>See the other <code><a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map(types::substitution_map &amp;, const Expression &amp;)</a></code> function for a detailed discussion on the role of this template argument.</td></tr>
    <tr><td class="paramname">SymbolicType</td><td>Any symbolic type that is understood by the <a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map()</a> functions. This includes an individual <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>, as well as Tensors and SymmetricTensors of Expressions. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. This <code>ValueType</code> is somewhat arbitrary as it is only used to create default-constructed values as entries in the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8e00bfd0783385c0c431fef59346c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e00bfd0783385c0c431fef59346c3c">&#9670;&nbsp;</a></span>add_to_symbol_map() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>other_symbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for adding empty entries, with the key values equal to the key entries in <code>other_symbols</code>, to the symbolic map <code>symbol_map</code>.</p>
<p>For more context which this function is used, see the other <code><a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map(types::substitution_map &amp;, const Expression &amp;)</a></code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>See the other <code><a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map(types::substitution_map &amp;, const Expression &amp;)</a></code> function for a detailed discussion on the role of this template argument.</td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. This <code>ValueType</code> is somewhat arbitrary as it is only used to create default-constructed values as entries in the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0649a36b9b18c401a0b535bb67868ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0649a36b9b18c401a0b535bb67868ed9">&#9670;&nbsp;</a></span>add_to_symbol_map() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double, typename SymbolicType , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SymbolicType &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>other_symbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for adding empty entries, with the key values equal to the entries in <code>symbol</code> plus <code>other_symbols</code>, to the symbolic map <code>symbol_map</code>. It is expected that all entries in <code>symbol</code> and <code>other_symbols</code> be of a <code>SymbolicType</code>, compatible with the other <a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map()</a> functions.</p>
<p>For more context which this function is used, see the other <code><a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map(types::substitution_map &amp;, const Expression &amp;)</a></code> function.</p>
<p>With this function it is possible to add entries from different types to a symbolic map. An example may be as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> symbol_map = ...;</div><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map</a>(</div><div class="line">  symbol_map,</div><div class="line">  Expression(...),</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim,Expression&gt;</a>(...),</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim,Expression&gt;</a>(...));</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>See the other <code><a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map(types::substitution_map &amp;, const Expression &amp;)</a></code> function for a detailed discussion on the role of this template argument.</td></tr>
    <tr><td class="paramname">SymbolicType</td><td>Any symbolic type that is understood by the <a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map()</a> functions. This includes individual <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>, std::vector&lt;Expression&gt;, as well as Tensors and SymmetricTensors of Expressions. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. This <code>ValueType</code> is somewhat arbitrary as it is only used to create default-constructed values as entries in the map. </td></tr>
    <tr><td class="paramname">Args</td><td>A type associated with the parameter pack that contains any number of other <code>SymbolicTypes</code>. All types held by the parameter pack share the same restriction as the <code>SymbolicType</code> documented above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0b1e479cf204c054932042095d31962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b1e479cf204c054932042095d31962">&#9670;&nbsp;</a></span>set_value_in_symbol_map() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::set_value_in_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the entry for <code>symbol</code> in the <code>substitution_map</code> and set its corresponding <code>value</code>.</p>
<p>This function may be used to safely transform an existing or null symbolic map (one with uninitialized entries) into one that can be used to conduct symbolic substitution operations (i.e., a substitution map). </p>

</div>
</div>
<a id="acc58b401c4f2040eb58ee6433c7a8673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc58b401c4f2040eb58ee6433c7a8673">&#9670;&nbsp;</a></span>set_value_in_symbol_map() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SymbolicType , typename ValueType , typename T  = typename std::enable_if&lt;                ::internal::is_explicitly_convertible&lt;                  SymbolicType,                  const SymEngine::RCP&lt;const SymEngine::Basic&gt; &amp;&gt;::value &amp;&amp;                std::is_constructible&lt;SymbolicType, ValueType&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::set_value_in_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SymbolicType &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the entry for <code>symbol</code> in the <code>substitution_map</code> and set its corresponding <code>value</code>.</p>
<p>This function may be used to safely transform an existing or null symbolic map (one with uninitialized entries) into one that can be used to conduct symbolic substitution operations (i.e., a substitution map).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SymbolicType</td><td>A type that represents a symbolic variable. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>SymbolicType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
    <tr><td class="paramname">T</td><td>An arbitrary type resulting from the application of the SFINAE idiom to selectively specialize this class. The required condition is fulfilled when the <code>SymbolicType</code> can be explicitly converted to a <code>const SymEngine::RCP&lt;const SymEngine::Basic&gt; &amp;</code>, and it is possible to construct an <code>SymbolicType</code> directly from the <code>ValueType</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f79d80b7a6d1b1634271eb2ed5fcd68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f79d80b7a6d1b1634271eb2ed5fcd68">&#9670;&nbsp;</a></span>set_value_in_symbol_map() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SymbolicType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::set_value_in_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; SymbolicType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the entries for <code>symbols</code> in the <code>substitution_map</code> and set their corresponding <code>values</code>.</p>
<p>This function may be used to safely transform an existing or null symbolic map (one with uninitialized entries) into one that can be used to conduct symbolic substitution operations (i.e., a substitution map).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SymbolicType</td><td>A type that represents a symbolic variable. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>SymbolicType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>SymbolicType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac839dc6fb678b16f65e963cdbbc4e6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac839dc6fb678b16f65e963cdbbc4e6fa">&#9670;&nbsp;</a></span>set_value_in_symbol_map() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SymbolicType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::set_value_in_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; SymbolicType, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the entry for <code>symbols</code> in the <code>substitution_map</code> and set their corresponding <code>values</code>. The modified symbol will have the key given by the first element of <code>symbol_value</code> and the value given by its second element.</p>
<p>This function may be used to safely transform an existing or null symbolic map (one with uninitialized entries) into one that can be used to conduct symbolic substitution operations (i.e., a substitution map).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SymbolicType</td><td>A type that represents a symbolic variable. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>SymbolicType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>SymbolicType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a63033798b01c018314eb2699f356ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a63033798b01c018314eb2699f356ce">&#9670;&nbsp;</a></span>set_value_in_symbol_map() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SymbolicType , typename ValueType , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::set_value_in_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; SymbolicType, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>other_symbol_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the entries for <code>symbols</code> in the <code>substitution_map</code> and set their corresponding <code>values</code>, followed by the same operation for the <code>other_symbol_values</code>.</p>
<p>This function may be used to safely transform an existing or null symbolic map (one with uninitialized entries) into one that can be used to conduct symbolic substitution operations (i.e., a substitution map).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SymbolicType</td><td>A type that represents a symbolic variable. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>SymbolicType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>SymbolicType</code> can be constructed from. </td></tr>
    <tr><td class="paramname">Args</td><td>A type associated with the parameter pack that contains any number of other pairs of <code>SymbolicTypes</code> and <code>ValueTypes</code>. All types held by the parameter pack share the same restriction as the <code>SymbolicType</code> and <code>ValueType</code> documented above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dff7cf6f0d7d19622837c258ba9817f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dff7cf6f0d7d19622837c258ba9817f">&#9670;&nbsp;</a></span>set_value_in_symbol_map() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SymbolicType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::set_value_in_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; SymbolicType, ValueType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the entries for <code>symbols</code> in the <code>substitution_map</code> and set their corresponding <code>values</code>. The modified symbol will have the key given by the first element of each paired entry in the <code>symbol_values</code> vector and the value given by its respective second element.</p>
<p>This function may be used to safely transform an existing or null symbolic map (one with uninitialized entries) into one that can be used to conduct symbolic substitution operations (i.e., a substitution map).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SymbolicType</td><td>A type that represents a symbolic variable. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>SymbolicType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>SymbolicType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab771f82adc3a0b146902aea99155d1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab771f82adc3a0b146902aea99155d1bf">&#9670;&nbsp;</a></span>set_value_in_symbol_map() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::set_value_in_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the entries for <code>symbols</code> in the <code>substitution_map</code> and set their corresponding <code>values</code>. The modified symbol will have the key given by the each element the <code>symbol_values</code> map and the value given by its respective mapped element.</p>
<p>This function may be used to safely transform an existing or null symbolic map (one with uninitialized entries) into one that can be used to conduct symbolic substitution operations (i.e., a substitution map). </p>

</div>
</div>
<a id="aecd8502f0296caba06f86c06bc449e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd8502f0296caba06f86c06bc449e51">&#9670;&nbsp;</a></span>make_substitution_map() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> Differentiation::SD::make_substitution_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a substitution map that has the entry key given by <code>symbol</code> and the value given by <code>value</code>. It is expected that the key entry be valid symbol or symbolic expression.</p>
<p>The values that map to a <code>symbol</code> would typically be of an arithmetic type. However, in some instances is may be useful to map a symbolic type to another symbolic type (i.e. perform partial substitution). In such a situation the <a class="el" href="namespaceDifferentiation_1_1SD.html#ad978861d8e1b008dae23cf8c99d82c13">resolve_explicit_dependencies()</a> function may be useful to simplify the final substitution map by resolving all explicit interdependencies between entries in the substitution map. </p>

<p class="definition">Definition at line <a class="el" href="symengine__scalar__operations_8cc_source.html#l00172">172</a> of file <a class="el" href="symengine__scalar__operations_8cc_source.html">symengine_scalar_operations.cc</a>.</p>

</div>
</div>
<a id="a11c0ecc04f2bc13fbe1922457b04c7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c0ecc04f2bc13fbe1922457b04c7fe">&#9670;&nbsp;</a></span>make_substitution_map() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , typename ValueType , typename T  = typename std::enable_if&lt;                ::internal::is_explicitly_convertible&lt;                  ExpressionType,                  const SymEngine::RCP&lt;const SymEngine::Basic&gt; &amp;&gt;::value &amp;&amp;                std::is_constructible&lt;ExpressionType, ValueType&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> Differentiation::SD::make_substitution_map </td>
          <td>(</td>
          <td class="paramtype">const ExpressionType &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a substitution map that has the entry key given by <code>symbol</code> and the value given by <code>value</code>. It is expected that the key entry be valid symbol or symbolic expression.</p>
<p>The values that map to a <code>symbol</code> would typically be of a <code>ValueType</code> (i.e., an arithmetic type). However, in some instances is may be useful to map a symbolic type to another symbolic type (i.e. perform partial substitution). In such a situation the <a class="el" href="namespaceDifferentiation_1_1SD.html#ad978861d8e1b008dae23cf8c99d82c13">resolve_explicit_dependencies()</a> function may be useful to simplify the final substitution map by resolving all explicit interdependencies between entries in the substitution map.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpressionType</td><td>A type that represents a symbolic expression. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>ExpressionType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
    <tr><td class="paramname">T</td><td>An arbitrary type resulting from the application of the SFINAE idiom to selectively specialize this class. The required condition is fulfilled when the <code>ExpressionType</code> can be explicitly converted to a <code>const SymEngine::RCP&lt;const SymEngine::Basic&gt; &amp;</code>, and it is possible to construct an <code>ExpressionType</code> directly from the <code>ValueType</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3212bdb3135c7fa3bf045e5403dabab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3212bdb3135c7fa3bf045e5403dabab1">&#9670;&nbsp;</a></span>make_substitution_map() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> Differentiation::SD::make_substitution_map </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; ExpressionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a substitution map that has the entry keys given by <code>symbols</code> and the values given by <code>values</code>. It is expected that all key entries be valid symbols or symbolic expressions.</p>
<p>It is possible to map symbolic types to other symbolic types using this function. For more details on this, see the other <code>make_substitution_map(const Expression &amp;, const ValueType &amp;)</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpressionType</td><td>A type that represents a symbolic expression. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>ExpressionType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d7c5d9560b091512182a57e4c1eda30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7c5d9560b091512182a57e4c1eda30">&#9670;&nbsp;</a></span>make_substitution_map() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> Differentiation::SD::make_substitution_map </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; ExpressionType, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a substitution map that has the key given by the first entry in <code>symbol_value</code>, and the value of its second entry. It is expected that the key entry be a valid symbol or symbolic expression.</p>
<p>It is possible to map symbolic types to other symbolic types using this function. For more details on this, see the other <code>make_substitution_map(const Expression &amp;, const ValueType &amp;)</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpressionType</td><td>A type that represents a symbolic expression. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>ExpressionType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac64061c41c44b39b5e3375261c655672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64061c41c44b39b5e3375261c655672">&#9670;&nbsp;</a></span>make_substitution_map() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> Differentiation::SD::make_substitution_map </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; ExpressionType, ValueType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a substitution map that has the keys given by the first entry of each element of <code>symbol_values</code>, and the values given its second entry. It is expected that all key entries be valid symbols or symbolic expressions.</p>
<p>It is possible to map symbolic types to other symbolic types using this function. For more details on this, see the other <code>make_substitution_map(const Expression &amp;, const ValueType &amp;)</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpressionType</td><td>A type that represents a symbolic expression. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>ExpressionType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a305cfc857540b0ad7af4c12652ac6dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305cfc857540b0ad7af4c12652ac6dce">&#9670;&nbsp;</a></span>make_substitution_map() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , typename ValueType , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> Differentiation::SD::make_substitution_map </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; ExpressionType, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>other_symbol_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a substitution map that has the key given by the first entry in <code>symbol_value</code>, and the value of its second entry, followed by the addition of the <code>other_symbol_values</code>. It is expected that all key entries be valid symbols or symbolic expressions.</p>
<p>With this function it is possible to construct a symbolic substitution map from different types, so long as there exists a <a class="el" href="namespaceDifferentiation_1_1SD.html#ad0b015b556ca354a241a3b7f8e3a8248">add_to_substitution_map()</a> function with the signature corresponding to the pair types. An example may be as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a></div><div class="line">  = <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>(</div><div class="line">      std::make_pair(Expression(...), 3),</div><div class="line">      std::make_pair(<a class="code" href="classTensor.html">Tensor&lt;1,dim,Expression&gt;</a>(...),</div><div class="line">                     <a class="code" href="classTensor.html">Tensor&lt;1,dim,float&gt;</a>(...)),</div><div class="line">      std::make_pair(<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim,Expression&gt;</a>(...),</div><div class="line">                     <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim,double&gt;</a>(...)));</div></div><!-- fragment --><p>It is possible to map symbolic types to other symbolic types using this function. For more details on this, see the other <code>make_substitution_map(const Expression &amp;, const ValueType &amp;)</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpressionType</td><td>Any symbolic expression type that is understood by the <a class="el" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map()</a> functions. This includes individual <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>, as well as Tensors and SymmetricTensors of Expressions. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
    <tr><td class="paramname">Args</td><td>A type associated with the parameter pack that contains any number of other <code>ExpressionTypes</code>. All types held by the parameter pack share the same restriction as the <code>ExpressionType</code> documented above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0b015b556ca354a241a3b7f8e3a8248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b015b556ca354a241a3b7f8e3a8248">&#9670;&nbsp;</a></span>add_to_substitution_map() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_substitution_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function to add an entry to the <code>substitution_map</code>. The new entry will have the key given by <code>symbol</code> with its paired <code>value</code>. Such maps are required to perform substitution of symbolic expressions, with key entries being exchanges with their pair values.</p>
<p>This function is guaranteed to create an ordering that is identical to the typical <a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map()</a> call that may be used when initially configuring a <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">BatchOptimizer</a>. This helps one conform to the requirement that the arguments sent into lambda and LLVM JIT compiled functions (created by optimizing symbolic expressions) (i) be the same, and (ii) have a constant ordering.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>A template parameter that enforces whether or not the <code>symbol</code> has to be a valid one or not. In the overwhelming majority of cases, the default value of <code>false</code> should be selected, with the result that an exception will be thrown if the input <code>symbolic</code> is, in fact, not a symbolic value or expression. An exceptional case is, for example, when performing symbolic assembly on a finite element level. When extracting the symbolic equivalent of the shape function gradients using FEExtractors, the returned tensor will have some <em>a priori</em> determined zero-valued components. These trivial components are not valid symbols (as they are not symbolic expressions), and we would typically wish to guard against their (erroneous) inclusion. In this scenario, for convenience, one could set <code>ignore_invalid_symbols</code> to <code>true</code> and these zero-valued entries would be skipped over and ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d3f4cfdae943581997ba68f1cbf8911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3f4cfdae943581997ba68f1cbf8911">&#9670;&nbsp;</a></span>add_to_substitution_map() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, typename ExpressionType , typename ValueType , typename  = typename std::enable_if&lt;                ::internal::is_explicitly_convertible&lt;                  ExpressionType,                  const SymEngine::RCP&lt;const SymEngine::Basic&gt; &amp;&gt;::value &amp;&amp;                std::is_constructible&lt;ExpressionType, ValueType&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_substitution_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExpressionType &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function to add an entry to the <code>substitution_map</code>. The new entry will have the key given by <code>symbol</code> with its paired <code>value</code>.</p>
<p>The <code>ExpressionType</code> will be used to convert the <code>value</code> to a compatible SymEngine number type. It is therefore required that the <code>ExpressionType</code> </p><ol type="1">
<li>can be constructed from a <code>ValueType</code>, and that</li>
<li>it is convertible to a <code>const SymEngine::RCP&lt;const SymEngine::Basic&gt; &amp;</code>.</li>
</ol>
<p>For more context which this function is used, see the other <code>add_to_substitution_map(<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;)</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>See the other <code>add_to_substitution_map(<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;)</code> function for a detailed discussion on the role of this template argument.</td></tr>
    <tr><td class="paramname">ExpressionType</td><td>A type that represents a symbolic expression. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>ExpressionType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab80e6c4720516092d4f5106ef28f1be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80e6c4720516092d4f5106ef28f1be1">&#9670;&nbsp;</a></span>add_to_substitution_map() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, typename ExpressionType , typename ValueType , typename  = typename std::enable_if&lt;                ::internal::is_explicitly_convertible&lt;                  ExpressionType,                  const SymEngine::RCP&lt;const SymEngine::Basic&gt; &amp;&gt;::value &amp;&amp;                std::is_constructible&lt;ExpressionType, ValueType&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_substitution_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ExpressionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for adding multiple entries to the <code>substitution_map</code>. The new entries will have the keys given in the <code>symbols</code> vector, each of which will be paired index-wise with its corresponding element in the <code>values</code> vector.</p>
<p>The class represented by the <code>ExpressionType</code> template parameter will be used to convert the p value to a compatible SymEngine number type. It is therefore required that the <code>ExpressionType</code> </p><ol type="1">
<li>can be constructed from a <code>ValueType</code>, and that</li>
<li>it is convertible to a <code>const SymEngine::RCP&lt;const SymEngine::Basic&gt; &amp;</code>.</li>
</ol>
<p>For more context which this function is used, see the other <code>add_to_substitution_map(<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;)</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>See the other <code>add_to_substitution_map(<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;)</code> function for a detailed discussion on the role of this template argument.</td></tr>
    <tr><td class="paramname">ExpressionType</td><td>A type that represents a symbolic expression. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>ExpressionType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc9f91f997c57f7c99ea56861b47288b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9f91f997c57f7c99ea56861b47288b">&#9670;&nbsp;</a></span>add_to_substitution_map() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_substitution_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for adding multiple entries to the <code>substitution_map</code>. The new entries will have the keys given in the <code>symbols</code> vector, each of which will be paired index-wise with its corresponding element in the <code>values</code> vector. It is expected that there are no duplicate entries between the two maps.</p>
<p>For more context which this function is used, see the other <code>add_to_substitution_map(<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;)</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>See the other <code>add_to_substitution_map(<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;)</code> function for a detailed discussion on the role of this template argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05d37dc642ad6457ea2b4e3985ef8a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d37dc642ad6457ea2b4e3985ef8a94">&#9670;&nbsp;</a></span>add_to_substitution_map() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, typename ExpressionType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_substitution_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; ExpressionType, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function to add an entry to the <code>substitution_map</code>. The new entry will have the key given by the first element of <code>symbol_value</code> and the value given by its second element. It is expected that the key entry be a valid symbol or symbolic expression, and that the paired <code>symbol_value</code> elements are compatible with the other <a class="el" href="namespaceDifferentiation_1_1SD.html#ad0b015b556ca354a241a3b7f8e3a8248">add_to_substitution_map()</a> functions.</p>
<p>The <code>ExpressionType</code> and its associated <code>ValueType</code> need not be scalar types. So, for example, this function could be used to add tensor-valued data to the map in the following way:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> substitution_map = ...;</div><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD.html#ad0b015b556ca354a241a3b7f8e3a8248">add_to_substitution_map</a>(</div><div class="line">  substitution_map,</div><div class="line">  std::make_pair(<a class="code" href="classTensor.html">Tensor&lt;1,dim,Expression&gt;</a>(...),</div><div class="line">                 <a class="code" href="classTensor.html">Tensor&lt;1,dim,double&gt;</a>(...))</div><div class="line">);</div></div><!-- fragment --><p>For more context which this function is used, see the other <code>add_to_substitution_map(<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;)</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>See the other <code>add_to_substitution_map(<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;)</code> function for a detailed discussion on the role of this template argument.</td></tr>
    <tr><td class="paramname">ExpressionType</td><td>Any symbolic expression type that is understood by the <a class="el" href="namespaceDifferentiation_1_1SD.html#ad0b015b556ca354a241a3b7f8e3a8248">add_to_substitution_map()</a> functions. This includes individual <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>, as well as Tensors and SymmetricTensors of Expressions. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13e9bcd3273f551163cc4adfd07ecc02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e9bcd3273f551163cc4adfd07ecc02">&#9670;&nbsp;</a></span>add_to_substitution_map() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, typename ExpressionType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_substitution_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; ExpressionType, ValueType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for adding multiple entries to the <code>substitution_map</code>. The new entries will have the keys given by first entry of each element of <code>symbol_values</code>, and the values given its second entry. It is expected that the key entry be a valid symbols or symbolic expressions, and that the paired <code>symbol_value</code> elements are compatible with the other <a class="el" href="namespaceDifferentiation_1_1SD.html#ad0b015b556ca354a241a3b7f8e3a8248">add_to_substitution_map()</a> functions.</p>
<p>The <code>ExpressionType</code> and its associated <code>ValueType</code> need not be scalar types. So, for example, this function could be used to add tensor-valued data to the map in the following way:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> substitution_map = ...;</div><div class="line"><span class="keyword">using</span> vector_entry_t = std::vector&lt;std::pair&lt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim,Expression&gt;</a>, <a class="code" href="classTensor.html">Tensor&lt;1,dim,double&gt;</a></div><div class="line">&gt;&gt;;</div><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD.html#ad0b015b556ca354a241a3b7f8e3a8248">add_to_substitution_map</a>(</div><div class="line">  substitution_map,</div><div class="line">  vector_entry_t{</div><div class="line">    {Tensor&lt;1,dim,Expression&gt;(...), Tensor&lt;1,dim,double&gt;(...)},</div><div class="line">    {Tensor&lt;1,dim,Expression&gt;(...), Tensor&lt;1,dim,double&gt;(...)}</div><div class="line">  });</div></div><!-- fragment --><p>For more context which this function is used, see the other <code>add_to_substitution_map(<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;)</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>See the other <code>add_to_substitution_map(<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;)</code> function for a detailed discussion on the role of this template argument.</td></tr>
    <tr><td class="paramname">ExpressionType</td><td>Any symbolic expression type that is understood by the <a class="el" href="namespaceDifferentiation_1_1SD.html#ad0b015b556ca354a241a3b7f8e3a8248">add_to_substitution_map()</a> functions. This includes individual <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>, as well as Tensors and SymmetricTensors of Expressions. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1e3232db3c76af854a36b4a31ecf6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e3232db3c76af854a36b4a31ecf6fe">&#9670;&nbsp;</a></span>add_to_substitution_map() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, typename ExpressionType , typename ValueType , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_substitution_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; ExpressionType, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>other_symbol_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for adding multiple entries to the <code>substitution_map</code>. The new entries will have the keys given by first entry of each element of <code>symbol_values</code>, and the values given its second entry, along with the addition of the <code>other_symbol_values</code>. It is expected that the key entry be a valid symbols or symbolic expressions, and that the paired <code>symbol_value</code> elements are compatible with the other <a class="el" href="namespaceDifferentiation_1_1SD.html#ad0b015b556ca354a241a3b7f8e3a8248">add_to_substitution_map()</a> functions.</p>
<p>With this function it is possible to construct a symbolic substitution map from different types, so long as there exists a <a class="el" href="namespaceDifferentiation_1_1SD.html#ad0b015b556ca354a241a3b7f8e3a8248">add_to_substitution_map()</a> function with the signature corresponding to the pair types. An example may be as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> substitution_map = ...;</div><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD.html#ad0b015b556ca354a241a3b7f8e3a8248">add_to_substitution_map</a>(</div><div class="line">  substitution_map,</div><div class="line">  std::make_pair(Expression(...), 3),</div><div class="line">  std::make_pair(<a class="code" href="classTensor.html">Tensor&lt;1,dim,Expression&gt;</a>(...),</div><div class="line">                 <a class="code" href="classTensor.html">Tensor&lt;1,dim,float&gt;</a>(...)),</div><div class="line">  std::make_pair(<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim,Expression&gt;</a>(...),</div><div class="line">                 <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim,double&gt;</a>(...)));</div></div><!-- fragment --><p>It is possible to map symbolic types to other symbolic types using this function. For more details on this, see the other <code>make_substitution_map(const Expression &amp;, const ValueType &amp;)</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpressionType</td><td>Any symbolic expression type that is understood by the <a class="el" href="namespaceDifferentiation_1_1SD.html#ad0b015b556ca354a241a3b7f8e3a8248">add_to_substitution_map()</a> functions. This includes individual <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>, as well as Tensors and SymmetricTensors of Expressions. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
    <tr><td class="paramname">Args</td><td>A type associated with the parameter pack that contains any number of other <code>ExpressionTypes</code>. All types held by the parameter pack share the same restriction as the <code>ExpressionType</code> documented above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a5ba04d787e659f4b72565d82da814f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5ba04d787e659f4b72565d82da814f">&#9670;&nbsp;</a></span>merge_substitution_maps() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::merge_substitution_maps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate two symbolic maps, merging a second map <code>substitution_map_in</code> in-place into the initial and resultant map <code>substitution_map_out</code>. The map <code>substitution_map_out</code> need not initially be empty.</p>
<dl class="section note"><dt>Note</dt><dd>Duplicate symbols (keys) in the maps are permitted, so long as their values are equal. If this is not the case then an error will be thrown. </dd></dl>

</div>
</div>
<a id="a4a14780a49d970f6a8c9f43c4cf0628a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a14780a49d970f6a8c9f43c4cf0628a">&#9670;&nbsp;</a></span>merge_substitution_maps() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::merge_substitution_maps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>other_substitution_maps_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate multiple symbolic maps, merging the maps <code>substitution_map_in</code> and <code>other_substitution_maps_in</code>, a collection of other maps, in-place into the resultant map <code>substitution_map_out</code>. The map <code>substitution_map_out</code> need not initially be empty.</p>
<dl class="section note"><dt>Note</dt><dd>Duplicate symbols (keys) in the maps are permitted, so long as their values are equal. If this is not the case then an error will be thrown. </dd></dl>

</div>
</div>
<a id="afb976c7a9a19d1d86c4ff95a0ffab6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb976c7a9a19d1d86c4ff95a0ffab6f4">&#9670;&nbsp;</a></span>merge_substitution_maps() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> Differentiation::SD::merge_substitution_maps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>other_substitution_maps_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate multiple symbolic maps, merging the maps <code>substitution_map_in</code> and <code>other_substitution_maps_in</code> and returning the result.</p>
<dl class="section note"><dt>Note</dt><dd>Duplicate symbols (keys) in the maps are permitted, so long as their values are equal. If this is not the case then an error will be thrown. </dd></dl>

</div>
</div>
<a id="ad978861d8e1b008dae23cf8c99d82c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad978861d8e1b008dae23cf8c99d82c13">&#9670;&nbsp;</a></span>resolve_explicit_dependencies() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> Differentiation::SD::resolve_explicit_dependencies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>force_cyclic_dependency_resolution</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a substitution map that has any explicit interdependencies between the entries of the input <code>substitution_map</code> resolved.</p>
<p>The <code>force_cyclic_dependency_resolution</code> flag exists to ensure, if desired, that no cyclic dependencies can exist in the returned map. If a cyclic dependency exists in the input substitution map, <code>substitution_map</code>, then with this flag set to <code>true</code> the dependency cycle is broken by a dictionary-ordered substitution. For example, if the substitution map contains two entries <code>map["a"] -&gt; "b"</code> and <code>map["b"] -&gt; "a"</code>, then the result of calling this function would be a map with the elements <code>map["a"] -&gt; "a"</code> and <code>map["b"] -&gt; "a"</code>.</p>
<p>If one symbol is an explicit function of another, and it is desired that all their values are completely resolved, then it may be necessary to perform substitution a number of times before the result is finalized. This function performs substitution sweeps for a set of symbolic variables until all explicit relationships between the symbols in the map have been resolved. Whether each entry returns a symbolic or real value depends on the nature of the values stored in the substitution map. If the values associated with a key are also symbolic then the returned result may still be symbolic in nature. The terminal result of using the input substitution map, <code>symbol_values</code>, is then guaranteed to be rendered by a single substitition of the returned dependency-resolved map.</p>
<p>Example: If <code>map["a"] -&gt; 1</code> and <code>map["b"] -&gt; "a"+ 2</code>, then the function \(f(a,b(a)) = a+b\) will be evaluated and the result \(f\vert_{a=1,b=a+2} = 3+a\) is determined upon the completion of the first sweep. A second sweep is therefore necessary to resolve the final symbol, and the returned value is ultimately \(f = [3+a]_{a=1} = 4\). By resolving the explicit relationships between all symbols in the map, we determine that <code>map["a"] -&gt; 1</code> and <code>map["b"] -&gt; 1 + 2 = 3</code> and thus, using only one substitution, that \(f = a+b = 1 + 3 = 4\). </p>

</div>
</div>
<a id="a36339a4b0cde7f6ea62756c9851458db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36339a4b0cde7f6ea62756c9851458db">&#9670;&nbsp;</a></span>resolve_explicit_dependencies() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> Differentiation::SD::resolve_explicit_dependencies </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; ExpressionType, ValueType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>force_cyclic_dependency_resolution</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a substitution map that has any explicit interdependencies between the entries of the map generated by the paired elements in the <code>symbol_values</code> vector resolved. The <code>force_cyclic_dependency_resolution</code> exists to ensure, if desired, that no cyclic dependencies can exist in the returned map.</p>
<p>This function performs substitution sweeps for a set of symbolic variables until all explicit relationships between the symbols in the map have been resolved. Whether each entry returns a symbolic or real value depends on the chosen ValueType and the values represented therein. If the ValueType is another <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>, and they contain symbols then the returned result may still be symbolic in nature.</p>
<p>For an example of what this function does, see the documentation for the other <code>resolve_explicit_dependencies(const types::substitution_map &amp;)</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpressionType</td><td>A type that represents a symbolic expression. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>ExpressionType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adee79451c8fcfef0b37efbedd461756a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee79451c8fcfef0b37efbedd461756a">&#9670;&nbsp;</a></span>substitute() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a single substitution sweep of a set of symbols into the given symbolic expression. The symbols in the <code>expression</code> that correspond to the entry keys of the <code>substitution_map</code> are substituted with the map entry's associated value. This substitution function may be used to give a set of symbolic variables either a numeric interpretation or some symbolic definition.</p>
<dl class="section note"><dt>Note</dt><dd>It is not required that all symbolic expressions be fully resolved when using this function. In other words, partial substitutions are valid.</dd>
<dd>
This function call is typically expensive, as by default it performs a dictionary substitution for the symbols in the symbolic expression. Should the numerical value of some symbolic expression be desired, then this performance deficit may be mitigated through the use of the <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">BatchOptimizer</a> class. Situation dependent, the overhead of using a typical dictionary based substitution may be on par with that of a substitution performed using a <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">BatchOptimizer</a>. This is because there is an overhead to setting up the optimizer, so this should be taken into consideration if substitution is to occur for the given symbolic expression only a few times.</dd>
<dd>
If the symbols stored in the map are explicitly dependent on one another, then the returned result depends on the order in which the map is traversed. It is recommended to first resolve all interdependencies in the map using the <a class="el" href="namespaceDifferentiation_1_1SD.html#ad978861d8e1b008dae23cf8c99d82c13">resolve_explicit_dependencies()</a> function.</dd></dl>
<p>Examples: </p><ol>
<li>
<p class="startli">If <code>map["a"] == 1</code> and <code>map["b"] == "a" + 2</code>, then the function \(f(a,b(a)) := a+b\) will be evaluated and the result \(f\vert_{a=1,b=a+2} = 3+a\) is returned. This return is because the symbol "a" is substituted throughout the function first, and only then is the symbol "b(a)" substituted, by which time its explicit dependency on "a" cannot be resolved.</p>
<p class="endli"></p>
</li>
<li>
If <code>map["a"] == "b"+2</code> and <code>map["b"] == 1</code>, then the function \(f(a(b),b): = a+b\) will be evaluated and the result \(f\vert_{a=b+2, b} = [b+2+b]_{b=1} = 4\) is returned. This is because the explicitly dependent symbol "a(b)" is substituted first followed by the symbol "b". </li>
</ol>

</div>
</div>
<a id="a72fa25740f0fedca16330bb0046aff45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fa25740f0fedca16330bb0046aff45">&#9670;&nbsp;</a></span>substitute() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a substitution of the <code>symbol</code> into the given <code>expression</code>. All matches are assigned the corresponding <code>value</code>. This substitution function may be used to give a set of symbolic variables either a numeric interpretation or some symbolic definition.</p>
<p>For more information regarding the performance of symbolic substitution, see the other <code><a class="el" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">substitute(const Expression &amp;, const types::substitution_map &amp;)</a></code> function.</p>
<dl class="section note"><dt>Note</dt><dd>It is not required that all symbolic expressions be fully resolved when using this function. In other words, partial substitutions are valid.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62ac6f9b4e7aa798c6efbb7964621e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ac6f9b4e7aa798c6efbb7964621e6c">&#9670;&nbsp;</a></span>substitute() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType Differentiation::SD::substitute </td>
          <td>(</td>
          <td class="paramtype">const ExpressionType &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>symbol_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a single substitution sweep of a set of symbols into the given symbolic expression. The symbols in the <code>expression</code> that correspond to a matching entry key of the <code>symbol_values</code> vector entry are substituted by the entry's associated value. This substitution function may be used to give a set of symbolic variables either a numeric interpretation or some symbolic definition.</p>
<p>For more information regarding the performance of symbolic substitution, see the other <code><a class="el" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">substitute(const Expression &amp;, const types::substitution_map &amp;)</a></code> function.</p>
<dl class="section note"><dt>Note</dt><dd>It is not required that all symbolic expressions be fully resolved when using this function. In other words, partial substitutions are valid.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpressionType</td><td>A type that represents a symbolic expression. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, but this may also represent Tensors and SymmetricTensors of Expressions. </td></tr>
    <tr><td class="paramname">Args</td><td>Any symbolic type and value combination that is understood by the <a class="el" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map()</a> functions. This includes arguments involving individual Expressions, std::vector&lt;Expression&gt;, as well as Tensors and SymmetricTensors of Expressions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e50a66591b18a5b0df49603edcdfaca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e50a66591b18a5b0df49603edcdfaca">&#9670;&nbsp;</a></span>substitute_and_evaluate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType Differentiation::SD::substitute_and_evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a single substitution sweep of a set of symbols into the given symbolic function, and immediately evaluate the result. The symbols in the <code>expression</code> that correspond to the entry keys of the <code>substitution_map</code> are substituted with the map entry's associated value. This substitution function is used to give a set of symbolic variables a numeric interpretation, with the returned result being of the type specified by the <code>ValueType</code> template argument.</p>
<p>For more information regarding the performance of symbolic substitution, and the outcome of evaluation using a substitution map with cyclic dependencies, see the <code><a class="el" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">substitute(const Expression &amp;, const types::substitution_map &amp;)</a></code> function.</p>
<dl class="section note"><dt>Note</dt><dd>It is required that all symbols in the <code>expression</code> be successfully resolved by the <code>substitution_map</code>. If only partial substitution is performed, then an error is thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. In the context of this particular function, this template parameter is typically arithmetic in nature. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acabf0ce15f1ed9386272796e33266ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabf0ce15f1ed9386272796e33266ed1">&#9670;&nbsp;</a></span>substitute_and_evaluate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType Differentiation::SD::substitute_and_evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>symbol_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a single substitution sweep of a set of symbols into the given symbolic function, and immediately evaluate the result. The symbols in the <code>expression</code> that correspond to the entry keys of the <code>substitution_map</code> are substituted with the map entry's associated value. This substitution function is used to give a set of symbolic variables a numeric interpretation with the returned result being of the type specified by the <code>ValueType</code> template argument.</p>
<p>For more information regarding the performance of symbolic substitution, and the outcome of evaluation using a substitution map with cyclic dependencies, see the <code><a class="el" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">substitute(const Expression &amp;, const types::substitution_map &amp;)</a></code> function.</p>
<dl class="section note"><dt>Note</dt><dd>It is required that all symbols in the <code>expression</code> be successfully resolved by the substitution map that is generated with the input collection of <code>symbol_values</code>. If only partial substitution is performed, then an error is thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. In the context of this particular function, this template parameter is typically arithmetic in nature. </td></tr>
    <tr><td class="paramname">Args</td><td>Any symbolic type and value combination that is understood by the <a class="el" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map()</a> functions. This includes arguments involving individual Expressions, std::vector&lt;Expression&gt;, as well as Tensors and SymmetricTensors of Expressions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf16bdf4d5a0b48dd84496e379742426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf16bdf4d5a0b48dd84496e379742426">&#9670;&nbsp;</a></span>make_vector_of_symbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; Differentiation::SD::make_vector_of_symbols </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a vector of Expressions representing a vectorial symbolic variable with the identifier specified by <code>symbol</code>.</p>
<p>For example, if the <code>symbol</code> is the string <code>"v"</code> then the vectorial symbolic variable that is returned represents the vector \(v\). Each component of \(v\) is prefixed by the given <code>symbol</code>, and has a suffix that indicates its component index.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>The dimension of the returned tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol</td><td>An identifier (or name) for the vector of returned symbolic variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector (a rank-1 tensor) of symbolic variables with the name of each individual component prefixed by <code>symbol</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is up to the user to ensure that there is no ambiguity in the symbols used within a section of code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__tensor__operations_8cc_source.html#l00237">237</a> of file <a class="el" href="symengine__tensor__operations_8cc_source.html">symengine_tensor_operations.cc</a>.</p>

</div>
</div>
<a id="a2f2a2f11a2a0d6d3aa773f92bea974f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2a2f11a2a0d6d3aa773f92bea974f0">&#9670;&nbsp;</a></span>make_tensor_of_symbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; Differentiation::SD::make_tensor_of_symbols </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a tensor of Expressions representing a tensorial symbolic variable with the identifier specified by <code>symbol</code>.</p>
<p>For example, if the <code>symbol</code> is the string <code>"T"</code> then the tensorial symbolic variable that is returned represents the vector \(T\). Each component of \(T\) is prefixed by the given <code>symbol</code>, and has a suffix that indicates its component indices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rank</td><td>The rank of the returned tensor. </td></tr>
    <tr><td class="paramname">dim</td><td>The dimension of the returned tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol</td><td>An identifier (or name) for the tensor of returned symbolic variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor of symbolic variables with the name of each individual component prefixed by <code>symbol</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is up to the user to ensure that there is no ambiguity in the symbols used within a section of code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__tensor__operations_8cc_source.html#l00256">256</a> of file <a class="el" href="symengine__tensor__operations_8cc_source.html">symengine_tensor_operations.cc</a>.</p>

</div>
</div>
<a id="aa97c3f1e51baf8bc4a96d563f2131e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97c3f1e51baf8bc4a96d563f2131e91">&#9670;&nbsp;</a></span>make_symmetric_tensor_of_symbols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; Differentiation::SD::make_symmetric_tensor_of_symbols </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symmetric tensor of Expressions representing a tensorial symbolic variable with the identifier specified by <code>symbol</code>.</p>
<p>For example, if the <code>symbol</code> is the string <code>"S"</code> then the tensorial symbolic variable that is returned represents the vector \(S\). Each component of \(S\) is prefixed by the given <code>symbol</code>, and has a suffix that indicates its component indices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rank</td><td>The rank of the returned tensor. </td></tr>
    <tr><td class="paramname">dim</td><td>The dimension of the returned tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol</td><td>An identifier (or name) for the tensor of returned symbolic variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor of symbolic variables with the name of each individual component prefixed by <code>symbol</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is up to the user to ensure that there is no ambiguity in the symbols used within a section of code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__tensor__operations_8cc_source.html#l00264">264</a> of file <a class="el" href="symengine__tensor__operations_8cc_source.html">symengine_tensor_operations.cc</a>.</p>

</div>
</div>
<a id="a2bfd282b55409799ef156075db8d0b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfd282b55409799ef156075db8d0b3b">&#9670;&nbsp;</a></span>make_vector_of_symbolic_functions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::make_vector_of_symbolic_functions </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a vector of <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> representing a vectorial symbolic function with the identifier specified by <code>symbol</code>. The functions' symbolic dependencies are specified by the keys to the input <code>arguments</code> map; the values stored in the map are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>The dimension of the returned tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol</td><td>An identifier (or name) for the vector of returned symbolic functions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>A map of input arguments to the returned symbolic functions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector (a rank-1 tensor) of generic symbolic functions with the name of each individual component prefixed by <code>symbol</code>, a suffix that indicates its component index, and the number of input arguments equal to the length of <code>arguments</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is up to the user to ensure that there is no ambiguity in the symbols used within a section of code. </dd></dl>

</div>
</div>
<a id="a368493d4c3226c9bbaf614b920476b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368493d4c3226c9bbaf614b920476b9b">&#9670;&nbsp;</a></span>make_tensor_of_symbolic_functions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::make_tensor_of_symbolic_functions </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a tensor of <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> representing a tensorial symbolic function with the identifier specified by <code>symbol</code>. The functions' symbolic dependencies are specified by the keys to the input <code>arguments</code> map; the values stored in the map are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rank</td><td>The rank of the returned tensor. </td></tr>
    <tr><td class="paramname">dim</td><td>The dimension of the returned tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol</td><td>An identifier (or name) for the tensor of returned symbolic functions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>A map of input arguments to the returned symbolic functions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor of generic symbolic functions with the name of each individual component prefixed by <code>symbol</code>, a suffix that indicates its component indeices, and the number of input arguments equal to the length of <code>arguments</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is up to the user to ensure that there is no ambiguity in the symbols used within a section of code. </dd></dl>

</div>
</div>
<a id="a7405fe0e432fb69cfb8dfbd2a2b6283d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7405fe0e432fb69cfb8dfbd2a2b6283d">&#9670;&nbsp;</a></span>make_symmetric_tensor_of_symbolic_functions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::make_symmetric_tensor_of_symbolic_functions </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a symmetric tensor of <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> representing a tensorial symbolic function with the identifier specified by <code>symbol</code>. The functions' symbolic dependencies are specified by the keys to the input <code>arguments</code> map; the values stored in the map are ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rank</td><td>The rank of the returned tensor. </td></tr>
    <tr><td class="paramname">dim</td><td>The dimension of the returned tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">symbol</td><td>An identifier (or name) for the tensor of returned symbolic functions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arguments</td><td>A map of input arguments to the returned symbolic functions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A symmetric tensor of generic symbolic functions with the name of each individual component prefixed by <code>symbol</code>, a suffix that indicates its component indeices, and the number of input arguments equal to the length of <code>arguments</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is up to the user to ensure that there is no ambiguity in the symbols used within a section of code. </dd></dl>

</div>
</div>
<a id="ac93a538c6480892ac66df149272893c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93a538c6480892ac66df149272893c2">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::differentiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the symbolic result of computing the partial derivative of the scalar <code>f</code> with respect to the tensor <code>T</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>A scalar symbolic function or (dependent) expression. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>A tensor of symbolic (independent) variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor of symbolic functions or expressions representing the result \(\frac{\partial f}{\partial \mathbf{T}}\). </dd></dl>

</div>
</div>
<a id="a0ab10e86661304529ece5b17f379dee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab10e86661304529ece5b17f379dee1">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::differentiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the symbolic result of computing the partial derivative of the scalar <code>f</code> with respect to the symmetric tensor <code>S</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>A scalar symbolic function or (dependent) expression. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>A symmetric tensor of symbolic (independent) variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The symmetric tensor of symbolic functions or expressions representing the result \(\frac{\partial f}{\partial \mathbf{S}}\). </dd></dl>

</div>
</div>
<a id="a6e0f4c3763b9b5e4d53dd87bd65f4a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0f4c3763b9b5e4d53dd87bd65f4a89">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::differentiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the symbolic result of computing the partial derivative of the rank-0 tensor (or scalar) <code>f</code> with respect to the tensor <code>T</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>A rank-0 tensor symbolic function or (dependent) expression. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>A tensor of symbolic (independent) variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor of symbolic functions or expressions representing the result \(\frac{\partial f}{\partial \mathbf{T}}\). </dd></dl>

</div>
</div>
<a id="aadceeeb5cdcf950a31c51bb855e5d257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadceeeb5cdcf950a31c51bb855e5d257">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::differentiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the symbolic result of computing the partial derivative of the rank-0 tensor (or scalar) <code>f</code> with respect to the symmetric tensor <code>S</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>A rank-0 tensor symbolic function or (dependent) expression. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>A symmetric tensor of symbolic (independent) variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The symmetric tensor of symbolic functions or expressions representing the result \(\frac{\partial f}{\partial \mathbf{S}}\). </dd></dl>

</div>
</div>
<a id="a5d3b1a30b1c609983ae0f191ba504cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3b1a30b1c609983ae0f191ba504cc8">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::differentiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the symbolic result of computing the partial derivative of the tensor <code>T</code> with respect to the scalar <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>A tensor of symbolic functions or (dependent) expressions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A scalar symbolic (independent) variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor of symbolic functions or expressions representing the result \(\frac{\partial \mathbf{T}}{\partial x}\). </dd></dl>

</div>
</div>
<a id="ac02faabf11ecdccda6a882d2e4492271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02faabf11ecdccda6a882d2e4492271">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::differentiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the symbolic result of computing the partial derivative of the symmetric tensor <code>S</code> with respect to the scalar <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>A symmetric tensor of symbolic functions or (dependent) expressions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A scalar symbolic (independent) variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The symmetric tensor of symbolic functions or expressions representing the result \(\frac{\partial \mathbf{S}}{\partial x}\). </dd></dl>

</div>
</div>
<a id="ac902fb9d64ebb96f61007b93e861a8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac902fb9d64ebb96f61007b93e861a8a4">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::differentiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the symbolic result of computing the partial derivative of the tensor <code>T</code> with respect to the rank-0 tensor <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>A tensor of symbolic functions or (dependent) expressions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A rank-0 tensor containing a symbolic (independent) variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor of symbolic functions or expressions representing the result \(\frac{\partial \mathbf{T}}{\partial x}\). </dd></dl>

</div>
</div>
<a id="a812215228c7af11a7334e29e42e77b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812215228c7af11a7334e29e42e77b99">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::differentiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the symbolic result of computing the partial derivative of the symmetric tensor <code>S</code> with respect to the rank-0 tensor <code>x</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>A symmetric tensor of symbolic functions or (dependent) expressions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>A rank-0 tensor containing a symbolic (independent) variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The symmetric tensor of symbolic functions or expressions representing the result \(\frac{\partial \mathbf{S}}{\partial x}\). </dd></dl>

</div>
</div>
<a id="a7d7589166a2bc319c287c64166972f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7589166a2bc319c287c64166972f07">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_1, int rank_2, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;rank_1 + rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::differentiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>T1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>T2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the symbolic result of computing the partial derivative of the tensor <code>T1</code> with respect to the tensor <code>T2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T1</td><td>A tensor of symbolic functions or (dependent) expressions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T2</td><td>A tensor of symbolic (independent) variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor of symbolic functions or variables representing the result \(\frac{\partial \mathbf{T}_{1}}{\partial \mathbf{T}_{2}}\). </dd></dl>

</div>
</div>
<a id="a02211d5bbb95fe106f846fc7c982a776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02211d5bbb95fe106f846fc7c982a776">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_1, int rank_2, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;rank_1 + rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::differentiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the symbolic result of computing the partial derivative of the symmetric tensor <code>S1</code> with respect to the symmetric tensor <code>S2</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>A symmetric tensor of symbolic functions or (dependent) expressions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>A symmetric tensor of symbolic (independent) variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The symmetric tensor of symbolic functions or variables representing the result \(\frac{\partial \mathbf{S}_{1}}{\partial \mathbf{S}_{2}}\). </dd></dl>

</div>
</div>
<a id="ae0dea62bc85060b081c117fe3e10765a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0dea62bc85060b081c117fe3e10765a">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_1, int rank_2, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;rank_1 + rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::differentiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the symbolic result of computing the partial derivative of the tensor <code>T</code> with respect to the symmetric tensor <code>S</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>A tensor of symbolic functions or (dependent) expressions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>A symmetric tensor of symbolic (independent) variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor of symbolic functions or variables representing the result \(\frac{\partial \mathbf{T}}{\partial \mathbf{S}}\). </dd></dl>

</div>
</div>
<a id="aeead2841828227700989be04348ec74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeead2841828227700989be04348ec74c">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_1, int rank_2, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;rank_1 + rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::differentiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_1, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the symbolic result of computing the partial derivative of the symmetric tensor <code>S</code> with respect to the tensor <code>T</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>A symmetric tensor of symbolic functions or (dependent) expressions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>A tensor of symbolic (independent) variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor of symbolic functions or variables representing the result \(\frac{\partial \mathbf{S}}{\partial \mathbf{T}}\). </dd></dl>

</div>
</div>
<a id="a8be6f297bb4c44760876b1788bce798b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be6f297bb4c44760876b1788bce798b">&#9670;&nbsp;</a></span>add_to_symbol_map() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double, int rank, int dim, typename SymbolicType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, SymbolicType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for adding empty entries, with the key values equal to the entries in the <code>symbol_tensor</code>, to the symbolic map <code>symbol_map</code>.</p>
<p>For more context which this function is used, see the other <code><a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map(types::substitution_map &amp;, const Expression &amp;)</a></code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>See the other <code><a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map(types::substitution_map &amp;, const Expression &amp;)</a></code> function for a detailed discussion on the role of this template argument.</td></tr>
    <tr><td class="paramname">SymbolicType</td><td>A type that represents a symbolic variable. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>SymbolicType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. This <code>ValueType</code> is somewhat arbitrary as it is only used to create default-constructed values as entries in the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a759b65e70890f3516bb5f9a45bbf407c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759b65e70890f3516bb5f9a45bbf407c">&#9670;&nbsp;</a></span>add_to_symbol_map() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, typename ValueType  = double, int rank, int dim, typename SymbolicType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, SymbolicType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for adding empty entries, with the key values equal to the entries in the <code>symbol_tensor</code>, to the symbolic map <code>symbol_map</code>.</p>
<p>For more context which this function is used, see the other <code><a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map(types::substitution_map &amp;, const Expression &amp;)</a></code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>See the other <code><a class="el" href="namespaceDifferentiation_1_1SD.html#abcc4f6ff9d1bff45c3085ed9fd73aa18">add_to_symbol_map(types::substitution_map &amp;, const Expression &amp;)</a></code> function for a detailed discussion on the role of this template argument.</td></tr>
    <tr><td class="paramname">SymbolicType</td><td>A type that represents a symbolic variable. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>SymbolicType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. This <code>ValueType</code> is somewhat arbitrary as it is only used to create default-constructed values as entries in the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaa621416986e5d7eddc310002ebeacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa621416986e5d7eddc310002ebeacb">&#9670;&nbsp;</a></span>set_value_in_symbol_map() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename SymbolicType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::set_value_in_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, SymbolicType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the input <code>symbols</code> in the <code>substitution_map</code> and set the entries corresponding to the key values given by <code>symbol_tensor</code> to the values given by <code>value_tensor</code>.</p>
<p>This function may be used to safely transform an existing or null symbolic map (one with uninitialized entries) into one that can be used to conduct symbolic substitution operations (i.e., a substitution map).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SymbolicType</td><td>A type that represents a symbolic variable. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>SymbolicType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfcb3a9c34ab9417de2284ee19c54ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcb3a9c34ab9417de2284ee19c54ff4">&#9670;&nbsp;</a></span>set_value_in_symbol_map() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename SymbolicType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::set_value_in_symbol_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, SymbolicType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the input <code>symbols</code> in the <code>substitution_map</code> and set the entries corresponding to the key values given by <code>symbol_tensor</code> to the values given by <code>value_tensor</code>.</p>
<p>This function may be used to safely transform an existing or null symbolic map (one with uninitialized entries) into one that can be used to conduct symbolic substitution operations (i.e., a substitution map).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SymbolicType</td><td>A type that represents a symbolic variable. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>SymbolicType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b13952c3d09aa1ae79ff8eab3773da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b13952c3d09aa1ae79ff8eab3773da7">&#9670;&nbsp;</a></span>make_substitution_map() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename ExpressionType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> Differentiation::SD::make_substitution_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, ExpressionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a substitution map that has the entry keys given by the <code>symbol_tensor</code> and the values given by the <code>value_tensor</code>. It is expected that all key entries be valid symbols or symbolic expressions.</p>
<p>It is possible to map symbolic types to other symbolic types using this function. For more details on this, see the other <code>make_substitution_map(const Expression &amp;,const ValueType &amp;)</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpressionType</td><td>A type that represents a symbolic expression. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>ExpressionType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2544f3556e6ceb1b19ce884908684990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2544f3556e6ceb1b19ce884908684990">&#9670;&nbsp;</a></span>make_substitution_map() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename ExpressionType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> Differentiation::SD::make_substitution_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, ExpressionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a substitution map that has the entry keys given by the <code>symbol_tensor</code> and the values given by the <code>value_tensor</code>. It is expected that all key entries be valid symbols or symbolic expressions.</p>
<p>It is possible to map symbolic types to other symbolic types using this function. For more details on this, see the other <code>make_substitution_map(const Expression &amp;,const ValueType &amp;)</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpressionType</td><td>A type that represents a symbolic expression. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>ExpressionType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9af7c430740ad0e2d879f2a3ffe810b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af7c430740ad0e2d879f2a3ffe810b2">&#9670;&nbsp;</a></span>add_to_substitution_map() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, int rank, int dim, typename ExpressionType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_substitution_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, ExpressionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for adding an entry to the <code>substitution_map</code>. The new entries will have the keys given in the <code>symbol_tensor</code> with their paired values extracted from the corresponding elements of the <code>value_tensor</code>.</p>
<p>For more context which this function is used, see the other <code>add_to_substitution_map(<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;)</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>See the other <code>add_to_substitution_map(<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;)</code> function for a detailed discussion on the role of this template argument.</td></tr>
    <tr><td class="paramname">ExpressionType</td><td>A type that represents a symbolic expression. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>ExpressionType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bb4e8ce590dd97be2c5b01fad15d47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb4e8ce590dd97be2c5b01fad15d47f">&#9670;&nbsp;</a></span>add_to_substitution_map() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ignore_invalid_symbols = false, int rank, int dim, typename ExpressionType , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::add_to_substitution_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, ExpressionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function for adding an entry to the <code>substitution_map</code>. The new entries will have the keys given in the <code>symbol_tensor</code> with their paired values extracted from the corresponding elements of the <code>value_tensor</code>.</p>
<p>For more context which this function is used, see the other <code>add_to_substitution_map(<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;,const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;)</code> function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ignore_invalid_symbols</td><td>See the other <code>add_to_substitution_map(<a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;)</code> function for a detailed discussion on the role of this template argument.</td></tr>
    <tr><td class="paramname">ExpressionType</td><td>A type that represents a symbolic expression. The <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class is often suitable for this purpose, although if the <code>ValueType</code> is not supported by this class then a user-defined <code>ExpressionType</code> should be used. </td></tr>
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. Although it is typically arithmetic in nature, it may also represent another symbolic expression type or be a special type that a user-defined <code>ExpressionType</code> can be constructed from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab297853eae55534a38638f7887348652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab297853eae55534a38638f7887348652">&#9670;&nbsp;</a></span>substitute() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expression_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a single substitution sweep of a set of symbols into the given tensor of symbolic expressions. The symbols in the <code>expression_tensor</code> that correspond to the entry keys of the <code>substitution_map</code> are substituted with the map entry's associated value. This substitution function may be used to give a set of symbolic variables either a numeric interpretation or some symbolic definition.</p>
<p>For more information regarding the performance of symbolic substitution, and the outcome of evaluation using a substitution map with cyclic dependencies, see the <code><a class="el" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">substitute(const Expression &amp;, const types::substitution_map &amp;)</a></code> function.</p>
<dl class="section note"><dt>Note</dt><dd>It is not required that all symbolic expressions be fully resolved when using this function. In other words, partial substitutions are valid. </dd></dl>

</div>
</div>
<a id="abc22550a817b46e0fb20ed207859aef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc22550a817b46e0fb20ed207859aef3">&#9670;&nbsp;</a></span>substitute() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&gt; Differentiation::SD::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expression_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a single substitution sweep of a set of symbols into the given symmetric tensor of symbolic expressions. The symbols in the <code>expression_tensor</code> that correspond to the entry keys of the <code>substitution_map</code> are substituted with the map entry's associated value. This substitution function may be used to give a set of symbolic variables either a numeric interpretation or some symbolic definition.</p>
<p>For more information regarding the performance of symbolic substitution, and the outcome of evaluation using a substitution map with cyclic dependencies, see the <code><a class="el" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">substitute(const Expression &amp;, const types::substitution_map &amp;)</a></code> function.</p>
<dl class="section note"><dt>Note</dt><dd>It is not required that all symbolic expressions be fully resolved when using this function. In other words, partial substitutions are valid. </dd></dl>

</div>
</div>
<a id="a410764be28925140b4345993acb40312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410764be28925140b4345993acb40312">&#9670;&nbsp;</a></span>substitute_and_evaluate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;rank, dim, ValueType&gt; Differentiation::SD::substitute_and_evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expression_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a single substitution sweep of a set of symbols into the given tensor of symbolic expressions, and immediately evaluate the tensorial result. The symbols in the <code>expression_tensor</code> that correspond to the entry keys of the <code>substitution_map</code> are substituted with the map entry's associated value. This substitution function is used to give a set of symbolic variables a numeric interpretation with the returned result being of the type specified by the <code>ValueType</code> template argument.</p>
<p>For more information regarding the performance of symbolic substitution, and the outcome of evaluation using a substitution map with cyclic dependencies, see the <code><a class="el" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">substitute(const Expression &amp;, const types::substitution_map &amp;)</a></code> function.</p>
<dl class="section note"><dt>Note</dt><dd>It is required that all symbols in <code>expression_tensor</code> be successfully resolved by the <code>substitution_map</code>. If only partial substitution is performed, then an error is thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. In the context of this particular function, this template parameter is typically arithmetic in nature. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7473afda8f91d4bc41b8d5d3a713f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7473afda8f91d4bc41b8d5d3a713f97">&#9670;&nbsp;</a></span>substitute_and_evaluate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , int rank, int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;rank, dim, ValueType&gt; Differentiation::SD::substitute_and_evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expression_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a single substitution sweep of a set of symbols into the given symmetric tensor of symbolic expressions, and immediately evaluate the tensorial result. The symbols in the <code>expression_tensor</code> that correspond to the entry keys of the <code>substitution_map</code> are substituted with the map entry's associated value. This substitution function is used to give a set of symbolic variables a numeric interpretation, with the returned result being of the type specified by the <code>ValueType</code> template argument.</p>
<p>For more information regarding the performance of symbolic substitution, and the outcome of evaluation using a substitution map with cyclic dependencies, see the <code><a class="el" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">substitute(const Expression &amp;, const types::substitution_map &amp;)</a></code> function.</p>
<dl class="section note"><dt>Note</dt><dd>It is required that all symbols in <code>expression_tensor</code> be successfully resolved by the <code>substitution_map</code>. If only partial substitution is performed, then an error is thrown.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>A type that corresponds to the <code>value</code> that the <code>symbol</code> is to represent. In the context of this particular function, this template parameter is typically arithmetic in nature. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63580cd7253055ea87706f9fe3c5f52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63580cd7253055ea87706f9fe3c5f52d">&#9670;&nbsp;</a></span>Expression::operator const SymEngine::RCP< const SymEngine::Basic > &()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::operator const SymEngine::RCP&lt; const SymEngine::Basic &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00276">276</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a145415551e08d4e10d75683ccebe9e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145415551e08d4e10d75683ccebe9e37">&#9670;&nbsp;</a></span>operator &() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Logical and operator.</p>
<dl class="section note"><dt>Note</dt><dd>This operator can only be applied on boolean and conditional expressions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00450">450</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a650506d4f70b6fd7a72863a68de2a46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650506d4f70b6fd7a72863a68de2a46a">&#9670;&nbsp;</a></span>operator &&() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>And operator.</p>
<dl class="section note"><dt>Note</dt><dd>This operator can only be applied on boolean and conditional expressions. This operator is a convenience wrapper for the logical and operator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00501">501</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
